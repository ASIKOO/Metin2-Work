; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?msc_aszD3DDevDesc@D3D_CDeviceInfo@@1PAPBDA	; D3D_CDeviceInfo::msc_aszD3DDevDesc
PUBLIC	?msc_aeD3DDevType@D3D_CDeviceInfo@@1QBW4_D3DDEVTYPE@@B ; D3D_CDeviceInfo::msc_aeD3DDevType
PUBLIC	??_C@_03KNIPLHMP@HAL@				; `string'
PUBLIC	??_C@_03GPMNEAGC@REF@				; `string'
;	COMDAT ??_C@_03GPMNEAGC@REF@
CONST	SEGMENT
??_C@_03GPMNEAGC@REF@ DB 'REF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KNIPLHMP@HAL@
CONST	SEGMENT
??_C@_03KNIPLHMP@HAL@ DB 'HAL', 00H			; `string'
CONST	ENDS
CONST	SEGMENT
?msc_aeD3DDevType@D3D_CDeviceInfo@@1QBW4_D3DDEVTYPE@@B DD 01H ; D3D_CDeviceInfo::msc_aeD3DDevType
	DD	02H
CONST	ENDS
_DATA	SEGMENT
?msc_aszD3DDevDesc@D3D_CDeviceInfo@@1PAPBDA DD FLAT:??_C@_03KNIPLHMP@HAL@ ; D3D_CDeviceInfo::msc_aszD3DDevDesc
	DD	FLAT:??_C@_03GPMNEAGC@REF@
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?GetString@D3D_SModeInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; D3D_SModeInfo::GetString
PUBLIC	??1D3D_CAdapterDisplayModeList@@QAE@XZ		; D3D_CAdapterDisplayModeList::~D3D_CAdapterDisplayModeList
PUBLIC	?Build@D3D_CAdapterDisplayModeList@@QAEXAAUIDirect3D8@@W4_D3DFORMAT@@I@Z ; D3D_CAdapterDisplayModeList::Build
PUBLIC	?GetDisplayModeNum@D3D_CAdapterDisplayModeList@@QAEIXZ ; D3D_CAdapterDisplayModeList::GetDisplayModeNum
PUBLIC	?GetPixelFormatNum@D3D_CAdapterDisplayModeList@@QAEIXZ ; D3D_CAdapterDisplayModeList::GetPixelFormatNum
PUBLIC	?GetDisplayModer@D3D_CAdapterDisplayModeList@@QAEABU_D3DDISPLAYMODE@@I@Z ; D3D_CAdapterDisplayModeList::GetDisplayModer
PUBLIC	?GetPixelFormatr@D3D_CAdapterDisplayModeList@@QAEABW4_D3DFORMAT@@I@Z ; D3D_CAdapterDisplayModeList::GetPixelFormatr
PUBLIC	??0D3D_CDeviceInfo@@QAE@XZ			; D3D_CDeviceInfo::D3D_CDeviceInfo
PUBLIC	??1D3D_CDeviceInfo@@QAE@XZ			; D3D_CDeviceInfo::~D3D_CDeviceInfo
PUBLIC	?Build@D3D_CDeviceInfo@@QAEHAAUIDirect3D8@@IIAAVD3D_CAdapterDisplayModeList@@P6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z ; D3D_CDeviceInfo::Build
PUBLIC	?Find@D3D_CDeviceInfo@@QAEHIIIHPAI@Z		; D3D_CDeviceInfo::Find
PUBLIC	?GetD3DModeInfoNum@D3D_CDeviceInfo@@QAEIXZ	; D3D_CDeviceInfo::GetD3DModeInfoNum
PUBLIC	?GetString@D3D_CDeviceInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; D3D_CDeviceInfo::GetString
PUBLIC	?FindDepthStencilFormat@D3D_CDeviceInfo@@QAEHAAUIDirect3D8@@IW4_D3DDEVTYPE@@W4_D3DFORMAT@@PAW44@@Z ; D3D_CDeviceInfo::FindDepthStencilFormat
PUBLIC	?GetD3DModeInfop@D3D_CDeviceInfo@@QAEPAUD3D_SModeInfo@@I@Z ; D3D_CDeviceInfo::GetD3DModeInfop
PUBLIC	??0D3D_CAdapterInfo@@QAE@XZ			; D3D_CAdapterInfo::D3D_CAdapterInfo
PUBLIC	??1D3D_CAdapterInfo@@QAE@XZ			; D3D_CAdapterInfo::~D3D_CAdapterInfo
PUBLIC	?Find@D3D_CAdapterInfo@@QAEHIIIHPAI0@Z		; D3D_CAdapterInfo::Find
PUBLIC	?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z ; D3D_CAdapterInfo::Build
PUBLIC	?GetString@D3D_CAdapterInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; D3D_CAdapterInfo::GetString
PUBLIC	?GetDesktopD3DDisplayModer@D3D_CAdapterInfo@@QAEAAU_D3DDISPLAYMODE@@XZ ; D3D_CAdapterInfo::GetDesktopD3DDisplayModer
PUBLIC	?GetDesktopD3DDisplayModep@D3D_CAdapterInfo@@QAEPAU_D3DDISPLAYMODE@@XZ ; D3D_CAdapterInfo::GetDesktopD3DDisplayModep
PUBLIC	?GetD3DDeviceInfop@D3D_CAdapterInfo@@QAEPAVD3D_CDeviceInfo@@I@Z ; D3D_CAdapterInfo::GetD3DDeviceInfop
PUBLIC	?GetD3DModeInfop@D3D_CAdapterInfo@@QAEPAUD3D_SModeInfo@@II@Z ; D3D_CAdapterInfo::GetD3DModeInfop
PUBLIC	??0D3D_CDisplayModeAutoDetector@@QAE@XZ		; D3D_CDisplayModeAutoDetector::D3D_CDisplayModeAutoDetector
PUBLIC	??1D3D_CDisplayModeAutoDetector@@QAE@XZ		; D3D_CDisplayModeAutoDetector::~D3D_CDisplayModeAutoDetector
PUBLIC	?Find@D3D_CDisplayModeAutoDetector@@QAEHIIIHPAI00@Z ; D3D_CDisplayModeAutoDetector::Find
PUBLIC	?Build@D3D_CDisplayModeAutoDetector@@QAEHAAUIDirect3D8@@P6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z ; D3D_CDisplayModeAutoDetector::Build
PUBLIC	?GetD3DAdapterInfop@D3D_CDisplayModeAutoDetector@@QAEPAVD3D_CAdapterInfo@@I@Z ; D3D_CDisplayModeAutoDetector::GetD3DAdapterInfop
PUBLIC	?GetD3DModeInfop@D3D_CDisplayModeAutoDetector@@QAEPAUD3D_SModeInfo@@III@Z ; D3D_CDisplayModeAutoDetector::GetD3DModeInfop
PUBLIC	?GetString@D3D_CDisplayModeAutoDetector@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; D3D_CDisplayModeAutoDetector::GetString
PUBLIC	??$find_if@PAU_D3DDISPLAYMODE@@UFIsEqualD3DDisplayMode@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@QAU1@UFIsEqualD3DDisplayMode@@@Z ; std::find_if<_D3DDISPLAYMODE *,FIsEqualD3DDisplayMode>
PUBLIC	??$find@PAW4_D3DFORMAT@@W41@@std@@YAPAW4_D3DFORMAT@@PAW41@QAW41@ABW41@@Z ; std::find<enum _D3DFORMAT *,enum _D3DFORMAT>
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_C@_07NFANNNEC@UNKNOWN@			; `string'
PUBLIC	??_C@_04NFAOCDCH@HWVP@				; `string'
PUBLIC	??_C@_04EFINLMAB@MXVP@				; `string'
PUBLIC	??_C@_04MCDOIFLE@SWVP@				; `string'
PUBLIC	??_C@_0O@KEGMOEDA@?$CFdx?$CFdx?$CFd?5?$CFs?$AN?6@ ; `string'
PUBLIC	??_C@_0CP@HNBDJADM@?$CFs?$AN?6?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_04CDOPIHIK@?$CFd?4?5@			; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6@			; `string'
PUBLIC	??_C@_0M@FCEPDHJA@Device?5?$CFd?$AN?6@		; `string'
PUBLIC	??_C@_0N@NKJKCJIP@Adapter?5?$CFd?$AN?6@		; `string'
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_qsort:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_strlen:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_0N@NKJKCJIP@Adapter?5?$CFd?$AN?6@
CONST	SEGMENT
??_C@_0N@NKJKCJIP@Adapter?5?$CFd?$AN?6@ DB 'Adapter %d', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCEPDHJA@Device?5?$CFd?$AN?6@
CONST	SEGMENT
??_C@_0M@FCEPDHJA@Device?5?$CFd?$AN?6@ DB 'Device %d', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CDOPIHIK@?$CFd?4?5@
CONST	SEGMENT
??_C@_04CDOPIHIK@?$CFd?4?5@ DB '%d. ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HNBDJADM@?$CFs?$AN?6?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0CP@HNBDJADM@?$CFs?$AN?6?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '%'
	DB	's', 0dH, 0aH, '========================================', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KEGMOEDA@?$CFdx?$CFdx?$CFd?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_0O@KEGMOEDA@?$CFdx?$CFdx?$CFd?5?$CFs?$AN?6@ DB '%dx%dx%d %s', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04MCDOIFLE@SWVP@
CONST	SEGMENT
??_C@_04MCDOIFLE@SWVP@ DB 'SWVP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EFINLMAB@MXVP@
CONST	SEGMENT
??_C@_04EFINLMAB@MXVP@ DB 'MXVP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NFAOCDCH@HWVP@
CONST	SEGMENT
??_C@_04NFAOCDCH@HWVP@ DB 'HWVP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NFANNNEC@UNKNOWN@
CONST	SEGMENT
??_C@_07NFANNNEC@UNKNOWN@ DB 'UNKNOWN', 00H		; `string'
CONST	ENDS
;	COMDAT ?szVP@?1??GetString@D3D_SModeInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4PAPBDA
_DATA	SEGMENT
?szVP@?1??GetString@D3D_SModeInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4PAPBDA DD FLAT:??_C@_07NFANNNEC@UNKNOWN@ ; `D3D_SModeInfo::GetString'::`2'::szVP
	DD	FLAT:??_C@_04NFAOCDCH@HWVP@
	DD	FLAT:??_C@_04EFINLMAB@MXVP@
	DD	FLAT:??_C@_04MCDOIFLE@SWVP@
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1D3D_CDisplayModeAutoDetector@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z$0
__ehfuncinfo$?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1D3D_CAdapterInfo@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Al$ = -64						; size = 4
__First1$ = -60						; size = 4
__First1$ = -56						; size = 4
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T2 = -44						; size = 4
__Old_ptr$3 = -40					; size = 4
__Old_capacity$ = -36					; size = 4
__New_capacity$ = -32					; size = 4
__New_size$ = -28					; size = 4
__New_ptr$ = -24					; size = 4
_this$ = -20						; size = 4
__Raw_new$ = -16					; size = 4
__My_data$ = -12					; size = 4
__Old_size$ = -8					; size = 4
__Overflow_is_possible$4 = -3				; size = 1
$T5 = -2						; size = 1
$T6 = -1						; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 e4	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 dc	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 e4	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 e0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 c0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 fd 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 e0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 e8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d e4	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 e8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d dc 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 65		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 d8	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 d8	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ac	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  000af	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  000b2	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  000bd	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c0	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c6	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000c9	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000cc	ff 75 c8	 push	 DWORD PTR __First1$[ebp]
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000d7	c6 45 ff 00	 mov	 BYTE PTR $T6[ebp], 0
  000db	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000de	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  000e1	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000e4	8a 55 ff	 mov	 dl, BYTE PTR $T6[ebp]
  000e7	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ea	8b 45 dc	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000ed	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ee	50		 push	 eax
  000ef	ff 75 d8	 push	 DWORD PTR __Old_ptr$3[ebp]
  000f2	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000f7	59		 pop	 ecx
  000f8	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000fc	8b 4d e8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000ff	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  00101	eb 4c		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00103	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  00106	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00109	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  0010c	e8 00 00 00 00	 call	 _memcpy
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00114	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00117	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  0011a	89 45 c4	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00120	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00123	ff 75 c4	 push	 DWORD PTR __First1$[ebp]
  00126	e8 00 00 00 00	 call	 _memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0012e	c6 45 fe 00	 mov	 BYTE PTR $T5[ebp], 0
  00132	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00135	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  00138	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  0013b	8a 55 fe	 mov	 dl, BYTE PTR $T5[ebp]
  0013e	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00141	8d 45 e8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00144	50		 push	 eax
  00145	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00148	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0014d	59		 pop	 ecx
  0014e	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  0014f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  00152	c9		 leave
  00153	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$find@PAW4_D3DFORMAT@@W41@@std@@YAPAW4_D3DFORMAT@@PAW41@QAW41@ABW41@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__First$ = -8						; size = 4
$T4 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$find@PAW4_D3DFORMAT@@W41@@std@@YAPAW4_D3DFORMAT@@PAW41@QAW41@ABW41@@Z PROC ; std::find<enum _D3DFORMAT *,enum _D3DFORMAT>, COMDAT

; 5478 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1303 :         return _It + 0;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  0000c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 5474 :     return _Find_unchecked1(_First, _Last, _Val, _Memchr_opt{});

  00012	33 c0		 xor	 eax, eax
  00014	88 45 ff	 mov	 BYTE PTR $T4[ebp], al
  00017	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  0001a	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax

; 5439 :     for (; _First != _Last; ++_First) {

  0001d	eb 09		 jmp	 SHORT $LN14@find
$LN12@find:
  0001f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00022	83 c0 04	 add	 eax, 4
  00025	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax
$LN14@find:
  00028	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  0002b	3b 45 f0	 cmp	 eax, DWORD PTR $T2[ebp]
  0002e	74 10		 je	 SHORT $LN9@find

; 5440 :         if (*_First == _Val) {

  00030	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00033	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0003a	75 02		 jne	 SHORT $LN15@find

; 5441 :             break;

  0003c	eb 02		 jmp	 SHORT $LN9@find
$LN15@find:

; 5442 :         }
; 5443 :     }

  0003e	eb df		 jmp	 SHORT $LN12@find
$LN9@find:

; 5479 :     _Adl_verify_range(_First, _Last);
; 5480 :     _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

  00040	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00043	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 1492 :         _It = static_cast<_UIter&&>(_UIt);

  00046	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00049	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 5481 :     return _First;

  0004c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 5482 : }

  0004f	c9		 leave
  00050	c3		 ret	 0
??$find@PAW4_D3DFORMAT@@W41@@std@@YAPAW4_D3DFORMAT@@PAW41@QAW41@ABW41@@Z ENDP ; std::find<enum _D3DFORMAT *,enum _D3DFORMAT>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$find_if@PAU_D3DDISPLAYMODE@@UFIsEqualD3DDisplayMode@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@QAU1@UFIsEqualD3DDisplayMode@@@Z
_TEXT	SEGMENT
__ULast$ = -12						; size = 4
$T1 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$find_if@PAU_D3DDISPLAYMODE@@UFIsEqualD3DDisplayMode@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@QAU1@UFIsEqualD3DDisplayMode@@@Z PROC ; std::find_if<_D3DDISPLAYMODE *,FIsEqualD3DDisplayMode>, COMDAT

; 5787 : _NODISCARD _CONSTEXPR20 _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { // find first satisfying _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 5788 :     _Adl_verify_range(_First, _Last);
; 5789 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 5790 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR __ULast$[ebp], eax

; 5791 :     for (; _UFirst != _ULast; ++_UFirst) {

  00012	eb 09		 jmp	 SHORT $LN4@find_if
$LN2@find_if:
  00014	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00017	83 c0 10	 add	 eax, 16			; 00000010H
  0001a	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@find_if:
  0001d	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00020	3b 45 f4	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00023	74 4b		 je	 SHORT $LN3@find_if
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp

; 13   : 		if (rkD3DDMTest.Width!=m_pkD3DDMChk->Width)

  00025	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  0002b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0002f	74 06		 je	 SHORT $LN14@find_if

; 14   : 			return FALSE;

  00031	83 65 f8 00	 and	 DWORD PTR $T1[ebp], 0
  00035	eb 2f		 jmp	 SHORT $LN13@find_if
$LN14@find_if:

; 15   : 		
; 16   : 		if (rkD3DDMTest.Height!=m_pkD3DDMChk->Height)

  00037	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  0003d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00040	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00043	74 06		 je	 SHORT $LN15@find_if

; 17   : 			return FALSE;

  00045	83 65 f8 00	 and	 DWORD PTR $T1[ebp], 0
  00049	eb 1b		 jmp	 SHORT $LN13@find_if
$LN15@find_if:

; 18   : 		
; 19   : 		if (rkD3DDMTest.Format!=m_pkD3DDMChk->Format)

  0004b	8b 45 10	 mov	 eax, DWORD PTR __Pred$[ebp]
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00051	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00054	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00057	74 06		 je	 SHORT $LN16@find_if

; 20   : 			return FALSE;

  00059	83 65 f8 00	 and	 DWORD PTR $T1[ebp], 0
  0005d	eb 07		 jmp	 SHORT $LN13@find_if
$LN16@find_if:

; 21   : 		
; 22   : 		return TRUE;

  0005f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
$LN13@find_if:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5792 :         if (_Pred(*_UFirst)) {

  00066	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  0006a	74 02		 je	 SHORT $LN5@find_if

; 5793 :             break;

  0006c	eb 02		 jmp	 SHORT $LN3@find_if
$LN5@find_if:

; 5794 :         }
; 5795 :     }

  0006e	eb a4		 jmp	 SHORT $LN2@find_if
$LN3@find_if:

; 1492 :         _It = static_cast<_UIter&&>(_UIt);

  00070	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00073	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 5796 : 
; 5797 :     _Seek_wrapped(_First, _UFirst);
; 5798 :     return _First;

  00076	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 5799 : }

  00079	c9		 leave
  0007a	c3		 ret	 0
??$find_if@PAU_D3DDISPLAYMODE@@UFIsEqualD3DDisplayMode@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@QAU1@UFIsEqualD3DDisplayMode@@@Z ENDP ; std::find_if<_D3DDISPLAYMODE *,FIsEqualD3DDisplayMode>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?CompareD3DDisplayModeOrder@@YAHPBX0@Z
_TEXT	SEGMENT
_p2$ = -8						; size = 4
_p1$ = -4						; size = 4
_arg1$ = 8						; size = 4
_arg2$ = 12						; size = 4
?CompareD3DDisplayModeOrder@@YAHPBX0@Z PROC		; CompareD3DDisplayModeOrder, COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 30   :     D3DDISPLAYMODE* p1 = (D3DDISPLAYMODE*)arg1;

  00005	8b 45 08	 mov	 eax, DWORD PTR _arg1$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR _p1$[ebp], eax

; 31   :     D3DDISPLAYMODE* p2 = (D3DDISPLAYMODE*)arg2;

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _arg2$[ebp]
  0000e	89 45 f8	 mov	 DWORD PTR _p2$[ebp], eax

; 32   : 
; 33   :     if( p1->Format > p2->Format )   return -1;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _p1$[ebp]
  00014	8b 4d f8	 mov	 ecx, DWORD PTR _p2$[ebp]
  00017	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0001a	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  0001d	7e 05		 jle	 SHORT $LN2@CompareD3D
  0001f	83 c8 ff	 or	 eax, -1
  00022	eb 5d		 jmp	 SHORT $LN1@CompareD3D
$LN2@CompareD3D:

; 34   :     if( p1->Format < p2->Format )   return +1;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _p1$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _p2$[ebp]
  0002a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0002d	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00030	7d 05		 jge	 SHORT $LN3@CompareD3D
  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	eb 4a		 jmp	 SHORT $LN1@CompareD3D
$LN3@CompareD3D:

; 35   :     if( p1->Width  < p2->Width )    return -1;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _p1$[ebp]
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _p2$[ebp]
  0003d	8b 00		 mov	 eax, DWORD PTR [eax]
  0003f	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00041	73 05		 jae	 SHORT $LN4@CompareD3D
  00043	83 c8 ff	 or	 eax, -1
  00046	eb 39		 jmp	 SHORT $LN1@CompareD3D
$LN4@CompareD3D:

; 36   :     if( p1->Width  > p2->Width )    return +1;

  00048	8b 45 fc	 mov	 eax, DWORD PTR _p1$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _p2$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]
  00050	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00052	76 05		 jbe	 SHORT $LN5@CompareD3D
  00054	33 c0		 xor	 eax, eax
  00056	40		 inc	 eax
  00057	eb 28		 jmp	 SHORT $LN1@CompareD3D
$LN5@CompareD3D:

; 37   :     if( p1->Height < p2->Height )   return -1;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _p1$[ebp]
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _p2$[ebp]
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00065	73 05		 jae	 SHORT $LN6@CompareD3D
  00067	83 c8 ff	 or	 eax, -1
  0006a	eb 15		 jmp	 SHORT $LN1@CompareD3D
$LN6@CompareD3D:

; 38   :     if( p1->Height > p2->Height )   return +1;

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _p1$[ebp]
  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _p2$[ebp]
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00078	76 05		 jbe	 SHORT $LN7@CompareD3D
  0007a	33 c0		 xor	 eax, eax
  0007c	40		 inc	 eax
  0007d	eb 02		 jmp	 SHORT $LN1@CompareD3D
$LN7@CompareD3D:

; 39   : 
; 40   :     return 0;

  0007f	33 c0		 xor	 eax, eax
$LN1@CompareD3D:

; 41   : }

  00081	c9		 leave
  00082	c3		 ret	 0
?CompareD3DDisplayModeOrder@@YAHPBX0@Z ENDP		; CompareD3DDisplayModeOrder
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetString@D3D_CDisplayModeAutoDetector@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_rkAdapterInfo$1 = -128					; size = 4
$T2 = -124						; size = 4
$T3 = -120						; size = 4
_this$ = -116						; size = 4
_iD3DAdapterInfo$4 = -112				; size = 4
_szText$5 = -108					; size = 1025
__$ArrayPad$ = 920					; size = 4
_pstEnumList$ = 932					; size = 4
?GetString@D3D_CDisplayModeAutoDetector@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; D3D_CDisplayModeAutoDetector::GetString, COMDAT
; _this$ = ecx

; 637  : {

  00000	55		 push	 ebp
  00001	8d ac 24 64 fc
	ff ff		 lea	 ebp, DWORD PTR [esp-924]
  00008	81 ec 1c 04 00
	00		 sub	 esp, 1052		; 0000041cH
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 98 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 8c	 mov	 DWORD PTR _this$[ebp], ecx

; 638  : 	for (UINT iD3DAdapterInfo=0; iD3DAdapterInfo<m_uD3DAdapterInfoCount; ++iD3DAdapterInfo)

  0001e	83 65 90 00	 and	 DWORD PTR _iD3DAdapterInfo$4[ebp], 0
  00022	eb 07		 jmp	 SHORT $LN4@GetString
$LN2@GetString:
  00024	8b 45 90	 mov	 eax, DWORD PTR _iD3DAdapterInfo$4[ebp]
  00027	40		 inc	 eax
  00028	89 45 90	 mov	 DWORD PTR _iD3DAdapterInfo$4[ebp], eax
$LN4@GetString:
  0002b	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 90	 mov	 ecx, DWORD PTR _iD3DAdapterInfo$4[ebp]
  00031	3b 88 70 19 03
	00		 cmp	 ecx, DWORD PTR [eax+203120]
  00037	73 5b		 jae	 SHORT $LN1@GetString

; 639  : 	{
; 640  : 		char szText[1024+1];
; 641  : 		_snprintf(szText, sizeof(szText), "Adapter %d\r\n", iD3DAdapterInfo);

  00039	ff 75 90	 push	 DWORD PTR _iD3DAdapterInfo$4[ebp]
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NKJKCJIP@Adapter?5?$CFd?$AN?6@
  00041	68 01 04 00 00	 push	 1025			; 00000401H
  00046	8d 45 94	 lea	 eax, DWORD PTR _szText$5[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 __snprintf
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00052	8d 45 94	 lea	 eax, DWORD PTR _szText$5[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _strlen
  0005b	59		 pop	 ecx
  0005c	89 45 88	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0005f	8b 45 88	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00065	ff 75 84	 push	 DWORD PTR $T2[ebp]
  00068	8d 45 94	 lea	 eax, DWORD PTR _szText$5[ebp]
  0006b	50		 push	 eax
  0006c	8b 8d a4 03 00
	00		 mov	 ecx, DWORD PTR _pstEnumList$[ebp]
  00072	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp

; 644  : 		D3D_CAdapterInfo& rkAdapterInfo=m_akD3DAdapterInfo[iD3DAdapterInfo];	

  00077	69 45 90 58 4f
	00 00		 imul	 eax, DWORD PTR _iD3DAdapterInfo$4[ebp], 20312
  0007e	03 45 8c	 add	 eax, DWORD PTR _this$[ebp]
  00081	89 45 80	 mov	 DWORD PTR _rkAdapterInfo$1[ebp], eax

; 645  : 		rkAdapterInfo.GetString(pstEnumList);

  00084	ff b5 a4 03 00
	00		 push	 DWORD PTR _pstEnumList$[ebp]
  0008a	8b 4d 80	 mov	 ecx, DWORD PTR _rkAdapterInfo$1[ebp]
  0008d	e8 00 00 00 00	 call	 ?GetString@D3D_CAdapterInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; D3D_CAdapterInfo::GetString

; 646  : 	}

  00092	eb 90		 jmp	 SHORT $LN2@GetString
$LN1@GetString:

; 647  : }

  00094	8b 8d 98 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	33 cd		 xor	 ecx, ebp
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	81 c5 9c 03 00
	00		 add	 ebp, 924		; 0000039cH
  000a7	c9		 leave
  000a8	c2 04 00	 ret	 4
?GetString@D3D_CDisplayModeAutoDetector@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; D3D_CDisplayModeAutoDetector::GetString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetD3DModeInfop@D3D_CDisplayModeAutoDetector@@QAEPAUD3D_SModeInfo@@III@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pkD3D_SModeInfo$1 = -12				; size = 4
_pkD3DDevInfo$2 = -8					; size = 4
_pkD3DAdapterInfo$ = -4					; size = 4
_iD3DAdapterInfo$ = 8					; size = 4
_iD3DDevInfo$ = 12					; size = 4
_iD3D_SModeInfo$ = 16					; size = 4
?GetD3DModeInfop@D3D_CDisplayModeAutoDetector@@QAEPAUD3D_SModeInfo@@III@Z PROC ; D3D_CDisplayModeAutoDetector::GetD3DModeInfop, COMDAT
; _this$ = ecx

; 587  : {	       

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 588  : 	D3D_CAdapterInfo* pkD3DAdapterInfo=GetD3DAdapterInfop(iD3DAdapterInfo);

  00009	ff 75 08	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  0000c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetD3DAdapterInfop@D3D_CDisplayModeAutoDetector@@QAEPAVD3D_CAdapterInfo@@I@Z ; D3D_CDisplayModeAutoDetector::GetD3DAdapterInfop
  00014	89 45 fc	 mov	 DWORD PTR _pkD3DAdapterInfo$[ebp], eax

; 589  : 	if (pkD3DAdapterInfo)

  00017	83 7d fc 00	 cmp	 DWORD PTR _pkD3DAdapterInfo$[ebp], 0
  0001b	74 2d		 je	 SHORT $LN2@GetD3DMode

; 590  : 	{
; 591  : 		D3D_CDeviceInfo* pkD3DDevInfo=pkD3DAdapterInfo->GetD3DDeviceInfop(iD3DDevInfo);

  0001d	ff 75 0c	 push	 DWORD PTR _iD3DDevInfo$[ebp]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _pkD3DAdapterInfo$[ebp]
  00023	e8 00 00 00 00	 call	 ?GetD3DDeviceInfop@D3D_CAdapterInfo@@QAEPAVD3D_CDeviceInfo@@I@Z ; D3D_CAdapterInfo::GetD3DDeviceInfop
  00028	89 45 f8	 mov	 DWORD PTR _pkD3DDevInfo$2[ebp], eax

; 592  : 		if (pkD3DDevInfo)

  0002b	83 7d f8 00	 cmp	 DWORD PTR _pkD3DDevInfo$2[ebp], 0
  0002f	74 19		 je	 SHORT $LN2@GetD3DMode

; 593  : 		{
; 594  : 			D3D_SModeInfo* pkD3D_SModeInfo=pkD3DDevInfo->GetD3DModeInfop(iD3D_SModeInfo);		

  00031	ff 75 10	 push	 DWORD PTR _iD3D_SModeInfo$[ebp]
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _pkD3DDevInfo$2[ebp]
  00037	e8 00 00 00 00	 call	 ?GetD3DModeInfop@D3D_CDeviceInfo@@QAEPAUD3D_SModeInfo@@I@Z ; D3D_CDeviceInfo::GetD3DModeInfop
  0003c	89 45 f4	 mov	 DWORD PTR _pkD3D_SModeInfo$1[ebp], eax

; 595  : 			if (pkD3D_SModeInfo)

  0003f	83 7d f4 00	 cmp	 DWORD PTR _pkD3D_SModeInfo$1[ebp], 0
  00043	74 05		 je	 SHORT $LN2@GetD3DMode

; 596  : 				return pkD3D_SModeInfo;

  00045	8b 45 f4	 mov	 eax, DWORD PTR _pkD3D_SModeInfo$1[ebp]
  00048	eb 02		 jmp	 SHORT $LN1@GetD3DMode
$LN2@GetD3DMode:

; 597  : 		}
; 598  : 	}
; 599  : 	return NULL;	

  0004a	33 c0		 xor	 eax, eax
$LN1@GetD3DMode:

; 600  : }

  0004c	c9		 leave
  0004d	c2 0c 00	 ret	 12			; 0000000cH
?GetD3DModeInfop@D3D_CDisplayModeAutoDetector@@QAEPAUD3D_SModeInfo@@III@Z ENDP ; D3D_CDisplayModeAutoDetector::GetD3DModeInfop
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetD3DAdapterInfop@D3D_CDisplayModeAutoDetector@@QAEPAVD3D_CAdapterInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iD3DAdapterInfo$ = 8					; size = 4
?GetD3DAdapterInfop@D3D_CDisplayModeAutoDetector@@QAEPAVD3D_CAdapterInfo@@I@Z PROC ; D3D_CDisplayModeAutoDetector::GetD3DAdapterInfop, COMDAT
; _this$ = ecx

; 579  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 	if (iD3DAdapterInfo >= m_uD3DAdapterInfoCount)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _iD3DAdapterInfo$[ebp]
  0000d	3b 88 70 19 03
	00		 cmp	 ecx, DWORD PTR [eax+203120]
  00013	72 04		 jb	 SHORT $LN2@GetD3DAdap

; 581  : 		return NULL;

  00015	33 c0		 xor	 eax, eax
  00017	eb 0a		 jmp	 SHORT $LN1@GetD3DAdap
$LN2@GetD3DAdap:

; 582  : 
; 583  : 	return &m_akD3DAdapterInfo[iD3DAdapterInfo];

  00019	69 45 08 58 4f
	00 00		 imul	 eax, DWORD PTR _iD3DAdapterInfo$[ebp], 20312
  00020	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
$LN1@GetD3DAdap:

; 584  : }

  00023	c9		 leave
  00024	c2 04 00	 ret	 4
?GetD3DAdapterInfop@D3D_CDisplayModeAutoDetector@@QAEPAVD3D_CAdapterInfo@@I@Z ENDP ; D3D_CDisplayModeAutoDetector::GetD3DAdapterInfop
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?Build@D3D_CDisplayModeAutoDetector@@QAEHAAUIDirect3D8@@P6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z
_TEXT	SEGMENT
_rkAdapterInfo$1 = -20					; size = 4
tv70 = -16						; size = 4
_iD3DAdapterInfo$2 = -12				; size = 4
_uTotalAdapterCount$ = -8				; size = 4
_this$ = -4						; size = 4
_rkD3D$ = 8						; size = 4
_pfnConfirmDevice$ = 12					; size = 4
?Build@D3D_CDisplayModeAutoDetector@@QAEHAAUIDirect3D8@@P6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z PROC ; D3D_CDisplayModeAutoDetector::Build, COMDAT
; _this$ = ecx

; 617  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 618  : 	m_uD3DAdapterInfoCount=0;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 a0 70 19 03
	00 00		 and	 DWORD PTR [eax+203120], 0

; 619  : 
; 620  : 	UINT uTotalAdapterCount=rkD3D.GetAdapterCount();	

  00013	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  0001b	ff 50 10	 call	 DWORD PTR [eax+16]
  0001e	89 45 f8	 mov	 DWORD PTR _uTotalAdapterCount$[ebp], eax

; 621  : 	uTotalAdapterCount=min(uTotalAdapterCount, D3DADAPTERINFO_NUM);

  00021	83 7d f8 0a	 cmp	 DWORD PTR _uTotalAdapterCount$[ebp], 10 ; 0000000aH
  00025	73 08		 jae	 SHORT $LN8@Build
  00027	8b 45 f8	 mov	 eax, DWORD PTR _uTotalAdapterCount$[ebp]
  0002a	89 45 f0	 mov	 DWORD PTR tv70[ebp], eax
  0002d	eb 07		 jmp	 SHORT $LN9@Build
$LN8@Build:
  0002f	c7 45 f0 0a 00
	00 00		 mov	 DWORD PTR tv70[ebp], 10	; 0000000aH
$LN9@Build:
  00036	8b 45 f0	 mov	 eax, DWORD PTR tv70[ebp]
  00039	89 45 f8	 mov	 DWORD PTR _uTotalAdapterCount$[ebp], eax

; 622  : 
; 623  : 	for (UINT iD3DAdapterInfo=0; iD3DAdapterInfo<uTotalAdapterCount; ++iD3DAdapterInfo)

  0003c	83 65 f4 00	 and	 DWORD PTR _iD3DAdapterInfo$2[ebp], 0
  00040	eb 07		 jmp	 SHORT $LN4@Build
$LN2@Build:
  00042	8b 45 f4	 mov	 eax, DWORD PTR _iD3DAdapterInfo$2[ebp]
  00045	40		 inc	 eax
  00046	89 45 f4	 mov	 DWORD PTR _iD3DAdapterInfo$2[ebp], eax
$LN4@Build:
  00049	8b 45 f4	 mov	 eax, DWORD PTR _iD3DAdapterInfo$2[ebp]
  0004c	3b 45 f8	 cmp	 eax, DWORD PTR _uTotalAdapterCount$[ebp]
  0004f	73 3d		 jae	 SHORT $LN3@Build

; 624  : 	{
; 625  : 		D3D_CAdapterInfo& rkAdapterInfo=m_akD3DAdapterInfo[m_uD3DAdapterInfoCount];	

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	69 80 70 19 03
	00 58 4f 00 00	 imul	 eax, DWORD PTR [eax+203120], 20312
  0005e	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]
  00061	89 45 ec	 mov	 DWORD PTR _rkAdapterInfo$1[ebp], eax

; 626  : 		if (rkAdapterInfo.Build(rkD3D, iD3DAdapterInfo, pfnConfirmDevice))

  00064	ff 75 0c	 push	 DWORD PTR _pfnConfirmDevice$[ebp]
  00067	ff 75 f4	 push	 DWORD PTR _iD3DAdapterInfo$2[ebp]
  0006a	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  0006d	8b 4d ec	 mov	 ecx, DWORD PTR _rkAdapterInfo$1[ebp]
  00070	e8 00 00 00 00	 call	 ?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z ; D3D_CAdapterInfo::Build
  00075	85 c0		 test	 eax, eax
  00077	74 13		 je	 SHORT $LN5@Build

; 627  : 			++m_uD3DAdapterInfoCount;

  00079	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	8b 80 70 19 03
	00		 mov	 eax, DWORD PTR [eax+203120]
  00082	40		 inc	 eax
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	89 81 70 19 03
	00		 mov	 DWORD PTR [ecx+203120], eax
$LN5@Build:

; 628  : 	}

  0008c	eb b4		 jmp	 SHORT $LN2@Build
$LN3@Build:

; 629  : 
; 630  : 	if (m_uD3DAdapterInfoCount>0)

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00091	83 b8 70 19 03
	00 00		 cmp	 DWORD PTR [eax+203120], 0
  00098	76 05		 jbe	 SHORT $LN6@Build

; 631  : 		return TRUE;

  0009a	33 c0		 xor	 eax, eax
  0009c	40		 inc	 eax
  0009d	eb 02		 jmp	 SHORT $LN1@Build
$LN6@Build:

; 632  : 
; 633  : 	return FALSE;

  0009f	33 c0		 xor	 eax, eax
$LN1@Build:

; 634  : }

  000a1	c9		 leave
  000a2	c2 08 00	 ret	 8
?Build@D3D_CDisplayModeAutoDetector@@QAEHAAUIDirect3D8@@P6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z ENDP ; D3D_CDisplayModeAutoDetector::Build
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?Find@D3D_CDisplayModeAutoDetector@@QAEHIIIHPAI00@Z
_TEXT	SEGMENT
_rkAdapterInfo$1 = -12					; size = 4
_this$ = -8						; size = 4
_iD3DAdapterInfo$2 = -4					; size = 4
_uScrWidth$ = 8						; size = 4
_uScrHeight$ = 12					; size = 4
_uScrDepthBits$ = 16					; size = 4
_isWindowed$ = 20					; size = 4
_piD3DModeInfo$ = 24					; size = 4
_piD3DDevInfo$ = 28					; size = 4
_piD3DAdapterInfo$ = 32					; size = 4
?Find@D3D_CDisplayModeAutoDetector@@QAEHIIIHPAI00@Z PROC ; D3D_CDisplayModeAutoDetector::Find, COMDAT
; _this$ = ecx

; 603  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 604  : 	for (UINT iD3DAdapterInfo=0; iD3DAdapterInfo<m_uD3DAdapterInfoCount; ++iD3DAdapterInfo)

  00009	83 65 fc 00	 and	 DWORD PTR _iD3DAdapterInfo$2[ebp], 0
  0000d	eb 07		 jmp	 SHORT $LN4@Find
$LN2@Find:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _iD3DAdapterInfo$2[ebp]
  00012	40		 inc	 eax
  00013	89 45 fc	 mov	 DWORD PTR _iD3DAdapterInfo$2[ebp], eax
$LN4@Find:
  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _iD3DAdapterInfo$2[ebp]
  0001c	3b 88 70 19 03
	00		 cmp	 ecx, DWORD PTR [eax+203120]
  00022	73 3a		 jae	 SHORT $LN3@Find

; 605  : 	{
; 606  : 		D3D_CAdapterInfo& rkAdapterInfo=m_akD3DAdapterInfo[iD3DAdapterInfo];

  00024	69 45 fc 58 4f
	00 00		 imul	 eax, DWORD PTR _iD3DAdapterInfo$2[ebp], 20312
  0002b	03 45 f8	 add	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 f4	 mov	 DWORD PTR _rkAdapterInfo$1[ebp], eax

; 607  : 		if (rkAdapterInfo.Find(uScrWidth, uScrHeight, uScrDepthBits, isWindowed, piD3DModeInfo, piD3DDevInfo))

  00031	ff 75 1c	 push	 DWORD PTR _piD3DDevInfo$[ebp]
  00034	ff 75 18	 push	 DWORD PTR _piD3DModeInfo$[ebp]
  00037	ff 75 14	 push	 DWORD PTR _isWindowed$[ebp]
  0003a	ff 75 10	 push	 DWORD PTR _uScrDepthBits$[ebp]
  0003d	ff 75 0c	 push	 DWORD PTR _uScrHeight$[ebp]
  00040	ff 75 08	 push	 DWORD PTR _uScrWidth$[ebp]
  00043	8b 4d f4	 mov	 ecx, DWORD PTR _rkAdapterInfo$1[ebp]
  00046	e8 00 00 00 00	 call	 ?Find@D3D_CAdapterInfo@@QAEHIIIHPAI0@Z ; D3D_CAdapterInfo::Find
  0004b	85 c0		 test	 eax, eax
  0004d	74 0d		 je	 SHORT $LN5@Find

; 608  : 		{
; 609  : 			*piD3DAdapterInfo=iD3DAdapterInfo;

  0004f	8b 45 20	 mov	 eax, DWORD PTR _piD3DAdapterInfo$[ebp]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _iD3DAdapterInfo$2[ebp]
  00055	89 08		 mov	 DWORD PTR [eax], ecx

; 610  : 			return TRUE;

  00057	33 c0		 xor	 eax, eax
  00059	40		 inc	 eax
  0005a	eb 04		 jmp	 SHORT $LN1@Find
$LN5@Find:

; 611  : 		}
; 612  : 	}

  0005c	eb b1		 jmp	 SHORT $LN2@Find
$LN3@Find:

; 613  : 	return FALSE;

  0005e	33 c0		 xor	 eax, eax
$LN1@Find:

; 614  : }

  00060	c9		 leave
  00061	c2 1c 00	 ret	 28			; 0000001cH
?Find@D3D_CDisplayModeAutoDetector@@QAEHIIIHPAI00@Z ENDP ; D3D_CDisplayModeAutoDetector::Find
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ??1D3D_CDisplayModeAutoDetector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3D_CDisplayModeAutoDetector@@QAE@XZ PROC		; D3D_CDisplayModeAutoDetector::~D3D_CDisplayModeAutoDetector, COMDAT
; _this$ = ecx

; 575  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1D3D_CDisplayModeAutoDetector@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 576  : }

  00026	68 00 00 00 00	 push	 OFFSET ??1D3D_CAdapterInfo@@QAE@XZ ; D3D_CAdapterInfo::~D3D_CAdapterInfo
  0002b	6a 0a		 push	 10			; 0000000aH
  0002d	68 58 4f 00 00	 push	 20312			; 00004f58H
  00032	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00044	59		 pop	 ecx
  00045	c9		 leave
  00046	c3		 ret	 0
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
  0004a	cc		 int	 3
  0004b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1D3D_CDisplayModeAutoDetector@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1D3D_CDisplayModeAutoDetector@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1D3D_CDisplayModeAutoDetector@@QAE@XZ ENDP		; D3D_CDisplayModeAutoDetector::~D3D_CDisplayModeAutoDetector
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ??0D3D_CDisplayModeAutoDetector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0D3D_CDisplayModeAutoDetector@@QAE@XZ PROC		; D3D_CDisplayModeAutoDetector::D3D_CDisplayModeAutoDetector, COMDAT
; _this$ = ecx

; 570  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET ??1D3D_CAdapterInfo@@QAE@XZ ; D3D_CAdapterInfo::~D3D_CAdapterInfo
  0000c	68 00 00 00 00	 push	 OFFSET ??0D3D_CAdapterInfo@@QAE@XZ ; D3D_CAdapterInfo::D3D_CAdapterInfo
  00011	6a 0a		 push	 10			; 0000000aH
  00013	68 58 4f 00 00	 push	 20312			; 00004f58H
  00018	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z

; 571  : 	m_uD3DAdapterInfoCount=0;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	83 a0 70 19 03
	00 00		 and	 DWORD PTR [eax+203120], 0

; 572  : }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0D3D_CDisplayModeAutoDetector@@QAE@XZ ENDP		; D3D_CDisplayModeAutoDetector::D3D_CDisplayModeAutoDetector
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetD3DModeInfop@D3D_CAdapterInfo@@QAEPAUD3D_SModeInfo@@II@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pkD3DModeInfo$1 = -8					; size = 4
_pkD3DDevInfo$ = -4					; size = 4
_iD3DDevInfo$ = 8					; size = 4
_iD3D_SModeInfo$ = 12					; size = 4
?GetD3DModeInfop@D3D_CAdapterInfo@@QAEPAUD3D_SModeInfo@@II@Z PROC ; D3D_CAdapterInfo::GetD3DModeInfop, COMDAT
; _this$ = ecx

; 501  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 502  : 	D3D_CDeviceInfo* pkD3DDevInfo=GetD3DDeviceInfop(iD3DDevInfo);

  00009	ff 75 08	 push	 DWORD PTR _iD3DDevInfo$[ebp]
  0000c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetD3DDeviceInfop@D3D_CAdapterInfo@@QAEPAVD3D_CDeviceInfo@@I@Z ; D3D_CAdapterInfo::GetD3DDeviceInfop
  00014	89 45 fc	 mov	 DWORD PTR _pkD3DDevInfo$[ebp], eax

; 503  : 	if (pkD3DDevInfo)

  00017	83 7d fc 00	 cmp	 DWORD PTR _pkD3DDevInfo$[ebp], 0
  0001b	74 19		 je	 SHORT $LN2@GetD3DMode

; 504  : 	{
; 505  : 		D3D_SModeInfo* pkD3DModeInfo=pkD3DDevInfo->GetD3DModeInfop(iD3D_SModeInfo);		

  0001d	ff 75 0c	 push	 DWORD PTR _iD3D_SModeInfo$[ebp]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _pkD3DDevInfo$[ebp]
  00023	e8 00 00 00 00	 call	 ?GetD3DModeInfop@D3D_CDeviceInfo@@QAEPAUD3D_SModeInfo@@I@Z ; D3D_CDeviceInfo::GetD3DModeInfop
  00028	89 45 f8	 mov	 DWORD PTR _pkD3DModeInfo$1[ebp], eax

; 506  : 		if (pkD3DModeInfo)

  0002b	83 7d f8 00	 cmp	 DWORD PTR _pkD3DModeInfo$1[ebp], 0
  0002f	74 05		 je	 SHORT $LN2@GetD3DMode

; 507  : 			return pkD3DModeInfo;

  00031	8b 45 f8	 mov	 eax, DWORD PTR _pkD3DModeInfo$1[ebp]
  00034	eb 02		 jmp	 SHORT $LN1@GetD3DMode
$LN2@GetD3DMode:

; 508  : 	}
; 509  : 	return NULL;

  00036	33 c0		 xor	 eax, eax
$LN1@GetD3DMode:

; 510  : }

  00038	c9		 leave
  00039	c2 08 00	 ret	 8
?GetD3DModeInfop@D3D_CAdapterInfo@@QAEPAUD3D_SModeInfo@@II@Z ENDP ; D3D_CAdapterInfo::GetD3DModeInfop
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetD3DDeviceInfop@D3D_CAdapterInfo@@QAEPAVD3D_CDeviceInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iD3DDevInfo$ = 8					; size = 4
?GetD3DDeviceInfop@D3D_CAdapterInfo@@QAEPAVD3D_CDeviceInfo@@I@Z PROC ; D3D_CAdapterInfo::GetD3DDeviceInfop, COMDAT
; _this$ = ecx

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 494  : 	if (iD3DDevInfo >= m_uD3DDevInfoNum)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _iD3DDevInfo$[ebp]
  0000d	3b 88 40 04 00
	00		 cmp	 ecx, DWORD PTR [eax+1088]
  00013	72 04		 jb	 SHORT $LN2@GetD3DDevi

; 495  : 		return NULL;

  00015	33 c0		 xor	 eax, eax
  00017	eb 11		 jmp	 SHORT $LN1@GetD3DDevi
$LN2@GetD3DDevi:

; 496  : 
; 497  : 	return &m_akD3DDevInfo[iD3DDevInfo];	

  00019	69 45 08 04 0f
	00 00		 imul	 eax, DWORD PTR _iD3DDevInfo$[ebp], 3844
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8d 84 01 44 04
	00 00		 lea	 eax, DWORD PTR [ecx+eax+1092]
$LN1@GetD3DDevi:

; 498  : }

  0002a	c9		 leave
  0002b	c2 04 00	 ret	 4
?GetD3DDeviceInfop@D3D_CAdapterInfo@@QAEPAVD3D_CDeviceInfo@@I@Z ENDP ; D3D_CAdapterInfo::GetD3DDeviceInfop
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetDesktopD3DDisplayModep@D3D_CAdapterInfo@@QAEPAU_D3DDISPLAYMODE@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDesktopD3DDisplayModep@D3D_CAdapterInfo@@QAEPAU_D3DDISPLAYMODE@@XZ PROC ; D3D_CAdapterInfo::GetDesktopD3DDisplayModep, COMDAT
; _this$ = ecx

; 488  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 489  : 	return &m_kD3DDMDesktop;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	05 2c 04 00 00	 add	 eax, 1068		; 0000042cH

; 490  : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?GetDesktopD3DDisplayModep@D3D_CAdapterInfo@@QAEPAU_D3DDISPLAYMODE@@XZ ENDP ; D3D_CAdapterInfo::GetDesktopD3DDisplayModep
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetDesktopD3DDisplayModer@D3D_CAdapterInfo@@QAEAAU_D3DDISPLAYMODE@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDesktopD3DDisplayModer@D3D_CAdapterInfo@@QAEAAU_D3DDISPLAYMODE@@XZ PROC ; D3D_CAdapterInfo::GetDesktopD3DDisplayModer, COMDAT
; _this$ = ecx

; 483  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 484  : 	return m_kD3DDMDesktop;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	05 2c 04 00 00	 add	 eax, 1068		; 0000042cH

; 485  : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?GetDesktopD3DDisplayModer@D3D_CAdapterInfo@@QAEAAU_D3DDISPLAYMODE@@XZ ENDP ; D3D_CAdapterInfo::GetDesktopD3DDisplayModer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetString@D3D_CAdapterInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_rkD3DDevInfo$1 = -128					; size = 4
$T2 = -124						; size = 4
$T3 = -120						; size = 4
_this$ = -116						; size = 4
_iDevInfo$4 = -112					; size = 4
_szText$5 = -108					; size = 1025
__$ArrayPad$ = 920					; size = 4
_pstEnumList$ = 932					; size = 4
?GetString@D3D_CAdapterInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; D3D_CAdapterInfo::GetString, COMDAT
; _this$ = ecx

; 555  : {

  00000	55		 push	 ebp
  00001	8d ac 24 64 fc
	ff ff		 lea	 ebp, DWORD PTR [esp-924]
  00008	81 ec 1c 04 00
	00		 sub	 esp, 1052		; 0000041cH
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 98 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 8c	 mov	 DWORD PTR _this$[ebp], ecx

; 556  : 	for (UINT iDevInfo=0; iDevInfo<m_uD3DDevInfoNum; ++iDevInfo)

  0001e	83 65 90 00	 and	 DWORD PTR _iDevInfo$4[ebp], 0
  00022	eb 07		 jmp	 SHORT $LN4@GetString
$LN2@GetString:
  00024	8b 45 90	 mov	 eax, DWORD PTR _iDevInfo$4[ebp]
  00027	40		 inc	 eax
  00028	89 45 90	 mov	 DWORD PTR _iDevInfo$4[ebp], eax
$LN4@GetString:
  0002b	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 90	 mov	 ecx, DWORD PTR _iDevInfo$4[ebp]
  00031	3b 88 40 04 00
	00		 cmp	 ecx, DWORD PTR [eax+1088]
  00037	73 62		 jae	 SHORT $LN1@GetString

; 557  : 	{		
; 558  : 		char szText[1024+1];
; 559  : 		_snprintf(szText, sizeof(szText), "Device %d\r\n", iDevInfo);

  00039	ff 75 90	 push	 DWORD PTR _iDevInfo$4[ebp]
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FCEPDHJA@Device?5?$CFd?$AN?6@
  00041	68 01 04 00 00	 push	 1025			; 00000401H
  00046	8d 45 94	 lea	 eax, DWORD PTR _szText$5[ebp]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 __snprintf
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00052	8d 45 94	 lea	 eax, DWORD PTR _szText$5[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _strlen
  0005b	59		 pop	 ecx
  0005c	89 45 88	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0005f	8b 45 88	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00065	ff 75 84	 push	 DWORD PTR $T2[ebp]
  00068	8d 45 94	 lea	 eax, DWORD PTR _szText$5[ebp]
  0006b	50		 push	 eax
  0006c	8b 8d a4 03 00
	00		 mov	 ecx, DWORD PTR _pstEnumList$[ebp]
  00072	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp

; 562  :         D3D_CDeviceInfo& rkD3DDevInfo=m_akD3DDevInfo[iDevInfo];

  00077	69 45 90 04 0f
	00 00		 imul	 eax, DWORD PTR _iDevInfo$4[ebp], 3844
  0007e	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	8d 84 01 44 04
	00 00		 lea	 eax, DWORD PTR [ecx+eax+1092]
  00088	89 45 80	 mov	 DWORD PTR _rkD3DDevInfo$1[ebp], eax

; 563  : 		rkD3DDevInfo.GetString(pstEnumList);			

  0008b	ff b5 a4 03 00
	00		 push	 DWORD PTR _pstEnumList$[ebp]
  00091	8b 4d 80	 mov	 ecx, DWORD PTR _rkD3DDevInfo$1[ebp]
  00094	e8 00 00 00 00	 call	 ?GetString@D3D_CDeviceInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; D3D_CDeviceInfo::GetString

; 564  : 	}	

  00099	eb 89		 jmp	 SHORT $LN2@GetString
$LN1@GetString:

; 565  : }

  0009b	8b 8d 98 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a1	33 cd		 xor	 ecx, ebp
  000a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a8	81 c5 9c 03 00
	00		 add	 ebp, 924		; 0000039cH
  000ae	c9		 leave
  000af	c2 04 00	 ret	 4
?GetString@D3D_CAdapterInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; D3D_CAdapterInfo::GetString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
$T3 = -36						; size = 4
_rkD3DDevInfo$4 = -32					; size = 4
_akD3DDevInfo$ = -28					; size = 4
_rkD3DDMDesktop$ = -24					; size = 4
_iDevType$5 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_kD3DADMList$ = 0					; size = 1688
__$ArrayPad$ = 1688					; size = 4
_rkD3D$ = 1700						; size = 4
_iD3DAdapterInfo$ = 1704				; size = 4
_pfnConfirmDevice$ = 1708				; size = 4
?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z PROC ; D3D_CAdapterInfo::Build, COMDAT
; _this$ = ecx

; 527  : {

  00000	55		 push	 ebp
  00001	8d ac 24 64 f9
	ff ff		 lea	 ebp, DWORD PTR [esp-1692]
  00008	81 ec 9c 06 00
	00		 sub	 esp, 1692		; 0000069cH
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 98 06 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 528  : 	D3DDISPLAYMODE& rkD3DDMDesktop=m_kD3DDMDesktop;

  00039	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	05 2c 04 00 00	 add	 eax, 1068		; 0000042cH
  00041	89 45 e8	 mov	 DWORD PTR _rkD3DDMDesktop$[ebp], eax

; 529  : 	if (FAILED(rkD3D.GetAdapterDisplayMode(iD3DAdapterInfo, &rkD3DDMDesktop)))

  00044	ff 75 e8	 push	 DWORD PTR _rkD3DDMDesktop$[ebp]
  00047	ff b5 a8 06 00
	00		 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  0004d	8b 85 a4 06 00
	00		 mov	 eax, DWORD PTR _rkD3D$[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	ff b5 a4 06 00
	00		 push	 DWORD PTR _rkD3D$[ebp]
  0005b	ff 50 20	 call	 DWORD PTR [eax+32]
  0005e	85 c0		 test	 eax, eax
  00060	7d 07		 jge	 SHORT $LN5@Build

; 530  : 		return FALSE;

  00062	33 c0		 xor	 eax, eax
  00064	e9 e3 00 00 00	 jmp	 $LN1@Build
$LN5@Build:

; 531  : 
; 532  : 	rkD3D.GetAdapterIdentifier(iD3DAdapterInfo, D3DENUM_NO_WHQL_LEVEL, &m_kD3DAdapterIdentifier);

  00069	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  0006c	6a 02		 push	 2
  0006e	ff b5 a8 06 00
	00		 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  00074	8b 85 a4 06 00
	00		 mov	 eax, DWORD PTR _rkD3D$[ebp]
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	ff b5 a4 06 00
	00		 push	 DWORD PTR _rkD3D$[ebp]
  00082	ff 50 14	 call	 DWORD PTR [eax+20]

; 533  : 	
; 534  : 	m_iCurD3DDevInfo=0;

  00085	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00088	83 a0 3c 04 00
	00 00		 and	 DWORD PTR [eax+1084], 0

; 535  : 	m_uD3DDevInfoNum=0;

  0008f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00092	83 a0 40 04 00
	00 00		 and	 DWORD PTR [eax+1088], 0

; 536  : 
; 537  : 	D3D_CAdapterDisplayModeList kD3DADMList;

  00099	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 538  : 	kD3DADMList.Build(rkD3D, m_kD3DDMDesktop.Format, iD3DAdapterInfo);

  0009d	ff b5 a8 06 00
	00		 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  000a3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	ff b0 38 04 00
	00		 push	 DWORD PTR [eax+1080]
  000ac	ff b5 a4 06 00
	00		 push	 DWORD PTR _rkD3D$[ebp]
  000b2	8d 4d 00	 lea	 ecx, DWORD PTR _kD3DADMList$[ebp]
  000b5	e8 00 00 00 00	 call	 ?Build@D3D_CAdapterDisplayModeList@@QAEXAAUIDirect3D8@@W4_D3DFORMAT@@I@Z ; D3D_CAdapterDisplayModeList::Build

; 539  : 
; 540  : 	D3D_CDeviceInfo* akD3DDevInfo=m_akD3DDevInfo;

  000ba	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	05 44 04 00 00	 add	 eax, 1092		; 00000444H
  000c2	89 45 e4	 mov	 DWORD PTR _akD3DDevInfo$[ebp], eax

; 541  : 	for (UINT iDevType=0; iDevType<D3DDEVICETYPE_NUM; ++iDevType)

  000c5	83 65 ec 00	 and	 DWORD PTR _iDevType$5[ebp], 0
  000c9	eb 07		 jmp	 SHORT $LN4@Build
$LN2@Build:
  000cb	8b 45 ec	 mov	 eax, DWORD PTR _iDevType$5[ebp]
  000ce	40		 inc	 eax
  000cf	89 45 ec	 mov	 DWORD PTR _iDevType$5[ebp], eax
$LN4@Build:
  000d2	83 7d ec 02	 cmp	 DWORD PTR _iDevType$5[ebp], 2
  000d6	73 4d		 jae	 SHORT $LN3@Build

; 542  : 	{		
; 543  :         D3D_CDeviceInfo& rkD3DDevInfo=akD3DDevInfo[m_uD3DDevInfoNum];

  000d8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000db	69 80 40 04 00
	00 04 0f 00 00	 imul	 eax, DWORD PTR [eax+1088], 3844
  000e5	03 45 e4	 add	 eax, DWORD PTR _akD3DDevInfo$[ebp]
  000e8	89 45 e0	 mov	 DWORD PTR _rkD3DDevInfo$4[ebp], eax

; 544  : 		if (rkD3DDevInfo.Build(rkD3D, iD3DAdapterInfo, iDevType, kD3DADMList, pfnConfirmDevice))

  000eb	ff b5 ac 06 00
	00		 push	 DWORD PTR _pfnConfirmDevice$[ebp]
  000f1	8d 45 00	 lea	 eax, DWORD PTR _kD3DADMList$[ebp]
  000f4	50		 push	 eax
  000f5	ff 75 ec	 push	 DWORD PTR _iDevType$5[ebp]
  000f8	ff b5 a8 06 00
	00		 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  000fe	ff b5 a4 06 00
	00		 push	 DWORD PTR _rkD3D$[ebp]
  00104	8b 4d e0	 mov	 ecx, DWORD PTR _rkD3DDevInfo$4[ebp]
  00107	e8 00 00 00 00	 call	 ?Build@D3D_CDeviceInfo@@QAEHAAUIDirect3D8@@IIAAVD3D_CAdapterDisplayModeList@@P6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z ; D3D_CDeviceInfo::Build
  0010c	85 c0		 test	 eax, eax
  0010e	74 13		 je	 SHORT $LN6@Build

; 545  : 			++m_uD3DDevInfoNum;

  00110	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00113	8b 80 40 04 00
	00		 mov	 eax, DWORD PTR [eax+1088]
  00119	40		 inc	 eax
  0011a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	89 81 40 04 00
	00		 mov	 DWORD PTR [ecx+1088], eax
$LN6@Build:

; 546  : 	}

  00123	eb a6		 jmp	 SHORT $LN2@Build
$LN3@Build:

; 547  : 	
; 548  : 	if (m_uD3DDevInfoNum>0)

  00125	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00128	83 b8 40 04 00
	00 00		 cmp	 DWORD PTR [eax+1088], 0
  0012f	76 10		 jbe	 SHORT $LN7@Build

; 549  : 		return TRUE;

  00131	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR $T3[ebp], 1
  00138	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0013c	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0013f	eb 0b		 jmp	 SHORT $LN1@Build
$LN7@Build:

; 550  : 
; 551  : 	return FALSE;

  00141	83 65 d8 00	 and	 DWORD PTR $T2[ebp], 0
  00145	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00149	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@Build:

; 552  : }

  0014c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00156	59		 pop	 ecx
  00157	8b 8d 98 06 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015d	33 cd		 xor	 ecx, ebp
  0015f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00164	81 c5 9c 06 00
	00		 add	 ebp, 1692		; 0000069cH
  0016a	c9		 leave
  0016b	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _kD3DADMList$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1D3D_CAdapterDisplayModeList@@QAE@XZ ; D3D_CAdapterDisplayModeList::~D3D_CAdapterDisplayModeList
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 8a a4 06 00
	00		 mov	 ecx, DWORD PTR [edx+1700]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Build@D3D_CAdapterInfo@@QAEHAAUIDirect3D8@@IP6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z ENDP ; D3D_CAdapterInfo::Build
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?Find@D3D_CAdapterInfo@@QAEHIIIHPAI0@Z
_TEXT	SEGMENT
_rkD3DDevInfo$1 = -12					; size = 4
_this$ = -8						; size = 4
_iDevInfo$2 = -4					; size = 4
_uScrWidth$ = 8						; size = 4
_uScrHeight$ = 12					; size = 4
_uScrDepthBits$ = 16					; size = 4
_isWindowed$ = 20					; size = 4
_piD3DModeInfo$ = 24					; size = 4
_piD3DDevInfo$ = 28					; size = 4
?Find@D3D_CAdapterInfo@@QAEHIIIHPAI0@Z PROC		; D3D_CAdapterInfo::Find, COMDAT
; _this$ = ecx

; 513  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 514  : 	for (UINT iDevInfo=0; iDevInfo<m_uD3DDevInfoNum; ++iDevInfo)

  00009	83 65 fc 00	 and	 DWORD PTR _iDevInfo$2[ebp], 0
  0000d	eb 07		 jmp	 SHORT $LN4@Find
$LN2@Find:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _iDevInfo$2[ebp]
  00012	40		 inc	 eax
  00013	89 45 fc	 mov	 DWORD PTR _iDevInfo$2[ebp], eax
$LN4@Find:
  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _iDevInfo$2[ebp]
  0001c	3b 88 40 04 00
	00		 cmp	 ecx, DWORD PTR [eax+1088]
  00022	73 3e		 jae	 SHORT $LN3@Find

; 515  : 	{		
; 516  :         D3D_CDeviceInfo& rkD3DDevInfo=m_akD3DDevInfo[iDevInfo];

  00024	69 45 fc 04 0f
	00 00		 imul	 eax, DWORD PTR _iDevInfo$2[ebp], 3844
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8d 84 01 44 04
	00 00		 lea	 eax, DWORD PTR [ecx+eax+1092]
  00035	89 45 f4	 mov	 DWORD PTR _rkD3DDevInfo$1[ebp], eax

; 517  : 		if (rkD3DDevInfo.Find(uScrWidth, uScrHeight, uScrDepthBits, isWindowed, piD3DModeInfo))

  00038	ff 75 18	 push	 DWORD PTR _piD3DModeInfo$[ebp]
  0003b	ff 75 14	 push	 DWORD PTR _isWindowed$[ebp]
  0003e	ff 75 10	 push	 DWORD PTR _uScrDepthBits$[ebp]
  00041	ff 75 0c	 push	 DWORD PTR _uScrHeight$[ebp]
  00044	ff 75 08	 push	 DWORD PTR _uScrWidth$[ebp]
  00047	8b 4d f4	 mov	 ecx, DWORD PTR _rkD3DDevInfo$1[ebp]
  0004a	e8 00 00 00 00	 call	 ?Find@D3D_CDeviceInfo@@QAEHIIIHPAI@Z ; D3D_CDeviceInfo::Find
  0004f	85 c0		 test	 eax, eax
  00051	74 0d		 je	 SHORT $LN5@Find

; 518  : 		{
; 519  : 			*piD3DDevInfo=iDevInfo;

  00053	8b 45 1c	 mov	 eax, DWORD PTR _piD3DDevInfo$[ebp]
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _iDevInfo$2[ebp]
  00059	89 08		 mov	 DWORD PTR [eax], ecx

; 520  : 			return TRUE;

  0005b	33 c0		 xor	 eax, eax
  0005d	40		 inc	 eax
  0005e	eb 04		 jmp	 SHORT $LN1@Find
$LN5@Find:

; 521  : 		}
; 522  : 	}

  00060	eb ad		 jmp	 SHORT $LN2@Find
$LN3@Find:

; 523  : 	return FALSE;

  00062	33 c0		 xor	 eax, eax
$LN1@Find:

; 524  : }

  00064	c9		 leave
  00065	c2 18 00	 ret	 24			; 00000018H
?Find@D3D_CAdapterInfo@@QAEHIIIHPAI0@Z ENDP		; D3D_CAdapterInfo::Find
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.h
;	COMDAT ??1D3D_CAdapterInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3D_CAdapterInfo@@QAE@XZ PROC			; D3D_CAdapterInfo::~D3D_CAdapterInfo, COMDAT
; _this$ = ecx

; 110  : 		~D3D_CAdapterInfo() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1D3D_CAdapterInfo@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	68 00 00 00 00	 push	 OFFSET ??1D3D_CDeviceInfo@@QAE@XZ ; D3D_CDeviceInfo::~D3D_CDeviceInfo
  0002b	6a 05		 push	 5
  0002d	68 04 0f 00 00	 push	 3844			; 00000f04H
  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	05 44 04 00 00	 add	 eax, 1092		; 00000444H
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00040	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00043	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004a	59		 pop	 ecx
  0004b	c9		 leave
  0004c	c3		 ret	 0
  0004d	cc		 int	 3
  0004e	cc		 int	 3
  0004f	cc		 int	 3
  00050	cc		 int	 3
  00051	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1D3D_CAdapterInfo@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1D3D_CAdapterInfo@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1D3D_CAdapterInfo@@QAE@XZ ENDP			; D3D_CAdapterInfo::~D3D_CAdapterInfo
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.h
;	COMDAT ??0D3D_CAdapterInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0D3D_CAdapterInfo@@QAE@XZ PROC			; D3D_CAdapterInfo::D3D_CAdapterInfo, COMDAT
; _this$ = ecx

; 109  : 		D3D_CAdapterInfo() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	68 00 00 00 00	 push	 OFFSET ??1D3D_CDeviceInfo@@QAE@XZ ; D3D_CDeviceInfo::~D3D_CDeviceInfo
  0000c	68 00 00 00 00	 push	 OFFSET ??0D3D_CDeviceInfo@@QAE@XZ ; D3D_CDeviceInfo::D3D_CDeviceInfo
  00011	6a 05		 push	 5
  00013	68 04 0f 00 00	 push	 3844			; 00000f04H
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	05 44 04 00 00	 add	 eax, 1092		; 00000444H
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c3		 ret	 0
??0D3D_CAdapterInfo@@QAE@XZ ENDP			; D3D_CAdapterInfo::D3D_CAdapterInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetD3DModeInfop@D3D_CDeviceInfo@@QAEPAUD3D_SModeInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iD3D_SModeInfo$ = 8					; size = 4
?GetD3DModeInfop@D3D_CDeviceInfo@@QAEPAUD3D_SModeInfo@@I@Z PROC ; D3D_CDeviceInfo::GetD3DModeInfop, COMDAT
; _this$ = ecx

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 175  : 	if (iD3D_SModeInfo >= m_uD3DModeInfoNum)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _iD3D_SModeInfo$[ebp]
  0000d	3b 88 e4 00 00
	00		 cmp	 ecx, DWORD PTR [eax+228]
  00013	72 04		 jb	 SHORT $LN2@GetD3DMode

; 176  : 		return NULL;

  00015	33 c0		 xor	 eax, eax
  00017	eb 0e		 jmp	 SHORT $LN1@GetD3DMode
$LN2@GetD3DMode:

; 177  : 
; 178  : 	return &m_akD3DModeInfo[iD3D_SModeInfo];

  00019	6b 45 08 18	 imul	 eax, DWORD PTR _iD3D_SModeInfo$[ebp], 24
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	8d 84 01 e8 00
	00 00		 lea	 eax, DWORD PTR [ecx+eax+232]
$LN1@GetD3DMode:

; 179  : }

  00027	c9		 leave
  00028	c2 04 00	 ret	 4
?GetD3DModeInfop@D3D_CDeviceInfo@@QAEPAUD3D_SModeInfo@@I@Z ENDP ; D3D_CDeviceInfo::GetD3DModeInfop
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?FindDepthStencilFormat@D3D_CDeviceInfo@@QAEHAAUIDirect3D8@@IW4_D3DDEVTYPE@@W4_D3DFORMAT@@PAW44@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_m_dwMinStencilBits$ = -8				; size = 4
_m_dwMinDepthBits$ = -4					; size = 4
_rkD3D$ = 8						; size = 4
_iD3DAdapterInfo$ = 12					; size = 4
_DeviceType$ = 16					; size = 4
_TargetFormat$ = 20					; size = 4
_pDepthStencilFormat$ = 24				; size = 4
?FindDepthStencilFormat@D3D_CDeviceInfo@@QAEHAAUIDirect3D8@@IW4_D3DDEVTYPE@@W4_D3DFORMAT@@PAW44@@Z PROC ; D3D_CDeviceInfo::FindDepthStencilFormat, COMDAT
; _this$ = ecx

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 183  :     UINT m_dwMinDepthBits    = 16;

  00009	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR _m_dwMinDepthBits$[ebp], 16 ; 00000010H

; 184  :     UINT m_dwMinStencilBits  = 0;

  00010	83 65 f8 00	 and	 DWORD PTR _m_dwMinStencilBits$[ebp], 0

; 185  : 
; 186  :     if( m_dwMinDepthBits <= 16 && m_dwMinStencilBits == 0 )

  00014	83 7d fc 10	 cmp	 DWORD PTR _m_dwMinDepthBits$[ebp], 16 ; 00000010H
  00018	77 52		 ja	 SHORT $LN2@FindDepthS
  0001a	83 7d f8 00	 cmp	 DWORD PTR _m_dwMinStencilBits$[ebp], 0
  0001e	75 4c		 jne	 SHORT $LN2@FindDepthS

; 187  :     {
; 188  :         if( SUCCEEDED( rkD3D.CheckDeviceFormat( iD3DAdapterInfo, DeviceType,

  00020	6a 50		 push	 80			; 00000050H
  00022	6a 01		 push	 1
  00024	6a 02		 push	 2
  00026	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  00029	ff 75 10	 push	 DWORD PTR _DeviceType$[ebp]
  0002c	ff 75 0c	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  0002f	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  00037	ff 50 28	 call	 DWORD PTR [eax+40]
  0003a	85 c0		 test	 eax, eax
  0003c	7c 2e		 jl	 SHORT $LN2@FindDepthS

; 189  :             TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D16 ) ) )
; 190  :         {
; 191  :             if( SUCCEEDED( rkD3D.CheckDepthStencilMatch( iD3DAdapterInfo, DeviceType,

  0003e	6a 50		 push	 80			; 00000050H
  00040	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  00043	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  00046	ff 75 10	 push	 DWORD PTR _DeviceType$[ebp]
  00049	ff 75 0c	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  0004c	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
  00051	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  00054	ff 50 30	 call	 DWORD PTR [eax+48]
  00057	85 c0		 test	 eax, eax
  00059	7c 11		 jl	 SHORT $LN2@FindDepthS

; 192  :                 TargetFormat, TargetFormat, D3DFMT_D16 ) ) )
; 193  :             {
; 194  :                 *pDepthStencilFormat = D3DFMT_D16;

  0005b	8b 45 18	 mov	 eax, DWORD PTR _pDepthStencilFormat$[ebp]
  0005e	c7 00 50 00 00
	00		 mov	 DWORD PTR [eax], 80	; 00000050H

; 195  :                 return TRUE;

  00064	33 c0		 xor	 eax, eax
  00066	40		 inc	 eax
  00067	e9 b4 01 00 00	 jmp	 $LN1@FindDepthS
$LN2@FindDepthS:

; 196  :             }
; 197  :         }
; 198  :     }
; 199  : 
; 200  :     if( m_dwMinDepthBits <= 15 && m_dwMinStencilBits <= 1 )

  0006c	83 7d fc 0f	 cmp	 DWORD PTR _m_dwMinDepthBits$[ebp], 15 ; 0000000fH
  00070	77 52		 ja	 SHORT $LN5@FindDepthS
  00072	83 7d f8 01	 cmp	 DWORD PTR _m_dwMinStencilBits$[ebp], 1
  00076	77 4c		 ja	 SHORT $LN5@FindDepthS

; 201  :     {
; 202  :         if( SUCCEEDED( rkD3D.CheckDeviceFormat( iD3DAdapterInfo, DeviceType,

  00078	6a 49		 push	 73			; 00000049H
  0007a	6a 01		 push	 1
  0007c	6a 02		 push	 2
  0007e	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  00081	ff 75 10	 push	 DWORD PTR _DeviceType$[ebp]
  00084	ff 75 0c	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  00087	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  0008a	8b 00		 mov	 eax, DWORD PTR [eax]
  0008c	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  0008f	ff 50 28	 call	 DWORD PTR [eax+40]
  00092	85 c0		 test	 eax, eax
  00094	7c 2e		 jl	 SHORT $LN5@FindDepthS

; 203  :             TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D15S1 ) ) )
; 204  :         {
; 205  :             if( SUCCEEDED( rkD3D.CheckDepthStencilMatch( iD3DAdapterInfo, DeviceType,

  00096	6a 49		 push	 73			; 00000049H
  00098	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  0009b	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  0009e	ff 75 10	 push	 DWORD PTR _DeviceType$[ebp]
  000a1	ff 75 0c	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  000a4	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  000ac	ff 50 30	 call	 DWORD PTR [eax+48]
  000af	85 c0		 test	 eax, eax
  000b1	7c 11		 jl	 SHORT $LN5@FindDepthS

; 206  :                 TargetFormat, TargetFormat, D3DFMT_D15S1 ) ) )
; 207  :             {
; 208  :                 *pDepthStencilFormat = D3DFMT_D15S1;

  000b3	8b 45 18	 mov	 eax, DWORD PTR _pDepthStencilFormat$[ebp]
  000b6	c7 00 49 00 00
	00		 mov	 DWORD PTR [eax], 73	; 00000049H

; 209  :                 return TRUE;

  000bc	33 c0		 xor	 eax, eax
  000be	40		 inc	 eax
  000bf	e9 5c 01 00 00	 jmp	 $LN1@FindDepthS
$LN5@FindDepthS:

; 210  :             }
; 211  :         }
; 212  :     }
; 213  : 
; 214  :     if( m_dwMinDepthBits <= 24 && m_dwMinStencilBits == 0 )

  000c4	83 7d fc 18	 cmp	 DWORD PTR _m_dwMinDepthBits$[ebp], 24 ; 00000018H
  000c8	77 52		 ja	 SHORT $LN8@FindDepthS
  000ca	83 7d f8 00	 cmp	 DWORD PTR _m_dwMinStencilBits$[ebp], 0
  000ce	75 4c		 jne	 SHORT $LN8@FindDepthS

; 215  :     {
; 216  :         if( SUCCEEDED( rkD3D.CheckDeviceFormat( iD3DAdapterInfo, DeviceType,

  000d0	6a 4d		 push	 77			; 0000004dH
  000d2	6a 01		 push	 1
  000d4	6a 02		 push	 2
  000d6	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  000d9	ff 75 10	 push	 DWORD PTR _DeviceType$[ebp]
  000dc	ff 75 0c	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  000df	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  000e2	8b 00		 mov	 eax, DWORD PTR [eax]
  000e4	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  000e7	ff 50 28	 call	 DWORD PTR [eax+40]
  000ea	85 c0		 test	 eax, eax
  000ec	7c 2e		 jl	 SHORT $LN8@FindDepthS

; 217  :             TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D24X8 ) ) )
; 218  :         {
; 219  :             if( SUCCEEDED( rkD3D.CheckDepthStencilMatch( iD3DAdapterInfo, DeviceType,

  000ee	6a 4d		 push	 77			; 0000004dH
  000f0	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  000f3	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  000f6	ff 75 10	 push	 DWORD PTR _DeviceType$[ebp]
  000f9	ff 75 0c	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  000fc	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  000ff	8b 00		 mov	 eax, DWORD PTR [eax]
  00101	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  00104	ff 50 30	 call	 DWORD PTR [eax+48]
  00107	85 c0		 test	 eax, eax
  00109	7c 11		 jl	 SHORT $LN8@FindDepthS

; 220  :                 TargetFormat, TargetFormat, D3DFMT_D24X8 ) ) )
; 221  :             {
; 222  :                 *pDepthStencilFormat = D3DFMT_D24X8;

  0010b	8b 45 18	 mov	 eax, DWORD PTR _pDepthStencilFormat$[ebp]
  0010e	c7 00 4d 00 00
	00		 mov	 DWORD PTR [eax], 77	; 0000004dH

; 223  :                 return TRUE;

  00114	33 c0		 xor	 eax, eax
  00116	40		 inc	 eax
  00117	e9 04 01 00 00	 jmp	 $LN1@FindDepthS
$LN8@FindDepthS:

; 224  :             }
; 225  :         }
; 226  :     }
; 227  : 
; 228  :     if( m_dwMinDepthBits <= 24 && m_dwMinStencilBits <= 8 )

  0011c	83 7d fc 18	 cmp	 DWORD PTR _m_dwMinDepthBits$[ebp], 24 ; 00000018H
  00120	77 52		 ja	 SHORT $LN11@FindDepthS
  00122	83 7d f8 08	 cmp	 DWORD PTR _m_dwMinStencilBits$[ebp], 8
  00126	77 4c		 ja	 SHORT $LN11@FindDepthS

; 229  :     {
; 230  :         if( SUCCEEDED( rkD3D.CheckDeviceFormat( iD3DAdapterInfo, DeviceType,

  00128	6a 4b		 push	 75			; 0000004bH
  0012a	6a 01		 push	 1
  0012c	6a 02		 push	 2
  0012e	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  00131	ff 75 10	 push	 DWORD PTR _DeviceType$[ebp]
  00134	ff 75 0c	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  00137	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  0013a	8b 00		 mov	 eax, DWORD PTR [eax]
  0013c	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  0013f	ff 50 28	 call	 DWORD PTR [eax+40]
  00142	85 c0		 test	 eax, eax
  00144	7c 2e		 jl	 SHORT $LN11@FindDepthS

; 231  :             TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D24S8 ) ) )
; 232  :         {
; 233  :             if( SUCCEEDED( rkD3D.CheckDepthStencilMatch( iD3DAdapterInfo, DeviceType,

  00146	6a 4b		 push	 75			; 0000004bH
  00148	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  0014b	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  0014e	ff 75 10	 push	 DWORD PTR _DeviceType$[ebp]
  00151	ff 75 0c	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  00154	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  00157	8b 00		 mov	 eax, DWORD PTR [eax]
  00159	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  0015c	ff 50 30	 call	 DWORD PTR [eax+48]
  0015f	85 c0		 test	 eax, eax
  00161	7c 11		 jl	 SHORT $LN11@FindDepthS

; 234  :                 TargetFormat, TargetFormat, D3DFMT_D24S8 ) ) )
; 235  :             {
; 236  :                 *pDepthStencilFormat = D3DFMT_D24S8;

  00163	8b 45 18	 mov	 eax, DWORD PTR _pDepthStencilFormat$[ebp]
  00166	c7 00 4b 00 00
	00		 mov	 DWORD PTR [eax], 75	; 0000004bH

; 237  :                 return TRUE;

  0016c	33 c0		 xor	 eax, eax
  0016e	40		 inc	 eax
  0016f	e9 ac 00 00 00	 jmp	 $LN1@FindDepthS
$LN11@FindDepthS:

; 238  :             }
; 239  :         }
; 240  :     }
; 241  : 
; 242  :     if( m_dwMinDepthBits <= 24 && m_dwMinStencilBits <= 4 )

  00174	83 7d fc 18	 cmp	 DWORD PTR _m_dwMinDepthBits$[ebp], 24 ; 00000018H
  00178	77 4f		 ja	 SHORT $LN14@FindDepthS
  0017a	83 7d f8 04	 cmp	 DWORD PTR _m_dwMinStencilBits$[ebp], 4
  0017e	77 49		 ja	 SHORT $LN14@FindDepthS

; 243  :     {
; 244  :         if( SUCCEEDED( rkD3D.CheckDeviceFormat( iD3DAdapterInfo, DeviceType,

  00180	6a 4f		 push	 79			; 0000004fH
  00182	6a 01		 push	 1
  00184	6a 02		 push	 2
  00186	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  00189	ff 75 10	 push	 DWORD PTR _DeviceType$[ebp]
  0018c	ff 75 0c	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  0018f	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  00192	8b 00		 mov	 eax, DWORD PTR [eax]
  00194	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  00197	ff 50 28	 call	 DWORD PTR [eax+40]
  0019a	85 c0		 test	 eax, eax
  0019c	7c 2b		 jl	 SHORT $LN14@FindDepthS

; 245  :             TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D24X4S4 ) ) )
; 246  :         {
; 247  :             if( SUCCEEDED( rkD3D.CheckDepthStencilMatch( iD3DAdapterInfo, DeviceType,

  0019e	6a 4f		 push	 79			; 0000004fH
  001a0	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  001a3	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  001a6	ff 75 10	 push	 DWORD PTR _DeviceType$[ebp]
  001a9	ff 75 0c	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  001ac	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  001af	8b 00		 mov	 eax, DWORD PTR [eax]
  001b1	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  001b4	ff 50 30	 call	 DWORD PTR [eax+48]
  001b7	85 c0		 test	 eax, eax
  001b9	7c 0e		 jl	 SHORT $LN14@FindDepthS

; 248  :                 TargetFormat, TargetFormat, D3DFMT_D24X4S4 ) ) )
; 249  :             {
; 250  :                 *pDepthStencilFormat = D3DFMT_D24X4S4;

  001bb	8b 45 18	 mov	 eax, DWORD PTR _pDepthStencilFormat$[ebp]
  001be	c7 00 4f 00 00
	00		 mov	 DWORD PTR [eax], 79	; 0000004fH

; 251  :                 return TRUE;

  001c4	33 c0		 xor	 eax, eax
  001c6	40		 inc	 eax
  001c7	eb 57		 jmp	 SHORT $LN1@FindDepthS
$LN14@FindDepthS:

; 252  :             }
; 253  :         }
; 254  :     }
; 255  : 
; 256  :     if( m_dwMinDepthBits <= 32 && m_dwMinStencilBits == 0 )

  001c9	83 7d fc 20	 cmp	 DWORD PTR _m_dwMinDepthBits$[ebp], 32 ; 00000020H
  001cd	77 4f		 ja	 SHORT $LN17@FindDepthS
  001cf	83 7d f8 00	 cmp	 DWORD PTR _m_dwMinStencilBits$[ebp], 0
  001d3	75 49		 jne	 SHORT $LN17@FindDepthS

; 257  :     {
; 258  :         if( SUCCEEDED( rkD3D.CheckDeviceFormat( iD3DAdapterInfo, DeviceType,

  001d5	6a 47		 push	 71			; 00000047H
  001d7	6a 01		 push	 1
  001d9	6a 02		 push	 2
  001db	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  001de	ff 75 10	 push	 DWORD PTR _DeviceType$[ebp]
  001e1	ff 75 0c	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  001e4	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  001e7	8b 00		 mov	 eax, DWORD PTR [eax]
  001e9	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  001ec	ff 50 28	 call	 DWORD PTR [eax+40]
  001ef	85 c0		 test	 eax, eax
  001f1	7c 2b		 jl	 SHORT $LN17@FindDepthS

; 259  :             TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D32 ) ) )
; 260  :         {
; 261  :             if( SUCCEEDED( rkD3D.CheckDepthStencilMatch( iD3DAdapterInfo, DeviceType,

  001f3	6a 47		 push	 71			; 00000047H
  001f5	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  001f8	ff 75 14	 push	 DWORD PTR _TargetFormat$[ebp]
  001fb	ff 75 10	 push	 DWORD PTR _DeviceType$[ebp]
  001fe	ff 75 0c	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  00201	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  00204	8b 00		 mov	 eax, DWORD PTR [eax]
  00206	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  00209	ff 50 30	 call	 DWORD PTR [eax+48]
  0020c	85 c0		 test	 eax, eax
  0020e	7c 0e		 jl	 SHORT $LN17@FindDepthS

; 262  :                 TargetFormat, TargetFormat, D3DFMT_D32 ) ) )
; 263  :             {
; 264  :                 *pDepthStencilFormat = D3DFMT_D32;

  00210	8b 45 18	 mov	 eax, DWORD PTR _pDepthStencilFormat$[ebp]
  00213	c7 00 47 00 00
	00		 mov	 DWORD PTR [eax], 71	; 00000047H

; 265  :                 return TRUE;

  00219	33 c0		 xor	 eax, eax
  0021b	40		 inc	 eax
  0021c	eb 02		 jmp	 SHORT $LN1@FindDepthS
$LN17@FindDepthS:

; 266  :             }
; 267  :         }
; 268  :     }
; 269  : 
; 270  :     return FALSE;

  0021e	33 c0		 xor	 eax, eax
$LN1@FindDepthS:

; 271  : }

  00220	c9		 leave
  00221	c2 14 00	 ret	 20			; 00000014H
?FindDepthStencilFormat@D3D_CDeviceInfo@@QAEHAAUIDirect3D8@@IW4_D3DDEVTYPE@@W4_D3DFORMAT@@PAW44@@Z ENDP ; D3D_CDeviceInfo::FindDepthStencilFormat
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetString@D3D_CDeviceInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = -128						; size = 4
$T2 = -124						; size = 4
_rkModeInfo$3 = -120					; size = 4
$T4 = -116						; size = 4
$T5 = -112						; size = 4
$T6 = -108						; size = 4
$T7 = -104						; size = 4
_this$ = -100						; size = 4
_iD3D_SModeInfo$8 = -96					; size = 4
_szText$ = -92						; size = 1025
__$ArrayPad$ = 936					; size = 4
_pstEnumList$ = 948					; size = 4
?GetString@D3D_CDeviceInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; D3D_CDeviceInfo::GetString, COMDAT
; _this$ = ecx

; 463  : {

  00000	55		 push	 ebp
  00001	8d ac 24 54 fc
	ff ff		 lea	 ebp, DWORD PTR [esp-940]
  00008	81 ec 2c 04 00
	00		 sub	 esp, 1068		; 0000042cH
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 a8 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 9c	 mov	 DWORD PTR _this$[ebp], ecx

; 464  : 	char szText[1024+1];
; 465  : 	_snprintf(szText, sizeof(szText), "%s\r\n========================================\r\n", m_szDevDesc);

  0001e	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  00021	ff 30		 push	 DWORD PTR [eax]
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@HNBDJADM@?$CFs?$AN?6?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
  00028	68 01 04 00 00	 push	 1025			; 00000401H
  0002d	8d 45 a4	 lea	 eax, DWORD PTR _szText$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 __snprintf
  00036	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00039	8d 45 a4	 lea	 eax, DWORD PTR _szText$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _strlen
  00042	59		 pop	 ecx
  00043	89 45 98	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00046	8b 45 98	 mov	 eax, DWORD PTR $T7[ebp]
  00049	89 45 94	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0004c	ff 75 94	 push	 DWORD PTR $T6[ebp]
  0004f	8d 45 a4	 lea	 eax, DWORD PTR _szText$[ebp]
  00052	50		 push	 eax
  00053	8b 8d b4 03 00
	00		 mov	 ecx, DWORD PTR _pstEnumList$[ebp]
  00059	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp

; 468  : 	for (UINT iD3D_SModeInfo=0; iD3D_SModeInfo<m_uD3DModeInfoNum; ++iD3D_SModeInfo)

  0005e	83 65 a0 00	 and	 DWORD PTR _iD3D_SModeInfo$8[ebp], 0
  00062	eb 07		 jmp	 SHORT $LN4@GetString
$LN2@GetString:
  00064	8b 45 a0	 mov	 eax, DWORD PTR _iD3D_SModeInfo$8[ebp]
  00067	40		 inc	 eax
  00068	89 45 a0	 mov	 DWORD PTR _iD3D_SModeInfo$8[ebp], eax
$LN4@GetString:
  0006b	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 4d a0	 mov	 ecx, DWORD PTR _iD3D_SModeInfo$8[ebp]
  00071	3b 88 e4 00 00
	00		 cmp	 ecx, DWORD PTR [eax+228]
  00077	73 5f		 jae	 SHORT $LN3@GetString

; 469  : 	{
; 470  : 		_snprintf(szText, sizeof(szText), "%d. ", iD3D_SModeInfo);

  00079	ff 75 a0	 push	 DWORD PTR _iD3D_SModeInfo$8[ebp]
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_04CDOPIHIK@?$CFd?4?5@
  00081	68 01 04 00 00	 push	 1025			; 00000401H
  00086	8d 45 a4	 lea	 eax, DWORD PTR _szText$[ebp]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 __snprintf
  0008f	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00092	8d 45 a4	 lea	 eax, DWORD PTR _szText$[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 _strlen
  0009b	59		 pop	 ecx
  0009c	89 45 90	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0009f	8b 45 90	 mov	 eax, DWORD PTR $T5[ebp]
  000a2	89 45 8c	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000a5	ff 75 8c	 push	 DWORD PTR $T4[ebp]
  000a8	8d 45 a4	 lea	 eax, DWORD PTR _szText$[ebp]
  000ab	50		 push	 eax
  000ac	8b 8d b4 03 00
	00		 mov	 ecx, DWORD PTR _pstEnumList$[ebp]
  000b2	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp

; 473  : 		D3D_SModeInfo& rkModeInfo=m_akD3DModeInfo[iD3D_SModeInfo];

  000b7	6b 45 a0 18	 imul	 eax, DWORD PTR _iD3D_SModeInfo$8[ebp], 24
  000bb	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	8d 84 01 e8 00
	00 00		 lea	 eax, DWORD PTR [ecx+eax+232]
  000c5	89 45 88	 mov	 DWORD PTR _rkModeInfo$3[ebp], eax

; 474  : 		rkModeInfo.GetString(pstEnumList);

  000c8	ff b5 b4 03 00
	00		 push	 DWORD PTR _pstEnumList$[ebp]
  000ce	8b 4d 88	 mov	 ecx, DWORD PTR _rkModeInfo$3[ebp]
  000d1	e8 00 00 00 00	 call	 ?GetString@D3D_SModeInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; D3D_SModeInfo::GetString

; 475  : 	}

  000d6	eb 8c		 jmp	 SHORT $LN2@GetString
$LN3@GetString:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_02PCIJFNDE@?$AN?6@
  000dd	e8 00 00 00 00	 call	 _strlen
  000e2	59		 pop	 ecx
  000e3	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000e6	8b 45 84	 mov	 eax, DWORD PTR $T2[ebp]
  000e9	89 45 80	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000ec	ff 75 80	 push	 DWORD PTR $T1[ebp]
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_02PCIJFNDE@?$AN?6@
  000f4	8b 8d b4 03 00
	00		 mov	 ecx, DWORD PTR _pstEnumList$[ebp]
  000fa	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp

; 478  : }

  000ff	8b 8d a8 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00105	33 cd		 xor	 ecx, ebp
  00107	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010c	81 c5 ac 03 00
	00		 add	 ebp, 940		; 000003acH
  00112	c9		 leave
  00113	c2 04 00	 ret	 4
?GetString@D3D_CDeviceInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; D3D_CDeviceInfo::GetString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetD3DModeInfoNum@D3D_CDeviceInfo@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetD3DModeInfoNum@D3D_CDeviceInfo@@QAEIXZ PROC		; D3D_CDeviceInfo::GetD3DModeInfoNum, COMDAT
; _this$ = ecx

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 170  : 	return m_uD3DModeInfoNum;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 e4 00 00
	00		 mov	 eax, DWORD PTR [eax+228]

; 171  : }

  00010	c9		 leave
  00011	c3		 ret	 0
?GetD3DModeInfoNum@D3D_CDeviceInfo@@QAEIXZ ENDP		; D3D_CDeviceInfo::GetD3DModeInfoNum
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?Find@D3D_CDeviceInfo@@QAEHIIIHPAI@Z
_TEXT	SEGMENT
tv83 = -20						; size = 4
tv79 = -16						; size = 4
_this$ = -12						; size = 4
_rkModeInfo$1 = -8					; size = 4
_iD3D_SModeInfo$2 = -4					; size = 4
_uScrWidth$ = 8						; size = 4
_uScrHeight$ = 12					; size = 4
_uScrDepthBits$ = 16					; size = 4
_isWindowed$ = 20					; size = 4
_piD3DModeInfo$ = 24					; size = 4
?Find@D3D_CDeviceInfo@@QAEHIIIHPAI@Z PROC		; D3D_CDeviceInfo::Find, COMDAT
; _this$ = ecx

; 423  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 424  : 	if (isWindowed)

  00009	83 7d 14 00	 cmp	 DWORD PTR _isWindowed$[ebp], 0
  0000d	74 13		 je	 SHORT $LN9@Find

; 425  : 		if (!m_isWindowed)

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 b8 f8 0e 00
	00 00		 cmp	 DWORD PTR [eax+3832], 0
  00019	75 07		 jne	 SHORT $LN9@Find

; 426  : 			return FALSE;

  0001b	33 c0		 xor	 eax, eax
  0001d	e9 98 00 00 00	 jmp	 $LN1@Find
$LN9@Find:

; 427  : 
; 428  : 	for (UINT iD3D_SModeInfo=0; iD3D_SModeInfo<m_uD3DModeInfoNum; ++iD3D_SModeInfo)

  00022	83 65 fc 00	 and	 DWORD PTR _iD3D_SModeInfo$2[ebp], 0
  00026	eb 07		 jmp	 SHORT $LN4@Find
$LN2@Find:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _iD3D_SModeInfo$2[ebp]
  0002b	40		 inc	 eax
  0002c	89 45 fc	 mov	 DWORD PTR _iD3D_SModeInfo$2[ebp], eax
$LN4@Find:
  0002f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _iD3D_SModeInfo$2[ebp]
  00035	3b 88 e4 00 00
	00		 cmp	 ecx, DWORD PTR [eax+228]
  0003b	73 7b		 jae	 SHORT $LN3@Find

; 429  : 	{
; 430  : 		D3D_SModeInfo& rkModeInfo=m_akD3DModeInfo[iD3D_SModeInfo];

  0003d	6b 45 fc 18	 imul	 eax, DWORD PTR _iD3D_SModeInfo$2[ebp], 24
  00041	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	8d 84 01 e8 00
	00 00		 lea	 eax, DWORD PTR [ecx+eax+232]
  0004b	89 45 f8	 mov	 DWORD PTR _rkModeInfo$1[ebp], eax

; 431  : 		if (rkModeInfo.m_uScrWidth==uScrWidth && rkModeInfo.m_uScrHeight==uScrHeight)

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _rkModeInfo$1[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	3b 45 08	 cmp	 eax, DWORD PTR _uScrWidth$[ebp]
  00056	75 5b		 jne	 SHORT $LN11@Find
  00058	8b 45 f8	 mov	 eax, DWORD PTR _rkModeInfo$1[ebp]
  0005b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005e	3b 45 0c	 cmp	 eax, DWORD PTR _uScrHeight$[ebp]
  00061	75 50		 jne	 SHORT $LN11@Find

; 432  : 		{
; 433  : 			if (uScrDepthBits==16)

  00063	83 7d 10 10	 cmp	 DWORD PTR _uScrDepthBits$[ebp], 16 ; 00000010H
  00067	75 26		 jne	 SHORT $LN12@Find

; 434  : 			{
; 435  : 				switch (rkModeInfo.m_eD3DFmtPixel)

  00069	8b 45 f8	 mov	 eax, DWORD PTR _rkModeInfo$1[ebp]
  0006c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0006f	89 45 f0	 mov	 DWORD PTR tv79[ebp], eax
  00072	83 7d f0 17	 cmp	 DWORD PTR tv79[ebp], 23	; 00000017H
  00076	7c 15		 jl	 SHORT $LN5@Find
  00078	83 7d f0 19	 cmp	 DWORD PTR tv79[ebp], 25	; 00000019H
  0007c	7e 02		 jle	 SHORT $LN14@Find
  0007e	eb 0d		 jmp	 SHORT $LN5@Find
$LN14@Find:

; 436  : 				{
; 437  : 					case D3DFMT_R5G6B5:
; 438  : 					case D3DFMT_X1R5G5B5:
; 439  : 					case D3DFMT_A1R5G5B5:
; 440  : 						*piD3DModeInfo=iD3D_SModeInfo;

  00080	8b 45 18	 mov	 eax, DWORD PTR _piD3DModeInfo$[ebp]
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _iD3D_SModeInfo$2[ebp]
  00086	89 08		 mov	 DWORD PTR [eax], ecx

; 441  : 						return TRUE;

  00088	33 c0		 xor	 eax, eax
  0008a	40		 inc	 eax
  0008b	eb 2d		 jmp	 SHORT $LN1@Find
$LN5@Find:

; 442  : 						break;
; 443  : 				}
; 444  : 			}

  0008d	eb 24		 jmp	 SHORT $LN11@Find
$LN12@Find:

; 445  : 			else
; 446  : 			{
; 447  : 				switch (rkModeInfo.m_eD3DFmtPixel)

  0008f	8b 45 f8	 mov	 eax, DWORD PTR _rkModeInfo$1[ebp]
  00092	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00095	89 45 ec	 mov	 DWORD PTR tv83[ebp], eax
  00098	83 7d ec 14	 cmp	 DWORD PTR tv83[ebp], 20	; 00000014H
  0009c	7c 15		 jl	 SHORT $LN11@Find
  0009e	83 7d ec 16	 cmp	 DWORD PTR tv83[ebp], 22	; 00000016H
  000a2	7e 02		 jle	 SHORT $LN15@Find
  000a4	eb 0d		 jmp	 SHORT $LN11@Find
$LN15@Find:

; 448  : 				{
; 449  : 					case D3DFMT_X8R8G8B8:
; 450  : 					case D3DFMT_A8R8G8B8:
; 451  : 					case D3DFMT_R8G8B8:
; 452  : 						*piD3DModeInfo=iD3D_SModeInfo;

  000a6	8b 45 18	 mov	 eax, DWORD PTR _piD3DModeInfo$[ebp]
  000a9	8b 4d fc	 mov	 ecx, DWORD PTR _iD3D_SModeInfo$2[ebp]
  000ac	89 08		 mov	 DWORD PTR [eax], ecx

; 453  : 						return TRUE;

  000ae	33 c0		 xor	 eax, eax
  000b0	40		 inc	 eax
  000b1	eb 07		 jmp	 SHORT $LN1@Find
$LN11@Find:

; 454  : 						break;
; 455  : 				}
; 456  : 			}
; 457  : 		}		
; 458  : 	}

  000b3	e9 70 ff ff ff	 jmp	 $LN2@Find
$LN3@Find:

; 459  : 	return FALSE;

  000b8	33 c0		 xor	 eax, eax
$LN1@Find:

; 460  : }

  000ba	c9		 leave
  000bb	c2 14 00	 ret	 20			; 00000014H
?Find@D3D_CDeviceInfo@@QAEHIIIHPAI@Z ENDP		; D3D_CDeviceInfo::Find
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?Build@D3D_CDeviceInfo@@QAEHAAUIDirect3D8@@IIAAVD3D_CAdapterDisplayModeList@@P6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z
_TEXT	SEGMENT
_isHALSampleCompatible$ = -216				; size = 4
_uD3DFmtNum$1 = -212					; size = 4
_uD3DDMNum$2 = -208					; size = 4
_isHALDesktopCompatible$ = -204				; size = 4
_isHALWindowedCompatible$ = -200			; size = 4
_isHALExists$ = -196					; size = 4
_uD3DFmtNum$3 = -192					; size = 4
_c_szD3DDevDesc$ = -188					; size = 4
_c_eD3DDevType$ = -184					; size = 4
_c_rkD3DDM$4 = -180					; size = 4
_iD3DDM$5 = -176					; size = 4
_rkModeInfo$6 = -172					; size = 4
_iFmt$7 = -168						; size = 4
_eD3DFmtPixel$8 = -164					; size = 4
_iFmt$9 = -160						; size = 4
_dwD3DBehavior$10 = -156				; size = 4
_isFormatConfirmed$11 = -152				; size = 4
_this$ = -148						; size = 4
_adwD3DBehavior$ = -144					; size = 80
_aisFormatConfirmed$ = -64				; size = 80
_aeD3DFmtDepthStencil$ = 16				; size = 80
__$ArrayPad$ = 96					; size = 4
_rkD3D$ = 108						; size = 4
_iD3DAdapterInfo$ = 112					; size = 4
_iDevType$ = 116					; size = 4
_rkD3DADMList$ = 120					; size = 4
_pfnConfirmDevice$ = 124				; size = 4
?Build@D3D_CDeviceInfo@@QAEHAAUIDirect3D8@@IIAAVD3D_CAdapterDisplayModeList@@P6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z PROC ; D3D_CDeviceInfo::Build, COMDAT
; _this$ = ecx

; 274  : {	

  00000	55		 push	 ebp
  00001	8d 6c 24 9c	 lea	 ebp, DWORD PTR [esp-100]
  00005	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 60	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 275  : 	assert(pfnConfirmDevice!=NULL && "D3D_CDeviceInfo::Build");
; 276  : 
; 277  : 	const D3DDEVTYPE	c_eD3DDevType=msc_aeD3DDevType[iDevType];

  0001b	8b 45 74	 mov	 eax, DWORD PTR _iDevType$[ebp]
  0001e	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?msc_aeD3DDevType@D3D_CDeviceInfo@@1QBW4_D3DDEVTYPE@@B[eax*4]
  00025	89 85 48 ff ff
	ff		 mov	 DWORD PTR _c_eD3DDevType$[ebp], eax

; 278  : 	const TCHAR*		c_szD3DDevDesc=msc_aszD3DDevDesc[iDevType];

  0002b	8b 45 74	 mov	 eax, DWORD PTR _iDevType$[ebp]
  0002e	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?msc_aszD3DDevDesc@D3D_CDeviceInfo@@1PAPBDA[eax*4]
  00035	89 85 44 ff ff
	ff		 mov	 DWORD PTR _c_szD3DDevDesc$[ebp], eax

; 279  : 
; 280  :     m_eD3DDevType = c_eD3DDevType;

  0003b	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _c_eD3DDevType$[ebp]
  00047	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 281  :     rkD3D.GetDeviceCaps(iD3DAdapterInfo, c_eD3DDevType, &m_kD3DCaps);

  0004a	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00050	83 c0 08	 add	 eax, 8
  00053	50		 push	 eax
  00054	ff b5 48 ff ff
	ff		 push	 DWORD PTR _c_eD3DDevType$[ebp]
  0005a	ff 75 70	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  0005d	8b 45 6c	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	ff 75 6c	 push	 DWORD PTR _rkD3D$[ebp]
  00065	ff 50 34	 call	 DWORD PTR [eax+52]

; 282  : 
; 283  :     m_szDevDesc = c_szD3DDevDesc;

  00068	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _c_szD3DDevDesc$[ebp]
  00074	89 08		 mov	 DWORD PTR [eax], ecx

; 284  :     m_uD3DModeInfoNum=0;

  00076	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0007c	83 a0 e4 00 00
	00 00		 and	 DWORD PTR [eax+228], 0

; 285  :     m_canDoWindowed = FALSE;

  00083	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00089	83 a0 dc 00 00
	00 00		 and	 DWORD PTR [eax+220], 0

; 286  :     m_isWindowed = FALSE;

  00090	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00096	83 a0 f8 0e 00
	00 00		 and	 DWORD PTR [eax+3832], 0

; 287  :     m_eD3DMSTFullscreen = D3DMULTISAMPLE_NONE;

  0009d	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000a3	83 a0 00 0f 00
	00 00		 and	 DWORD PTR [eax+3840], 0

; 288  :     m_eD3DMSTWindowed = D3DMULTISAMPLE_NONE;

  000aa	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000b0	83 a0 fc 0e 00
	00 00		 and	 DWORD PTR [eax+3836], 0

; 289  : 
; 290  : 	BOOL  aisFormatConfirmed[20];
; 291  : 	DWORD adwD3DBehavior[20];
; 292  : 	D3DFORMAT aeD3DFmtDepthStencil[20];
; 293  : 	
; 294  :     BOOL isHALExists = FALSE;

  000b7	83 a5 3c ff ff
	ff 00		 and	 DWORD PTR _isHALExists$[ebp], 0

; 295  :     BOOL isHALWindowedCompatible = FALSE;

  000be	83 a5 38 ff ff
	ff 00		 and	 DWORD PTR _isHALWindowedCompatible$[ebp], 0

; 296  :     BOOL isHALDesktopCompatible = FALSE;

  000c5	83 a5 34 ff ff
	ff 00		 and	 DWORD PTR _isHALDesktopCompatible$[ebp], 0

; 297  :     BOOL isHALSampleCompatible = FALSE;

  000cc	83 a5 28 ff ff
	ff 00		 and	 DWORD PTR _isHALSampleCompatible$[ebp], 0

; 298  : 
; 299  : 	// GetFlagInfo
; 300  : 	{
; 301  : 		UINT uD3DFmtNum=rkD3DADMList.GetPixelFormatNum();

  000d3	8b 4d 78	 mov	 ecx, DWORD PTR _rkD3DADMList$[ebp]
  000d6	e8 00 00 00 00	 call	 ?GetPixelFormatNum@D3D_CAdapterDisplayModeList@@QAEIXZ ; D3D_CAdapterDisplayModeList::GetPixelFormatNum
  000db	89 85 40 ff ff
	ff		 mov	 DWORD PTR _uD3DFmtNum$3[ebp], eax

; 302  : 
; 303  : 		for (DWORD iFmt=0; iFmt<uD3DFmtNum; ++iFmt)

  000e1	83 a5 60 ff ff
	ff 00		 and	 DWORD PTR _iFmt$9[ebp], 0
  000e8	eb 0d		 jmp	 SHORT $LN4@Build
$LN2@Build:
  000ea	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _iFmt$9[ebp]
  000f0	40		 inc	 eax
  000f1	89 85 60 ff ff
	ff		 mov	 DWORD PTR _iFmt$9[ebp], eax
$LN4@Build:
  000f7	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _iFmt$9[ebp]
  000fd	3b 85 40 ff ff
	ff		 cmp	 eax, DWORD PTR _uD3DFmtNum$3[ebp]
  00103	0f 83 13 02 00
	00		 jae	 $LN3@Build

; 304  : 		{
; 305  : 			D3DFORMAT eD3DFmtPixel=rkD3DADMList.GetPixelFormatr(iFmt);		

  00109	ff b5 60 ff ff
	ff		 push	 DWORD PTR _iFmt$9[ebp]
  0010f	8b 4d 78	 mov	 ecx, DWORD PTR _rkD3DADMList$[ebp]
  00112	e8 00 00 00 00	 call	 ?GetPixelFormatr@D3D_CAdapterDisplayModeList@@QAEABW4_D3DFORMAT@@I@Z ; D3D_CAdapterDisplayModeList::GetPixelFormatr
  00117	8b 00		 mov	 eax, DWORD PTR [eax]
  00119	89 85 5c ff ff
	ff		 mov	 DWORD PTR _eD3DFmtPixel$8[ebp], eax

; 306  : 			DWORD dwD3DBehavior=0;

  0011f	83 a5 64 ff ff
	ff 00		 and	 DWORD PTR _dwD3DBehavior$10[ebp], 0

; 307  : 			BOOL isFormatConfirmed=FALSE;			

  00126	83 a5 68 ff ff
	ff 00		 and	 DWORD PTR _isFormatConfirmed$11[ebp], 0

; 308  : 
; 309  : 			aeD3DFmtDepthStencil[iFmt] = D3DFMT_UNKNOWN;

  0012d	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _iFmt$9[ebp]
  00133	83 64 85 10 00	 and	 DWORD PTR _aeD3DFmtDepthStencil$[ebp+eax*4], 0

; 310  : 
; 311  : 			// SkipNoRenderTargetFormat;
; 312  : 			if (FAILED(rkD3D.CheckDeviceType(iD3DAdapterInfo, m_eD3DDevType, eD3DFmtPixel, eD3DFmtPixel, FALSE)))

  00138	6a 00		 push	 0
  0013a	ff b5 5c ff ff
	ff		 push	 DWORD PTR _eD3DFmtPixel$8[ebp]
  00140	ff b5 5c ff ff
	ff		 push	 DWORD PTR _eD3DFmtPixel$8[ebp]
  00146	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0014c	ff 70 04	 push	 DWORD PTR [eax+4]
  0014f	ff 75 70	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  00152	8b 45 6c	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  00155	8b 00		 mov	 eax, DWORD PTR [eax]
  00157	ff 75 6c	 push	 DWORD PTR _rkD3D$[ebp]
  0015a	ff 50 24	 call	 DWORD PTR [eax+36]
  0015d	85 c0		 test	 eax, eax
  0015f	7d 02		 jge	 SHORT $LN11@Build

; 313  : 				continue;

  00161	eb 87		 jmp	 SHORT $LN2@Build
$LN11@Build:

; 314  : 
; 315  : 			if (D3DDEVTYPE_HAL==m_eD3DDevType)

  00163	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00169	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  0016d	75 37		 jne	 SHORT $LN12@Build

; 316  : 			{
; 317  : 				isHALExists=TRUE;

  0016f	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _isHALExists$[ebp], 1

; 318  : 				
; 319  : 				if (m_kD3DCaps.Caps2 & D3DCAPS2_CANRENDERWINDOWED)

  00179	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0017f	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00182	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00187	74 1d		 je	 SHORT $LN12@Build

; 320  : 				{
; 321  : 					isHALWindowedCompatible=TRUE;

  00189	c7 85 38 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _isHALWindowedCompatible$[ebp], 1

; 322  : 
; 323  : 					if (iFmt==0)

  00193	83 bd 60 ff ff
	ff 00		 cmp	 DWORD PTR _iFmt$9[ebp], 0
  0019a	75 0a		 jne	 SHORT $LN12@Build

; 324  : 						isHALDesktopCompatible=TRUE;

  0019c	c7 85 34 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _isHALDesktopCompatible$[ebp], 1
$LN12@Build:

; 325  :                 
; 326  : 				}
; 327  : 			}
; 328  : 
; 329  : 			// Confirm the device/format for HW vertex processing
; 330  : 			if (m_kD3DCaps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT)

  001a6	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001ac	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  001af	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  001b4	0f 84 be 00 00
	00		 je	 $LN15@Build

; 331  : 			{
; 332  : 				if (m_kD3DCaps.DevCaps & D3DDEVCAPS_PUREDEVICE)

  001ba	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001c0	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  001c3	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  001c8	74 34		 je	 SHORT $LN16@Build

; 333  : 				{
; 334  : 					dwD3DBehavior=D3DCREATE_HARDWARE_VERTEXPROCESSING|D3DCREATE_PUREDEVICE;

  001ca	c7 85 64 ff ff
	ff 50 00 00 00	 mov	 DWORD PTR _dwD3DBehavior$10[ebp], 80 ; 00000050H

; 335  : 
; 336  : 					if (pfnConfirmDevice(m_kD3DCaps, dwD3DBehavior, eD3DFmtPixel))

  001d4	ff b5 5c ff ff
	ff		 push	 DWORD PTR _eD3DFmtPixel$8[ebp]
  001da	ff b5 64 ff ff
	ff		 push	 DWORD PTR _dwD3DBehavior$10[ebp]
  001e0	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001e6	83 c0 08	 add	 eax, 8
  001e9	50		 push	 eax
  001ea	ff 55 7c	 call	 DWORD PTR _pfnConfirmDevice$[ebp]
  001ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f0	85 c0		 test	 eax, eax
  001f2	74 0a		 je	 SHORT $LN16@Build

; 337  : 						isFormatConfirmed = TRUE;

  001f4	c7 85 68 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _isFormatConfirmed$11[ebp], 1
$LN16@Build:

; 338  : 				}
; 339  : 
; 340  : 				if (FALSE == isFormatConfirmed)

  001fe	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _isFormatConfirmed$11[ebp], 0
  00205	75 34		 jne	 SHORT $LN18@Build

; 341  : 				{
; 342  : 					dwD3DBehavior = D3DCREATE_HARDWARE_VERTEXPROCESSING;

  00207	c7 85 64 ff ff
	ff 40 00 00 00	 mov	 DWORD PTR _dwD3DBehavior$10[ebp], 64 ; 00000040H

; 343  : 
; 344  : 					if (pfnConfirmDevice(m_kD3DCaps, dwD3DBehavior, eD3DFmtPixel))

  00211	ff b5 5c ff ff
	ff		 push	 DWORD PTR _eD3DFmtPixel$8[ebp]
  00217	ff b5 64 ff ff
	ff		 push	 DWORD PTR _dwD3DBehavior$10[ebp]
  0021d	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00223	83 c0 08	 add	 eax, 8
  00226	50		 push	 eax
  00227	ff 55 7c	 call	 DWORD PTR _pfnConfirmDevice$[ebp]
  0022a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022d	85 c0		 test	 eax, eax
  0022f	74 0a		 je	 SHORT $LN18@Build

; 345  : 						isFormatConfirmed = TRUE;

  00231	c7 85 68 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _isFormatConfirmed$11[ebp], 1
$LN18@Build:

; 346  : 				}
; 347  : 
; 348  : 				if (FALSE == isFormatConfirmed)

  0023b	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _isFormatConfirmed$11[ebp], 0
  00242	75 34		 jne	 SHORT $LN15@Build

; 349  : 				{
; 350  : 					dwD3DBehavior = D3DCREATE_MIXED_VERTEXPROCESSING;

  00244	c7 85 64 ff ff
	ff 80 00 00 00	 mov	 DWORD PTR _dwD3DBehavior$10[ebp], 128 ; 00000080H

; 351  : 
; 352  : 					if (pfnConfirmDevice(m_kD3DCaps, dwD3DBehavior, eD3DFmtPixel))

  0024e	ff b5 5c ff ff
	ff		 push	 DWORD PTR _eD3DFmtPixel$8[ebp]
  00254	ff b5 64 ff ff
	ff		 push	 DWORD PTR _dwD3DBehavior$10[ebp]
  0025a	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00260	83 c0 08	 add	 eax, 8
  00263	50		 push	 eax
  00264	ff 55 7c	 call	 DWORD PTR _pfnConfirmDevice$[ebp]
  00267	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026a	85 c0		 test	 eax, eax
  0026c	74 0a		 je	 SHORT $LN15@Build

; 353  : 						isFormatConfirmed = TRUE;

  0026e	c7 85 68 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _isFormatConfirmed$11[ebp], 1
$LN15@Build:

; 354  : 				}	
; 355  : 			}
; 356  : 
; 357  : 			// Confirm the device/format for SW vertex processing        
; 358  : 			if (FALSE == isFormatConfirmed)

  00278	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _isFormatConfirmed$11[ebp], 0
  0027f	75 34		 jne	 SHORT $LN22@Build

; 359  : 			{
; 360  : 				dwD3DBehavior = D3DCREATE_SOFTWARE_VERTEXPROCESSING;

  00281	c7 85 64 ff ff
	ff 20 00 00 00	 mov	 DWORD PTR _dwD3DBehavior$10[ebp], 32 ; 00000020H

; 361  : 				
; 362  : 				if (pfnConfirmDevice(m_kD3DCaps, dwD3DBehavior, eD3DFmtPixel))

  0028b	ff b5 5c ff ff
	ff		 push	 DWORD PTR _eD3DFmtPixel$8[ebp]
  00291	ff b5 64 ff ff
	ff		 push	 DWORD PTR _dwD3DBehavior$10[ebp]
  00297	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0029d	83 c0 08	 add	 eax, 8
  002a0	50		 push	 eax
  002a1	ff 55 7c	 call	 DWORD PTR _pfnConfirmDevice$[ebp]
  002a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a7	85 c0		 test	 eax, eax
  002a9	74 0a		 je	 SHORT $LN22@Build

; 363  : 					isFormatConfirmed = TRUE;            

  002ab	c7 85 68 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _isFormatConfirmed$11[ebp], 1
$LN22@Build:

; 364  : 			}
; 365  : 			
; 366  : 			if (isFormatConfirmed)

  002b5	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR _isFormatConfirmed$11[ebp], 0
  002bc	74 36		 je	 SHORT $LN24@Build

; 367  : 			{
; 368  : 				if (!FindDepthStencilFormat(rkD3D, iD3DAdapterInfo, c_eD3DDevType, eD3DFmtPixel, &aeD3DFmtDepthStencil[iFmt]))

  002be	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _iFmt$9[ebp]
  002c4	8d 44 85 10	 lea	 eax, DWORD PTR _aeD3DFmtDepthStencil$[ebp+eax*4]
  002c8	50		 push	 eax
  002c9	ff b5 5c ff ff
	ff		 push	 DWORD PTR _eD3DFmtPixel$8[ebp]
  002cf	ff b5 48 ff ff
	ff		 push	 DWORD PTR _c_eD3DDevType$[ebp]
  002d5	ff 75 70	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  002d8	ff 75 6c	 push	 DWORD PTR _rkD3D$[ebp]
  002db	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002e1	e8 00 00 00 00	 call	 ?FindDepthStencilFormat@D3D_CDeviceInfo@@QAEHAAUIDirect3D8@@IW4_D3DDEVTYPE@@W4_D3DFORMAT@@PAW44@@Z ; D3D_CDeviceInfo::FindDepthStencilFormat
  002e6	85 c0		 test	 eax, eax
  002e8	75 0a		 jne	 SHORT $LN24@Build

; 369  : 					isFormatConfirmed = TRUE;

  002ea	c7 85 68 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _isFormatConfirmed$11[ebp], 1
$LN24@Build:

; 370  :             
; 371  : 			}
; 372  : 			
; 373  : 			adwD3DBehavior[iFmt]=dwD3DBehavior;

  002f4	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _iFmt$9[ebp]
  002fa	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _dwD3DBehavior$10[ebp]
  00300	89 8c 85 70 ff
	ff ff		 mov	 DWORD PTR _adwD3DBehavior$[ebp+eax*4], ecx

; 374  : 			aisFormatConfirmed[iFmt]=isFormatConfirmed;

  00307	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _iFmt$9[ebp]
  0030d	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _isFormatConfirmed$11[ebp]
  00313	89 4c 85 c0	 mov	 DWORD PTR _aisFormatConfirmed$[ebp+eax*4], ecx

; 375  : 		}

  00317	e9 ce fd ff ff	 jmp	 $LN2@Build
$LN3@Build:

; 376  : 	}
; 377  : 
; 378  : 	// BuildModeInfoList
; 379  : 	{
; 380  : 		UINT uD3DDMNum=rkD3DADMList.GetDisplayModeNum();

  0031c	8b 4d 78	 mov	 ecx, DWORD PTR _rkD3DADMList$[ebp]
  0031f	e8 00 00 00 00	 call	 ?GetDisplayModeNum@D3D_CAdapterDisplayModeList@@QAEIXZ ; D3D_CAdapterDisplayModeList::GetDisplayModeNum
  00324	89 85 30 ff ff
	ff		 mov	 DWORD PTR _uD3DDMNum$2[ebp], eax

; 381  : 		UINT uD3DFmtNum=rkD3DADMList.GetPixelFormatNum();

  0032a	8b 4d 78	 mov	 ecx, DWORD PTR _rkD3DADMList$[ebp]
  0032d	e8 00 00 00 00	 call	 ?GetPixelFormatNum@D3D_CAdapterDisplayModeList@@QAEIXZ ; D3D_CAdapterDisplayModeList::GetPixelFormatNum
  00332	89 85 2c ff ff
	ff		 mov	 DWORD PTR _uD3DFmtNum$1[ebp], eax

; 382  : 
; 383  : 
; 384  : 		for (UINT iD3DDM=0; iD3DDM<uD3DDMNum; ++iD3DDM)

  00338	83 a5 50 ff ff
	ff 00		 and	 DWORD PTR _iD3DDM$5[ebp], 0
  0033f	eb 0d		 jmp	 SHORT $LN7@Build
$LN5@Build:
  00341	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _iD3DDM$5[ebp]
  00347	40		 inc	 eax
  00348	89 85 50 ff ff
	ff		 mov	 DWORD PTR _iD3DDM$5[ebp], eax
$LN7@Build:
  0034e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _iD3DDM$5[ebp]
  00354	3b 85 30 ff ff
	ff		 cmp	 eax, DWORD PTR _uD3DDMNum$2[ebp]
  0035a	0f 83 22 01 00
	00		 jae	 $LN6@Build

; 385  : 		{
; 386  : 			const D3DDISPLAYMODE& c_rkD3DDM=rkD3DADMList.GetDisplayModer(iD3DDM);

  00360	ff b5 50 ff ff
	ff		 push	 DWORD PTR _iD3DDM$5[ebp]
  00366	8b 4d 78	 mov	 ecx, DWORD PTR _rkD3DADMList$[ebp]
  00369	e8 00 00 00 00	 call	 ?GetDisplayModer@D3D_CAdapterDisplayModeList@@QAEABU_D3DDISPLAYMODE@@I@Z ; D3D_CAdapterDisplayModeList::GetDisplayModer
  0036e	89 85 4c ff ff
	ff		 mov	 DWORD PTR _c_rkD3DDM$4[ebp], eax

; 387  : 			for (DWORD iFmt=0; iFmt<uD3DFmtNum; ++iFmt)

  00374	83 a5 58 ff ff
	ff 00		 and	 DWORD PTR _iFmt$7[ebp], 0
  0037b	eb 0d		 jmp	 SHORT $LN10@Build
$LN8@Build:
  0037d	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _iFmt$7[ebp]
  00383	40		 inc	 eax
  00384	89 85 58 ff ff
	ff		 mov	 DWORD PTR _iFmt$7[ebp], eax
$LN10@Build:
  0038a	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _iFmt$7[ebp]
  00390	3b 85 2c ff ff
	ff		 cmp	 eax, DWORD PTR _uD3DFmtNum$1[ebp]
  00396	0f 83 e1 00 00
	00		 jae	 $LN9@Build

; 388  : 			{			
; 389  : 				if (rkD3DADMList.GetPixelFormatr(iFmt)==c_rkD3DDM.Format)

  0039c	ff b5 58 ff ff
	ff		 push	 DWORD PTR _iFmt$7[ebp]
  003a2	8b 4d 78	 mov	 ecx, DWORD PTR _rkD3DADMList$[ebp]
  003a5	e8 00 00 00 00	 call	 ?GetPixelFormatr@D3D_CAdapterDisplayModeList@@QAEABW4_D3DFORMAT@@I@Z ; D3D_CAdapterDisplayModeList::GetPixelFormatr
  003aa	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _c_rkD3DDM$4[ebp]
  003b0	8b 00		 mov	 eax, DWORD PTR [eax]
  003b2	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  003b5	0f 85 bd 00 00
	00		 jne	 $LN26@Build

; 390  : 				{
; 391  : 					if (aisFormatConfirmed[iFmt] == TRUE )

  003bb	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _iFmt$7[ebp]
  003c1	83 7c 85 c0 01	 cmp	 DWORD PTR _aisFormatConfirmed$[ebp+eax*4], 1
  003c6	0f 85 ac 00 00
	00		 jne	 $LN26@Build

; 392  : 					{
; 393  : 						D3D_SModeInfo& rkModeInfo=m_akD3DModeInfo[m_uD3DModeInfoNum++];

  003cc	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003d2	6b 80 e4 00 00
	00 18		 imul	 eax, DWORD PTR [eax+228], 24
  003d9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003df	8d 84 01 e8 00
	00 00		 lea	 eax, DWORD PTR [ecx+eax+232]
  003e6	89 85 54 ff ff
	ff		 mov	 DWORD PTR _rkModeInfo$6[ebp], eax
  003ec	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003f2	8b 80 e4 00 00
	00		 mov	 eax, DWORD PTR [eax+228]
  003f8	40		 inc	 eax
  003f9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003ff	89 81 e4 00 00
	00		 mov	 DWORD PTR [ecx+228], eax

; 394  : 						rkModeInfo.m_uScrWidth=c_rkD3DDM.Width;

  00405	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _rkModeInfo$6[ebp]
  0040b	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _c_rkD3DDM$4[ebp]
  00411	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00413	89 08		 mov	 DWORD PTR [eax], ecx

; 395  : 						rkModeInfo.m_uScrHeight=c_rkD3DDM.Height;

  00415	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _rkModeInfo$6[ebp]
  0041b	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _c_rkD3DDM$4[ebp]
  00421	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00424	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 396  : 						rkModeInfo.m_eD3DFmtPixel=c_rkD3DDM.Format;

  00427	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _rkModeInfo$6[ebp]
  0042d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _c_rkD3DDM$4[ebp]
  00433	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00436	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 397  : 						rkModeInfo.m_dwD3DBehavior=adwD3DBehavior[iFmt];

  00439	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _rkModeInfo$6[ebp]
  0043f	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _iFmt$7[ebp]
  00445	8b 8c 8d 70 ff
	ff ff		 mov	 ecx, DWORD PTR _adwD3DBehavior$[ebp+ecx*4]
  0044c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 398  : 						rkModeInfo.m_eD3DFmtDepthStencil=aeD3DFmtDepthStencil[iFmt];

  0044f	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _rkModeInfo$6[ebp]
  00455	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _iFmt$7[ebp]
  0045b	8b 4c 8d 10	 mov	 ecx, DWORD PTR _aeD3DFmtDepthStencil$[ebp+ecx*4]
  0045f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 399  : 						
; 400  : 						if( m_eD3DDevType == D3DDEVTYPE_HAL )

  00462	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00468	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  0046c	75 0a		 jne	 SHORT $LN26@Build

; 401  : 							isHALSampleCompatible = TRUE;

  0046e	c7 85 28 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _isHALSampleCompatible$[ebp], 1
$LN26@Build:

; 402  : 					}
; 403  : 				}
; 404  : 			}

  00478	e9 00 ff ff ff	 jmp	 $LN8@Build
$LN9@Build:

; 405  : 		}

  0047d	e9 bf fe ff ff	 jmp	 $LN5@Build
$LN6@Build:

; 406  : 	}
; 407  : 
; 408  : 	// Check if the device is compatible with the desktop display mode
; 409  : 	// (which was added initially as formats[0])
; 410  : 	if (aisFormatConfirmed[0] && (m_kD3DCaps.Caps2 & D3DCAPS2_CANRENDERWINDOWED) )

  00482	6a 04		 push	 4
  00484	58		 pop	 eax
  00485	6b c0 00	 imul	 eax, eax, 0
  00488	83 7c 05 c0 00	 cmp	 DWORD PTR _aisFormatConfirmed$[ebp+eax], 0
  0048d	74 30		 je	 SHORT $LN29@Build
  0048f	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00495	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00498	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0049d	74 20		 je	 SHORT $LN29@Build

; 411  : 	{
; 412  : 		m_canDoWindowed=TRUE;

  0049f	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004a5	c7 80 dc 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+220], 1

; 413  : 		m_isWindowed=TRUE;

  004af	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004b5	c7 80 f8 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+3832], 1
$LN29@Build:

; 414  : 	}
; 415  : 	
; 416  : 	if (m_uD3DModeInfoNum>0)

  004bf	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004c5	83 b8 e4 00 00
	00 00		 cmp	 DWORD PTR [eax+228], 0
  004cc	76 05		 jbe	 SHORT $LN30@Build

; 417  : 		return TRUE;

  004ce	33 c0		 xor	 eax, eax
  004d0	40		 inc	 eax
  004d1	eb 02		 jmp	 SHORT $LN1@Build
$LN30@Build:

; 418  : 
; 419  : 	return FALSE;

  004d3	33 c0		 xor	 eax, eax
$LN1@Build:

; 420  : }

  004d5	8b 4d 60	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d8	33 cd		 xor	 ecx, ebp
  004da	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004df	83 c5 64	 add	 ebp, 100		; 00000064H
  004e2	c9		 leave
  004e3	c2 14 00	 ret	 20			; 00000014H
?Build@D3D_CDeviceInfo@@QAEHAAUIDirect3D8@@IIAAVD3D_CAdapterDisplayModeList@@P6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z ENDP ; D3D_CDeviceInfo::Build
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.h
;	COMDAT ??1D3D_CDeviceInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1D3D_CDeviceInfo@@QAE@XZ PROC				; D3D_CDeviceInfo::~D3D_CDeviceInfo, COMDAT
; _this$ = ecx

; 63   : 		~D3D_CDeviceInfo() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1D3D_CDeviceInfo@@QAE@XZ ENDP				; D3D_CDeviceInfo::~D3D_CDeviceInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.h
;	COMDAT ??0D3D_CDeviceInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0D3D_CDeviceInfo@@QAE@XZ PROC				; D3D_CDeviceInfo::D3D_CDeviceInfo, COMDAT
; _this$ = ecx

; 62   : 		D3D_CDeviceInfo() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c9		 leave
  0000b	c3		 ret	 0
??0D3D_CDeviceInfo@@QAE@XZ ENDP				; D3D_CDeviceInfo::D3D_CDeviceInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetPixelFormatr@D3D_CAdapterDisplayModeList@@QAEABW4_D3DFORMAT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iD3DFmt$ = 8						; size = 4
?GetPixelFormatr@D3D_CAdapterDisplayModeList@@QAEABW4_D3DFORMAT@@I@Z PROC ; D3D_CAdapterDisplayModeList::GetPixelFormatr, COMDAT
; _this$ = ecx

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   : 	assert(iD3DFmt<m_uD3DFmtNum);
; 67   : 	return m_aeD3DFmt[iD3DFmt];

  00007	8b 45 08	 mov	 eax, DWORD PTR _iD3DFmt$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8d 84 81 40 06
	00 00		 lea	 eax, DWORD PTR [ecx+eax*4+1600]

; 68   : }

  00014	c9		 leave
  00015	c2 04 00	 ret	 4
?GetPixelFormatr@D3D_CAdapterDisplayModeList@@QAEABW4_D3DFORMAT@@I@Z ENDP ; D3D_CAdapterDisplayModeList::GetPixelFormatr
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetDisplayModer@D3D_CAdapterDisplayModeList@@QAEABU_D3DDISPLAYMODE@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iD3DDM$ = 8						; size = 4
?GetDisplayModer@D3D_CAdapterDisplayModeList@@QAEABU_D3DDISPLAYMODE@@I@Z PROC ; D3D_CAdapterDisplayModeList::GetDisplayModer, COMDAT
; _this$ = ecx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 60   : 	assert(iD3DDM<m_uD3DDMNum);
; 61   : 	return m_akD3DDM[iD3DDM];

  00007	8b 45 08	 mov	 eax, DWORD PTR _iD3DDM$[ebp]
  0000a	c1 e0 04	 shl	 eax, 4
  0000d	03 45 fc	 add	 eax, DWORD PTR _this$[ebp]

; 62   : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?GetDisplayModer@D3D_CAdapterDisplayModeList@@QAEABU_D3DDISPLAYMODE@@I@Z ENDP ; D3D_CAdapterDisplayModeList::GetDisplayModer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetPixelFormatNum@D3D_CAdapterDisplayModeList@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPixelFormatNum@D3D_CAdapterDisplayModeList@@QAEIXZ PROC ; D3D_CAdapterDisplayModeList::GetPixelFormatNum, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 54   : 	return m_uD3DFmtNum;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 94 06 00
	00		 mov	 eax, DWORD PTR [eax+1684]

; 55   : }

  00010	c9		 leave
  00011	c3		 ret	 0
?GetPixelFormatNum@D3D_CAdapterDisplayModeList@@QAEIXZ ENDP ; D3D_CAdapterDisplayModeList::GetPixelFormatNum
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetDisplayModeNum@D3D_CAdapterDisplayModeList@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDisplayModeNum@D3D_CAdapterDisplayModeList@@QAEIXZ PROC ; D3D_CAdapterDisplayModeList::GetDisplayModeNum, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 49   : 	return m_uD3DDMNum;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 90 06 00
	00		 mov	 eax, DWORD PTR [eax+1680]

; 50   : }

  00010	c9		 leave
  00011	c3		 ret	 0
?GetDisplayModeNum@D3D_CAdapterDisplayModeList@@QAEIXZ ENDP ; D3D_CAdapterDisplayModeList::GetDisplayModeNum
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?Build@D3D_CAdapterDisplayModeList@@QAEXAAUIDirect3D8@@W4_D3DFORMAT@@I@Z
_TEXT	SEGMENT
_peD3DFmtFind$1 = -72					; size = 4
_pkD3DDMFind$2 = -68					; size = 4
$T3 = -64						; size = 4
_uAdapterModeNum$ = -60					; size = 4
_peD3DFmtEnd$4 = -56					; size = 4
_pkD3DDMEnd$5 = -52					; size = 4
_rkD3DDMNew$6 = -48					; size = 4
_this$ = -44						; size = 4
_akD3DDM$ = -40						; size = 4
_aeD3DFmt$ = -36					; size = 4
_iD3DAdapterInfoMode$7 = -32				; size = 4
_uD3DDMNum$ = -28					; size = 4
_uD3DFmtNum$ = -24					; size = 4
_kD3DDMCur$8 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_rkD3D$ = 8						; size = 4
_eD3DFmtDefault$ = 12					; size = 4
_iD3DAdapterInfo$ = 16					; size = 4
?Build@D3D_CAdapterDisplayModeList@@QAEXAAUIDirect3D8@@W4_D3DFORMAT@@I@Z PROC ; D3D_CAdapterDisplayModeList::Build, COMDAT
; _this$ = ecx

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 72   : 	D3DDISPLAYMODE* akD3DDM=m_akD3DDM;

  00013	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 d8	 mov	 DWORD PTR _akD3DDM$[ebp], eax

; 73   : 	D3DFORMAT* aeD3DFmt=m_aeD3DFmt;	

  00019	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	05 40 06 00 00	 add	 eax, 1600		; 00000640H
  00021	89 45 dc	 mov	 DWORD PTR _aeD3DFmt$[ebp], eax

; 74   : 
; 75   : 	UINT uD3DDMNum=0;

  00024	83 65 e4 00	 and	 DWORD PTR _uD3DDMNum$[ebp], 0

; 76   : 	UINT uD3DFmtNum=0;

  00028	83 65 e8 00	 and	 DWORD PTR _uD3DFmtNum$[ebp], 0

; 77   : 
; 78   : 	aeD3DFmt[uD3DFmtNum++]=eD3DFmtDefault;

  0002c	8b 45 e8	 mov	 eax, DWORD PTR _uD3DFmtNum$[ebp]
  0002f	8b 4d dc	 mov	 ecx, DWORD PTR _aeD3DFmt$[ebp]
  00032	8b 55 0c	 mov	 edx, DWORD PTR _eD3DFmtDefault$[ebp]
  00035	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  00038	8b 45 e8	 mov	 eax, DWORD PTR _uD3DFmtNum$[ebp]
  0003b	40		 inc	 eax
  0003c	89 45 e8	 mov	 DWORD PTR _uD3DFmtNum$[ebp], eax

; 79   : 
; 80   : 	UINT uAdapterModeNum=rkD3D.GetAdapterModeCount(iD3DAdapterInfo);

  0003f	ff 75 10	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  00042	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  0004a	ff 50 18	 call	 DWORD PTR [eax+24]
  0004d	89 45 c4	 mov	 DWORD PTR _uAdapterModeNum$[ebp], eax

; 81   : 	for (UINT iD3DAdapterInfoMode=0; iD3DAdapterInfoMode<uAdapterModeNum; iD3DAdapterInfoMode++)

  00050	83 65 e0 00	 and	 DWORD PTR _iD3DAdapterInfoMode$7[ebp], 0
  00054	eb 07		 jmp	 SHORT $LN4@Build
$LN2@Build:
  00056	8b 45 e0	 mov	 eax, DWORD PTR _iD3DAdapterInfoMode$7[ebp]
  00059	40		 inc	 eax
  0005a	89 45 e0	 mov	 DWORD PTR _iD3DAdapterInfoMode$7[ebp], eax
$LN4@Build:
  0005d	8b 45 e0	 mov	 eax, DWORD PTR _iD3DAdapterInfoMode$7[ebp]
  00060	3b 45 c4	 cmp	 eax, DWORD PTR _uAdapterModeNum$[ebp]
  00063	0f 83 d1 00 00
	00		 jae	 $LN3@Build

; 82   : 	{			
; 83   : 		D3DDISPLAYMODE kD3DDMCur;
; 84   : 		rkD3D.EnumAdapterModes(iD3DAdapterInfo, iD3DAdapterInfoMode, &kD3DDMCur);

  00069	8d 45 ec	 lea	 eax, DWORD PTR _kD3DDMCur$8[ebp]
  0006c	50		 push	 eax
  0006d	ff 75 e0	 push	 DWORD PTR _iD3DAdapterInfoMode$7[ebp]
  00070	ff 75 10	 push	 DWORD PTR _iD3DAdapterInfo$[ebp]
  00073	8b 45 08	 mov	 eax, DWORD PTR _rkD3D$[ebp]
  00076	8b 00		 mov	 eax, DWORD PTR [eax]
  00078	ff 75 08	 push	 DWORD PTR _rkD3D$[ebp]
  0007b	ff 50 1c	 call	 DWORD PTR [eax+28]

; 85   : 
; 86   : 		// IsFilterOutLowResolutionMode
; 87   : 		if( kD3DDMCur.Width  < FILTEROUT_LOWRESOLUTION_WIDTH || kD3DDMCur.Height < FILTEROUT_LOWRESOLUTION_HEIGHT )

  0007e	81 7d ec 80 02
	00 00		 cmp	 DWORD PTR _kD3DDMCur$8[ebp], 640 ; 00000280H
  00085	72 09		 jb	 SHORT $LN6@Build
  00087	81 7d f0 e0 01
	00 00		 cmp	 DWORD PTR _kD3DDMCur$8[ebp+4], 480 ; 000001e0H
  0008e	73 02		 jae	 SHORT $LN5@Build
$LN6@Build:

; 88   : 			continue;

  00090	eb c4		 jmp	 SHORT $LN2@Build
$LN5@Build:

; 89   : 		
; 90   : 		// FindDisplayMode
; 91   : 		D3DDISPLAYMODE* pkD3DDMEnd=akD3DDM+uD3DDMNum;

  00092	8b 45 e4	 mov	 eax, DWORD PTR _uD3DDMNum$[ebp]
  00095	c1 e0 04	 shl	 eax, 4
  00098	03 45 d8	 add	 eax, DWORD PTR _akD3DDM$[ebp]
  0009b	89 45 cc	 mov	 DWORD PTR _pkD3DDMEnd$5[ebp], eax

; 9    : 		m_pkD3DDMChk=pkD3DDMChk;

  0009e	8d 45 ec	 lea	 eax, DWORD PTR _kD3DDMCur$8[ebp]
  000a1	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax

; 92   : 		D3DDISPLAYMODE* pkD3DDMFind=std::find_if(akD3DDM, pkD3DDMEnd, FIsEqualD3DDisplayMode(&kD3DDMCur));

  000a4	ff 75 c0	 push	 DWORD PTR $T3[ebp]
  000a7	ff 75 cc	 push	 DWORD PTR _pkD3DDMEnd$5[ebp]
  000aa	ff 75 d8	 push	 DWORD PTR _akD3DDM$[ebp]
  000ad	e8 00 00 00 00	 call	 ??$find_if@PAU_D3DDISPLAYMODE@@UFIsEqualD3DDisplayMode@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@QAU1@UFIsEqualD3DDisplayMode@@@Z ; std::find_if<_D3DDISPLAYMODE *,FIsEqualD3DDisplayMode>
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b5	89 45 bc	 mov	 DWORD PTR _pkD3DDMFind$2[ebp], eax

; 93   : 
; 94   : 		// IsNewDisplayMode
; 95   : 		if (pkD3DDMFind==pkD3DDMEnd && uD3DDMNum<D3DDISPLAYMODE_MAX)

  000b8	8b 45 bc	 mov	 eax, DWORD PTR _pkD3DDMFind$2[ebp]
  000bb	3b 45 cc	 cmp	 eax, DWORD PTR _pkD3DDMEnd$5[ebp]
  000be	75 75		 jne	 SHORT $LN7@Build
  000c0	83 7d e4 64	 cmp	 DWORD PTR _uD3DDMNum$[ebp], 100 ; 00000064H
  000c4	73 6f		 jae	 SHORT $LN7@Build

; 96   : 		{
; 97   : 			D3DDISPLAYMODE& rkD3DDMNew=akD3DDM[uD3DDMNum++];					

  000c6	8b 45 e4	 mov	 eax, DWORD PTR _uD3DDMNum$[ebp]
  000c9	c1 e0 04	 shl	 eax, 4
  000cc	03 45 d8	 add	 eax, DWORD PTR _akD3DDM$[ebp]
  000cf	89 45 d0	 mov	 DWORD PTR _rkD3DDMNew$6[ebp], eax
  000d2	8b 45 e4	 mov	 eax, DWORD PTR _uD3DDMNum$[ebp]
  000d5	40		 inc	 eax
  000d6	89 45 e4	 mov	 DWORD PTR _uD3DDMNum$[ebp], eax

; 98   : 			rkD3DDMNew.Width=kD3DDMCur.Width;

  000d9	8b 45 d0	 mov	 eax, DWORD PTR _rkD3DDMNew$6[ebp]
  000dc	8b 4d ec	 mov	 ecx, DWORD PTR _kD3DDMCur$8[ebp]
  000df	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			rkD3DDMNew.Height=kD3DDMCur.Height;

  000e1	8b 45 d0	 mov	 eax, DWORD PTR _rkD3DDMNew$6[ebp]
  000e4	8b 4d f0	 mov	 ecx, DWORD PTR _kD3DDMCur$8[ebp+4]
  000e7	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 100  : 			rkD3DDMNew.Format=kD3DDMCur.Format;									

  000ea	8b 45 d0	 mov	 eax, DWORD PTR _rkD3DDMNew$6[ebp]
  000ed	8b 4d f8	 mov	 ecx, DWORD PTR _kD3DDMCur$8[ebp+12]
  000f0	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 101  : 
; 102  : 			// FindFormat
; 103  : 			D3DFORMAT* peD3DFmtEnd=aeD3DFmt+uD3DFmtNum;

  000f3	8b 45 e8	 mov	 eax, DWORD PTR _uD3DFmtNum$[ebp]
  000f6	8b 4d dc	 mov	 ecx, DWORD PTR _aeD3DFmt$[ebp]
  000f9	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000fc	89 45 c8	 mov	 DWORD PTR _peD3DFmtEnd$4[ebp], eax

; 104  : 			D3DFORMAT* peD3DFmtFind=std::find(aeD3DFmt, peD3DFmtEnd, kD3DDMCur.Format);

  000ff	8d 45 f8	 lea	 eax, DWORD PTR _kD3DDMCur$8[ebp+12]
  00102	50		 push	 eax
  00103	ff 75 c8	 push	 DWORD PTR _peD3DFmtEnd$4[ebp]
  00106	ff 75 dc	 push	 DWORD PTR _aeD3DFmt$[ebp]
  00109	e8 00 00 00 00	 call	 ??$find@PAW4_D3DFORMAT@@W41@@std@@YAPAW4_D3DFORMAT@@PAW41@QAW41@ABW41@@Z ; std::find<enum _D3DFORMAT *,enum _D3DFORMAT>
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00111	89 45 b8	 mov	 DWORD PTR _peD3DFmtFind$1[ebp], eax

; 105  : 
; 106  : 			// IsNewFormat
; 107  : 			if (peD3DFmtFind==peD3DFmtEnd && uD3DFmtNum<D3DFORMAT_MAX)

  00114	8b 45 b8	 mov	 eax, DWORD PTR _peD3DFmtFind$1[ebp]
  00117	3b 45 c8	 cmp	 eax, DWORD PTR _peD3DFmtEnd$4[ebp]
  0011a	75 19		 jne	 SHORT $LN7@Build
  0011c	83 7d e8 14	 cmp	 DWORD PTR _uD3DFmtNum$[ebp], 20 ; 00000014H
  00120	73 13		 jae	 SHORT $LN7@Build

; 108  : 			{
; 109  : 				aeD3DFmt[uD3DFmtNum++]=kD3DDMCur.Format;

  00122	8b 45 e8	 mov	 eax, DWORD PTR _uD3DFmtNum$[ebp]
  00125	8b 4d dc	 mov	 ecx, DWORD PTR _aeD3DFmt$[ebp]
  00128	8b 55 f8	 mov	 edx, DWORD PTR _kD3DDMCur$8[ebp+12]
  0012b	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  0012e	8b 45 e8	 mov	 eax, DWORD PTR _uD3DFmtNum$[ebp]
  00131	40		 inc	 eax
  00132	89 45 e8	 mov	 DWORD PTR _uD3DFmtNum$[ebp], eax
$LN7@Build:

; 110  : 			}											
; 111  : 		}				
; 112  : 	}

  00135	e9 1c ff ff ff	 jmp	 $LN2@Build
$LN3@Build:

; 113  : 
; 114  : 	qsort(akD3DDM, uD3DDMNum, sizeof(D3DDISPLAYMODE), CompareD3DDisplayModeOrder);				

  0013a	68 00 00 00 00	 push	 OFFSET ?CompareD3DDisplayModeOrder@@YAHPBX0@Z ; CompareD3DDisplayModeOrder
  0013f	6a 10		 push	 16			; 00000010H
  00141	ff 75 e4	 push	 DWORD PTR _uD3DDMNum$[ebp]
  00144	ff 75 d8	 push	 DWORD PTR _akD3DDM$[ebp]
  00147	e8 00 00 00 00	 call	 _qsort
  0014c	83 c4 10	 add	 esp, 16			; 00000010H

; 115  : 
; 116  : 	m_uD3DFmtNum=uD3DFmtNum;

  0014f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00152	8b 4d e8	 mov	 ecx, DWORD PTR _uD3DFmtNum$[ebp]
  00155	89 88 94 06 00
	00		 mov	 DWORD PTR [eax+1684], ecx

; 117  : 	m_uD3DDMNum=uD3DDMNum;

  0015b	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0015e	8b 4d e4	 mov	 ecx, DWORD PTR _uD3DDMNum$[ebp]
  00161	89 88 90 06 00
	00		 mov	 DWORD PTR [eax+1680], ecx

; 118  : }

  00167	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016a	33 cd		 xor	 ecx, ebp
  0016c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00171	c9		 leave
  00172	c2 0c 00	 ret	 12			; 0000000cH
?Build@D3D_CAdapterDisplayModeList@@QAEXAAUIDirect3D8@@W4_D3DFORMAT@@I@Z ENDP ; D3D_CAdapterDisplayModeList::Build
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.h
;	COMDAT ??1D3D_CAdapterDisplayModeList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1D3D_CAdapterDisplayModeList@@QAE@XZ PROC		; D3D_CAdapterDisplayModeList::~D3D_CAdapterDisplayModeList, COMDAT
; _this$ = ecx

; 31   : 		~D3D_CAdapterDisplayModeList() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1D3D_CAdapterDisplayModeList@@QAE@XZ ENDP		; D3D_CAdapterDisplayModeList::~D3D_CAdapterDisplayModeList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp
;	COMDAT ?GetString@D3D_SModeInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = -128						; size = 4
$T2 = -124						; size = 4
_uScrDepthBits$ = -120					; size = 4
tv65 = -116						; size = 4
tv69 = -112						; size = 4
_this$ = -108						; size = 4
_iVP$ = -104						; size = 4
_szText$ = -100						; size = 1025
__$ArrayPad$ = 928					; size = 4
_pstEnumList$ = 940					; size = 4
?GetString@D3D_SModeInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; D3D_SModeInfo::GetString, COMDAT
; _this$ = ecx

; 123  : {		

  00000	55		 push	 ebp
  00001	8d ac 24 5c fc
	ff ff		 lea	 ebp, DWORD PTR [esp-932]
  00008	81 ec 24 04 00
	00		 sub	 esp, 1060		; 00000424H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 a0 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 124  : 	UINT uScrDepthBits=16;

  0001e	c7 45 88 10 00
	00 00		 mov	 DWORD PTR _uScrDepthBits$[ebp], 16 ; 00000010H

; 125  : 	switch (m_eD3DFmtPixel)

  00025	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0002b	89 45 8c	 mov	 DWORD PTR tv65[ebp], eax
  0002e	83 7d 8c 14	 cmp	 DWORD PTR tv65[ebp], 20	; 00000014H
  00032	7c 0f		 jl	 SHORT $LN2@GetString
  00034	83 7d 8c 16	 cmp	 DWORD PTR tv65[ebp], 22	; 00000016H
  00038	7e 02		 jle	 SHORT $LN6@GetString
  0003a	eb 07		 jmp	 SHORT $LN2@GetString
$LN6@GetString:

; 126  : 	{
; 127  : 		case D3DFMT_X8R8G8B8:
; 128  : 		case D3DFMT_A8R8G8B8:
; 129  : 		case D3DFMT_R8G8B8:
; 130  : 			uScrDepthBits=32;

  0003c	c7 45 88 20 00
	00 00		 mov	 DWORD PTR _uScrDepthBits$[ebp], 32 ; 00000020H
$LN2@GetString:

; 131  : 			break;
; 132  : 	}
; 133  : 
; 134  : 	int iVP=0;

  00043	83 65 98 00	 and	 DWORD PTR _iVP$[ebp], 0

; 135  : 
; 136  : 	switch (m_dwD3DBehavior)

  00047	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0004d	89 45 90	 mov	 DWORD PTR tv69[ebp], eax
  00050	83 7d 90 20	 cmp	 DWORD PTR tv69[ebp], 32	; 00000020H
  00054	74 23		 je	 SHORT $LN9@GetString
  00056	83 7d 90 40	 cmp	 DWORD PTR tv69[ebp], 64	; 00000040H
  0005a	74 0b		 je	 SHORT $LN7@GetString
  0005c	81 7d 90 80 00
	00 00		 cmp	 DWORD PTR tv69[ebp], 128 ; 00000080H
  00063	74 0b		 je	 SHORT $LN8@GetString
  00065	eb 19		 jmp	 SHORT $LN4@GetString
$LN7@GetString:

; 137  : 	{
; 138  : 		case D3DCREATE_HARDWARE_VERTEXPROCESSING:
; 139  : 			iVP=1;

  00067	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _iVP$[ebp], 1

; 140  : 			break;

  0006e	eb 10		 jmp	 SHORT $LN4@GetString
$LN8@GetString:

; 141  : 		case D3DCREATE_MIXED_VERTEXPROCESSING:
; 142  : 			iVP=2;

  00070	c7 45 98 02 00
	00 00		 mov	 DWORD PTR _iVP$[ebp], 2

; 143  : 			break;

  00077	eb 07		 jmp	 SHORT $LN4@GetString
$LN9@GetString:

; 144  : 		case D3DCREATE_SOFTWARE_VERTEXPROCESSING:
; 145  : 			iVP=3;

  00079	c7 45 98 03 00
	00 00		 mov	 DWORD PTR _iVP$[ebp], 3
$LN4@GetString:

; 146  : 			break;
; 147  : 	}
; 148  : 
; 149  : 	static const char* szVP[4]=
; 150  : 	{
; 151  : 		"UNKNOWN",
; 152  : 		"HWVP",
; 153  : 		"MXVP",
; 154  : 		"SWVP",
; 155  : 	};
; 156  : 
; 157  : 	char szText[1024+1];
; 158  : 	_snprintf(szText, sizeof(szText), "%dx%dx%d %s\r\n", m_uScrWidth, m_uScrHeight, uScrDepthBits, szVP[iVP]);

  00080	8b 45 98	 mov	 eax, DWORD PTR _iVP$[ebp]
  00083	ff 34 85 00 00
	00 00		 push	 DWORD PTR ?szVP@?1??GetString@D3D_SModeInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4PAPBDA[eax*4]
  0008a	ff 75 88	 push	 DWORD PTR _uScrDepthBits$[ebp]
  0008d	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00090	ff 70 04	 push	 DWORD PTR [eax+4]
  00093	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00096	ff 30		 push	 DWORD PTR [eax]
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KEGMOEDA@?$CFdx?$CFdx?$CFd?5?$CFs?$AN?6@
  0009d	68 01 04 00 00	 push	 1025			; 00000401H
  000a2	8d 45 9c	 lea	 eax, DWORD PTR _szText$[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 __snprintf
  000ab	83 c4 1c	 add	 esp, 28			; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000ae	8d 45 9c	 lea	 eax, DWORD PTR _szText$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _strlen
  000b7	59		 pop	 ecx
  000b8	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000bb	8b 45 84	 mov	 eax, DWORD PTR $T2[ebp]
  000be	89 45 80	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000c1	ff 75 80	 push	 DWORD PTR $T1[ebp]
  000c4	8d 45 9c	 lea	 eax, DWORD PTR _szText$[ebp]
  000c7	50		 push	 eax
  000c8	8b 8d ac 03 00
	00		 mov	 ecx, DWORD PTR _pstEnumList$[ebp]
  000ce	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.cpp

; 160  : }

  000d3	8b 8d a0 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	81 c5 a4 03 00
	00		 add	 ebp, 932		; 000003a4H
  000e6	c9		 leave
  000e7	c2 04 00	 ret	 4
?GetString@D3D_SModeInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; D3D_SModeInfo::GetString
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv75 = -12						; size = 4
$T3 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4284 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 0f	 or	 eax, 15			; 0000000fH
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  00012	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4287 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 46		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0001f	d1 e8		 shr	 eax, 1
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4291 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 32		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003e	3b 45 f8	 cmp	 eax, DWORD PTR $T3[ebp]
  00041	73 08		 jae	 SHORT $LN7@Calculate_
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00046	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00049	eb 06		 jmp	 SHORT $LN8@Calculate_
$LN7@Calculate_:
  0004b	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  0004e	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
$LN8@Calculate_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00057	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4295 :     }

  00062	c9		 leave
  00063	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -24						; size = 1
__First1$ = -20						; size = 4
__Old_ptr$2 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2935 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2936 :         // append [_Ptr, _Ptr + _Count)
; 2937 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 2938 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 49		 ja	 SHORT $LN2@append

; 2939 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00023	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2940 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 2941 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8b 45 f0	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  0003a	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR __First1$[ebp], eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00046	ff 75 ec	 push	 DWORD PTR __First1$[ebp]
  00049	e8 00 00 00 00	 call	 _memmove
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2942 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00051	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00055	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00058	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]

; 428  :         _Left = _Right;

  0005b	8b 4d f0	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  0005e	8a 55 ff	 mov	 dl, BYTE PTR $T3[ebp]
  00061	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2943 :             return *this;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	eb 19		 jmp	 SHORT $LN1@append
$LN2@append:

; 2944 :         }
; 2945 : 
; 2946 :         return _Reallocate_grow_by(

  00069	33 c0		 xor	 eax, eax
  0006b	88 45 e8	 mov	 BYTE PTR $T1[ebp], al
  0006e	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00071	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00074	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00077	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 2947 :             _Count,
; 2948 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2949 :                 const size_type _Count) {
; 2950 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2953 :             },
; 2954 :             _Ptr, _Count);
; 2955 :     }

  00082	c9		 leave
  00083	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1969 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1970 :         int _Result;
; 1971 :         va_list _ArgList;
; 1972 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00020	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	83 c9 01	 or	 ecx, 1
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00034	83 c4 1c	 add	 esp, 28			; 0000001cH
  00037	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0003a	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003e	7d 06		 jge	 SHORT $LN7@snprintf
  00040	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN3@snprintf
$LN7@snprintf:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00049	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@snprintf:

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0004c	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004f	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1975 :         __crt_va_end(_ArgList);

  00052	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1976 :         return _Result;

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1977 :     }

  00059	c9		 leave
  0005a	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
