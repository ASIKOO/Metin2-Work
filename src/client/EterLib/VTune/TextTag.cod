; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
PUBLIC	?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z ; GetTextTagOutputString
PUBLIC	?GetTextTagOutputLen@@YAHPB_WH@Z		; GetTextTagOutputLen
PUBLIC	?FindColorTagEndPosition@@YAHPB_WH@Z		; FindColorTagEndPosition
PUBLIC	?FindColorTagStartPosition@@YAHPB_WH@Z		; FindColorTagStartPosition
PUBLIC	?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z ; GetTextTagInternalPosFromRenderPos
PUBLIC	??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z$1
__ehfuncinfo$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTextTagOutputLen@@YAHPB_WH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTextTagOutputLen@@YAHPB_WH@Z$0
__ehfuncinfo$?GetTextTagOutputLen@@YAHPB_WH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetTextTagOutputLen@@YAHPB_WH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z$1
__ehfuncinfo$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z
_TEXT	SEGMENT
__Max_possible$1 = -88					; size = 4
__Al$ = -84						; size = 4
$T2 = -80						; size = 4
__Ptr$ = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
__Old_ptr$6 = -60					; size = 4
__Old_capacity$ = -56					; size = 4
__New_capacity$ = -52					; size = 4
__New_size$ = -48					; size = 4
__Count$ = -44						; size = 4
__New_ptr$ = -40					; size = 4
_this$ = -36						; size = 4
__Raw_new$ = -32					; size = 4
__My_data$ = -28					; size = 4
__Old_size$ = -24					; size = 4
$T7 = -18						; size = 2
__Ch$ = -16						; size = 2
$T8 = -10						; size = 2
__Ch$ = -8						; size = 2
__Overflow_is_possible$9 = -1				; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 2
??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 e8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00020	2b 45 e8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 d0	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 c8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00047	50		 push	 eax
  00048	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 d0	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 cc	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 c0	 mov	 eax, DWORD PTR $T5[ebp]
  00065	89 45 ac	 mov	 DWORD PTR __Al$[ebp], eax

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00068	8b 45 cc	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006b	40		 inc	 eax
  0006c	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0006f	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$9[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00073	c7 45 a8 ff ff
	ff 7f		 mov	 DWORD PTR __Max_possible$1[ebp], 2147483647 ; 7fffffffH

; 60   :         if (_Count > _Max_possible) {

  0007a	81 7d d4 ff ff
	ff 7f		 cmp	 DWORD PTR __Count$[ebp], 2147483647 ; 7fffffffH
  00081	76 05		 jbe	 SHORT $LN68@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00083	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN68@Reallocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00088	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  0008b	d1 e0		 shl	 eax, 1
  0008d	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00090	ff 75 bc	 push	 DWORD PTR $T4[ebp]
  00093	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00098	59		 pop	 ecx
  00099	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0009c	8b 45 b8	 mov	 eax, DWORD PTR $T3[ebp]
  0009f	89 45 d8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  000a2	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a5	8b 4d d0	 mov	 ecx, DWORD PTR __New_size$[ebp]
  000a8	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  000ab	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ae	8b 4d cc	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000b1	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000b4	8b 45 d8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  000b7	89 45 b4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000ba	8b 45 b4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000bd	89 45 e0	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  000c0	83 7d c8 08	 cmp	 DWORD PTR __Old_capacity$[ebp], 8
  000c4	72 69		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000c6	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000c9	8b 00		 mov	 eax, DWORD PTR [eax]
  000cb	89 45 c4	 mov	 DWORD PTR __Old_ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000ce	8b 45 c4	 mov	 eax, DWORD PTR __Old_ptr$6[ebp]
  000d1	89 45 b0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000d4	66 8b 45 10	 mov	 ax, WORD PTR _<_Args_0>$[ebp]
  000d8	66 89 45 f8	 mov	 WORD PTR __Ch$[ebp], ax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000dc	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000df	d1 e0		 shl	 eax, 1
  000e1	50		 push	 eax
  000e2	ff 75 b0	 push	 DWORD PTR $T2[ebp]
  000e5	ff 75 e0	 push	 DWORD PTR __Raw_new$[ebp]
  000e8	e8 00 00 00 00	 call	 _memcpy
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  :         _Left = _Right;

  000f0	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000f3	8b 4d e0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000f6	66 8b 55 f8	 mov	 dx, WORD PTR __Ch$[ebp]
  000fa	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 3706 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  000fe	33 c0		 xor	 eax, eax
  00100	66 89 45 f6	 mov	 WORD PTR $T8[ebp], ax

; 281  :         _Left = _Right;

  00104	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00107	8b 4d e0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  0010a	66 8b 55 f6	 mov	 dx, WORD PTR $T8[ebp]
  0010e	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00113	8b 45 c8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  00116	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  0011a	50		 push	 eax
  0011b	ff 75 c4	 push	 DWORD PTR __Old_ptr$6[ebp]
  0011e	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00123	59		 pop	 ecx
  00124	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  00125	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00128	8b 4d d8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0012b	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  0012d	eb 4d		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  0012f	66 8b 45 10	 mov	 ax, WORD PTR _<_Args_0>$[ebp]
  00133	66 89 45 f0	 mov	 WORD PTR __Ch$[ebp], ax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00137	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0013a	d1 e0		 shl	 eax, 1
  0013c	50		 push	 eax
  0013d	ff 75 e4	 push	 DWORD PTR __My_data$[ebp]
  00140	ff 75 e0	 push	 DWORD PTR __Raw_new$[ebp]
  00143	e8 00 00 00 00	 call	 _memcpy
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  :         _Left = _Right;

  0014b	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0014e	8b 4d e0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  00151	66 8b 55 f0	 mov	 dx, WORD PTR __Ch$[ebp]
  00155	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 3706 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00159	33 c0		 xor	 eax, eax
  0015b	66 89 45 ee	 mov	 WORD PTR $T7[ebp], ax

; 281  :         _Left = _Right;

  0015f	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00162	8b 4d e0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  00165	66 8b 55 ee	 mov	 dx, WORD PTR $T7[ebp]
  00169	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0016e	8d 45 d8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00171	50		 push	 eax
  00172	ff 75 e4	 push	 DWORD PTR __My_data$[ebp]
  00175	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  0017a	59		 pop	 ecx
  0017b	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  0017c	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
$LN71@Reallocate:

; 4357 :     }

  0017f	c9		 leave
  00180	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
;	COMDAT ?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z
_TEXT	SEGMENT
$T2 = -112						; size = 4
_len$ = -108						; size = 4
__Ch$ = -104						; size = 2
$T3 = -100						; size = 4
_this$ = -96						; size = 4
_this$ = -92						; size = 4
_hyperlinkStep$ = -88					; size = 4
_output_len$ = -84					; size = 4
_internal_offset$ = -80					; size = 4
_tag$4 = -76						; size = 4
_i$5 = -72						; size = 4
_color_tag$ = -65					; size = 1
_dst$ = -64						; size = 24
_extraInfo$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_src$ = 8						; size = 4
_src_len$ = 12						; size = 4
_offset$ = 16						; size = 4
?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z PROC	; GetTextTagInternalPosFromRenderPos, COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 64	 sub	 esp, 100		; 00000064H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00028	8d 45 c0	 lea	 eax, DWORD PTR _dst$[ebp]
  0002b	89 45 a4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  00036	8d 4d c0	 lea	 ecx, DWORD PTR _dst$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 79   : 	std::wstring dst;

  0003e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00042	8d 45 d8	 lea	 eax, DWORD PTR _extraInfo$[ebp]
  00045	89 45 a0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00048	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  00050	8d 4d d8	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  00053	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 80   : 	std::wstring extraInfo;

  00058	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 81   :     int output_len = 0;

  0005c	83 65 ac 00	 and	 DWORD PTR _output_len$[ebp], 0

; 82   :     int hyperlinkStep = 0;

  00060	83 65 a8 00	 and	 DWORD PTR _hyperlinkStep$[ebp], 0

; 83   : 	bool color_tag = false;

  00064	c6 45 bf 00	 mov	 BYTE PTR _color_tag$[ebp], 0

; 84   : 	int internal_offset = 0;

  00068	83 65 b0 00	 and	 DWORD PTR _internal_offset$[ebp], 0

; 85   : 
; 86   :     for (int i = 0; i < src_len; )

  0006c	83 65 b8 00	 and	 DWORD PTR _i$5[ebp], 0
$LN4@GetTextTag:
  00070	8b 45 b8	 mov	 eax, DWORD PTR _i$5[ebp]
  00073	3b 45 0c	 cmp	 eax, DWORD PTR _src_len$[ebp]
  00076	0f 8d dc 00 00
	00		 jge	 $LN3@GetTextTag

; 87   :     {
; 88   :         int tag = GetTextTag(&src[i], src_len - i, len, extraInfo);

  0007c	8d 45 d8	 lea	 eax, DWORD PTR _extraInfo$[ebp]
  0007f	50		 push	 eax
  00080	8d 45 94	 lea	 eax, DWORD PTR _len$[ebp]
  00083	50		 push	 eax
  00084	8b 45 0c	 mov	 eax, DWORD PTR _src_len$[ebp]
  00087	2b 45 b8	 sub	 eax, DWORD PTR _i$5[ebp]
  0008a	50		 push	 eax
  0008b	8b 45 b8	 mov	 eax, DWORD PTR _i$5[ebp]
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  00091	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
  0009a	83 c4 10	 add	 esp, 16			; 00000010H
  0009d	89 45 b4	 mov	 DWORD PTR _tag$4[ebp], eax

; 89   : 
; 90   :         if (tag == TEXT_TAG_COLOR)

  000a0	83 7d b4 02	 cmp	 DWORD PTR _tag$4[ebp], 2
  000a4	75 0f		 jne	 SHORT $LN5@GetTextTag

; 91   : 		{
; 92   : 			color_tag = true;

  000a6	c6 45 bf 01	 mov	 BYTE PTR _color_tag$[ebp], 1

; 93   : 			internal_offset = i;

  000aa	8b 45 b8	 mov	 eax, DWORD PTR _i$5[ebp]
  000ad	89 45 b0	 mov	 DWORD PTR _internal_offset$[ebp], eax

; 94   : 		}

  000b0	e9 95 00 00 00	 jmp	 $LN6@GetTextTag
$LN5@GetTextTag:

; 95   : 		else if (tag == TEXT_TAG_RESTORE_COLOR)

  000b5	83 7d b4 05	 cmp	 DWORD PTR _tag$4[ebp], 5
  000b9	75 09		 jne	 SHORT $LN7@GetTextTag

; 96   : 		{
; 97   : 			color_tag = false;

  000bb	c6 45 bf 00	 mov	 BYTE PTR _color_tag$[ebp], 0

; 98   : 		}

  000bf	e9 86 00 00 00	 jmp	 $LN6@GetTextTag
$LN7@GetTextTag:

; 99   :         else if (tag == TEXT_TAG_PLAIN || tag == TEXT_TAG_TAG)

  000c4	83 7d b4 00	 cmp	 DWORD PTR _tag$4[ebp], 0
  000c8	74 06		 je	 SHORT $LN11@GetTextTag
  000ca	83 7d b4 01	 cmp	 DWORD PTR _tag$4[ebp], 1
  000ce	75 61		 jne	 SHORT $LN9@GetTextTag
$LN11@GetTextTag:

; 100  :         {
; 101  :             if (hyperlinkStep == 0)

  000d0	83 7d a8 00	 cmp	 DWORD PTR _hyperlinkStep$[ebp], 0
  000d4	75 59		 jne	 SHORT $LN12@GetTextTag

; 102  : 			{
; 103  : 				if (!color_tag)

  000d6	0f b6 45 bf	 movzx	 eax, BYTE PTR _color_tag$[ebp]
  000da	85 c0		 test	 eax, eax
  000dc	75 06		 jne	 SHORT $LN13@GetTextTag

; 104  : 					internal_offset = i;

  000de	8b 45 b8	 mov	 eax, DWORD PTR _i$5[ebp]
  000e1	89 45 b0	 mov	 DWORD PTR _internal_offset$[ebp], eax
$LN13@GetTextTag:

; 105  : 
; 106  : 				if (offset <= output_len)

  000e4	8b 45 10	 mov	 eax, DWORD PTR _offset$[ebp]
  000e7	3b 45 ac	 cmp	 eax, DWORD PTR _output_len$[ebp]
  000ea	7f 23		 jg	 SHORT $LN14@GetTextTag

; 107  : 					return internal_offset;

  000ec	8b 45 b0	 mov	 eax, DWORD PTR _internal_offset$[ebp]
  000ef	89 45 9c	 mov	 DWORD PTR $T3[ebp], eax
  000f2	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000f6	8d 4d d8	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  000f9	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 107  : 					return internal_offset;

  000fe	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00102	8d 4d c0	 lea	 ecx, DWORD PTR _dst$[ebp]
  00105	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 107  : 					return internal_offset;

  0010a	8b 45 9c	 mov	 eax, DWORD PTR $T3[ebp]
  0010d	eb 6a		 jmp	 SHORT $LN1@GetTextTag
$LN14@GetTextTag:

; 108  : 
; 109  :                 ++output_len;

  0010f	8b 45 ac	 mov	 eax, DWORD PTR _output_len$[ebp]
  00112	40		 inc	 eax
  00113	89 45 ac	 mov	 DWORD PTR _output_len$[ebp], eax

; 110  : 				dst += src[i];

  00116	8b 45 b8	 mov	 eax, DWORD PTR _i$5[ebp]
  00119	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0011c	66 8b 04 41	 mov	 ax, WORD PTR [ecx+eax*2]
  00120	66 89 45 98	 mov	 WORD PTR __Ch$[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2905 :         push_back(_Ch);

  00124	ff 75 98	 push	 DWORD PTR __Ch$[ebp]
  00127	8d 4d c0	 lea	 ecx, DWORD PTR _dst$[ebp]
  0012a	e8 00 00 00 00	 call	 ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
$LN12@GetTextTag:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 112  :         }

  0012f	eb 19		 jmp	 SHORT $LN6@GetTextTag
$LN9@GetTextTag:

; 113  :         else if (tag == TEXT_TAG_HYPERLINK_START)

  00131	83 7d b4 03	 cmp	 DWORD PTR _tag$4[ebp], 3
  00135	75 09		 jne	 SHORT $LN15@GetTextTag

; 114  :             hyperlinkStep = 1;

  00137	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR _hyperlinkStep$[ebp], 1
  0013e	eb 0a		 jmp	 SHORT $LN6@GetTextTag
$LN15@GetTextTag:

; 115  :         else if (tag == TEXT_TAG_HYPERLINK_END)

  00140	83 7d b4 04	 cmp	 DWORD PTR _tag$4[ebp], 4
  00144	75 04		 jne	 SHORT $LN6@GetTextTag

; 116  :             hyperlinkStep = 0;

  00146	83 65 a8 00	 and	 DWORD PTR _hyperlinkStep$[ebp], 0
$LN6@GetTextTag:

; 117  : 
; 118  :         i += len;

  0014a	8b 45 b8	 mov	 eax, DWORD PTR _i$5[ebp]
  0014d	03 45 94	 add	 eax, DWORD PTR _len$[ebp]
  00150	89 45 b8	 mov	 DWORD PTR _i$5[ebp], eax

; 119  :     }

  00153	e9 18 ff ff ff	 jmp	 $LN4@GetTextTag
$LN3@GetTextTag:

; 121  : 	return internal_offset;

  00158	8b 45 b0	 mov	 eax, DWORD PTR _internal_offset$[ebp]
  0015b	89 45 90	 mov	 DWORD PTR $T2[ebp], eax
  0015e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00162	8d 4d d8	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  00165	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 121  : 	return internal_offset;

  0016a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0016e	8d 4d c0	 lea	 ecx, DWORD PTR _dst$[ebp]
  00171	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 121  : 	return internal_offset;

  00176	8b 45 90	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@GetTextTag:

; 122  : }

  00179	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00183	59		 pop	 ecx
  00184	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00187	33 cd		 xor	 ecx, ebp
  00189	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018e	c9		 leave
  0018f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _dst$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z ENDP	; GetTextTagInternalPosFromRenderPos
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
;	COMDAT ?FindColorTagStartPosition@@YAHPB_WH@Z
_TEXT	SEGMENT
_len$1 = -8						; size = 4
_cur$ = -4						; size = 4
_src$ = 8						; size = 4
_src_len$ = 12						; size = 4
?FindColorTagStartPosition@@YAHPB_WH@Z PROC		; FindColorTagStartPosition, COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 152  :     if (src_len < 2)

  00005	83 7d 0c 02	 cmp	 DWORD PTR _src_len$[ebp], 2
  00009	7d 07		 jge	 SHORT $LN4@FindColorT

; 153  :         return 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	e9 a9 00 00 00	 jmp	 $LN1@FindColorT
$LN4@FindColorT:

; 154  : 
; 155  :     const wchar_t * cur = src;

  00012	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00015	89 45 fc	 mov	 DWORD PTR _cur$[ebp], eax

; 156  : 
; 157  :     // |r의 경우
; 158  :     if (*cur == L'r' && *(cur - 1) == L'|')

  00018	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  0001b	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0001e	83 f8 72	 cmp	 eax, 114		; 00000072H
  00021	75 7a		 jne	 SHORT $LN5@FindColorT
  00023	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00026	0f b7 40 fe	 movzx	 eax, WORD PTR [eax-2]
  0002a	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  0002d	75 6e		 jne	 SHORT $LN5@FindColorT

; 159  :     {
; 160  : 	    int len = src_len;

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _src_len$[ebp]
  00032	89 45 f8	 mov	 DWORD PTR _len$1[ebp], eax

; 161  : 
; 162  :         // ||r은 무시
; 163  :         if (len >= 2 && *(cur - 2) == L'|')

  00035	83 7d f8 02	 cmp	 DWORD PTR _len$1[ebp], 2
  00039	7c 11		 jl	 SHORT $LN7@FindColorT
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  0003e	0f b7 40 fc	 movzx	 eax, WORD PTR [eax-4]
  00042	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00045	75 05		 jne	 SHORT $LN7@FindColorT

; 164  :             return 1;

  00047	33 c0		 xor	 eax, eax
  00049	40		 inc	 eax
  0004a	eb 6f		 jmp	 SHORT $LN1@FindColorT
$LN7@FindColorT:

; 165  : 
; 166  :         cur -= 2;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  0004f	83 e8 04	 sub	 eax, 4
  00052	89 45 fc	 mov	 DWORD PTR _cur$[ebp], eax

; 167  :         len -= 2;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _len$1[ebp]
  00058	48		 dec	 eax
  00059	48		 dec	 eax
  0005a	89 45 f8	 mov	 DWORD PTR _len$1[ebp], eax
$LN2@FindColorT:

; 168  : 
; 169  :         // |c까지 찾아서 |위치까지 리턴한다.
; 170  :         while (len > 1) // 최소 2자를 검사해야 된다.

  0005d	83 7d f8 01	 cmp	 DWORD PTR _len$1[ebp], 1
  00061	7e 33		 jle	 SHORT $LN3@FindColorT

; 171  :         {
; 172  :             if (*cur == L'c' && *(cur - 1) == L'|')

  00063	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00066	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00069	83 f8 63	 cmp	 eax, 99			; 00000063H
  0006c	75 17		 jne	 SHORT $LN8@FindColorT
  0006e	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00071	0f b7 40 fe	 movzx	 eax, WORD PTR [eax-2]
  00075	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00078	75 0b		 jne	 SHORT $LN8@FindColorT

; 173  :                 return (src - cur) + 1;

  0007a	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0007d	2b 45 fc	 sub	 eax, DWORD PTR _cur$[ebp]
  00080	d1 f8		 sar	 eax, 1
  00082	40		 inc	 eax
  00083	eb 36		 jmp	 SHORT $LN1@FindColorT
$LN8@FindColorT:

; 174  : 
; 175  :             --cur;

  00085	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00088	48		 dec	 eax
  00089	48		 dec	 eax
  0008a	89 45 fc	 mov	 DWORD PTR _cur$[ebp], eax

; 176  :             --len;

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _len$1[ebp]
  00090	48		 dec	 eax
  00091	89 45 f8	 mov	 DWORD PTR _len$1[ebp], eax

; 177  :         }

  00094	eb c7		 jmp	 SHORT $LN2@FindColorT
$LN3@FindColorT:

; 178  :         return (src_len); // 못찾으면 전부;;

  00096	8b 45 0c	 mov	 eax, DWORD PTR _src_len$[ebp]
  00099	eb 20		 jmp	 SHORT $LN1@FindColorT

; 179  :     }

  0009b	eb 1c		 jmp	 SHORT $LN6@FindColorT
$LN5@FindColorT:

; 180  : 	// ||의 경우
; 181  : 	else if (*cur == L'|' && *(cur - 1) == L'|')

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  000a0	0f b7 00	 movzx	 eax, WORD PTR [eax]
  000a3	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  000a6	75 11		 jne	 SHORT $LN6@FindColorT
  000a8	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  000ab	0f b7 40 fe	 movzx	 eax, WORD PTR [eax-2]
  000af	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  000b2	75 05		 jne	 SHORT $LN6@FindColorT

; 182  : 		return 1;

  000b4	33 c0		 xor	 eax, eax
  000b6	40		 inc	 eax
  000b7	eb 02		 jmp	 SHORT $LN1@FindColorT
$LN6@FindColorT:

; 183  : 
; 184  :     return 0;

  000b9	33 c0		 xor	 eax, eax
$LN1@FindColorT:

; 185  : }

  000bb	c9		 leave
  000bc	c3		 ret	 0
?FindColorTagStartPosition@@YAHPB_WH@Z ENDP		; FindColorTagStartPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
;	COMDAT ?FindColorTagEndPosition@@YAHPB_WH@Z
_TEXT	SEGMENT
_left$1 = -8						; size = 4
_cur$ = -4						; size = 4
_src$ = 8						; size = 4
_src_len$ = 12						; size = 4
?FindColorTagEndPosition@@YAHPB_WH@Z PROC		; FindColorTagEndPosition, COMDAT

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 189  : 	const wchar_t * cur = src;

  00005	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR _cur$[ebp], eax

; 190  : 
; 191  : 	if (src_len >= 4 && *cur == L'|' && *(cur + 1) == L'c')

  0000b	83 7d 0c 04	 cmp	 DWORD PTR _src_len$[ebp], 4
  0000f	7c 63		 jl	 SHORT $LN4@FindColorT
  00011	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00014	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00017	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  0001a	75 58		 jne	 SHORT $LN4@FindColorT
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  0001f	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  00023	83 f8 63	 cmp	 eax, 99			; 00000063H
  00026	75 4c		 jne	 SHORT $LN4@FindColorT

; 192  : 	{
; 193  : 		int left = src_len - 2;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _src_len$[ebp]
  0002b	48		 dec	 eax
  0002c	48		 dec	 eax
  0002d	89 45 f8	 mov	 DWORD PTR _left$1[ebp], eax

; 194  : 		cur += 2;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00033	83 c0 04	 add	 eax, 4
  00036	89 45 fc	 mov	 DWORD PTR _cur$[ebp], eax
$LN2@FindColorT:

; 195  : 
; 196  : 		while (left > 1)

  00039	83 7d f8 01	 cmp	 DWORD PTR _left$1[ebp], 1
  0003d	7e 33		 jle	 SHORT $LN3@FindColorT

; 197  : 		{
; 198  : 			if (*cur == L'|' && *(cur + 1) == L'r')

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00042	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00045	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00048	75 17		 jne	 SHORT $LN6@FindColorT
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  0004d	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  00051	83 f8 72	 cmp	 eax, 114		; 00000072H
  00054	75 0b		 jne	 SHORT $LN6@FindColorT

; 199  : 				return (cur - src) + 1;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00059	2b 45 08	 sub	 eax, DWORD PTR _src$[ebp]
  0005c	d1 f8		 sar	 eax, 1
  0005e	40		 inc	 eax
  0005f	eb 37		 jmp	 SHORT $LN1@FindColorT
$LN6@FindColorT:

; 200  : 
; 201  : 			--left;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _left$1[ebp]
  00064	48		 dec	 eax
  00065	89 45 f8	 mov	 DWORD PTR _left$1[ebp], eax

; 202  : 			++cur;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  0006b	40		 inc	 eax
  0006c	40		 inc	 eax
  0006d	89 45 fc	 mov	 DWORD PTR _cur$[ebp], eax

; 203  : 		}

  00070	eb c7		 jmp	 SHORT $LN2@FindColorT
$LN3@FindColorT:

; 204  : 	}

  00072	eb 22		 jmp	 SHORT $LN5@FindColorT
$LN4@FindColorT:

; 205  : 	else if (src_len >= 2 && *cur == L'|' && *(cur + 1) == L'|')

  00074	83 7d 0c 02	 cmp	 DWORD PTR _src_len$[ebp], 2
  00078	7c 1c		 jl	 SHORT $LN5@FindColorT
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  0007d	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00080	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00083	75 11		 jne	 SHORT $LN5@FindColorT
  00085	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00088	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  0008c	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  0008f	75 05		 jne	 SHORT $LN5@FindColorT

; 206  : 		return 1;

  00091	33 c0		 xor	 eax, eax
  00093	40		 inc	 eax
  00094	eb 02		 jmp	 SHORT $LN1@FindColorT
$LN5@FindColorT:

; 207  : 
; 208  : 	return 0;

  00096	33 c0		 xor	 eax, eax
$LN1@FindColorT:

; 209  : }

  00098	c9		 leave
  00099	c3		 ret	 0
?FindColorTagEndPosition@@YAHPB_WH@Z ENDP		; FindColorTagEndPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
;	COMDAT ?GetTextTagOutputLen@@YAHPB_WH@Z
_TEXT	SEGMENT
$T2 = -64						; size = 4
_len$ = -60						; size = 4
_output_len$ = -56					; size = 4
_hyperlinkStep$ = -52					; size = 4
_tag$3 = -48						; size = 4
_i$4 = -44						; size = 4
_extraInfo$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_src$ = 8						; size = 4
_src_len$ = 12						; size = 4
?GetTextTagOutputLen@@YAHPB_WH@Z PROC			; GetTextTagOutputLen, COMDAT

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetTextTagOutputLen@@YAHPB_WH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 126  :     int len;
; 127  :     std::wstring extraInfo;

  00028	8d 4d d8	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 128  :     int output_len = 0;

  00034	83 65 c8 00	 and	 DWORD PTR _output_len$[ebp], 0

; 129  :     int hyperlinkStep = 0;

  00038	83 65 cc 00	 and	 DWORD PTR _hyperlinkStep$[ebp], 0

; 130  : 
; 131  :     for (int i = 0; i < src_len; )

  0003c	83 65 d4 00	 and	 DWORD PTR _i$4[ebp], 0
$LN4@GetTextTag:
  00040	8b 45 d4	 mov	 eax, DWORD PTR _i$4[ebp]
  00043	3b 45 0c	 cmp	 eax, DWORD PTR _src_len$[ebp]
  00046	7d 63		 jge	 SHORT $LN3@GetTextTag

; 132  :     {
; 133  :         int tag = GetTextTag(&src[i], src_len - i, len, extraInfo);

  00048	8d 45 d8	 lea	 eax, DWORD PTR _extraInfo$[ebp]
  0004b	50		 push	 eax
  0004c	8d 45 c4	 lea	 eax, DWORD PTR _len$[ebp]
  0004f	50		 push	 eax
  00050	8b 45 0c	 mov	 eax, DWORD PTR _src_len$[ebp]
  00053	2b 45 d4	 sub	 eax, DWORD PTR _i$4[ebp]
  00056	50		 push	 eax
  00057	8b 45 d4	 mov	 eax, DWORD PTR _i$4[ebp]
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _src$[ebp]
  0005d	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
  00066	83 c4 10	 add	 esp, 16			; 00000010H
  00069	89 45 d0	 mov	 DWORD PTR _tag$3[ebp], eax

; 134  : 
; 135  :         if (tag == TEXT_TAG_PLAIN || tag == TEXT_TAG_TAG)

  0006c	83 7d d0 00	 cmp	 DWORD PTR _tag$3[ebp], 0
  00070	74 06		 je	 SHORT $LN7@GetTextTag
  00072	83 7d d0 01	 cmp	 DWORD PTR _tag$3[ebp], 1
  00076	75 0f		 jne	 SHORT $LN5@GetTextTag
$LN7@GetTextTag:

; 136  :         {
; 137  :             if (hyperlinkStep == 0)

  00078	83 7d cc 00	 cmp	 DWORD PTR _hyperlinkStep$[ebp], 0
  0007c	75 07		 jne	 SHORT $LN8@GetTextTag

; 138  :                 ++output_len;

  0007e	8b 45 c8	 mov	 eax, DWORD PTR _output_len$[ebp]
  00081	40		 inc	 eax
  00082	89 45 c8	 mov	 DWORD PTR _output_len$[ebp], eax
$LN8@GetTextTag:

; 139  :         }

  00085	eb 19		 jmp	 SHORT $LN6@GetTextTag
$LN5@GetTextTag:

; 140  :         else if (tag == TEXT_TAG_HYPERLINK_START)

  00087	83 7d d0 03	 cmp	 DWORD PTR _tag$3[ebp], 3
  0008b	75 09		 jne	 SHORT $LN9@GetTextTag

; 141  :             hyperlinkStep = 1;

  0008d	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _hyperlinkStep$[ebp], 1
  00094	eb 0a		 jmp	 SHORT $LN6@GetTextTag
$LN9@GetTextTag:

; 142  :         else if (tag == TEXT_TAG_HYPERLINK_END)

  00096	83 7d d0 04	 cmp	 DWORD PTR _tag$3[ebp], 4
  0009a	75 04		 jne	 SHORT $LN6@GetTextTag

; 143  :             hyperlinkStep = 0;

  0009c	83 65 cc 00	 and	 DWORD PTR _hyperlinkStep$[ebp], 0
$LN6@GetTextTag:

; 144  : 
; 145  :         i += len;

  000a0	8b 45 d4	 mov	 eax, DWORD PTR _i$4[ebp]
  000a3	03 45 c4	 add	 eax, DWORD PTR _len$[ebp]
  000a6	89 45 d4	 mov	 DWORD PTR _i$4[ebp], eax

; 146  :     }

  000a9	eb 95		 jmp	 SHORT $LN4@GetTextTag
$LN3@GetTextTag:

; 147  :     return output_len;

  000ab	8b 45 c8	 mov	 eax, DWORD PTR _output_len$[ebp]
  000ae	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
  000b1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000b5	8d 4d d8	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 147  :     return output_len;

  000bd	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]

; 148  : }

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ce	33 cd		 xor	 ecx, ebp
  000d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d5	c9		 leave
  000d6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTextTagOutputLen@@YAHPB_WH@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?GetTextTagOutputLen@@YAHPB_WH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetTextTagOutputLen@@YAHPB_WH@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetTextTagOutputLen@@YAHPB_WH@Z ENDP			; GetTextTagOutputLen
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
;	COMDAT ?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z
_TEXT	SEGMENT
_len$ = -100						; size = 4
__Ch$ = -96						; size = 2
_this$ = -92						; size = 4
_this$ = -88						; size = 4
$T2 = -84						; size = 4
_output_len$ = -80					; size = 4
_hyperlinkStep$ = -76					; size = 4
_tag$3 = -72						; size = 4
_i$4 = -68						; size = 4
_extraInfo$ = -64					; size = 24
_dst$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_src$ = 12						; size = 4
_src_len$ = 16						; size = 4
?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z PROC ; GetTextTagOutputString, COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	83 65 ac 00	 and	 DWORD PTR $T2[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0002c	8d 45 d8	 lea	 eax, DWORD PTR _dst$[ebp]
  0002f	89 45 a8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00032	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  0003a	8d 4d d8	 lea	 ecx, DWORD PTR _dst$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 49   : 	std::wstring dst;

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00046	8d 45 c0	 lea	 eax, DWORD PTR _extraInfo$[ebp]
  00049	89 45 a4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004c	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  00054	8d 4d c0	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 50   : 	std::wstring extraInfo;

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 51   :     int output_len = 0;

  00060	83 65 b0 00	 and	 DWORD PTR _output_len$[ebp], 0

; 52   :     int hyperlinkStep = 0;

  00064	83 65 b4 00	 and	 DWORD PTR _hyperlinkStep$[ebp], 0

; 53   : 
; 54   :     for (int i = 0; i < src_len; )

  00068	83 65 bc 00	 and	 DWORD PTR _i$4[ebp], 0
$LN4@GetTextTag:
  0006c	8b 45 bc	 mov	 eax, DWORD PTR _i$4[ebp]
  0006f	3b 45 10	 cmp	 eax, DWORD PTR _src_len$[ebp]
  00072	7d 7f		 jge	 SHORT $LN3@GetTextTag

; 55   :     {
; 56   :         int tag = GetTextTag(&src[i], src_len - i, len, extraInfo);

  00074	8d 45 c0	 lea	 eax, DWORD PTR _extraInfo$[ebp]
  00077	50		 push	 eax
  00078	8d 45 9c	 lea	 eax, DWORD PTR _len$[ebp]
  0007b	50		 push	 eax
  0007c	8b 45 10	 mov	 eax, DWORD PTR _src_len$[ebp]
  0007f	2b 45 bc	 sub	 eax, DWORD PTR _i$4[ebp]
  00082	50		 push	 eax
  00083	8b 45 bc	 mov	 eax, DWORD PTR _i$4[ebp]
  00086	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00089	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
  00092	83 c4 10	 add	 esp, 16			; 00000010H
  00095	89 45 b8	 mov	 DWORD PTR _tag$3[ebp], eax

; 57   : 
; 58   :         if (tag == TEXT_TAG_PLAIN || tag == TEXT_TAG_TAG)

  00098	83 7d b8 00	 cmp	 DWORD PTR _tag$3[ebp], 0
  0009c	74 06		 je	 SHORT $LN7@GetTextTag
  0009e	83 7d b8 01	 cmp	 DWORD PTR _tag$3[ebp], 1
  000a2	75 28		 jne	 SHORT $LN5@GetTextTag
$LN7@GetTextTag:

; 59   :         {
; 60   :             if (hyperlinkStep == 0)

  000a4	83 7d b4 00	 cmp	 DWORD PTR _hyperlinkStep$[ebp], 0
  000a8	75 20		 jne	 SHORT $LN8@GetTextTag

; 61   : 			{
; 62   :                 ++output_len;

  000aa	8b 45 b0	 mov	 eax, DWORD PTR _output_len$[ebp]
  000ad	40		 inc	 eax
  000ae	89 45 b0	 mov	 DWORD PTR _output_len$[ebp], eax

; 63   : 				dst += src[i];

  000b1	8b 45 bc	 mov	 eax, DWORD PTR _i$4[ebp]
  000b4	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  000b7	66 8b 04 41	 mov	 ax, WORD PTR [ecx+eax*2]
  000bb	66 89 45 a0	 mov	 WORD PTR __Ch$[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2905 :         push_back(_Ch);

  000bf	ff 75 a0	 push	 DWORD PTR __Ch$[ebp]
  000c2	8d 4d d8	 lea	 ecx, DWORD PTR _dst$[ebp]
  000c5	e8 00 00 00 00	 call	 ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
$LN8@GetTextTag:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 65   :         }

  000ca	eb 19		 jmp	 SHORT $LN6@GetTextTag
$LN5@GetTextTag:

; 66   :         else if (tag == TEXT_TAG_HYPERLINK_START)

  000cc	83 7d b8 03	 cmp	 DWORD PTR _tag$3[ebp], 3
  000d0	75 09		 jne	 SHORT $LN9@GetTextTag

; 67   :             hyperlinkStep = 1;

  000d2	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _hyperlinkStep$[ebp], 1
  000d9	eb 0a		 jmp	 SHORT $LN6@GetTextTag
$LN9@GetTextTag:

; 68   :         else if (tag == TEXT_TAG_HYPERLINK_END)

  000db	83 7d b8 04	 cmp	 DWORD PTR _tag$3[ebp], 4
  000df	75 04		 jne	 SHORT $LN6@GetTextTag

; 69   :             hyperlinkStep = 0;

  000e1	83 65 b4 00	 and	 DWORD PTR _hyperlinkStep$[ebp], 0
$LN6@GetTextTag:

; 70   : 
; 71   :         i += len;

  000e5	8b 45 bc	 mov	 eax, DWORD PTR _i$4[ebp]
  000e8	03 45 9c	 add	 eax, DWORD PTR _len$[ebp]
  000eb	89 45 bc	 mov	 DWORD PTR _i$4[ebp], eax

; 72   :     }

  000ee	e9 79 ff ff ff	 jmp	 $LN4@GetTextTag
$LN3@GetTextTag:

; 73   : 	return dst;

  000f3	8d 45 d8	 lea	 eax, DWORD PTR _dst$[ebp]
  000f6	50		 push	 eax
  000f7	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000fa	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  000ff	8b 45 ac	 mov	 eax, DWORD PTR $T2[ebp]
  00102	83 c8 01	 or	 eax, 1
  00105	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax
  00108	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0010c	8d 4d c0	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  0010f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 73   : 	return dst;

  00114	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00118	8d 4d d8	 lea	 ecx, DWORD PTR _dst$[ebp]
  0011b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp

; 73   : 	return dst;

  00120	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 74   : }

  00123	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00126	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012d	59		 pop	 ecx
  0012e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00131	33 cd		 xor	 ecx, ebp
  00133	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00138	c9		 leave
  00139	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _dst$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z ENDP ; GetTextTagOutputString
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\TextTag.cpp
;	COMDAT ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_cur$ = -4						; size = 4
_src$ = 8						; size = 4
_maxLen$ = 12						; size = 4
_tagLen$ = 16						; size = 4
_extraInfo$ = 20					; size = 4
?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; GetTextTag, COMDAT

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6    :     tagLen = 1;

  00004	8b 45 10	 mov	 eax, DWORD PTR _tagLen$[ebp]
  00007	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 7    : 
; 8    :     if (maxLen < 2 || *src != L'|')

  0000d	83 7d 0c 02	 cmp	 DWORD PTR _maxLen$[ebp], 2
  00011	7c 0b		 jl	 SHORT $LN3@GetTextTag
  00013	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00016	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00019	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  0001c	74 07		 je	 SHORT $LN2@GetTextTag
$LN3@GetTextTag:

; 9    :         return TEXT_TAG_PLAIN;

  0001e	33 c0		 xor	 eax, eax
  00020	e9 b7 00 00 00	 jmp	 $LN1@GetTextTag
$LN2@GetTextTag:

; 10   : 
; 11   :     const wchar_t * cur = ++src;

  00025	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00028	40		 inc	 eax
  00029	40		 inc	 eax
  0002a	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
  0002d	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00030	89 45 fc	 mov	 DWORD PTR _cur$[ebp], eax

; 12   : 
; 13   :     if (*cur == L'c') // color

  00033	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00036	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00039	83 f8 63	 cmp	 eax, 99			; 00000063H
  0003c	75 32		 jne	 SHORT $LN4@GetTextTag

; 14   :     {
; 15   :         if (maxLen < 10)

  0003e	83 7d 0c 0a	 cmp	 DWORD PTR _maxLen$[ebp], 10 ; 0000000aH
  00042	7d 07		 jge	 SHORT $LN6@GetTextTag

; 16   :             return TEXT_TAG_PLAIN;

  00044	33 c0		 xor	 eax, eax
  00046	e9 91 00 00 00	 jmp	 $LN1@GetTextTag
$LN6@GetTextTag:

; 17   : 
; 18   :         tagLen = 10;

  0004b	8b 45 10	 mov	 eax, DWORD PTR _tagLen$[ebp]
  0004e	c7 00 0a 00 00
	00		 mov	 DWORD PTR [eax], 10	; 0000000aH

; 19   :         extraInfo.assign(++cur, 8);

  00054	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00057	40		 inc	 eax
  00058	40		 inc	 eax
  00059	89 45 fc	 mov	 DWORD PTR _cur$[ebp], eax
  0005c	6a 08		 push	 8
  0005e	ff 75 fc	 push	 DWORD PTR _cur$[ebp]
  00061	8b 4d 14	 mov	 ecx, DWORD PTR _extraInfo$[ebp]
  00064	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 20   :         return TEXT_TAG_COLOR;

  00069	6a 02		 push	 2
  0006b	58		 pop	 eax
  0006c	eb 6e		 jmp	 SHORT $LN1@GetTextTag

; 21   :     }

  0006e	eb 6a		 jmp	 SHORT $LN5@GetTextTag
$LN4@GetTextTag:

; 22   :     else if (*cur == L'|') // ||는 |로 표시한다.

  00070	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00073	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00076	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00079	75 10		 jne	 SHORT $LN7@GetTextTag

; 23   :     {
; 24   :         tagLen = 2;

  0007b	8b 45 10	 mov	 eax, DWORD PTR _tagLen$[ebp]
  0007e	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 25   :         return TEXT_TAG_TAG;

  00084	33 c0		 xor	 eax, eax
  00086	40		 inc	 eax
  00087	eb 53		 jmp	 SHORT $LN1@GetTextTag

; 26   :     }

  00089	eb 4f		 jmp	 SHORT $LN5@GetTextTag
$LN7@GetTextTag:

; 27   :     else if (*cur == L'r') // restore color

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  0008e	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00091	83 f8 72	 cmp	 eax, 114		; 00000072H
  00094	75 10		 jne	 SHORT $LN9@GetTextTag

; 28   :     {
; 29   :         tagLen = 2;

  00096	8b 45 10	 mov	 eax, DWORD PTR _tagLen$[ebp]
  00099	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 30   :         return TEXT_TAG_RESTORE_COLOR;

  0009f	6a 05		 push	 5
  000a1	58		 pop	 eax
  000a2	eb 38		 jmp	 SHORT $LN1@GetTextTag

; 31   :     }

  000a4	eb 34		 jmp	 SHORT $LN5@GetTextTag
$LN9@GetTextTag:

; 32   :     else if (*cur == L'H') // hyperlink |Hitem:10000:0:0:0:0|h[이름]|h

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  000a9	0f b7 00	 movzx	 eax, WORD PTR [eax]
  000ac	83 f8 48	 cmp	 eax, 72			; 00000048H
  000af	75 10		 jne	 SHORT $LN11@GetTextTag

; 33   :     {
; 34   :         tagLen = 2;

  000b1	8b 45 10	 mov	 eax, DWORD PTR _tagLen$[ebp]
  000b4	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 35   :         return TEXT_TAG_HYPERLINK_START;

  000ba	6a 03		 push	 3
  000bc	58		 pop	 eax
  000bd	eb 1d		 jmp	 SHORT $LN1@GetTextTag

; 36   :     }

  000bf	eb 19		 jmp	 SHORT $LN5@GetTextTag
$LN11@GetTextTag:

; 37   :     else if (*cur == L'h') // end of hyperlink

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  000c4	0f b7 00	 movzx	 eax, WORD PTR [eax]
  000c7	83 f8 68	 cmp	 eax, 104		; 00000068H
  000ca	75 0e		 jne	 SHORT $LN5@GetTextTag

; 38   :     {
; 39   :         tagLen = 2;

  000cc	8b 45 10	 mov	 eax, DWORD PTR _tagLen$[ebp]
  000cf	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 40   :         return TEXT_TAG_HYPERLINK_END;

  000d5	6a 04		 push	 4
  000d7	58		 pop	 eax
  000d8	eb 02		 jmp	 SHORT $LN1@GetTextTag
$LN5@GetTextTag:

; 41   :     }
; 42   : 
; 43   :     return TEXT_TAG_PLAIN;

  000da	33 c0		 xor	 eax, eax
$LN1@GetTextTag:

; 44   : }

  000dc	c9		 leave
  000dd	c3		 ret	 0
?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; GetTextTag
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z
_TEXT	SEGMENT
__Max_possible$1 = -56					; size = 4
__Al$ = -52						; size = 4
__Ptr$ = -48						; size = 4
__Ptr$ = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
__Old_capacity$ = -28					; size = 4
$T5 = -24						; size = 4
__New_capacity$ = -20					; size = 4
__Count$ = -16						; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
$T6 = -4						; size = 2
__Overflow_is_possible$7 = -1				; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e4	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
  0002f	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  0003b	89 45 cc	 mov	 DWORD PTR __Al$[ebp], eax

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0003e	8b 45 ec	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00041	40		 inc	 eax
  00042	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00045	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$7[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00049	c7 45 c8 ff ff
	ff 7f		 mov	 DWORD PTR __Max_possible$1[ebp], 2147483647 ; 7fffffffH

; 60   :         if (_Count > _Max_possible) {

  00050	81 7d f0 ff ff
	ff 7f		 cmp	 DWORD PTR __Count$[ebp], 2147483647 ; 7fffffffH
  00057	76 05		 jbe	 SHORT $LN78@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00059	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN78@Reallocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00061	d1 e0		 shl	 eax, 1
  00063	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00066	ff 75 dc	 push	 DWORD PTR $T3[ebp]
  00069	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0006e	59		 pop	 ecx
  0006f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00072	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00075	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00078	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007e	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 4d ec	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00087	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  0008a	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008d	89 45 d4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00090	8b 45 d4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00093	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00096	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00099	d1 e0		 shl	 eax, 1
  0009b	50		 push	 eax
  0009c	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  0009f	ff 75 e8	 push	 DWORD PTR $T5[ebp]
  000a2	e8 00 00 00 00	 call	 _memcpy
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000aa	33 c0		 xor	 eax, eax
  000ac	66 89 45 fc	 mov	 WORD PTR $T6[ebp], ax

; 281  :         _Left = _Right;

  000b0	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  000b3	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp]
  000b6	66 8b 55 fc	 mov	 dx, WORD PTR $T6[ebp]
  000ba	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  000be	83 7d e4 08	 cmp	 DWORD PTR __Old_capacity$[ebp], 8
  000c2	72 24		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	8b 00		 mov	 eax, DWORD PTR [eax]
  000c9	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000cc	8b 45 e4	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000cf	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  000d3	50		 push	 eax
  000d4	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  000d7	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000dc	59		 pop	 ecx
  000dd	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000de	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000e4	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000e6	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000e8	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000eb	50		 push	 eax
  000ec	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000ef	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  000f4	59		 pop	 ecx
  000f5	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN81@Reallocate:

; 4325 :     }

  000f9	c9		 leave
  000fa	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z PROC		; std::_Destroy_in_place<wchar_t *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ENDP		; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -4						; size = 2
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 37		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ; std::_Destroy_in_place<wchar_t *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	8b 45 ec	 mov	 eax, DWORD PTR __Count$[ebp]
  00057	d1 e0		 shl	 eax, 1
  00059	50		 push	 eax
  0005a	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00062	59		 pop	 ecx
  00063	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00075	33 c0		 xor	 eax, eax
  00077	66 89 45 fc	 mov	 WORD PTR $T4[ebp], ax
  0007b	6a 02		 push	 2
  0007d	58		 pop	 eax
  0007e	6b c0 00	 imul	 eax, eax, 0

; 281  :         _Left = _Right;

  00081	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	66 8b 55 fc	 mov	 dx, WORD PTR $T4[ebp]
  00088	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx

; 4396 :     }

  0008c	c9		 leave
  0008d	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 2
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	33 c0		 xor	 eax, eax
  0001b	66 89 45 fe	 mov	 WORD PTR $T1[ebp], ax
  0001f	6a 02		 push	 2
  00021	58		 pop	 eax
  00022	6b c0 00	 imul	 eax, eax, 0

; 281  :         _Left = _Right;

  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	66 8b 55 fe	 mov	 dx, WORD PTR $T1[ebp]
  0002c	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx

; 4381 :     }

  00030	c9		 leave
  00031	c3		 ret	 0
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 07	 or	 eax, 7
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv75 = -12						; size = 4
$T3 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 4284 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 07	 or	 eax, 7
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  00012	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4287 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 46		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0001f	d1 e8		 shr	 eax, 1
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4291 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 32		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003e	3b 45 f8	 cmp	 eax, DWORD PTR $T3[ebp]
  00041	73 08		 jae	 SHORT $LN7@Calculate_
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00046	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00049	eb 06		 jmp	 SHORT $LN8@Calculate_
$LN7@Calculate_:
  0004b	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  0004e	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
$LN8@Calculate_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00057	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4295 :     }

  00062	c9		 leave
  00063	c3		 ret	 0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR __Alloc_max$[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  0001c	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR $T10[ebp], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00023	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00026	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00029	73 08		 jae	 SHORT $LN14@max_size
  0002b	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002e	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  00031	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00033	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00036	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00039	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  0003c	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003f	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  00042	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00045	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004d	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  00050	48		 dec	 eax
  00051	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00054	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0005b	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005e	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00061	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00064	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00067	73 08		 jae	 SHORT $LN22@max_size
  00069	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  0006c	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006f	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  00071	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00074	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00077	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  0007a	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007d	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  00080	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00083	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00086	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00088	c9		 leave
  00089	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z
_TEXT	SEGMENT
$T1 = -20						; size = 1
__Ptr$2 = -16						; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -2						; size = 2
__Ch$ = 8						; size = 2
?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back, COMDAT
; _this$ = ecx

; 3691 :     void push_back(const _Elem _Ch) { // insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3692 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 3693 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00018	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  0001b	73 3a		 jae	 SHORT $LN2@push_back

; 3694 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0001d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00020	40		 inc	 eax
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 3695 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  0002f	89 45 f0	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 281  :         _Left = _Right;

  00032	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00035	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$2[ebp]
  00038	66 8b 55 08	 mov	 dx, WORD PTR __Ch$[ebp]
  0003c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 3696 :             _Traits::assign(_Ptr[_Old_size], _Ch);
; 3697 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  00040	33 c0		 xor	 eax, eax
  00042	66 89 45 fe	 mov	 WORD PTR $T3[ebp], ax

; 281  :         _Left = _Right;

  00046	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00049	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$2[ebp]
  0004c	66 8b 55 fe	 mov	 dx, WORD PTR $T3[ebp]
  00050	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 3698 :             return;

  00055	eb 15		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 3699 :         }
; 3700 : 
; 3701 :         _Reallocate_grow_by(

  00057	33 c0		 xor	 eax, eax
  00059	88 45 ec	 mov	 BYTE PTR $T1[ebp], al
  0005c	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0005f	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00062	6a 01		 push	 1
  00064	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
$LN1@push_back:

; 3702 :             1,
; 3703 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 3704 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3705 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 3706 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 3707 :             },
; 3708 :             _Ch);
; 3709 :     }

  0006c	c9		 leave
  0006d	c2 04 00	 ret	 4
?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -2						; size = 2
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 41		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	d1 e0		 shl	 eax, 1
  0002d	50		 push	 eax
  0002e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00031	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00034	e8 00 00 00 00	 call	 _memmove
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0003c	33 c0		 xor	 eax, eax
  0003e	66 89 45 fe	 mov	 WORD PTR $T3[ebp], ax

; 281  :         _Left = _Right;

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00045	8b 4d f4	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  00048	66 8b 55 fe	 mov	 dx, WORD PTR $T3[ebp]
  0004c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 3049 :             return *this;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  00055	33 c0		 xor	 eax, eax
  00057	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  0005a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0005d	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00060	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  0006b	c9		 leave
  0006c	c2 08 00	 ret	 8
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
__My_data_mem$2 = -36					; size = 4
__Right_data_mem$3 = -32				; size = 4
_this$ = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T6 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4409 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00015	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00035	33 c0		 xor	 eax, eax
  00037	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
  0003a	8a 45 ff	 mov	 al, BYTE PTR $T6[ebp]
  0003d	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00040	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 dc	 mov	 DWORD PTR __My_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00046	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00049	89 45 e0	 mov	 DWORD PTR __Right_data_mem$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004c	6a 18		 push	 24			; 00000018H
  0004e	ff 75 e0	 push	 DWORD PTR __Right_data_mem$3[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __My_data_mem$2[ebp]
  00054	e8 00 00 00 00	 call	 _memcpy
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init

; 2499 :     }

  00064	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c9		 leave
  00068	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 14 00	 and	 DWORD PTR [eax+20], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c9		 leave
  00019	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
