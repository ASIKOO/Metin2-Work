; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; script::SArgumet::SArgumet
PUBLIC	??0SArgumet@script@@QAE@ABU01@@Z		; script::SArgumet::SArgumet
PUBLIC	??4SArgumet@script@@QAEXABU01@@Z		; script::SArgumet::operator=
PUBLIC	??1SArgumet@script@@QAE@XZ			; script::SArgumet::~SArgumet
PUBLIC	??_GSArgumet@script@@QAEPAXI@Z			; script::SArgumet::`scalar deleting destructor'
PUBLIC	??0?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::list<script::SArgumet,std::allocator<script::SArgumet> >
PUBLIC	??1?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::~list<script::SArgumet,std::allocator<script::SArgumet> >
PUBLIC	?_Copy_assign@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Copy_assign
PUBLIC	?_Unchecked_erase@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@QAU32@@Z ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Unchecked_erase
PUBLIC	?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::clear
PUBLIC	?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Alloc_sentinel_and_proxy
PUBLIC	??0SCmd@script@@QAE@ABU01@@Z			; script::SCmd::SCmd
PUBLIC	??4SCmd@script@@QAEXABU01@@Z			; script::SCmd::operator=
PUBLIC	??1SCmd@script@@QAE@XZ				; script::SCmd::~SCmd
PUBLIC	??_GSCmd@script@@QAEPAXI@Z			; script::SCmd::`scalar deleting destructor'
PUBLIC	??0Group@script@@QAE@XZ				; script::Group::Group
PUBLIC	??1Group@script@@QAE@XZ				; script::Group::~Group
PUBLIC	?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; script::Group::Create
PUBLIC	?GetCmd@Group@script@@QAE_NAAUSCmd@2@@Z		; script::Group::GetCmd
PUBLIC	?ReadCmd@Group@script@@QAE_NAAUSCmd@2@@Z	; script::Group::ReadCmd
PUBLIC	?GetError@Group@script@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; script::Group::GetError
PUBLIC	?SetError@Group@script@@AAEXPBD@Z		; script::Group::SetError
PUBLIC	?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; script::Group::GetArg
PUBLIC	??0?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAE@XZ ; std::list<script::SCmd,std::allocator<script::SCmd> >::list<script::SCmd,std::allocator<script::SCmd> >
PUBLIC	?_Unchecked_erase@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEPAU?$_List_node@USCmd@script@@PAX@2@QAU32@@Z ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Unchecked_erase
PUBLIC	?clear@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAEXXZ ; std::list<script::SCmd,std::allocator<script::SCmd> >::clear
PUBLIC	?_Tidy@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEXXZ ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEXXZ ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Alloc_sentinel_and_proxy
PUBLIC	?LocaleString_FindChar@@YAPBDPBDHD@Z		; LocaleString_FindChar
PUBLIC	?LocaleString_RightTrim@@YAHPADH@Z		; LocaleString_RightTrim
PUBLIC	?LocaleString_RightTrim@@YAXPAD@Z		; LocaleString_RightTrim
PUBLIC	?OLD_rtrim@@YAXPAD@Z				; OLD_rtrim
PUBLIC	?LocaleString_Skip@@YAPBDKPBD@Z			; LocaleString_Skip
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SCmd,void *>::_Free_non_head<std::allocator<std::_List_node<script::SCmd,void *> > >
PUBLIC	??$_Emplace@ABUSCmd@script@@@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAEPAU?$_List_node@USCmd@script@@PAX@1@QAU21@ABUSCmd@script@@@Z ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Emplace<script::SCmd const &>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SArgumet,void *>::_Free_non_head<std::allocator<std::_List_node<script::SArgumet,void *> > >
PUBLIC	??$_Emplace@USArgumet@script@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@QAU21@$$QAUSArgumet@script@@@Z ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Emplace<script::SArgumet>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<script::SCmd,void *> *,std::_List_node<script::SCmd,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SCmd,void *>::_Freenode0<std::allocator<std::_List_node<script::SCmd,void *> > >
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SArgumet,void *>::_Freenode0<std::allocator<std::_List_node<script::SArgumet,void *> > >
PUBLIC	??$_Pocca@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@YAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@0@ABV10@@Z ; std::_Pocca<std::allocator<std::_List_node<script::SArgumet,void *> > >
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USCmd@script@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >::_Transfer_before
PUBLIC	??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > ><script::SCmd const &>
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Transfer_before
PUBLIC	??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > ><script::SArgumet>
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<script::SCmd,void *> *>
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<script::SArgumet,void *> *>
PUBLIC	??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Assign_cast<script::SArgumet &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0> >
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * const &>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<script::SCmd,void *> *,std::_List_node<script::SCmd,void *> * const &>
PUBLIC	??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >
PUBLIC	??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Append_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0> >
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@PAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@$$QAPAU10@@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> *>
PUBLIC	??$_Attach_before@U?$_List_simple_types@USArgumet@script@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@AAV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@QAU21@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Attach_before<std::_List_simple_types<script::SArgumet> >
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_C@_0CI@BGFMKJOI@Infinite?5loop?5in?5LocaleString_S@ ; `string'
PUBLIC	??_C@_0DJ@OGJKDJPN@argument?5value?5overflow?3?5must?5b@ ; `string'
PUBLIC	??_C@_0DI@HBCKLDEP@argument?5name?5overflow?3?5must?5be@ ; `string'
PUBLIC	??_C@_0BB@DGGADPCI@no?5argument?5name@		; `string'
PUBLIC	??_C@_0BL@LOKOGIPA@Source?5file?5has?5no?5content@ ; `string'
PUBLIC	??_C@_06MJINCFFA@LETTER@			; `string'
PUBLIC	??_C@_05MFEJDJP@value@				; `string'
PUBLIC	??_C@_0CH@IJJEPPJM@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Syntax?5Erro@ ; `string'
PUBLIC	??_C@_0CO@FGKIOAND@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Buffer?5Over@ ; `string'
PUBLIC	??_C@_0DA@GPNGJHKH@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Unknown?5Arg@ ; `string'
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_isspace:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__CharNextExA@12:PROC
EXTRN	__imp__CharPrevExA@16:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	?GetDefaultCodePage@@YAKXZ:PROC			; GetDefaultCodePage
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?stLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4V45@A
_BSS	SEGMENT
?stLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4V45@A DB 018H DUP (?) ; `script::Group::Create'::`2'::stLetter
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 01H DUP (?) ; `script::Group::Create'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GPNGJHKH@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Unknown?5Arg@
CONST	SEGMENT
??_C@_0DA@GPNGJHKH@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Unknown?5Arg@ DB ' !! '
	DB	'PARSING ERROR - Unknown Arguments : %d, %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FGKIOAND@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Buffer?5Over@
CONST	SEGMENT
??_C@_0CO@FGKIOAND@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Buffer?5Over@ DB ' !! '
	DB	'PARSING ERROR - Buffer Overflow : %d, %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IJJEPPJM@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Syntax?5Erro@
CONST	SEGMENT
??_C@_0CH@IJJEPPJM@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Syntax?5Erro@ DB ' !! '
	DB	'PARSING ERROR - Syntax Error : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFEJDJP@value@
CONST	SEGMENT
??_C@_05MFEJDJP@value@ DB 'value', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJINCFFA@LETTER@
CONST	SEGMENT
??_C@_06MJINCFFA@LETTER@ DB 'LETTER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LOKOGIPA@Source?5file?5has?5no?5content@
CONST	SEGMENT
??_C@_0BL@LOKOGIPA@Source?5file?5has?5no?5content@ DB 'Source file has no'
	DB	' content', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DGGADPCI@no?5argument?5name@
CONST	SEGMENT
??_C@_0BB@DGGADPCI@no?5argument?5name@ DB 'no argument name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HBCKLDEP@argument?5name?5overflow?3?5must?5be@
CONST	SEGMENT
??_C@_0DI@HBCKLDEP@argument?5name?5overflow?3?5must?5be@ DB 'argument nam'
	DB	'e overflow: must be shorter than 32 letters', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@OGJKDJPN@argument?5value?5overflow?3?5must?5b@
CONST	SEGMENT
??_C@_0DJ@OGJKDJPN@argument?5value?5overflow?3?5must?5b@ DB 'argument val'
	DB	'ue overflow: must be shorter than 64 letters', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BGFMKJOI@Infinite?5loop?5in?5LocaleString_S@
CONST	SEGMENT
??_C@_0CI@BGFMKJOI@Infinite?5loop?5in?5LocaleString_S@ DB 'Infinite loop '
	DB	'in LocaleString_Skip [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z$0
__ehfuncinfo$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z$0
__ehfuncinfo$??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z$0
__ehfuncinfo$??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z$0
__ehfuncinfo$??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Group@script@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Group@script@@QAE@XZ$0
__ehfuncinfo$??0Group@script@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Group@script@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SCmd@script@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SCmd@script@@QAE@ABU01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SCmd@script@@QAE@ABU01@@Z$1
__ehfuncinfo$??0SCmd@script@@QAE@ABU01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SCmd@script@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SArgumet@script@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SArgumet@script@@QAE@ABU01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SArgumet@script@@QAE@ABU01@@Z$1
__ehfuncinfo$??0SArgumet@script@@QAE@ABU01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SArgumet@script@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$1
__ehfuncinfo$??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Attach_before@U?$_List_simple_types@USArgumet@script@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@AAV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@QAU21@@Z
_TEXT	SEGMENT
__Local_added$ = -20					; size = 4
__Local_tail$ = -16					; size = 4
__Insert_after$ = -12					; size = 4
__Local_head$ = -8					; size = 4
_this$ = -4						; size = 4
__List_data$ = 8					; size = 4
__Insert_before$ = 12					; size = 4
??$_Attach_before@U?$_List_simple_types@USArgumet@script@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@AAV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@QAU21@@Z PROC ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Attach_before<std::_List_simple_types<script::SArgumet> >, COMDAT
; _this$ = ecx

; 684  :     pointer _Attach_before(_List_val<_Val_types>& _List_data, const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 685  :         // Attach the elements in *this before _Insert_before.
; 686  :         // If *this is empty, returns _Insert_before; otherwise returns a pointer to the first inserted list node.
; 687  :         // Resets *this to the default-initialized state.
; 688  : 
; 689  :         const auto _Local_added = _Added;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 ec	 mov	 DWORD PTR __Local_added$[ebp], eax

; 690  :         if (_Local_added == 0) {

  00012	83 7d ec 00	 cmp	 DWORD PTR __Local_added$[ebp], 0
  00016	75 05		 jne	 SHORT $LN2@Attach_bef

; 691  :             return _Insert_before;

  00018	8b 45 0c	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0001b	eb 65		 jmp	 SHORT $LN3@Attach_bef
$LN2@Attach_bef:

; 692  :         }
; 693  : 
; 694  :         const auto _Local_head   = _Head;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00023	89 45 f8	 mov	 DWORD PTR __Local_head$[ebp], eax

; 695  :         const auto _Local_tail   = _Tail;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002c	89 45 f0	 mov	 DWORD PTR __Local_tail$[ebp], eax

; 696  :         const auto _Insert_after = _Insert_before->_Prev;

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  00032	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00035	89 45 f4	 mov	 DWORD PTR __Insert_after$[ebp], eax

; 697  : 
; 698  :         _Construct_in_place(_Local_head->_Prev, _Insert_after);

  00038	8d 45 f4	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  0003b	50		 push	 eax
  0003c	8b 45 f8	 mov	 eax, DWORD PTR __Local_head$[ebp]
  0003f	83 c0 04	 add	 eax, 4
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * const &>
  00048	59		 pop	 ecx
  00049	59		 pop	 ecx

; 699  :         _Insert_after->_Next = _Local_head;

  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR __Local_head$[ebp]
  00050	89 08		 mov	 DWORD PTR [eax], ecx

; 700  :         _Construct_in_place(_Local_tail->_Next, _Insert_before);

  00052	8d 45 0c	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00055	50		 push	 eax
  00056	ff 75 f0	 push	 DWORD PTR __Local_tail$[ebp]
  00059	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * const &>
  0005e	59		 pop	 ecx
  0005f	59		 pop	 ecx

; 701  :         _Insert_before->_Prev = _Local_tail;

  00060	8b 45 0c	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  00063	8b 4d f0	 mov	 ecx, DWORD PTR __Local_tail$[ebp]
  00066	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 702  : 
; 703  :         _List_data._Mysize += _Local_added;

  00069	8b 45 08	 mov	 eax, DWORD PTR __List_data$[ebp]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	03 45 ec	 add	 eax, DWORD PTR __Local_added$[ebp]
  00072	8b 4d 08	 mov	 ecx, DWORD PTR __List_data$[ebp]
  00075	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 704  :         _Added = 0;

  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 705  :         return _Local_head;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR __Local_head$[ebp]
$LN3@Attach_bef:

; 706  :     }

  00082	c9		 leave
  00083	c2 08 00	 ret	 8
??$_Attach_before@U?$_List_simple_types@USArgumet@script@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@AAV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@QAU21@@Z ENDP ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Attach_before<std::_List_simple_types<script::SArgumet> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@PAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@$$QAPAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@PAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@$$QAPAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> *>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@PAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@$$QAPAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
_TEXT	SEGMENT
__Newnode$ = -116					; size = 8
___formal$ = -108					; size = 4
___formal$ = -104					; size = 4
$T2 = -100						; size = 4
__Old_val$3 = -96					; size = 4
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
$T7 = -80						; size = 4
$T8 = -76						; size = 4
__Val$ = -72						; size = 4
__Old_val$9 = -68					; size = 4
$T10 = -64						; size = 4
$T11 = -60						; size = 4
$T12 = -56						; size = 4
$T13 = -52						; size = 4
$T14 = -48						; size = 4
__Val$ = -44						; size = 4
__Al_$ = -40						; size = 4
tv212 = -36						; size = 4
tv199 = -32						; size = 4
__Newhead$15 = -28					; size = 4
tv162 = -24						; size = 4
_this$ = -20						; size = 4
$T16 = -15						; size = 1
$T17 = -14						; size = 1
$T18 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z PROC ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Append_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx

; 655  :     void _Append_range_unchecked(_InIt _First, const _Sentinel _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 68	 sub	 esp, 104		; 00000068H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 74   :         return _Ptr == _Right._Ptr;

  00028	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002b	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0002e	75 09		 jne	 SHORT $LN10@Append_ran
  00030	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv162[ebp], 1
  00037	eb 04		 jmp	 SHORT $LN11@Append_ran
$LN10@Append_ran:
  00039	83 65 e8 00	 and	 DWORD PTR tv162[ebp], 0
$LN11@Append_ran:
  0003d	8a 45 e8	 mov	 al, BYTE PTR tv162[ebp]
  00040	88 45 f3	 mov	 BYTE PTR $T18[ebp], al

; 656  :         // Append the values in [_First, _Last)
; 657  :         if (_First == _Last) { // throws

  00043	0f b6 45 f3	 movzx	 eax, BYTE PTR $T18[ebp]
  00047	85 c0		 test	 eax, eax
  00049	74 05		 je	 SHORT $LN4@Append_ran

; 658  :             return;

  0004b	e9 87 01 00 00	 jmp	 $LN1@Append_ran
$LN4@Append_ran:

; 661  :         _Alloc_construct_ptr<_Alnode> _Newnode(_Al);

  00050	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	89 45 d8	 mov	 DWORD PTR __Al_$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00058	8b 45 d8	 mov	 eax, DWORD PTR __Al_$[ebp]
  0005b	89 45 8c	 mov	 DWORD PTR __Newnode$[ebp], eax
  0005e	83 65 90 00	 and	 DWORD PTR __Newnode$[ebp+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 661  :         _Alloc_construct_ptr<_Alnode> _Newnode(_Al);

  00062	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 662  :         if (_Added == 0) {

  00066	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00069	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0006d	75 7c		 jne	 SHORT $LN2@Append_ran

; 663  :             _Newnode._Allocate(); // throws

  0006f	8d 4d 8c	 lea	 ecx, DWORD PTR __Newnode$[ebp]
  00072	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Allocate

; 44   :         return _Ptr->_Myval;

  00077	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0007a	83 c0 08	 add	 eax, 8
  0007d	89 45 cc	 mov	 DWORD PTR $T13[ebp], eax

; 664  :             _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), *_First); // throws

  00080	8b 45 90	 mov	 eax, DWORD PTR __Newnode$[ebp+4]
  00083	83 c0 08	 add	 eax, 8
  00086	89 45 d4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00089	8b 45 d4	 mov	 eax, DWORD PTR __Val$[ebp]
  0008c	89 45 d0	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 664  :             _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), *_First); // throws

  0008f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 00		 mov	 eax, DWORD PTR [eax]
  00094	89 45 98	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00097	8b 45 d0	 mov	 eax, DWORD PTR $T14[ebp]
  0009a	89 45 c4	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0009d	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp]
  000a0	89 45 c8	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  000a3	ff 75 c8	 push	 DWORD PTR $T12[ebp]
  000a6	8b 4d c4	 mov	 ecx, DWORD PTR $T11[ebp]
  000a9	e8 00 00 00 00	 call	 ??0SArgumet@script@@QAE@ABU01@@Z ; script::SArgumet::SArgumet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 665  :             const auto _Newhead = _STD exchange(_Newnode._Ptr, pointer{});

  000ae	83 65 c0 00	 and	 DWORD PTR $T10[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000b2	8b 45 90	 mov	 eax, DWORD PTR __Newnode$[ebp+4]
  000b5	89 45 bc	 mov	 DWORD PTR __Old_val$9[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  000b8	8b 45 c0	 mov	 eax, DWORD PTR $T10[ebp]
  000bb	89 45 90	 mov	 DWORD PTR __Newnode$[ebp+4], eax

; 600  :     return _Old_val;

  000be	8b 45 bc	 mov	 eax, DWORD PTR __Old_val$9[ebp]
  000c1	89 45 e4	 mov	 DWORD PTR __Newhead$15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 666  :             _Head               = _Newhead;

  000c4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	8b 4d e4	 mov	 ecx, DWORD PTR __Newhead$15[ebp]
  000ca	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 667  :             _Tail               = _Newhead;

  000cd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d0	8b 4d e4	 mov	 ecx, DWORD PTR __Newhead$15[ebp]
  000d3	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 668  :             ++_Added;

  000d6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	40		 inc	 eax
  000dd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 52   :         _Ptr = _Ptr->_Next;

  000e3	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000e6	8b 00		 mov	 eax, DWORD PTR [eax]
  000e8	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN2@Append_ran:

; 74   :         return _Ptr == _Right._Ptr;

  000eb	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000ee	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  000f1	75 09		 jne	 SHORT $LN67@Append_ran
  000f3	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv199[ebp], 1
  000fa	eb 04		 jmp	 SHORT $LN68@Append_ran
$LN67@Append_ran:
  000fc	83 65 e0 00	 and	 DWORD PTR tv199[ebp], 0
$LN68@Append_ran:
  00100	8a 45 e0	 mov	 al, BYTE PTR tv199[ebp]
  00103	88 45 f2	 mov	 BYTE PTR $T17[ebp], al

; 78   :         return !(*this == _Right);

  00106	0f b6 45 f2	 movzx	 eax, BYTE PTR $T17[ebp]
  0010a	85 c0		 test	 eax, eax
  0010c	75 09		 jne	 SHORT $LN62@Append_ran
  0010e	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv212[ebp], 1
  00115	eb 04		 jmp	 SHORT $LN63@Append_ran
$LN62@Append_ran:
  00117	83 65 dc 00	 and	 DWORD PTR tv212[ebp], 0
$LN63@Append_ran:
  0011b	8a 45 dc	 mov	 al, BYTE PTR tv212[ebp]
  0011e	88 45 f1	 mov	 BYTE PTR $T16[ebp], al

; 669  :             ++_First; // throws
; 670  :         }
; 671  : 
; 672  :         while (_First != _Last) { // throws

  00121	0f b6 45 f1	 movzx	 eax, BYTE PTR $T16[ebp]
  00125	85 c0		 test	 eax, eax
  00127	0f 84 9e 00 00
	00		 je	 $LN3@Append_ran

; 673  :             _Newnode._Allocate(); // throws

  0012d	8d 4d 8c	 lea	 ecx, DWORD PTR __Newnode$[ebp]
  00130	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Allocate

; 44   :         return _Ptr->_Myval;

  00135	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00138	83 c0 08	 add	 eax, 8
  0013b	89 45 b0	 mov	 DWORD PTR $T7[ebp], eax

; 674  :             _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), *_First); // throws

  0013e	8b 45 90	 mov	 eax, DWORD PTR __Newnode$[ebp+4]
  00141	83 c0 08	 add	 eax, 8
  00144	89 45 b8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00147	8b 45 b8	 mov	 eax, DWORD PTR __Val$[ebp]
  0014a	89 45 b4	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 674  :             _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), *_First); // throws

  0014d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00150	8b 00		 mov	 eax, DWORD PTR [eax]
  00152	89 45 94	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00155	8b 45 b4	 mov	 eax, DWORD PTR $T8[ebp]
  00158	89 45 a8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0015b	8b 45 b0	 mov	 eax, DWORD PTR $T7[ebp]
  0015e	89 45 ac	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00161	ff 75 ac	 push	 DWORD PTR $T6[ebp]
  00164	8b 4d a8	 mov	 ecx, DWORD PTR $T5[ebp]
  00167	e8 00 00 00 00	 call	 ??0SArgumet@script@@QAE@ABU01@@Z ; script::SArgumet::SArgumet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 675  :             _Construct_in_place(_Tail->_Next, _Newnode._Ptr);

  0016c	8d 45 90	 lea	 eax, DWORD PTR __Newnode$[ebp+4]
  0016f	50		 push	 eax
  00170	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00173	ff 70 08	 push	 DWORD PTR [eax+8]
  00176	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>
  0017b	59		 pop	 ecx
  0017c	59		 pop	 ecx

; 676  :             _Construct_in_place(_Newnode._Ptr->_Prev, _Tail);

  0017d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00180	83 c0 08	 add	 eax, 8
  00183	50		 push	 eax
  00184	8b 45 90	 mov	 eax, DWORD PTR __Newnode$[ebp+4]
  00187	83 c0 04	 add	 eax, 4
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>
  00190	59		 pop	 ecx
  00191	59		 pop	 ecx

; 677  :             _Tail = _STD exchange(_Newnode._Ptr, pointer{});

  00192	83 65 a4 00	 and	 DWORD PTR $T4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00196	8b 45 90	 mov	 eax, DWORD PTR __Newnode$[ebp+4]
  00199	89 45 a0	 mov	 DWORD PTR __Old_val$3[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  0019c	8b 45 a4	 mov	 eax, DWORD PTR $T4[ebp]
  0019f	89 45 90	 mov	 DWORD PTR __Newnode$[ebp+4], eax

; 600  :     return _Old_val;

  001a2	8b 45 a0	 mov	 eax, DWORD PTR __Old_val$3[ebp]
  001a5	89 45 9c	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 677  :             _Tail = _STD exchange(_Newnode._Ptr, pointer{});

  001a8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001ab	8b 4d 9c	 mov	 ecx, DWORD PTR $T2[ebp]
  001ae	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 678  :             ++_Added;

  001b1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001b4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b7	40		 inc	 eax
  001b8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 52   :         _Ptr = _Ptr->_Next;

  001be	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  001c1	8b 00		 mov	 eax, DWORD PTR [eax]
  001c3	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 679  :             ++_First; // throws
; 680  :         }

  001c6	e9 20 ff ff ff	 jmp	 $LN2@Append_ran
$LN3@Append_ran:

; 681  :     }

  001cb	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001cf	8d 4d 8c	 lea	 ecx, DWORD PTR __Newnode$[ebp]
  001d2	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >
$LN1@Append_ran:
  001d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e1	59		 pop	 ecx
  001e2	c9		 leave
  001e3	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z$0:
  00000	8d 4d 8c	 lea	 ecx, DWORD PTR __Newnode$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ENDP ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Append_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__Al$ = -36						; size = 4
$T1 = -32						; size = 4
__Old_val$2 = -28					; size = 4
__New_val$ = -24					; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Subject$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >, COMDAT
; _this$ = ecx

; 734  :     ~_List_node_insert_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 735  :         if (_Added == 0) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 05		 jne	 SHORT $LN4@List_node_

; 736  :             return;

  00012	e9 81 00 00 00	 jmp	 $LN5@List_node_
$LN4@List_node_:

; 737  :         }
; 738  : 
; 739  :         _Construct_in_place(_Head->_Prev, pointer{});

  00017	83 65 f0 00	 and	 DWORD PTR $T4[ebp], 0
  0001b	8d 45 f0	 lea	 eax, DWORD PTR $T4[ebp]
  0001e	50		 push	 eax
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00025	83 c0 04	 add	 eax, 4
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@PAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@$$QAPAU10@@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> *>
  0002e	59		 pop	 ecx
  0002f	59		 pop	 ecx

; 740  :         _Construct_in_place(_Tail->_Next, pointer{});

  00030	83 65 ec 00	 and	 DWORD PTR $T3[ebp], 0
  00034	8d 45 ec	 lea	 eax, DWORD PTR $T3[ebp]
  00037	50		 push	 eax
  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	ff 70 08	 push	 DWORD PTR [eax+8]
  0003e	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@PAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@$$QAPAU10@@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> *>
  00043	59		 pop	 ecx
  00044	59		 pop	 ecx

; 741  :         pointer _Subject = _Head;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0004b	89 45 f8	 mov	 DWORD PTR __Subject$[ebp], eax
$LN2@List_node_:

; 742  :         while (_Subject) {

  0004e	83 7d f8 00	 cmp	 DWORD PTR __Subject$[ebp], 0
  00052	74 44		 je	 SHORT $LN5@List_node_

; 743  :             value_type::_Freenode(_Al, _STD exchange(_Subject, _Subject->_Next));

  00054	8b 45 f8	 mov	 eax, DWORD PTR __Subject$[ebp]
  00057	89 45 e8	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Subject$[ebp]
  0005d	89 45 e4	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00060	8b 45 e8	 mov	 eax, DWORD PTR __New_val$[ebp]
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	89 45 f8	 mov	 DWORD PTR __Subject$[ebp], eax

; 600  :     return _Old_val;

  00068	8b 45 e4	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0006b	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 743  :             value_type::_Freenode(_Al, _STD exchange(_Subject, _Subject->_Next));

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00071	8b 00		 mov	 eax, DWORD PTR [eax]
  00073	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00076	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00079	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0007c	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 706  :         _Ptr->~_Uty();

  0007f	6a 00		 push	 0
  00081	8b 4d e0	 mov	 ecx, DWORD PTR $T1[ebp]
  00084	e8 00 00 00 00	 call	 ??_GSArgumet@script@@QAEPAXI@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00089	ff 75 f4	 push	 DWORD PTR $T5[ebp]
  0008c	ff 75 dc	 push	 DWORD PTR __Al$[ebp]
  0008f	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SArgumet,void *>::_Freenode0<std::allocator<std::_List_node<script::SArgumet,void *> > >
  00094	59		 pop	 ecx
  00095	59		 pop	 ecx

; 744  :         }

  00096	eb b6		 jmp	 SHORT $LN2@List_node_
$LN5@List_node_:

; 745  :     }

  00098	c9		 leave
  00099	c3		 ret	 0
??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<script::SCmd,void *> *,std::_List_node<script::SCmd,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<script::SCmd,void *> *,std::_List_node<script::SCmd,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
_TEXT	SEGMENT
__Op$2 = -64						; size = 16
$T3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
tv163 = -36						; size = 4
__List_data$ = -32					; size = 4
__Myend$ = -28						; size = 4
_this$ = -24						; size = 4
__Old$ = -20						; size = 4
$T6 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__UFirst$ = 8						; size = 4
__ULast$ = 12						; size = 4
??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Assign_cast<script::SArgumet &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx

; 1265 :     void _Assign_cast(_UIter _UFirst, const _UIter _ULast) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1266 :         // assign [_UFirst, _ULast), casting existing nodes to _Target_ref
; 1267 :         const auto _Myend = _Mypair._Myval2._Myhead;

  00028	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	89 45 e4	 mov	 DWORD PTR __Myend$[ebp], eax

; 1268 :         auto _Old         = _Myend->_Next;

  00030	8b 45 e4	 mov	 eax, DWORD PTR __Myend$[ebp]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	89 45 ec	 mov	 DWORD PTR __Old$[ebp], eax
$LN4@Assign_cas:

; 1269 :         for (;;) { // attempt to reuse a node
; 1270 :             if (_Old == _Myend) { // no more nodes to reuse, append the rest

  00038	8b 45 ec	 mov	 eax, DWORD PTR __Old$[ebp]
  0003b	3b 45 e4	 cmp	 eax, DWORD PTR __Myend$[ebp]
  0003e	75 4c		 jne	 SHORT $LN5@Assign_cas

; 1787 :         return _Mypair._Get_first();

  00040	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00043	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00046	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00049	89 45 d4	 mov	 DWORD PTR $T4[ebp], eax

; 620  :     explicit _List_node_insert_op2(_Alnode& _Al_) : _Al(_Al_), _Added(0) {}

  0004c	8b 45 d4	 mov	 eax, DWORD PTR $T4[ebp]
  0004f	89 45 c0	 mov	 DWORD PTR __Op$2[ebp], eax
  00052	83 65 c4 00	 and	 DWORD PTR __Op$2[ebp+4], 0

; 1271 :                 _List_node_insert_op2<_Alnode> _Op(_Getal());

  00056	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1272 :                 _Op._Append_range_unchecked(_UFirst, _ULast);

  0005a	ff 75 0c	 push	 DWORD PTR __ULast$[ebp]
  0005d	ff 75 08	 push	 DWORD PTR __UFirst$[ebp]
  00060	8d 4d c0	 lea	 ecx, DWORD PTR __Op$2[ebp]
  00063	e8 00 00 00 00	 call	 ??$_Append_range_unchecked@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Append_range_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0> >

; 1273 :                 _Op._Attach_at_end(_Mypair._Myval2);

  00068	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	89 45 e0	 mov	 DWORD PTR __List_data$[ebp], eax

; 710  :         _Attach_before(_List_data, _List_data._Myhead);

  0006e	8b 45 e0	 mov	 eax, DWORD PTR __List_data$[ebp]
  00071	ff 30		 push	 DWORD PTR [eax]
  00073	ff 75 e0	 push	 DWORD PTR __List_data$[ebp]
  00076	8d 4d c0	 lea	 ecx, DWORD PTR __Op$2[ebp]
  00079	e8 00 00 00 00	 call	 ??$_Attach_before@U?$_List_simple_types@USArgumet@script@@@std@@@?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@AAV?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@1@QAU21@@Z ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Attach_before<std::_List_simple_types<script::SArgumet> >

; 1274 :                 return;

  0007e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00082	8d 4d c0	 lea	 ecx, DWORD PTR __Op$2[ebp]
  00085	e8 00 00 00 00	 call	 ??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >
  0008a	eb 5f		 jmp	 SHORT $LN1@Assign_cas
$LN5@Assign_cas:

; 74   :         return _Ptr == _Right._Ptr;

  0008c	8b 45 08	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0008f	3b 45 0c	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00092	75 09		 jne	 SHORT $LN79@Assign_cas
  00094	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv163[ebp], 1
  0009b	eb 04		 jmp	 SHORT $LN80@Assign_cas
$LN79@Assign_cas:
  0009d	83 65 dc 00	 and	 DWORD PTR tv163[ebp], 0
$LN80@Assign_cas:
  000a1	8a 45 dc	 mov	 al, BYTE PTR tv163[ebp]
  000a4	88 45 f3	 mov	 BYTE PTR $T6[ebp], al

; 1275 :             }
; 1276 : 
; 1277 :             if (_UFirst == _ULast) {

  000a7	0f b6 45 f3	 movzx	 eax, BYTE PTR $T6[ebp]
  000ab	85 c0		 test	 eax, eax
  000ad	74 10		 je	 SHORT $LN6@Assign_cas

; 1278 :                 // input sequence was shorter than existing list, destroy and deallocate what's left
; 1279 :                 _Unchecked_erase(_Old, _Myend);

  000af	ff 75 e4	 push	 DWORD PTR __Myend$[ebp]
  000b2	ff 75 ec	 push	 DWORD PTR __Old$[ebp]
  000b5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@QAU32@@Z ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Unchecked_erase

; 1280 :                 return;

  000bd	eb 2c		 jmp	 SHORT $LN1@Assign_cas
$LN6@Assign_cas:

; 44   :         return _Ptr->_Myval;

  000bf	8b 45 08	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000c2	83 c0 08	 add	 eax, 8
  000c5	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax

; 1281 :             }
; 1282 : 
; 1283 :             // reuse the node
; 1284 :             reinterpret_cast<_Target_ref>(_Old->_Myval) = *_UFirst;

  000c8	ff 75 d0	 push	 DWORD PTR $T3[ebp]
  000cb	8b 4d ec	 mov	 ecx, DWORD PTR __Old$[ebp]
  000ce	83 c1 08	 add	 ecx, 8
  000d1	e8 00 00 00 00	 call	 ??4SArgumet@script@@QAEXABU01@@Z ; script::SArgumet::operator=

; 1285 :             _Old                                        = _Old->_Next;

  000d6	8b 45 ec	 mov	 eax, DWORD PTR __Old$[ebp]
  000d9	8b 00		 mov	 eax, DWORD PTR [eax]
  000db	89 45 ec	 mov	 DWORD PTR __Old$[ebp], eax

; 52   :         _Ptr = _Ptr->_Next;

  000de	8b 45 08	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000e1	8b 00		 mov	 eax, DWORD PTR [eax]
  000e3	89 45 08	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1286 :             ++_UFirst;
; 1287 :         }

  000e6	e9 4d ff ff ff	 jmp	 $LN4@Assign_cas
$LN1@Assign_cas:

; 1288 :     }

  000eb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f5	59		 pop	 ecx
  000f6	c9		 leave
  000f7	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR __Op$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_List_node_insert_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_List_node_insert_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Assign_cast<script::SArgumet &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<script::SArgumet,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<script::SArgumet,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<script::SCmd,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<script::SCmd,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > ><script::SArgumet>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Allocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00043	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00046	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004f	83 c0 08	 add	 eax, 8
  00052	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  00058	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00063	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00066	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00069	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0006c	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0006f	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00072	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  00075	e8 00 00 00 00	 call	 ??0SArgumet@script@@QAE@ABU01@@Z ; script::SArgumet::SArgumet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 588  :     }

  0007a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	c9		 leave
  0008d	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > ><script::SArgumet>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
__Insert_after$ = -12					; size = 4
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f4	 mov	 DWORD PTR __Insert_after$[ebp], eax

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00012	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00015	50		 push	 eax
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * const &>
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00023	8d 45 f4	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  00026	50		 push	 eax
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * const &>
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx

; 603  :         const auto _Result    = this->_Ptr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 604  :         this->_Ptr            = pointer{};

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00048	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  0004e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  00051	8b 45 f4	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
___formal$ = -16					; size = 4
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 24		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	83 c0 08	 add	 eax, 8
  0001b	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	89 45 f0	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 706  :         _Ptr->~_Uty();

  0002c	6a 00		 push	 0
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00031	e8 00 00 00 00	 call	 ??_GSArgumet@script@@QAEPAXI@Z
$LN1@List_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 594  :     }

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >
  0003e	c9		 leave
  0003f	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 38	 imul	 eax, eax, 56
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 24 49
	92 04		 mov	 DWORD PTR __Max_possible$1[ebp], 76695844 ; 04924924H

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d 24 49 92 04	 cmp	 eax, 76695844		; 04924924H
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 38	 imul	 eax, eax, 56
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > ><script::SCmd const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >::_Allocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00043	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00046	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004f	83 c0 08	 add	 eax, 8
  00052	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  00058	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00063	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00066	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00069	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0006c	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0006f	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00072	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  00075	e8 00 00 00 00	 call	 ??0SCmd@script@@QAE@ABU01@@Z ; script::SCmd::SCmd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 588  :     }

  0007a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	c9		 leave
  0008d	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > ><script::SCmd const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USCmd@script@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
__Insert_after$ = -12					; size = 4
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USCmd@script@@PAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f4	 mov	 DWORD PTR __Insert_after$[ebp], eax

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00012	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00015	50		 push	 eax
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<script::SCmd,void *> *,std::_List_node<script::SCmd,void *> * const &>
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00023	8d 45 f4	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  00026	50		 push	 eax
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<script::SCmd,void *> *,std::_List_node<script::SCmd,void *> * const &>
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx

; 603  :         const auto _Result    = this->_Ptr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 604  :         this->_Ptr            = pointer{};

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00048	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  0004e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  00051	8b 45 f4	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USCmd@script@@PAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
___formal$ = -16					; size = 4
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 24		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	83 c0 08	 add	 eax, 8
  0001b	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	89 45 f0	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 706  :         _Ptr->~_Uty();

  0002c	6a 00		 push	 0
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00031	e8 00 00 00 00	 call	 ??_GSCmd@script@@QAEPAXI@Z
$LN1@List_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 594  :     }

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >
  0003e	c9		 leave
  0003f	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 28	 imul	 eax, eax, 40
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 66 66
	66 06		 mov	 DWORD PTR __Max_possible$1[ebp], 107374182 ; 06666666H

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d 66 66 66 06	 cmp	 eax, 107374182		; 06666666H
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 28	 imul	 eax, eax, 40
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<script::SCmd,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 885  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 886  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 887  :         _Left = _Right;
; 888  :     }
; 889  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@YAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@YAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<std::_List_node<script::SArgumet,void *> > >, COMDAT

; 885  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 886  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 887  :         _Left = _Right;
; 888  :     }
; 889  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@YAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<std::_List_node<script::SArgumet,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<script::SArgumet,void *>::_Freenode0<std::allocator<std::_List_node<script::SArgumet,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<script::SArgumet,void *> *>
  0000b	59		 pop	 ecx

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<script::SArgumet,void *> *>
  00018	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	6b c0 38	 imul	 eax, eax, 56
  0001f	50		 push	 eax
  00020	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 313  :     }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<script::SArgumet,void *>::_Freenode0<std::allocator<std::_List_node<script::SArgumet,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<script::SCmd,void *>::_Freenode0<std::allocator<std::_List_node<script::SCmd,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<script::SCmd,void *> *>
  0000b	59		 pop	 ecx

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<script::SCmd,void *> *>
  00018	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	6b c0 28	 imul	 eax, eax, 40
  0001f	50		 push	 eax
  00020	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 313  :     }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<script::SCmd,void *>::_Freenode0<std::allocator<std::_List_node<script::SCmd,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<script::SCmd,void *> *,std::_List_node<script::SCmd,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<script::SCmd,void *> *,std::_List_node<script::SCmd,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Emplace@USArgumet@script@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@QAU21@$$QAUSArgumet@script@@@Z
_TEXT	SEGMENT
__Op$ = -76						; size = 8
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
$T10 = -32						; size = 4
tv80 = -28						; size = 4
tv82 = -24						; size = 4
tv94 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@USArgumet@script@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@QAU21@$$QAUSArgumet@script@@@Z PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Emplace<script::SArgumet>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1791 :         return _Mypair._Get_first();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00015	89 45 e0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1791 :         return _Mypair._Get_first();

  00018	8b 45 e0	 mov	 eax, DWORD PTR $T10[ebp]
  0001b	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001e	c7 45 f4 24 49
	92 04		 mov	 DWORD PTR $T12[ebp], 76695844 ; 04924924H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00025	c7 45 dc ff ff
	ff 7f		 mov	 DWORD PTR $T9[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  0002c	8b 45 dc	 mov	 eax, DWORD PTR $T9[ebp]
  0002f	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00032	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00035	3b 45 f0	 cmp	 eax, DWORD PTR $T11[ebp]
  00038	73 08		 jae	 SHORT $LN22@Emplace
  0003a	8d 45 f4	 lea	 eax, DWORD PTR $T12[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  00040	eb 06		 jmp	 SHORT $LN23@Emplace
$LN22@Emplace:
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T11[ebp]
  00045	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
$LN23@Emplace:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  0004b	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00051	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  00054	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	3b 45 d0	 cmp	 eax, DWORD PTR $T6[ebp]
  00064	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  0006b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00070	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00073	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00079	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0007c	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0007f	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00082	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00085	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0008e	ff 75 e8	 push	 DWORD PTR tv82[ebp]
  00091	ff 75 e4	 push	 DWORD PTR tv80[ebp]
  00094	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  00097	e8 00 00 00 00	 call	 ??$?0USArgumet@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@$$QAUSArgumet@script@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > ><script::SArgumet>

; 1019 :         ++_Mysize;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	40		 inc	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1020 :         return _Op._Transfer_before(_Where);

  000a7	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000aa	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::_Transfer_before
  000b2	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  000b5	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000b8	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<script::SArgumet,void *> > >
  000bd	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
$LN3@Emplace:

; 1021 :     }

  000c0	c9		 leave
  000c1	c2 08 00	 ret	 8
??$_Emplace@USArgumet@script@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@QAU21@$$QAUSArgumet@script@@@Z ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Emplace<script::SArgumet>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Pnext$2 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<script::SArgumet,void *>::_Free_non_head<std::allocator<std::_List_node<script::SArgumet,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	83 20 00	 and	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00017	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0001c	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  0001f	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00023	74 2a		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  00025	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR __Pnext$2[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 706  :         _Ptr->~_Uty();

  00036	6a 00		 push	 0
  00038	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0003b	e8 00 00 00 00	 call	 ??_GSArgumet@script@@QAEPAXI@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00040	ff 75 fc	 push	 DWORD PTR __Pnode$[ebp]
  00043	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  00046	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SArgumet,void *>::_Freenode0<std::allocator<std::_List_node<script::SArgumet,void *> > >
  0004b	59		 pop	 ecx
  0004c	59		 pop	 ecx

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }

  0004d	eb ca		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  0004f	c9		 leave
  00050	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<script::SArgumet,void *>::_Free_non_head<std::allocator<std::_List_node<script::SArgumet,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Emplace@ABUSCmd@script@@@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAEPAU?$_List_node@USCmd@script@@PAX@1@QAU21@ABUSCmd@script@@@Z
_TEXT	SEGMENT
__Op$ = -76						; size = 8
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
$T10 = -32						; size = 4
tv80 = -28						; size = 4
tv82 = -24						; size = 4
tv94 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABUSCmd@script@@@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAEPAU?$_List_node@USCmd@script@@PAX@1@QAU21@ABUSCmd@script@@@Z PROC ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Emplace<script::SCmd const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1791 :         return _Mypair._Get_first();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00015	89 45 e0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1791 :         return _Mypair._Get_first();

  00018	8b 45 e0	 mov	 eax, DWORD PTR $T10[ebp]
  0001b	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001e	c7 45 f4 66 66
	66 06		 mov	 DWORD PTR $T12[ebp], 107374182 ; 06666666H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00025	c7 45 dc ff ff
	ff 7f		 mov	 DWORD PTR $T9[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  0002c	8b 45 dc	 mov	 eax, DWORD PTR $T9[ebp]
  0002f	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00032	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00035	3b 45 f0	 cmp	 eax, DWORD PTR $T11[ebp]
  00038	73 08		 jae	 SHORT $LN22@Emplace
  0003a	8d 45 f4	 lea	 eax, DWORD PTR $T12[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  00040	eb 06		 jmp	 SHORT $LN23@Emplace
$LN22@Emplace:
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T11[ebp]
  00045	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
$LN23@Emplace:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  0004b	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00051	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  00054	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	3b 45 d0	 cmp	 eax, DWORD PTR $T6[ebp]
  00064	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  0006b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00070	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00073	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00079	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0007c	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0007f	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00082	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00085	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0008e	ff 75 e8	 push	 DWORD PTR tv82[ebp]
  00091	ff 75 e4	 push	 DWORD PTR tv80[ebp]
  00094	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  00097	e8 00 00 00 00	 call	 ??$?0ABUSCmd@script@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@ABUSCmd@script@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > ><script::SCmd const &>

; 1019 :         ++_Mysize;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	40		 inc	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1020 :         return _Op._Transfer_before(_Where);

  000a7	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000aa	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USCmd@script@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >::_Transfer_before
  000b2	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  000b5	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000b8	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<script::SCmd,void *> > >
  000bd	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
$LN3@Emplace:

; 1021 :     }

  000c0	c9		 leave
  000c1	c2 08 00	 ret	 8
??$_Emplace@ABUSCmd@script@@@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAEPAU?$_List_node@USCmd@script@@PAX@1@QAU21@ABUSCmd@script@@@Z ENDP ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Emplace<script::SCmd const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Pnext$2 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<script::SCmd,void *>::_Free_non_head<std::allocator<std::_List_node<script::SCmd,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	83 20 00	 and	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00017	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0001c	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  0001f	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00023	74 2a		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  00025	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR __Pnext$2[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 706  :         _Ptr->~_Uty();

  00036	6a 00		 push	 0
  00038	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0003b	e8 00 00 00 00	 call	 ??_GSCmd@script@@QAEPAXI@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00040	ff 75 fc	 push	 DWORD PTR __Pnode$[ebp]
  00043	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  00046	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SCmd,void *>::_Freenode0<std::allocator<std::_List_node<script::SCmd,void *> > >
  0004b	59		 pop	 ecx
  0004c	59		 pop	 ecx

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }

  0004d	eb ca		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  0004f	c9		 leave
  00050	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<script::SCmd,void *>::_Free_non_head<std::allocator<std::_List_node<script::SCmd,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??__FstLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@YAXXZ
text$yd	SEGMENT
??__FstLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@YAXXZ PROC ; `script::Group::Create'::`2'::`dynamic atexit destructor for 'stLetter'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2801 :         _Tidy_deallocate();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?stLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4V45@A
  00008	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__FstLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@YAXXZ ENDP ; `script::Group::Create'::`2'::`dynamic atexit destructor for 'stLetter''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ?LocaleString_Skip@@YAPBDKPBD@Z
_TEXT	SEGMENT
_cur_len$1 = -12					; size = 4
_next$2 = -8						; size = 4
_loopCount$ = -4					; size = 4
_codePage$ = 8						; size = 4
_cur$ = 12						; size = 4
?LocaleString_Skip@@YAPBDKPBD@Z PROC			; LocaleString_Skip, COMDAT

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 123  : 	int loopCount = 0;

  00006	83 65 fc 00	 and	 DWORD PTR _loopCount$[ebp], 0
$LN2@LocaleStri:

; 124  : 
; 125  : 	while (*cur)

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _cur$[ebp]
  0000d	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00010	85 c0		 test	 eax, eax
  00012	0f 84 84 00 00
	00		 je	 $LN3@LocaleStri

; 126  : 	{
; 127  : 		if (++loopCount > 9216)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _loopCount$[ebp]
  0001b	40		 inc	 eax
  0001c	89 45 fc	 mov	 DWORD PTR _loopCount$[ebp], eax
  0001f	81 7d fc 00 24
	00 00		 cmp	 DWORD PTR _loopCount$[ebp], 9216 ; 00002400H
  00026	7e 11		 jle	 SHORT $LN4@LocaleStri

; 128  : 		{
; 129  : 			TraceError("Infinite loop in LocaleString_Skip [%s]", cur);

  00028	ff 75 0c	 push	 DWORD PTR _cur$[ebp]
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@BGFMKJOI@Infinite?5loop?5in?5LocaleString_S@
  00030	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx

; 130  : 			break;

  00037	eb 63		 jmp	 SHORT $LN3@LocaleStri
$LN4@LocaleStri:

; 131  : 		}
; 132  : 
; 133  : 		const char* next = CharNextExA(codePage, cur, 0);

  00039	6a 00		 push	 0
  0003b	ff 75 0c	 push	 DWORD PTR _cur$[ebp]
  0003e	ff 75 08	 push	 DWORD PTR _codePage$[ebp]
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextExA@12
  00047	89 45 f8	 mov	 DWORD PTR _next$2[ebp], eax

; 134  : 		int cur_len = next - cur;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _next$2[ebp]
  0004d	2b 45 0c	 sub	 eax, DWORD PTR _cur$[ebp]
  00050	89 45 f4	 mov	 DWORD PTR _cur_len$1[ebp], eax

; 135  : 		if (cur_len > 1)

  00053	83 7d f4 01	 cmp	 DWORD PTR _cur_len$1[ebp], 1
  00057	7e 08		 jle	 SHORT $LN5@LocaleStri

; 136  : 		{
; 137  : 			cur = next;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _next$2[ebp]
  0005c	89 45 0c	 mov	 DWORD PTR _cur$[ebp], eax

; 138  : 		}

  0005f	eb 36		 jmp	 SHORT $LN6@LocaleStri
$LN5@LocaleStri:

; 139  : 		else if (1 == cur_len)

  00061	83 7d f4 01	 cmp	 DWORD PTR _cur_len$1[ebp], 1
  00065	75 2e		 jne	 SHORT $LN7@LocaleStri

; 140  : 		{
; 141  : 			if (!isspace((unsigned char) *cur) && *cur != '\n' && *cur != '\r')

  00067	8b 45 0c	 mov	 eax, DWORD PTR _cur$[ebp]
  0006a	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 _isspace
  00073	59		 pop	 ecx
  00074	85 c0		 test	 eax, eax
  00076	75 1b		 jne	 SHORT $LN9@LocaleStri
  00078	8b 45 0c	 mov	 eax, DWORD PTR _cur$[ebp]
  0007b	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0007e	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00081	74 10		 je	 SHORT $LN9@LocaleStri
  00083	8b 45 0c	 mov	 eax, DWORD PTR _cur$[ebp]
  00086	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00089	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0008c	74 05		 je	 SHORT $LN9@LocaleStri

; 142  : 				return cur;

  0008e	8b 45 0c	 mov	 eax, DWORD PTR _cur$[ebp]
  00091	eb 0c		 jmp	 SHORT $LN1@LocaleStri
$LN9@LocaleStri:

; 143  : 		}

  00093	eb 02		 jmp	 SHORT $LN6@LocaleStri
$LN7@LocaleStri:

; 144  : 		else
; 145  : 		{
; 146  : 			break;

  00095	eb 05		 jmp	 SHORT $LN3@LocaleStri
$LN6@LocaleStri:

; 147  : 		}
; 148  : 	}

  00097	e9 6e ff ff ff	 jmp	 $LN2@LocaleStri
$LN3@LocaleStri:

; 149  : 	return cur;

  0009c	8b 45 0c	 mov	 eax, DWORD PTR _cur$[ebp]
$LN1@LocaleStri:

; 150  : }

  0009f	c9		 leave
  000a0	c3		 ret	 0
?LocaleString_Skip@@YAPBDKPBD@Z ENDP			; LocaleString_Skip
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ?OLD_rtrim@@YAXPAD@Z
_TEXT	SEGMENT
_prev_len$1 = -20					; size = 4
_end$2 = -16						; size = 4
_codePage$ = -12					; size = 4
_prev$3 = -8						; size = 4
_end$4 = -4						; size = 4
_base$ = 8						; size = 4
?OLD_rtrim@@YAXPAD@Z PROC				; OLD_rtrim, COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 80   : 	if (!base)

  00006	83 7d 08 00	 cmp	 DWORD PTR _base$[ebp], 0
  0000a	75 05		 jne	 SHORT $LN6@OLD_rtrim

; 81   : 		return;

  0000c	e9 1b 01 00 00	 jmp	 $LN1@OLD_rtrim
$LN6@OLD_rtrim:

; 82   : 
; 83   : 	DWORD codePage = GetDefaultCodePage();

  00011	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  00016	89 45 f4	 mov	 DWORD PTR _codePage$[ebp], eax

; 84   : 
; 85   : 	if (949 == codePage || 936 == codePage)

  00019	81 7d f4 b5 03
	00 00		 cmp	 DWORD PTR _codePage$[ebp], 949 ; 000003b5H
  00020	74 0d		 je	 SHORT $LN9@OLD_rtrim
  00022	81 7d f4 a8 03
	00 00		 cmp	 DWORD PTR _codePage$[ebp], 936 ; 000003a8H
  00029	0f 85 8a 00 00
	00		 jne	 $LN7@OLD_rtrim
$LN9@OLD_rtrim:

; 86   : 	{
; 87   : 		char* end = base + strlen(base) - 1;

  0002f	ff 75 08	 push	 DWORD PTR _base$[ebp]
  00032	e8 00 00 00 00	 call	 _strlen
  00037	59		 pop	 ecx
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _base$[ebp]
  0003b	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  0003f	89 45 fc	 mov	 DWORD PTR _end$4[ebp], eax
$LN2@OLD_rtrim:

; 88   : 
; 89   : 		while (end != base)

  00042	8b 45 fc	 mov	 eax, DWORD PTR _end$4[ebp]
  00045	3b 45 08	 cmp	 eax, DWORD PTR _base$[ebp]
  00048	74 6d		 je	 SHORT $LN3@OLD_rtrim

; 90   : 		{
; 91   : 			if (!isnhspace((unsigned char) *end) && *end != '\n' && *end != '\r' || (end!=base && *((unsigned char*)end-1)>0xa0))

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _end$4[ebp]
  0004d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00050	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  00055	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  0005a	7f 11		 jg	 SHORT $LN13@OLD_rtrim
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _end$4[ebp]
  0005f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _isspace
  00068	59		 pop	 ecx
  00069	85 c0		 test	 eax, eax
  0006b	75 16		 jne	 SHORT $LN12@OLD_rtrim
$LN13@OLD_rtrim:
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _end$4[ebp]
  00070	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00073	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00076	74 0b		 je	 SHORT $LN12@OLD_rtrim
  00078	8b 45 fc	 mov	 eax, DWORD PTR _end$4[ebp]
  0007b	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0007e	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00081	75 16		 jne	 SHORT $LN11@OLD_rtrim
$LN12@OLD_rtrim:
  00083	8b 45 fc	 mov	 eax, DWORD PTR _end$4[ebp]
  00086	3b 45 08	 cmp	 eax, DWORD PTR _base$[ebp]
  00089	74 10		 je	 SHORT $LN10@OLD_rtrim
  0008b	8b 45 fc	 mov	 eax, DWORD PTR _end$4[ebp]
  0008e	0f b6 40 ff	 movzx	 eax, BYTE PTR [eax-1]
  00092	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  00097	7e 02		 jle	 SHORT $LN10@OLD_rtrim
$LN11@OLD_rtrim:

; 92   : 				break;

  00099	eb 1c		 jmp	 SHORT $LN3@OLD_rtrim
$LN10@OLD_rtrim:

; 93   : 			
; 94   : 			*end = '\0';

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _end$4[ebp]
  0009e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 95   : 			
; 96   : 			end = CharPrevExA(codePage, base, end, 0);

  000a1	6a 00		 push	 0
  000a3	ff 75 fc	 push	 DWORD PTR _end$4[ebp]
  000a6	ff 75 08	 push	 DWORD PTR _base$[ebp]
  000a9	ff 75 f4	 push	 DWORD PTR _codePage$[ebp]
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharPrevExA@16
  000b2	89 45 fc	 mov	 DWORD PTR _end$4[ebp], eax

; 97   : 		}

  000b5	eb 8b		 jmp	 SHORT $LN2@OLD_rtrim
$LN3@OLD_rtrim:

; 98   : 	}

  000b7	eb 73		 jmp	 SHORT $LN1@OLD_rtrim
$LN7@OLD_rtrim:

; 99   : 	else
; 100  : 	{
; 101  : 		char* end = base + strlen(base);

  000b9	ff 75 08	 push	 DWORD PTR _base$[ebp]
  000bc	e8 00 00 00 00	 call	 _strlen
  000c1	59		 pop	 ecx
  000c2	03 45 08	 add	 eax, DWORD PTR _base$[ebp]
  000c5	89 45 f0	 mov	 DWORD PTR _end$2[ebp], eax
$LN4@OLD_rtrim:

; 102  : 
; 103  : 		while (end != base)

  000c8	8b 45 f0	 mov	 eax, DWORD PTR _end$2[ebp]
  000cb	3b 45 08	 cmp	 eax, DWORD PTR _base$[ebp]
  000ce	74 5c		 je	 SHORT $LN1@OLD_rtrim

; 104  : 		{
; 105  : 			char* prev = CharPrevExA(codePage, base, end, 0);

  000d0	6a 00		 push	 0
  000d2	ff 75 f0	 push	 DWORD PTR _end$2[ebp]
  000d5	ff 75 08	 push	 DWORD PTR _base$[ebp]
  000d8	ff 75 f4	 push	 DWORD PTR _codePage$[ebp]
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharPrevExA@16
  000e1	89 45 f8	 mov	 DWORD PTR _prev$3[ebp], eax

; 106  : 
; 107  : 			int prev_len = end - prev;

  000e4	8b 45 f0	 mov	 eax, DWORD PTR _end$2[ebp]
  000e7	2b 45 f8	 sub	 eax, DWORD PTR _prev$3[ebp]
  000ea	89 45 ec	 mov	 DWORD PTR _prev_len$1[ebp], eax

; 108  : 			if (prev_len != 1)

  000ed	83 7d ec 01	 cmp	 DWORD PTR _prev_len$1[ebp], 1
  000f1	74 02		 je	 SHORT $LN14@OLD_rtrim

; 109  : 				break;

  000f3	eb 37		 jmp	 SHORT $LN1@OLD_rtrim
$LN14@OLD_rtrim:

; 110  : 
; 111  : 			if (!isspace((unsigned char) *prev) && *prev != '\n' && *prev != '\r')

  000f5	8b 45 f8	 mov	 eax, DWORD PTR _prev$3[ebp]
  000f8	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _isspace
  00101	59		 pop	 ecx
  00102	85 c0		 test	 eax, eax
  00104	75 18		 jne	 SHORT $LN15@OLD_rtrim
  00106	8b 45 f8	 mov	 eax, DWORD PTR _prev$3[ebp]
  00109	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0010c	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0010f	74 0d		 je	 SHORT $LN15@OLD_rtrim
  00111	8b 45 f8	 mov	 eax, DWORD PTR _prev$3[ebp]
  00114	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00117	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0011a	74 02		 je	 SHORT $LN15@OLD_rtrim

; 112  : 				break;				

  0011c	eb 0e		 jmp	 SHORT $LN1@OLD_rtrim
$LN15@OLD_rtrim:

; 113  : 			
; 114  : 			*prev = '\0';

  0011e	8b 45 f8	 mov	 eax, DWORD PTR _prev$3[ebp]
  00121	c6 00 00	 mov	 BYTE PTR [eax], 0

; 115  : 			
; 116  : 			end = prev;

  00124	8b 45 f8	 mov	 eax, DWORD PTR _prev$3[ebp]
  00127	89 45 f0	 mov	 DWORD PTR _end$2[ebp], eax

; 117  : 		}

  0012a	eb 9c		 jmp	 SHORT $LN4@OLD_rtrim
$LN1@OLD_rtrim:

; 118  : 	}
; 119  : }

  0012c	c9		 leave
  0012d	c3		 ret	 0
?OLD_rtrim@@YAXPAD@Z ENDP				; OLD_rtrim
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ?LocaleString_RightTrim@@YAXPAD@Z
_TEXT	SEGMENT
_base$ = 8						; size = 4
?LocaleString_RightTrim@@YAXPAD@Z PROC			; LocaleString_RightTrim, COMDAT

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 75   : 	LocaleString_RightTrim(base, strlen(base));

  00003	ff 75 08	 push	 DWORD PTR _base$[ebp]
  00006	e8 00 00 00 00	 call	 _strlen
  0000b	59		 pop	 ecx
  0000c	50		 push	 eax
  0000d	ff 75 08	 push	 DWORD PTR _base$[ebp]
  00010	e8 00 00 00 00	 call	 ?LocaleString_RightTrim@@YAHPADH@Z ; LocaleString_RightTrim
  00015	59		 pop	 ecx
  00016	59		 pop	 ecx

; 76   : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?LocaleString_RightTrim@@YAXPAD@Z ENDP			; LocaleString_RightTrim
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ?LocaleString_RightTrim@@YAHPADH@Z
_TEXT	SEGMENT
_codePage$ = -20					; size = 4
_prev_len$1 = -16					; size = 4
_cur$2 = -12						; size = 4
_prev$3 = -8						; size = 4
_pos$ = -4						; size = 4
_base$ = 8						; size = 4
_len$ = 12						; size = 4
?LocaleString_RightTrim@@YAHPADH@Z PROC			; LocaleString_RightTrim, COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 46   : 	DWORD codePage = GetDefaultCodePage();

  00006	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  0000b	89 45 ec	 mov	 DWORD PTR _codePage$[ebp], eax

; 47   : 
; 48   : 	int pos = len;

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00011	89 45 fc	 mov	 DWORD PTR _pos$[ebp], eax
$LN2@LocaleStri:

; 49   : 	
; 50   : 	while (pos > 0)

  00014	83 7d fc 00	 cmp	 DWORD PTR _pos$[ebp], 0
  00018	7e 68		 jle	 SHORT $LN3@LocaleStri

; 51   : 	{
; 52   : 		char* cur = base + pos;

  0001a	8b 45 08	 mov	 eax, DWORD PTR _base$[ebp]
  0001d	03 45 fc	 add	 eax, DWORD PTR _pos$[ebp]
  00020	89 45 f4	 mov	 DWORD PTR _cur$2[ebp], eax

; 53   : 		char* prev = CharPrevExA(codePage, base, cur , 0);

  00023	6a 00		 push	 0
  00025	ff 75 f4	 push	 DWORD PTR _cur$2[ebp]
  00028	ff 75 08	 push	 DWORD PTR _base$[ebp]
  0002b	ff 75 ec	 push	 DWORD PTR _codePage$[ebp]
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharPrevExA@16
  00034	89 45 f8	 mov	 DWORD PTR _prev$3[ebp], eax

; 54   : 		
; 55   : 		int prev_len = cur - prev;

  00037	8b 45 f4	 mov	 eax, DWORD PTR _cur$2[ebp]
  0003a	2b 45 f8	 sub	 eax, DWORD PTR _prev$3[ebp]
  0003d	89 45 f0	 mov	 DWORD PTR _prev_len$1[ebp], eax

; 56   : 		if (prev_len != 1)

  00040	83 7d f0 01	 cmp	 DWORD PTR _prev_len$1[ebp], 1
  00044	74 02		 je	 SHORT $LN4@LocaleStri

; 57   : 			break;

  00046	eb 3a		 jmp	 SHORT $LN3@LocaleStri
$LN4@LocaleStri:

; 58   : 		
; 59   : 		if (!isspace((unsigned char) *prev) && *prev != '\n' && *prev != '\r')

  00048	8b 45 f8	 mov	 eax, DWORD PTR _prev$3[ebp]
  0004b	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _isspace
  00054	59		 pop	 ecx
  00055	85 c0		 test	 eax, eax
  00057	75 18		 jne	 SHORT $LN5@LocaleStri
  00059	8b 45 f8	 mov	 eax, DWORD PTR _prev$3[ebp]
  0005c	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0005f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00062	74 0d		 je	 SHORT $LN5@LocaleStri
  00064	8b 45 f8	 mov	 eax, DWORD PTR _prev$3[ebp]
  00067	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0006a	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0006d	74 02		 je	 SHORT $LN5@LocaleStri

; 60   : 			break;				

  0006f	eb 11		 jmp	 SHORT $LN3@LocaleStri
$LN5@LocaleStri:

; 61   : 		
; 62   : 		*prev = '\0';

  00071	8b 45 f8	 mov	 eax, DWORD PTR _prev$3[ebp]
  00074	c6 00 00	 mov	 BYTE PTR [eax], 0

; 63   : 		
; 64   : 		pos -= prev_len;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  0007a	2b 45 f0	 sub	 eax, DWORD PTR _prev_len$1[ebp]
  0007d	89 45 fc	 mov	 DWORD PTR _pos$[ebp], eax

; 65   : 	}

  00080	eb 92		 jmp	 SHORT $LN2@LocaleStri
$LN3@LocaleStri:

; 66   : 
; 67   : 	if (pos > 0)

  00082	83 7d fc 00	 cmp	 DWORD PTR _pos$[ebp], 0
  00086	7e 05		 jle	 SHORT $LN6@LocaleStri

; 68   : 		return pos;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  0008b	eb 02		 jmp	 SHORT $LN1@LocaleStri
$LN6@LocaleStri:

; 69   : 
; 70   : 	return 0;

  0008d	33 c0		 xor	 eax, eax
$LN1@LocaleStri:

; 71   : }

  0008f	c9		 leave
  00090	c3		 ret	 0
?LocaleString_RightTrim@@YAHPADH@Z ENDP			; LocaleString_RightTrim
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ?LocaleString_FindChar@@YAPBDPBDHD@Z
_TEXT	SEGMENT
_next$1 = -20						; size = 4
_codePage$ = -16					; size = 4
_cur_len$2 = -12					; size = 4
_cur$3 = -8						; size = 4
_pos$ = -4						; size = 4
_base$ = 8						; size = 4
_len$ = 12						; size = 4
_test$ = 16						; size = 1
?LocaleString_FindChar@@YAPBDPBDHD@Z PROC		; LocaleString_FindChar, COMDAT

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 14   : 	if (!base)

  00006	83 7d 08 00	 cmp	 DWORD PTR _base$[ebp], 0
  0000a	75 04		 jne	 SHORT $LN4@LocaleStri

; 15   : 		return NULL;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 70		 jmp	 SHORT $LN1@LocaleStri
$LN4@LocaleStri:

; 16   : 
; 17   : 	DWORD codePage = GetDefaultCodePage();

  00010	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  00015	89 45 f0	 mov	 DWORD PTR _codePage$[ebp], eax

; 18   : 	
; 19   : 	int pos = 0;

  00018	83 65 fc 00	 and	 DWORD PTR _pos$[ebp], 0
$LN2@LocaleStri:

; 20   : 	while (pos < len)

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  0001f	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  00022	7d 5a		 jge	 SHORT $LN3@LocaleStri

; 21   : 	{
; 22   : 		const char* cur = base + pos;

  00024	8b 45 08	 mov	 eax, DWORD PTR _base$[ebp]
  00027	03 45 fc	 add	 eax, DWORD PTR _pos$[ebp]
  0002a	89 45 f8	 mov	 DWORD PTR _cur$3[ebp], eax

; 23   : 		const char* next = CharNextExA(codePage, cur, 0);

  0002d	6a 00		 push	 0
  0002f	ff 75 f8	 push	 DWORD PTR _cur$3[ebp]
  00032	ff 75 f0	 push	 DWORD PTR _codePage$[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextExA@12
  0003b	89 45 ec	 mov	 DWORD PTR _next$1[ebp], eax

; 24   : 		int cur_len = next - cur;

  0003e	8b 45 ec	 mov	 eax, DWORD PTR _next$1[ebp]
  00041	2b 45 f8	 sub	 eax, DWORD PTR _cur$3[ebp]
  00044	89 45 f4	 mov	 DWORD PTR _cur_len$2[ebp], eax

; 25   : 		if (cur_len > 1)

  00047	83 7d f4 01	 cmp	 DWORD PTR _cur_len$2[ebp], 1
  0004b	7e 0b		 jle	 SHORT $LN5@LocaleStri

; 26   : 		{
; 27   : 			pos += cur_len;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  00050	03 45 f4	 add	 eax, DWORD PTR _cur_len$2[ebp]
  00053	89 45 fc	 mov	 DWORD PTR _pos$[ebp], eax

; 28   : 		}

  00056	eb 24		 jmp	 SHORT $LN6@LocaleStri
$LN5@LocaleStri:

; 29   : 		else if (1 == cur_len)

  00058	83 7d f4 01	 cmp	 DWORD PTR _cur_len$2[ebp], 1
  0005c	75 1c		 jne	 SHORT $LN7@LocaleStri

; 30   : 		{
; 31   : 			if (*cur == test)

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _cur$3[ebp]
  00061	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00064	0f be 4d 10	 movsx	 ecx, BYTE PTR _test$[ebp]
  00068	3b c1		 cmp	 eax, ecx
  0006a	75 05		 jne	 SHORT $LN9@LocaleStri

; 32   : 				return cur;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _cur$3[ebp]
  0006f	eb 0f		 jmp	 SHORT $LN1@LocaleStri
$LN9@LocaleStri:

; 33   : 
; 34   : 			++pos;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]
  00074	40		 inc	 eax
  00075	89 45 fc	 mov	 DWORD PTR _pos$[ebp], eax

; 35   : 		}

  00078	eb 02		 jmp	 SHORT $LN6@LocaleStri
$LN7@LocaleStri:

; 36   : 		else
; 37   : 		{
; 38   : 			break;

  0007a	eb 02		 jmp	 SHORT $LN3@LocaleStri
$LN6@LocaleStri:

; 39   : 		}
; 40   : 	}

  0007c	eb 9e		 jmp	 SHORT $LN2@LocaleStri
$LN3@LocaleStri:

; 41   : 	return NULL;

  0007e	33 c0		 xor	 eax, eax
$LN1@LocaleStri:

; 42   : }

  00080	c9		 leave
  00081	c3		 ret	 0
?LocaleString_FindChar@@YAPBDPBDHD@Z ENDP		; LocaleString_FindChar
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -36					; size = 4
__Al$ = -32						; size = 4
__Alproxy$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Newhead$ = -8						; size = 4
__Overflow_is_possible$5 = -2				; size = 1
_$S12$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEXXZ PROC ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00009	8d 45 ff	 lea	 eax, DWORD PTR _$S12$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 fe 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	c7 45 dc 66 66
	66 06		 mov	 DWORD PTR __Max_possible$1[ebp], 107374182 ; 06666666H

; 60   :         if (_Count > _Max_possible) {

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	3d 66 66 66 06	 cmp	 eax, 107374182		; 06666666H
  0002e	76 05		 jbe	 SHORT $LN15@Alloc_sent

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00030	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN15@Alloc_sent:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	6b c0 28	 imul	 eax, eax, 40
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003e	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00041	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00046	59		 pop	 ecx
  00047	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1775 :         auto _Newhead = _Al.allocate(1);

  0004a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00050	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00053	50		 push	 eax
  00054	ff 75 f8	 push	 DWORD PTR __Newhead$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<script::SCmd,void *> *,std::_List_node<script::SCmd,void *> * &>
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0005e	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00061	50		 push	 eax
  00062	8b 45 f8	 mov	 eax, DWORD PTR __Newhead$[ebp]
  00065	83 c0 04	 add	 eax, 4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USCmd@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USCmd@script@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<script::SCmd,void *> *,std::_List_node<script::SCmd,void *> * &>
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
$LN18@Alloc_sent:

; 1779 :         _Proxy._Release();
; 1780 :     }

  00078	c9		 leave
  00079	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEXXZ ENDP ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Tidy@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Al$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEXXZ PROC ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 1437 :         auto& _Al      = _Getal();
; 1438 :         auto& _My_data = _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();
; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SCmd,void *>::_Free_non_head<std::allocator<std::_List_node<script::SCmd,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	ff 30		 push	 DWORD PTR [eax]
  0002f	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SCmd,void *>::_Freenode0<std::allocator<std::_List_node<script::SCmd,void *> > >
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 1442 :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Tidy@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEXXZ ENDP ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?clear@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAEXXZ PROC ; std::list<script::SCmd,std::allocator<script::SCmd> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1428 :         _My_data._Orphan_non_end();
; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SCmd,void *>::_Free_non_head<std::allocator<std::_List_node<script::SCmd,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00032	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00034	89 08		 mov	 DWORD PTR [eax], ecx

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00036	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1432 :         _My_data._Mysize        = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00046	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1433 :     }

  0004a	c9		 leave
  0004b	c3		 ret	 0
?clear@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAEXXZ ENDP ; std::list<script::SCmd,std::allocator<script::SCmd> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Unchecked_erase@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEPAU?$_List_node@USCmd@script@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
?_Unchecked_erase@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEPAU?$_List_node@USCmd@script@@PAX@2@QAU32@@Z PROC ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Unchecked_erase, COMDAT
; _this$ = ecx

; 1359 :     _Nodeptr _Unchecked_erase(const _Nodeptr _Pnode) noexcept { // erase element at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1360 :         const auto _Result = _Pnode->_Next;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1361 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1362 :         --_Mypair._Myval2._Mysize;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	48		 dec	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1363 :         _Pnode->_Prev->_Next = _Result;

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00027	89 08		 mov	 DWORD PTR [eax], ecx

; 1364 :         _Result->_Prev       = _Pnode->_Prev;

  00029	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0002f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1787 :         return _Mypair._Get_first();

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0003b	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00041	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00044	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00047	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 706  :         _Ptr->~_Uty();

  0004a	6a 00		 push	 0
  0004c	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004f	e8 00 00 00 00	 call	 ??_GSCmd@script@@QAEPAXI@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00054	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00057	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@std@@@?$_List_node@USCmd@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCmd@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SCmd,void *>::_Freenode0<std::allocator<std::_List_node<script::SCmd,void *> > >
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx

; 1365 :         _Node::_Freenode(_Getal(), _Pnode);
; 1366 :         return _Result;

  00061	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 1367 :     }

  00064	c9		 leave
  00065	c2 04 00	 ret	 4
?_Unchecked_erase@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEPAU?$_List_node@USCmd@script@@PAX@2@QAU32@@Z ENDP ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??0?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAE@XZ PROC ; std::list<script::SCmd,std::allocator<script::SCmd> >::list<script::SCmd,std::allocator<script::SCmd> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 805  :         _Alloc_sentinel_and_proxy();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEXXZ ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Alloc_sentinel_and_proxy

; 806  :     }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAE@XZ ENDP ; std::list<script::SCmd,std::allocator<script::SCmd> >::list<script::SCmd,std::allocator<script::SCmd> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T2 = -84						; size = 4
$T3 = -80						; size = 4
tv203 = -76						; size = 4
$T4 = -72						; size = 4
$T5 = -68						; size = 4
tv145 = -64						; size = 4
_next$6 = -60						; size = 4
_codePage$ = -56					; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
$T9 = -44						; size = 4
$T10 = -40						; size = 4
_pos$ = -36						; size = 4
_cur$11 = -32						; size = 4
_iCharLen$ = -28					; size = 4
_iValueLen$ = -24					; size = 4
_iNameLen$ = -20					; size = 4
_isValue$ = -14						; size = 1
_c$12 = -13						; size = 1
__$EHRec$ = -12						; size = 12
$T13 = 0						; size = 48
$T14 = 48						; size = 48
$T15 = 96						; size = 24
$T16 = 120						; size = 24
$T17 = 144						; size = 24
$T18 = 168						; size = 24
_szValue$ = 192						; size = 65
_szName$ = 260						; size = 33
__$ArrayPad$ = 296					; size = 4
_c_arg_base$ = 308					; size = 4
_arg_len$ = 312						; size = 4
_argList$ = 316						; size = 4
?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z PROC ; script::Group::GetArg, COMDAT
; _this$ = ecx

; 153  : {

  00000	55		 push	 ebp
  00001	8d ac 24 d4 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-300]
  00008	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 4c	 sub	 esp, 76			; 0000004cH
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 28 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx

; 154  :     char szName[32 + 1];
; 155  :     char szValue[64 + 1];
; 156  : 
; 157  :     int iNameLen = 0;

  00039	83 65 ec 00	 and	 DWORD PTR _iNameLen$[ebp], 0

; 158  :     int iValueLen = 0;

  0003d	83 65 e8 00	 and	 DWORD PTR _iValueLen$[ebp], 0

; 159  : 	int iCharLen = 0;

  00041	83 65 e4 00	 and	 DWORD PTR _iCharLen$[ebp], 0

; 160  : 
; 161  : 	int pos = 0;

  00045	83 65 dc 00	 and	 DWORD PTR _pos$[ebp], 0

; 162  : 
; 163  :     bool isValue = false;

  00049	c6 45 f2 00	 mov	 BYTE PTR _isValue$[ebp], 0

; 164  : 
; 165  : 	DWORD codePage = GetDefaultCodePage();

  0004d	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  00052	89 45 c8	 mov	 DWORD PTR _codePage$[ebp], eax
$LN2@GetArg:

; 166  : 
; 167  :     while (pos < arg_len)

  00055	8b 45 dc	 mov	 eax, DWORD PTR _pos$[ebp]
  00058	3b 85 38 01 00
	00		 cmp	 eax, DWORD PTR _arg_len$[ebp]
  0005e	0f 8d 13 03 00
	00		 jge	 $LN3@GetArg

; 168  :     {
; 169  : 		const char* cur = c_arg_base + pos;

  00064	8b 85 34 01 00
	00		 mov	 eax, DWORD PTR _c_arg_base$[ebp]
  0006a	03 45 dc	 add	 eax, DWORD PTR _pos$[ebp]
  0006d	89 45 e0	 mov	 DWORD PTR _cur$11[ebp], eax

; 170  : 		const char* next = CharNextExA(codePage, cur, 0); 

  00070	6a 00		 push	 0
  00072	ff 75 e0	 push	 DWORD PTR _cur$11[ebp]
  00075	ff 75 c8	 push	 DWORD PTR _codePage$[ebp]
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextExA@12
  0007e	89 45 c4	 mov	 DWORD PTR _next$6[ebp], eax

; 171  : 		iCharLen = next - cur;

  00081	8b 45 c4	 mov	 eax, DWORD PTR _next$6[ebp]
  00084	2b 45 e0	 sub	 eax, DWORD PTR _cur$11[ebp]
  00087	89 45 e4	 mov	 DWORD PTR _iCharLen$[ebp], eax

; 172  : 
; 173  : 		if (iCharLen > 1)

  0008a	83 7d e4 01	 cmp	 DWORD PTR _iCharLen$[ebp], 1
  0008e	0f 8e bf 00 00
	00		 jle	 $LN4@GetArg

; 174  : 		{
; 175  : 			if (isValue)

  00094	0f b6 45 f2	 movzx	 eax, BYTE PTR _isValue$[ebp]
  00098	85 c0		 test	 eax, eax
  0009a	74 5a		 je	 SHORT $LN6@GetArg

; 176  : 			{
; 177  : 				if (iValueLen >= 64)

  0009c	83 7d e8 40	 cmp	 DWORD PTR _iValueLen$[ebp], 64 ; 00000040H
  000a0	7c 12		 jl	 SHORT $LN8@GetArg

; 178  : 				{
; 179  : 					TraceError("argument value overflow: must be shorter than 64 letters");

  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@OGJKDJPN@argument?5value?5overflow?3?5must?5b@
  000a7	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000ac	59		 pop	 ecx

; 180  : 					return false;

  000ad	32 c0		 xor	 al, al
  000af	e9 8f 03 00 00	 jmp	 $LN27@GetArg
$LN8@GetArg:

; 181  : 				}
; 182  : 
; 183  : 				memcpy(szValue+iValueLen, cur, iCharLen);                

  000b4	ff 75 e4	 push	 DWORD PTR _iCharLen$[ebp]
  000b7	ff 75 e0	 push	 DWORD PTR _cur$11[ebp]
  000ba	8b 45 e8	 mov	 eax, DWORD PTR _iValueLen$[ebp]
  000bd	8d 84 05 c0 00
	00 00		 lea	 eax, DWORD PTR _szValue$[ebp+eax]
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 _memcpy
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 				iValueLen += iCharLen;

  000cd	8b 45 e8	 mov	 eax, DWORD PTR _iValueLen$[ebp]
  000d0	03 45 e4	 add	 eax, DWORD PTR _iCharLen$[ebp]
  000d3	89 45 e8	 mov	 DWORD PTR _iValueLen$[ebp], eax

; 185  : 				szValue[iValueLen] = '\0';

  000d6	8b 45 e8	 mov	 eax, DWORD PTR _iValueLen$[ebp]
  000d9	89 45 d8	 mov	 DWORD PTR $T10[ebp], eax
  000dc	83 7d d8 41	 cmp	 DWORD PTR $T10[ebp], 65	; 00000041H
  000e0	73 02		 jae	 SHORT $LN28@GetArg
  000e2	eb 05		 jmp	 SHORT $LN29@GetArg
$LN28@GetArg:
  000e4	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN29@GetArg:
  000e9	8b 45 d8	 mov	 eax, DWORD PTR $T10[ebp]
  000ec	c6 84 05 c0 00
	00 00 00	 mov	 BYTE PTR _szValue$[ebp+eax], 0

; 186  : 			}

  000f4	eb 58		 jmp	 SHORT $LN7@GetArg
$LN6@GetArg:

; 187  : 			else
; 188  : 			{
; 189  : 				if (iNameLen >= 32)

  000f6	83 7d ec 20	 cmp	 DWORD PTR _iNameLen$[ebp], 32 ; 00000020H
  000fa	7c 12		 jl	 SHORT $LN9@GetArg

; 190  : 				{
; 191  : 					TraceError("argument name overflow: must be shorter than 32 letters");

  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HBCKLDEP@argument?5name?5overflow?3?5must?5be@
  00101	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00106	59		 pop	 ecx

; 192  : 					return false;

  00107	32 c0		 xor	 al, al
  00109	e9 35 03 00 00	 jmp	 $LN27@GetArg
$LN9@GetArg:

; 193  : 				}
; 194  : 				memcpy(szName+iNameLen, cur, iCharLen);				                

  0010e	ff 75 e4	 push	 DWORD PTR _iCharLen$[ebp]
  00111	ff 75 e0	 push	 DWORD PTR _cur$11[ebp]
  00114	8b 45 ec	 mov	 eax, DWORD PTR _iNameLen$[ebp]
  00117	8d 84 05 04 01
	00 00		 lea	 eax, DWORD PTR _szName$[ebp+eax]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _memcpy
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH

; 195  : 				iNameLen += iCharLen;

  00127	8b 45 ec	 mov	 eax, DWORD PTR _iNameLen$[ebp]
  0012a	03 45 e4	 add	 eax, DWORD PTR _iCharLen$[ebp]
  0012d	89 45 ec	 mov	 DWORD PTR _iNameLen$[ebp], eax

; 196  : 				szName[iNameLen] = '\0';

  00130	8b 45 ec	 mov	 eax, DWORD PTR _iNameLen$[ebp]
  00133	89 45 d4	 mov	 DWORD PTR $T9[ebp], eax
  00136	83 7d d4 21	 cmp	 DWORD PTR $T9[ebp], 33	; 00000021H
  0013a	73 02		 jae	 SHORT $LN30@GetArg
  0013c	eb 05		 jmp	 SHORT $LN31@GetArg
$LN30@GetArg:
  0013e	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN31@GetArg:
  00143	8b 45 d4	 mov	 eax, DWORD PTR $T9[ebp]
  00146	c6 84 05 04 01
	00 00 00	 mov	 BYTE PTR _szName$[ebp+eax], 0
$LN7@GetArg:

; 197  : 			}
; 198  : 		}

  0014e	e9 16 02 00 00	 jmp	 $LN5@GetArg
$LN4@GetArg:

; 199  : 		else if (iCharLen == 1)

  00153	83 7d e4 01	 cmp	 DWORD PTR _iCharLen$[ebp], 1
  00157	0f 85 0a 02 00
	00		 jne	 $LN10@GetArg

; 200  : 		{
; 201  : 			const char c = *cur;

  0015d	8b 45 e0	 mov	 eax, DWORD PTR _cur$11[ebp]
  00160	8a 00		 mov	 al, BYTE PTR [eax]
  00162	88 45 f3	 mov	 BYTE PTR _c$12[ebp], al

; 202  : 			if (c == '|')

  00165	0f be 45 f3	 movsx	 eax, BYTE PTR _c$12[ebp]
  00169	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  0016c	0f 85 ee 00 00
	00		 jne	 $LN12@GetArg

; 203  : 			{
; 204  : 				if (iNameLen == 0)

  00172	83 7d ec 00	 cmp	 DWORD PTR _iNameLen$[ebp], 0
  00176	75 12		 jne	 SHORT $LN14@GetArg

; 205  : 				{
; 206  : 					TraceError("no argument name");

  00178	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DGGADPCI@no?5argument?5name@
  0017d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00182	59		 pop	 ecx

; 207  : 					return false;

  00183	32 c0		 xor	 al, al
  00185	e9 b9 02 00 00	 jmp	 $LN27@GetArg
$LN14@GetArg:

; 208  : 				}
; 209  : 
; 210  : 				isValue = false;

  0018a	c6 45 f2 00	 mov	 BYTE PTR _isValue$[ebp], 0

; 211  : 
; 212  : 				iNameLen = LocaleString_RightTrim(szName, iNameLen);

  0018e	ff 75 ec	 push	 DWORD PTR _iNameLen$[ebp]
  00191	8d 85 04 01 00
	00		 lea	 eax, DWORD PTR _szName$[ebp]
  00197	50		 push	 eax
  00198	e8 00 00 00 00	 call	 ?LocaleString_RightTrim@@YAHPADH@Z ; LocaleString_RightTrim
  0019d	59		 pop	 ecx
  0019e	59		 pop	 ecx
  0019f	89 45 ec	 mov	 DWORD PTR _iNameLen$[ebp], eax

; 213  : 				iValueLen = LocaleString_RightTrim(szValue, iValueLen);

  001a2	ff 75 e8	 push	 DWORD PTR _iValueLen$[ebp]
  001a5	8d 85 c0 00 00
	00		 lea	 eax, DWORD PTR _szValue$[ebp]
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 ?LocaleString_RightTrim@@YAHPADH@Z ; LocaleString_RightTrim
  001b1	59		 pop	 ecx
  001b2	59		 pop	 ecx
  001b3	89 45 e8	 mov	 DWORD PTR _iValueLen$[ebp], eax

; 214  : 				argList.push_back(TArg(szName, szValue));

  001b6	8d 85 c0 00 00
	00		 lea	 eax, DWORD PTR _szValue$[ebp]
  001bc	50		 push	 eax
  001bd	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR $T17[ebp]
  001c3	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001c8	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  001cc	8d 85 04 01 00
	00		 lea	 eax, DWORD PTR _szName$[ebp]
  001d2	50		 push	 eax
  001d3	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR $T18[ebp]
  001d9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001de	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  001e2	8d 85 90 00 00
	00		 lea	 eax, DWORD PTR $T17[ebp]
  001e8	50		 push	 eax
  001e9	8d 85 a8 00 00
	00		 lea	 eax, DWORD PTR $T18[ebp]
  001ef	50		 push	 eax
  001f0	8d 4d 30	 lea	 ecx, DWORD PTR $T14[ebp]
  001f3	e8 00 00 00 00	 call	 ??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; script::SArgumet::SArgumet
  001f8	89 45 c0	 mov	 DWORD PTR tv145[ebp], eax
  001fb	8b 45 c0	 mov	 eax, DWORD PTR tv145[ebp]
  001fe	89 45 bc	 mov	 DWORD PTR $T5[ebp], eax
  00201	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00205	8b 45 bc	 mov	 eax, DWORD PTR $T5[ebp]
  00208	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 973  :         _Emplace(_Mypair._Myval2._Myhead, _STD move(_Val));

  0020b	ff 75 b8	 push	 DWORD PTR $T4[ebp]
  0020e	8b 85 3c 01 00
	00		 mov	 eax, DWORD PTR _argList$[ebp]
  00214	ff 30		 push	 DWORD PTR [eax]
  00216	8b 8d 3c 01 00
	00		 mov	 ecx, DWORD PTR _argList$[ebp]
  0021c	e8 00 00 00 00	 call	 ??$_Emplace@USArgumet@script@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@QAU21@$$QAUSArgumet@script@@@Z ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Emplace<script::SArgumet>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 214  : 				argList.push_back(TArg(szName, szValue));

  00221	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00225	8d 4d 48	 lea	 ecx, DWORD PTR $T14[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00228	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0022d	8d 4d 30	 lea	 ecx, DWORD PTR $T14[ebp]
  00230	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 214  : 				argList.push_back(TArg(szName, szValue));

  00235	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00239	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR $T18[ebp]
  0023f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 214  : 				argList.push_back(TArg(szName, szValue));

  00244	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00248	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR $T17[ebp]
  0024e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 216  : 				iNameLen = 0;

  00253	83 65 ec 00	 and	 DWORD PTR _iNameLen$[ebp], 0

; 217  : 				iValueLen = 0;

  00257	83 65 e8 00	 and	 DWORD PTR _iValueLen$[ebp], 0

; 218  : 			}

  0025b	e9 05 01 00 00	 jmp	 $LN13@GetArg
$LN12@GetArg:

; 219  : 			else if (c == ';')

  00260	0f be 45 f3	 movsx	 eax, BYTE PTR _c$12[ebp]
  00264	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00267	75 09		 jne	 SHORT $LN15@GetArg

; 220  : 			{
; 221  : 				isValue = true;

  00269	c6 45 f2 01	 mov	 BYTE PTR _isValue$[ebp], 1

; 222  : 			}

  0026d	e9 f3 00 00 00	 jmp	 $LN13@GetArg
$LN15@GetArg:

; 223  : 			//  ,       .
; 224  : 			else if (!isValue && iNameLen == 0 && isspace((unsigned char) c))

  00272	0f b6 45 f2	 movzx	 eax, BYTE PTR _isValue$[ebp]
  00276	85 c0		 test	 eax, eax
  00278	75 1a		 jne	 SHORT $LN17@GetArg
  0027a	83 7d ec 00	 cmp	 DWORD PTR _iNameLen$[ebp], 0
  0027e	75 14		 jne	 SHORT $LN17@GetArg
  00280	0f b6 45 f3	 movzx	 eax, BYTE PTR _c$12[ebp]
  00284	50		 push	 eax
  00285	e8 00 00 00 00	 call	 _isspace
  0028a	59		 pop	 ecx
  0028b	85 c0		 test	 eax, eax
  0028d	74 05		 je	 SHORT $LN17@GetArg

; 225  : 			{
; 226  : 			}

  0028f	e9 d1 00 00 00	 jmp	 $LN13@GetArg
$LN17@GetArg:

; 227  : 			//   
; 228  : 			else if (c == '\r' || c == '\n')

  00294	0f be 45 f3	 movsx	 eax, BYTE PTR _c$12[ebp]
  00298	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0029b	74 09		 je	 SHORT $LN21@GetArg
  0029d	0f be 45 f3	 movsx	 eax, BYTE PTR _c$12[ebp]
  002a1	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  002a4	75 05		 jne	 SHORT $LN19@GetArg
$LN21@GetArg:

; 229  : 			{
; 230  : 			}

  002a6	e9 ba 00 00 00	 jmp	 $LN13@GetArg
$LN19@GetArg:

; 231  : 			else
; 232  : 			{
; 233  : 				if (isValue)

  002ab	0f b6 45 f2	 movzx	 eax, BYTE PTR _isValue$[ebp]
  002af	85 c0		 test	 eax, eax
  002b1	74 5a		 je	 SHORT $LN22@GetArg

; 234  : 				{
; 235  : 					if (iValueLen >= 64)

  002b3	83 7d e8 40	 cmp	 DWORD PTR _iValueLen$[ebp], 64 ; 00000040H
  002b7	7c 12		 jl	 SHORT $LN24@GetArg

; 236  : 					{
; 237  : 						TraceError("argument value overflow: must be shorter than 64 letters");

  002b9	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@OGJKDJPN@argument?5value?5overflow?3?5must?5b@
  002be	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  002c3	59		 pop	 ecx

; 238  : 						return false;

  002c4	32 c0		 xor	 al, al
  002c6	e9 78 01 00 00	 jmp	 $LN27@GetArg
$LN24@GetArg:

; 239  : 					}
; 240  : 
; 241  : 					memcpy(szValue+iValueLen, cur, iCharLen);                

  002cb	ff 75 e4	 push	 DWORD PTR _iCharLen$[ebp]
  002ce	ff 75 e0	 push	 DWORD PTR _cur$11[ebp]
  002d1	8b 45 e8	 mov	 eax, DWORD PTR _iValueLen$[ebp]
  002d4	8d 84 05 c0 00
	00 00		 lea	 eax, DWORD PTR _szValue$[ebp+eax]
  002db	50		 push	 eax
  002dc	e8 00 00 00 00	 call	 _memcpy
  002e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 242  : 					iValueLen += iCharLen;

  002e4	8b 45 e8	 mov	 eax, DWORD PTR _iValueLen$[ebp]
  002e7	03 45 e4	 add	 eax, DWORD PTR _iCharLen$[ebp]
  002ea	89 45 e8	 mov	 DWORD PTR _iValueLen$[ebp], eax

; 243  : 					szValue[iValueLen]        = '\0';

  002ed	8b 45 e8	 mov	 eax, DWORD PTR _iValueLen$[ebp]
  002f0	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax
  002f3	83 7d d0 41	 cmp	 DWORD PTR $T8[ebp], 65	; 00000041H
  002f7	73 02		 jae	 SHORT $LN32@GetArg
  002f9	eb 05		 jmp	 SHORT $LN33@GetArg
$LN32@GetArg:
  002fb	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN33@GetArg:
  00300	8b 45 d0	 mov	 eax, DWORD PTR $T8[ebp]
  00303	c6 84 05 c0 00
	00 00 00	 mov	 BYTE PTR _szValue$[ebp+eax], 0

; 244  : 				}

  0030b	eb 58		 jmp	 SHORT $LN13@GetArg
$LN22@GetArg:

; 245  : 				else
; 246  : 				{
; 247  : 					if (iNameLen >= 32)

  0030d	83 7d ec 20	 cmp	 DWORD PTR _iNameLen$[ebp], 32 ; 00000020H
  00311	7c 12		 jl	 SHORT $LN25@GetArg

; 248  : 					{
; 249  : 						TraceError("argument name overflow: must be shorter than 32 letters");

  00313	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HBCKLDEP@argument?5name?5overflow?3?5must?5be@
  00318	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0031d	59		 pop	 ecx

; 250  : 						return false;

  0031e	32 c0		 xor	 al, al
  00320	e9 1e 01 00 00	 jmp	 $LN27@GetArg
$LN25@GetArg:

; 251  : 					}
; 252  : 					memcpy(szName+iNameLen, cur, iCharLen);				                

  00325	ff 75 e4	 push	 DWORD PTR _iCharLen$[ebp]
  00328	ff 75 e0	 push	 DWORD PTR _cur$11[ebp]
  0032b	8b 45 ec	 mov	 eax, DWORD PTR _iNameLen$[ebp]
  0032e	8d 84 05 04 01
	00 00		 lea	 eax, DWORD PTR _szName$[ebp+eax]
  00335	50		 push	 eax
  00336	e8 00 00 00 00	 call	 _memcpy
  0033b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 253  : 					iNameLen += iCharLen;

  0033e	8b 45 ec	 mov	 eax, DWORD PTR _iNameLen$[ebp]
  00341	03 45 e4	 add	 eax, DWORD PTR _iCharLen$[ebp]
  00344	89 45 ec	 mov	 DWORD PTR _iNameLen$[ebp], eax

; 254  : 					szName[iNameLen]        = '\0';

  00347	8b 45 ec	 mov	 eax, DWORD PTR _iNameLen$[ebp]
  0034a	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax
  0034d	83 7d cc 21	 cmp	 DWORD PTR $T7[ebp], 33	; 00000021H
  00351	73 02		 jae	 SHORT $LN34@GetArg
  00353	eb 05		 jmp	 SHORT $LN35@GetArg
$LN34@GetArg:
  00355	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN35@GetArg:
  0035a	8b 45 cc	 mov	 eax, DWORD PTR $T7[ebp]
  0035d	c6 84 05 04 01
	00 00 00	 mov	 BYTE PTR _szName$[ebp+eax], 0
$LN13@GetArg:

; 255  : 				}				
; 256  : 			}
; 257  : 		}

  00365	eb 02		 jmp	 SHORT $LN5@GetArg
$LN10@GetArg:

; 258  : 		else
; 259  : 		{
; 260  : 			break;

  00367	eb 0e		 jmp	 SHORT $LN3@GetArg
$LN5@GetArg:

; 261  : 		}
; 262  : 
; 263  : 		pos += iCharLen;

  00369	8b 45 dc	 mov	 eax, DWORD PTR _pos$[ebp]
  0036c	03 45 e4	 add	 eax, DWORD PTR _iCharLen$[ebp]
  0036f	89 45 dc	 mov	 DWORD PTR _pos$[ebp], eax

; 264  :     }

  00372	e9 de fc ff ff	 jmp	 $LN2@GetArg
$LN3@GetArg:

; 265  : 
; 266  :     if (iNameLen != 0 && iValueLen != 0)

  00377	83 7d ec 00	 cmp	 DWORD PTR _iNameLen$[ebp], 0
  0037b	0f 84 c0 00 00
	00		 je	 $LN26@GetArg
  00381	83 7d e8 00	 cmp	 DWORD PTR _iValueLen$[ebp], 0
  00385	0f 84 b6 00 00
	00		 je	 $LN26@GetArg

; 267  :     {
; 268  : 		iNameLen = LocaleString_RightTrim(szName, iNameLen);

  0038b	ff 75 ec	 push	 DWORD PTR _iNameLen$[ebp]
  0038e	8d 85 04 01 00
	00		 lea	 eax, DWORD PTR _szName$[ebp]
  00394	50		 push	 eax
  00395	e8 00 00 00 00	 call	 ?LocaleString_RightTrim@@YAHPADH@Z ; LocaleString_RightTrim
  0039a	59		 pop	 ecx
  0039b	59		 pop	 ecx
  0039c	89 45 ec	 mov	 DWORD PTR _iNameLen$[ebp], eax

; 269  : 		iValueLen = LocaleString_RightTrim(szValue, iValueLen);

  0039f	ff 75 e8	 push	 DWORD PTR _iValueLen$[ebp]
  003a2	8d 85 c0 00 00
	00		 lea	 eax, DWORD PTR _szValue$[ebp]
  003a8	50		 push	 eax
  003a9	e8 00 00 00 00	 call	 ?LocaleString_RightTrim@@YAHPADH@Z ; LocaleString_RightTrim
  003ae	59		 pop	 ecx
  003af	59		 pop	 ecx
  003b0	89 45 e8	 mov	 DWORD PTR _iValueLen$[ebp], eax

; 270  :         argList.push_back(TArg(szName, szValue));

  003b3	8d 85 c0 00 00
	00		 lea	 eax, DWORD PTR _szValue$[ebp]
  003b9	50		 push	 eax
  003ba	8d 4d 60	 lea	 ecx, DWORD PTR $T15[ebp]
  003bd	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003c2	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  003c9	8d 85 04 01 00
	00		 lea	 eax, DWORD PTR _szName$[ebp]
  003cf	50		 push	 eax
  003d0	8d 4d 78	 lea	 ecx, DWORD PTR $T16[ebp]
  003d3	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003d8	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  003dc	8d 45 60	 lea	 eax, DWORD PTR $T15[ebp]
  003df	50		 push	 eax
  003e0	8d 45 78	 lea	 eax, DWORD PTR $T16[ebp]
  003e3	50		 push	 eax
  003e4	8d 4d 00	 lea	 ecx, DWORD PTR $T13[ebp]
  003e7	e8 00 00 00 00	 call	 ??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; script::SArgumet::SArgumet
  003ec	89 45 b4	 mov	 DWORD PTR tv203[ebp], eax
  003ef	8b 45 b4	 mov	 eax, DWORD PTR tv203[ebp]
  003f2	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
  003f5	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003f9	8b 45 b0	 mov	 eax, DWORD PTR $T3[ebp]
  003fc	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 973  :         _Emplace(_Mypair._Myval2._Myhead, _STD move(_Val));

  003ff	ff 75 ac	 push	 DWORD PTR $T2[ebp]
  00402	8b 85 3c 01 00
	00		 mov	 eax, DWORD PTR _argList$[ebp]
  00408	ff 30		 push	 DWORD PTR [eax]
  0040a	8b 8d 3c 01 00
	00		 mov	 ecx, DWORD PTR _argList$[ebp]
  00410	e8 00 00 00 00	 call	 ??$_Emplace@USArgumet@script@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@QAU21@$$QAUSArgumet@script@@@Z ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Emplace<script::SArgumet>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 270  :         argList.push_back(TArg(szName, szValue));

  00415	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00419	8d 4d 18	 lea	 ecx, DWORD PTR $T13[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0041c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00421	8d 4d 00	 lea	 ecx, DWORD PTR $T13[ebp]
  00424	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 270  :         argList.push_back(TArg(szName, szValue));

  00429	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0042d	8d 4d 78	 lea	 ecx, DWORD PTR $T16[ebp]
  00430	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 270  :         argList.push_back(TArg(szName, szValue));

  00435	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00439	8d 4d 60	 lea	 ecx, DWORD PTR $T15[ebp]
  0043c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN26@GetArg:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 273  :     return true;

  00441	b0 01		 mov	 al, 1
$LN27@GetArg:

; 274  : }

  00443	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00446	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0044d	59		 pop	 ecx
  0044e	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00454	33 cd		 xor	 ecx, ebp
  00456	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045b	81 c5 2c 01 00
	00		 add	 ebp, 300		; 0000012cH
  00461	c9		 leave
  00462	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z$0:
  00000	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR $T17[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z$1:
  0000b	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR $T18[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z$2:
  00016	8d 4d 30	 lea	 ecx, DWORD PTR $T14[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1SArgumet@script@@QAE@XZ
__unwindfunclet$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z$3:
  0001e	8d 4d 60	 lea	 ecx, DWORD PTR $T15[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z$4:
  00026	8d 4d 78	 lea	 ecx, DWORD PTR $T16[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z$5:
  0002e	8d 4d 00	 lea	 ecx, DWORD PTR $T13[ebp]
  00031	e9 00 00 00 00	 jmp	 ??1SArgumet@script@@QAE@XZ
  00036	cc		 int	 3
  00037	cc		 int	 3
  00038	cc		 int	 3
  00039	cc		 int	 3
  0003a	cc		 int	 3
__ehhandler$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z:
  0003b	90		 npad	 1
  0003c	90		 npad	 1
  0003d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00041	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00044	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00047	33 c8		 xor	 ecx, eax
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b 8a 34 01 00
	00		 mov	 ecx, DWORD PTR [edx+308]
  00054	33 c8		 xor	 ecx, eax
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z
  00060	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ENDP ; script::Group::GetArg
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ?SetError@Group@script@@AAEXPBD@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
_c_pszError$ = 8					; size = 4
?SetError@Group@script@@AAEXPBD@Z PROC			; script::Group::SetError, COMDAT
; _this$ = ecx

; 433  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	ff 75 08	 push	 DWORD PTR _c_pszError$[ebp]
  0000c	e8 00 00 00 00	 call	 _strlen
  00011	59		 pop	 ecx
  00012	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00015	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001b	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0001e	ff 75 08	 push	 DWORD PTR _c_pszError$[ebp]
  00021	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 435  : }

  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
?SetError@Group@script@@AAEXPBD@Z ENDP			; script::Group::SetError
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ?GetError@Group@script@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetError@Group@script@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; script::Group::GetError, COMDAT
; _this$ = ecx

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 429  :     return m_stError;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 430  : }

  0000a	c9		 leave
  0000b	c3		 ret	 0
?GetError@Group@script@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; script::Group::GetError
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ?ReadCmd@Group@script@@QAE_NAAUSCmd@2@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
_this$ = -12						; size = 4
tv78 = -8						; size = 4
$T2 = -1						; size = 1
_cmd$ = 8						; size = 4
?ReadCmd@Group@script@@QAE_NAAUSCmd@2@@Z PROC		; script::Group::ReadCmd, COMDAT
; _this$ = ecx

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1200 :         return _Mypair._Myval2._Mysize == 0;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00010	75 09		 jne	 SHORT $LN6@ReadCmd
  00012	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN7@ReadCmd
$LN6@ReadCmd:
  0001b	83 65 f8 00	 and	 DWORD PTR tv78[ebp], 0
$LN7@ReadCmd:
  0001f	8a 45 f8	 mov	 al, BYTE PTR tv78[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T2[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 420  :     if (m_cmdList.empty())

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 04		 je	 SHORT $LN2@ReadCmd

; 421  :         return false;

  0002d	32 c0		 xor	 al, al
  0002f	eb 1b		 jmp	 SHORT $LN1@ReadCmd
$LN2@ReadCmd:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1212 :         return _Mypair._Myval2._Myhead->_Next->_Myval;

  00031	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	83 c0 08	 add	 eax, 8
  0003c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 423  :     cmd = m_cmdList.front();

  0003f	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _cmd$[ebp]
  00045	e8 00 00 00 00	 call	 ??4SCmd@script@@QAEXABU01@@Z ; script::SCmd::operator=

; 424  :     return true;

  0004a	b0 01		 mov	 al, 1
$LN1@ReadCmd:

; 425  : }

  0004c	c9		 leave
  0004d	c2 04 00	 ret	 4
?ReadCmd@Group@script@@QAE_NAAUSCmd@2@@Z ENDP		; script::Group::ReadCmd
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ?GetCmd@Group@script@@QAE_NAAUSCmd@2@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
_this$ = -16						; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -1						; size = 1
_cmd$ = 8						; size = 4
?GetCmd@Group@script@@QAE_NAAUSCmd@2@@Z PROC		; script::Group::GetCmd, COMDAT
; _this$ = ecx

; 409  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1200 :         return _Mypair._Myval2._Mysize == 0;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00010	75 09		 jne	 SHORT $LN6@GetCmd
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN7@GetCmd
$LN6@GetCmd:
  0001b	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN7@GetCmd:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T2[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 410  :     if (m_cmdList.empty())

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 04		 je	 SHORT $LN2@GetCmd

; 411  :         return false;

  0002d	32 c0		 xor	 al, al
  0002f	eb 33		 jmp	 SHORT $LN1@GetCmd
$LN2@GetCmd:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1212 :         return _Mypair._Myval2._Myhead->_Next->_Myval;

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	83 c0 08	 add	 eax, 8
  0003c	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 413  :     cmd = m_cmdList.front();

  0003f	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _cmd$[ebp]
  00045	e8 00 00 00 00	 call	 ??4SCmd@script@@QAEXABU01@@Z ; script::SCmd::operator=

; 414  :     m_cmdList.pop_front();

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 18	 add	 eax, 24			; 00000018H
  00050	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1248 :         _Unchecked_erase(_Mypair._Myval2._Myhead->_Next);

  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 00		 mov	 eax, DWORD PTR [eax]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEPAU?$_List_node@USCmd@script@@PAX@2@QAU32@@Z ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Unchecked_erase
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 415  :     return true;

  00062	b0 01		 mov	 al, 1
$LN1@GetCmd:

; 416  : }

  00064	c9		 leave
  00065	c2 04 00	 ret	 4
?GetCmd@Group@script@@QAE_NAAUSCmd@2@@Z ENDP		; script::Group::GetCmd
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T2 = -192						; size = 1
$T3 = -188						; size = 4
__ULast$4 = -184					; size = 4
__Last$ = -180						; size = 4
__First$ = -176						; size = 4
$T5 = -172						; size = 4
$T6 = -168						; size = 4
$T7 = -164						; size = 4
$T8 = -160						; size = 4
tv234 = -156						; size = 4
$T9 = -152						; size = 4
$T10 = -148						; size = 4
$T11 = -144						; size = 4
$T12 = -140						; size = 4
_space_next$13 = -136					; size = 4
_name_len$14 = -132					; size = 4
_data_end$15 = -128					; size = 4
$T16 = -124						; size = 4
$T17 = -120						; size = 4
tv142 = -116						; size = 4
$T18 = -112						; size = 4
$T19 = -108						; size = 4
_this$ = -104						; size = 4
_this$ = -100						; size = 4
_arg_len$20 = -96					; size = 4
$T21 = -92						; size = 4
_data_begin$22 = -88					; size = 4
_str_len$ = -84						; size = 4
_this$ = -80						; size = 4
__UFirst$23 = -76					; size = 4
_word_next$24 = -72					; size = 4
tv300 = -68						; size = 4
_arg$25 = -64						; size = 4
_space$26 = -60						; size = 4
_box_end$27 = -56					; size = 4
_word_len$28 = -52					; size = 4
_cur$29 = -48						; size = 1
_codePage$ = -44					; size = 4
_box_begin$30 = -40					; size = 4
_word$31 = -36						; size = 4
_this$ = -32						; size = 4
_str_base$ = -28					; size = 4
$T32 = -24						; size = 1
$T33 = -23						; size = 1
$T34 = -22						; size = 1
$T35 = -21						; size = 1
_data_len$36 = -20					; size = 4
_str_pos$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T37 = 0						; size = 48
$T38 = 48						; size = 48
$T39 = 96						; size = 24
$T40 = 120						; size = 24
_cmd$41 = 144						; size = 32
_box_data$ = 176					; size = 1025
__$ArrayPad$ = 1204					; size = 4
_stSource$ = 1216					; size = 4
?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; script::Group::Create, COMDAT
; _this$ = ecx

; 278  : {

  00000	55		 push	 ebp
  00001	8d ac 24 48 fb
	ff ff		 lea	 ebp, DWORD PTR [esp-1208]
  00008	81 ec b8 04 00
	00		 sub	 esp, 1208		; 000004b8H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 85 b4 04 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 	m_cmdList.clear();

  0003c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	83 c1 18	 add	 ecx, 24			; 00000018H
  00042	e8 00 00 00 00	 call	 ?clear@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAEXXZ ; std::list<script::SCmd,std::allocator<script::SCmd> >::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  00047	8b 85 c0 04 00
	00		 mov	 eax, DWORD PTR _stSource$[ebp]
  0004d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00050	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax

; 3848 :         return size() == 0;

  00056	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR $T11[ebp], 0
  0005d	75 09		 jne	 SHORT $LN44@Create
  0005f	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR tv300[ebp], 1
  00066	eb 04		 jmp	 SHORT $LN45@Create
$LN44@Create:
  00068	83 65 bc 00	 and	 DWORD PTR tv300[ebp], 0
$LN45@Create:
  0006c	8a 45 bc	 mov	 al, BYTE PTR tv300[ebp]
  0006f	88 45 eb	 mov	 BYTE PTR $T35[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 281  : 	if (stSource.empty())

  00072	0f b6 45 eb	 movzx	 eax, BYTE PTR $T35[ebp]
  00076	85 c0		 test	 eax, eax
  00078	74 07		 je	 SHORT $LN5@Create

; 282  : 		return false;

  0007a	32 c0		 xor	 al, al
  0007c	e9 d0 05 00 00	 jmp	 $LN22@Create
$LN5@Create:

; 283  : 
; 284  :     const char *str_base = stSource.c_str();

  00081	8b 8d c0 04 00
	00		 mov	 ecx, DWORD PTR _stSource$[ebp]
  00087	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0008c	89 45 e4	 mov	 DWORD PTR _str_base$[ebp], eax

; 285  :     if (!str_base || !*str_base)

  0008f	83 7d e4 00	 cmp	 DWORD PTR _str_base$[ebp], 0
  00093	74 0a		 je	 SHORT $LN7@Create
  00095	8b 45 e4	 mov	 eax, DWORD PTR _str_base$[ebp]
  00098	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0009b	85 c0		 test	 eax, eax
  0009d	75 12		 jne	 SHORT $LN6@Create
$LN7@Create:

; 286  :     {
; 287  :         TraceError("Source file has no content");

  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LOKOGIPA@Source?5file?5has?5no?5content@
  000a4	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000a9	59		 pop	 ecx

; 288  :         return false;

  000aa	32 c0		 xor	 al, al
  000ac	e9 a0 05 00 00	 jmp	 $LN22@Create
$LN6@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  000b1	8b 85 c0 04 00
	00		 mov	 eax, DWORD PTR _stSource$[ebp]
  000b7	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000ba	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 290  : 	int str_len = stSource.length();

  000c0	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  000c6	89 45 ac	 mov	 DWORD PTR _str_len$[ebp], eax

; 291  : 	int str_pos = 0;

  000c9	83 65 f0 00	 and	 DWORD PTR _str_pos$[ebp], 0

; 292  : 	
; 293  : 	DWORD codePage = GetDefaultCodePage();

  000cd	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  000d2	89 45 d4	 mov	 DWORD PTR _codePage$[ebp], eax

; 297  : 	static std::string stLetter;

  000d5	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  000da	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  000e1	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
  000ea	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  000f0	7e 44		 jle	 SHORT $LN2@Create
  000f2	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
  000f7	e8 00 00 00 00	 call	 __Init_thread_header
  000fc	59		 pop	 ecx
  000fd	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA, -1
  00104	75 30		 jne	 SHORT $LN2@Create
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00106	ff b5 40 ff ff
	ff		 push	 DWORD PTR $T2[ebp]
  0010c	b9 00 00 00 00	 mov	 ecx, OFFSET ?stLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4V45@A
  00111	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00116	b9 00 00 00 00	 mov	 ecx, OFFSET ?stLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4V45@A
  0011b	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 297  : 	static std::string stLetter;

  00120	68 00 00 00 00	 push	 OFFSET ??__FstLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@YAXXZ ; `script::Group::Create'::`2'::`dynamic atexit destructor for 'stLetter''
  00125	e8 00 00 00 00	 call	 _atexit
  0012a	59		 pop	 ecx
  0012b	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
  00130	e8 00 00 00 00	 call	 __Init_thread_footer
  00135	59		 pop	 ecx
$LN2@Create:
$LN3@Create:

; 298  : 	
; 299  :     while (str_pos < str_len)

  00136	8b 45 f0	 mov	 eax, DWORD PTR _str_pos$[ebp]
  00139	3b 45 ac	 cmp	 eax, DWORD PTR _str_len$[ebp]
  0013c	0f 8d 0d 05 00
	00		 jge	 $LN4@Create
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h

; 37   : 		SCmd()

  00142	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp]
  00148	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0014d	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00151	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp+24]
  00157	e8 00 00 00 00	 call	 ??0?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::list<script::SArgumet,std::allocator<script::SArgumet> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 301  :         TCmd cmd;

  0015c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 302  : 
; 303  : 		const char* word = str_base + str_pos;

  00163	8b 45 e4	 mov	 eax, DWORD PTR _str_base$[ebp]
  00166	03 45 f0	 add	 eax, DWORD PTR _str_pos$[ebp]
  00169	89 45 dc	 mov	 DWORD PTR _word$31[ebp], eax

; 304  : 		const char* word_next = CharNextExA(codePage, word, 0);

  0016c	6a 00		 push	 0
  0016e	ff 75 dc	 push	 DWORD PTR _word$31[ebp]
  00171	ff 75 d4	 push	 DWORD PTR _codePage$[ebp]
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextExA@12
  0017a	89 45 b8	 mov	 DWORD PTR _word_next$24[ebp], eax

; 305  : 		
; 306  : 		int word_len = word_next - word;

  0017d	8b 45 b8	 mov	 eax, DWORD PTR _word_next$24[ebp]
  00180	2b 45 dc	 sub	 eax, DWORD PTR _word$31[ebp]
  00183	89 45 cc	 mov	 DWORD PTR _word_len$28[ebp], eax

; 307  : 		
; 308  : 		if (word_len > 1)

  00186	83 7d cc 01	 cmp	 DWORD PTR _word_len$28[ebp], 1
  0018a	0f 8e 04 01 00
	00		 jle	 $LN8@Create

; 309  : 		{
; 310  : 			str_pos += word_len;

  00190	8b 45 f0	 mov	 eax, DWORD PTR _str_pos$[ebp]
  00193	03 45 cc	 add	 eax, DWORD PTR _word_len$28[ebp]
  00196	89 45 f0	 mov	 DWORD PTR _str_pos$[ebp], eax

; 311  : 
; 312  : 			{
; 313  : 				stLetter.assign(word, word_next);

  00199	8b 45 b8	 mov	 eax, DWORD PTR _word_next$24[ebp]
  0019c	89 85 4c ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  001a2	8b 45 dc	 mov	 eax, DWORD PTR _word$31[ebp]
  001a5	89 85 50 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3087 :         const auto _UFirst = _Get_unwrapped(_First);

  001ab	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  001b1	89 45 b4	 mov	 DWORD PTR __UFirst$23[ebp], eax

; 3088 :         const auto _ULast  = _Get_unwrapped(_Last);

  001b4	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR __Last$[ebp]
  001ba	89 85 48 ff ff
	ff		 mov	 DWORD PTR __ULast$4[ebp], eax

; 3090 :             return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  001c0	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR __ULast$4[ebp]
  001c6	2b 45 b4	 sub	 eax, DWORD PTR __UFirst$23[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  001c9	89 85 44 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3090 :             return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  001cf	ff b5 44 ff ff
	ff		 push	 DWORD PTR $T3[ebp]
  001d5	ff 75 b4	 push	 DWORD PTR __UFirst$23[ebp]
  001d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?stLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4V45@A
  001dd	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  001e2	68 00 00 00 00	 push	 OFFSET ??_C@_06MJINCFFA@LETTER@
  001e7	e8 00 00 00 00	 call	 _strlen
  001ec	59		 pop	 ecx
  001ed	89 45 94	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  001f0	8b 45 94	 mov	 eax, DWORD PTR $T19[ebp]
  001f3	89 45 90	 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  001f6	ff 75 90	 push	 DWORD PTR $T18[ebp]
  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_06MJINCFFA@LETTER@
  001fe	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp]
  00204	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 316  : 				cmd.argList.push_back(TArg("value", stLetter));

  00209	68 00 00 00 00	 push	 OFFSET ??_C@_05MFEJDJP@value@
  0020e	8d 4d 78	 lea	 ecx, DWORD PTR $T40[ebp]
  00211	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00216	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0021a	68 00 00 00 00	 push	 OFFSET ?stLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4V45@A
  0021f	8d 45 78	 lea	 eax, DWORD PTR $T40[ebp]
  00222	50		 push	 eax
  00223	8d 4d 30	 lea	 ecx, DWORD PTR $T38[ebp]
  00226	e8 00 00 00 00	 call	 ??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; script::SArgumet::SArgumet
  0022b	89 45 8c	 mov	 DWORD PTR tv142[ebp], eax
  0022e	8b 45 8c	 mov	 eax, DWORD PTR tv142[ebp]
  00231	89 45 88	 mov	 DWORD PTR $T17[ebp], eax
  00234	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00238	8b 45 88	 mov	 eax, DWORD PTR $T17[ebp]
  0023b	89 45 84	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 973  :         _Emplace(_Mypair._Myval2._Myhead, _STD move(_Val));

  0023e	ff 75 84	 push	 DWORD PTR $T16[ebp]
  00241	ff b5 a8 00 00
	00		 push	 DWORD PTR _cmd$41[ebp+24]
  00247	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp+24]
  0024d	e8 00 00 00 00	 call	 ??$_Emplace@USArgumet@script@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@QAU21@$$QAUSArgumet@script@@@Z ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Emplace<script::SArgumet>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 316  : 				cmd.argList.push_back(TArg("value", stLetter));

  00252	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00256	8d 4d 48	 lea	 ecx, DWORD PTR $T38[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00259	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0025e	8d 4d 30	 lea	 ecx, DWORD PTR $T38[ebp]
  00261	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 316  : 				cmd.argList.push_back(TArg("value", stLetter));

  00266	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0026a	8d 4d 78	 lea	 ecx, DWORD PTR $T40[ebp]
  0026d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 318  : 				m_cmdList.push_back(cmd);

  00272	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00275	83 c0 18	 add	 eax, 24			; 00000018H
  00278	89 45 b0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  0027b	8d 85 90 00 00
	00		 lea	 eax, DWORD PTR _cmd$41[ebp]
  00281	50		 push	 eax
  00282	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00285	ff 30		 push	 DWORD PTR [eax]
  00287	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0028a	e8 00 00 00 00	 call	 ??$_Emplace@ABUSCmd@script@@@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAEPAU?$_List_node@USCmd@script@@PAX@1@QAU21@ABUSCmd@script@@@Z ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Emplace<script::SCmd const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 321  : 		}

  0028f	e9 9c 03 00 00	 jmp	 $LN9@Create
$LN8@Create:

; 322  : 		else if (word_len == 1)

  00294	83 7d cc 01	 cmp	 DWORD PTR _word_len$28[ebp], 1
  00298	0f 85 76 03 00
	00		 jne	 $LN10@Create

; 323  : 		{
; 324  : 			const char cur = *word;

  0029e	8b 45 dc	 mov	 eax, DWORD PTR _word$31[ebp]
  002a1	8a 00		 mov	 al, BYTE PTR [eax]
  002a3	88 45 d0	 mov	 BYTE PTR _cur$29[ebp], al

; 325  : 
; 326  : 			if ('[' == cur)

  002a6	0f be 45 d0	 movsx	 eax, BYTE PTR _cur$29[ebp]
  002aa	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  002ad	0f 85 60 02 00
	00		 jne	 $LN12@Create

; 327  : 			{
; 328  : 				++str_pos;

  002b3	8b 45 f0	 mov	 eax, DWORD PTR _str_pos$[ebp]
  002b6	40		 inc	 eax
  002b7	89 45 f0	 mov	 DWORD PTR _str_pos$[ebp], eax

; 329  : 
; 330  : 				const char* box_begin = str_base + str_pos;

  002ba	8b 45 e4	 mov	 eax, DWORD PTR _str_base$[ebp]
  002bd	03 45 f0	 add	 eax, DWORD PTR _str_pos$[ebp]
  002c0	89 45 d8	 mov	 DWORD PTR _box_begin$30[ebp], eax

; 331  : 				const char* box_end = LocaleString_FindChar(box_begin, str_len - str_pos, ']');				

  002c3	6a 5d		 push	 93			; 0000005dH
  002c5	8b 45 ac	 mov	 eax, DWORD PTR _str_len$[ebp]
  002c8	2b 45 f0	 sub	 eax, DWORD PTR _str_pos$[ebp]
  002cb	50		 push	 eax
  002cc	ff 75 d8	 push	 DWORD PTR _box_begin$30[ebp]
  002cf	e8 00 00 00 00	 call	 ?LocaleString_FindChar@@YAPBDPBDHD@Z ; LocaleString_FindChar
  002d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d7	89 45 c8	 mov	 DWORD PTR _box_end$27[ebp], eax

; 332  : 				if (!box_end)

  002da	83 7d c8 00	 cmp	 DWORD PTR _box_end$27[ebp], 0
  002de	75 35		 jne	 SHORT $LN14@Create

; 333  : 				{
; 334  : 					TraceError(" !! PARSING ERROR - Syntax Error : %s\n", box_begin);

  002e0	ff 75 d8	 push	 DWORD PTR _box_begin$30[ebp]
  002e3	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@IJJEPPJM@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Syntax?5Erro@
  002e8	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  002ed	59		 pop	 ecx
  002ee	59		 pop	 ecx

; 335  : 					return false;

  002ef	c6 45 ea 00	 mov	 BYTE PTR $T34[ebp], 0
  002f3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  002f7	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  002fd	e8 00 00 00 00	 call	 ?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy
  00302	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00308	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 335  : 					return false;

  0030d	8a 45 ea	 mov	 al, BYTE PTR $T34[ebp]
  00310	e9 3c 03 00 00	 jmp	 $LN22@Create
$LN14@Create:

; 336  : 				}
; 337  : 				str_pos += box_end - box_begin + 1;

  00315	8b 45 c8	 mov	 eax, DWORD PTR _box_end$27[ebp]
  00318	2b 45 d8	 sub	 eax, DWORD PTR _box_begin$30[ebp]
  0031b	8b 4d f0	 mov	 ecx, DWORD PTR _str_pos$[ebp]
  0031e	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00322	89 45 f0	 mov	 DWORD PTR _str_pos$[ebp], eax

; 338  : 				
; 339  : 
; 340  : 				int data_len = 0;

  00325	83 65 ec 00	 and	 DWORD PTR _data_len$36[ebp], 0

; 341  : 				{
; 342  : 					const char* data_begin = LocaleString_Skip(codePage, box_begin);

  00329	ff 75 d8	 push	 DWORD PTR _box_begin$30[ebp]
  0032c	ff 75 d4	 push	 DWORD PTR _codePage$[ebp]
  0032f	e8 00 00 00 00	 call	 ?LocaleString_Skip@@YAPBDKPBD@Z ; LocaleString_Skip
  00334	59		 pop	 ecx
  00335	59		 pop	 ecx
  00336	89 45 a8	 mov	 DWORD PTR _data_begin$22[ebp], eax

; 343  : 					const char* data_end = box_end;

  00339	8b 45 c8	 mov	 eax, DWORD PTR _box_end$27[ebp]
  0033c	89 45 80	 mov	 DWORD PTR _data_end$15[ebp], eax

; 344  : 					data_len = data_end - data_begin;

  0033f	8b 45 80	 mov	 eax, DWORD PTR _data_end$15[ebp]
  00342	2b 45 a8	 sub	 eax, DWORD PTR _data_begin$22[ebp]
  00345	89 45 ec	 mov	 DWORD PTR _data_len$36[ebp], eax

; 345  : 					if (data_len >= 1024)

  00348	81 7d ec 00 04
	00 00		 cmp	 DWORD PTR _data_len$36[ebp], 1024 ; 00000400H
  0034f	7c 39		 jl	 SHORT $LN15@Create

; 346  : 					{
; 347  : 						TraceError(" !! PARSING ERROR - Buffer Overflow : %d, %s\n", data_len, str_base);

  00351	ff 75 e4	 push	 DWORD PTR _str_base$[ebp]
  00354	ff 75 ec	 push	 DWORD PTR _data_len$36[ebp]
  00357	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@FGKIOAND@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Buffer?5Over@
  0035c	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00361	83 c4 0c	 add	 esp, 12			; 0000000cH

; 348  : 						return false;

  00364	c6 45 e9 00	 mov	 BYTE PTR $T33[ebp], 0
  00368	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0036c	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  00372	e8 00 00 00 00	 call	 ?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy
  00377	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0037d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 348  : 						return false;

  00382	8a 45 e9	 mov	 al, BYTE PTR $T33[ebp]
  00385	e9 c7 02 00 00	 jmp	 $LN22@Create
$LN15@Create:

; 349  : 					}
; 350  : 					memcpy(box_data, data_begin, data_len);

  0038a	ff 75 ec	 push	 DWORD PTR _data_len$36[ebp]
  0038d	ff 75 a8	 push	 DWORD PTR _data_begin$22[ebp]
  00390	8d 85 b0 00 00
	00		 lea	 eax, DWORD PTR _box_data$[ebp]
  00396	50		 push	 eax
  00397	e8 00 00 00 00	 call	 _memcpy
  0039c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 351  : 					box_data[data_len] = '\0';

  0039f	8b 45 ec	 mov	 eax, DWORD PTR _data_len$36[ebp]
  003a2	89 45 a4	 mov	 DWORD PTR $T21[ebp], eax
  003a5	81 7d a4 01 04
	00 00		 cmp	 DWORD PTR $T21[ebp], 1025 ; 00000401H
  003ac	73 02		 jae	 SHORT $LN23@Create
  003ae	eb 05		 jmp	 SHORT $LN24@Create
$LN23@Create:
  003b0	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN24@Create:
  003b5	8b 45 a4	 mov	 eax, DWORD PTR $T21[ebp]
  003b8	c6 84 05 b0 00
	00 00 00	 mov	 BYTE PTR _box_data$[ebp+eax], 0

; 352  : 
; 353  : 					data_len = LocaleString_RightTrim(box_data, data_len); //   

  003c0	ff 75 ec	 push	 DWORD PTR _data_len$36[ebp]
  003c3	8d 85 b0 00 00
	00		 lea	 eax, DWORD PTR _box_data$[ebp]
  003c9	50		 push	 eax
  003ca	e8 00 00 00 00	 call	 ?LocaleString_RightTrim@@YAHPADH@Z ; LocaleString_RightTrim
  003cf	59		 pop	 ecx
  003d0	59		 pop	 ecx
  003d1	89 45 ec	 mov	 DWORD PTR _data_len$36[ebp], eax

; 354  : 				}
; 355  : 
; 356  : 				{
; 357  : 					const char* space = LocaleString_FindChar(box_data, data_len, ' ');

  003d4	6a 20		 push	 32			; 00000020H
  003d6	ff 75 ec	 push	 DWORD PTR _data_len$36[ebp]
  003d9	8d 85 b0 00 00
	00		 lea	 eax, DWORD PTR _box_data$[ebp]
  003df	50		 push	 eax
  003e0	e8 00 00 00 00	 call	 ?LocaleString_FindChar@@YAPBDPBDHD@Z ; LocaleString_FindChar
  003e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e8	89 45 c4	 mov	 DWORD PTR _space$26[ebp], eax

; 358  : 					if (space)  //  

  003eb	83 7d c4 00	 cmp	 DWORD PTR _space$26[ebp], 0
  003ef	0f 84 ba 00 00
	00		 je	 $LN16@Create

; 359  : 					{
; 360  : 						int name_len = space - box_data;

  003f5	8b 45 c4	 mov	 eax, DWORD PTR _space$26[ebp]
  003f8	8d 8d b0 00 00
	00		 lea	 ecx, DWORD PTR _box_data$[ebp]
  003fe	2b c1		 sub	 eax, ecx
  00400	89 85 7c ff ff
	ff		 mov	 DWORD PTR _name_len$14[ebp], eax

; 361  : 						cmd.name.assign(box_data, name_len);

  00406	ff b5 7c ff ff
	ff		 push	 DWORD PTR _name_len$14[ebp]
  0040c	8d 85 b0 00 00
	00		 lea	 eax, DWORD PTR _box_data$[ebp]
  00412	50		 push	 eax
  00413	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp]
  00419	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 362  : 						
; 363  : 						const char* space_next = CharNextExA(codePage, space, 0);

  0041e	6a 00		 push	 0
  00420	ff 75 c4	 push	 DWORD PTR _space$26[ebp]
  00423	ff 75 d4	 push	 DWORD PTR _codePage$[ebp]
  00426	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextExA@12
  0042c	89 85 78 ff ff
	ff		 mov	 DWORD PTR _space_next$13[ebp], eax

; 364  : 						const char* arg = LocaleString_Skip(codePage, space_next);

  00432	ff b5 78 ff ff
	ff		 push	 DWORD PTR _space_next$13[ebp]
  00438	ff 75 d4	 push	 DWORD PTR _codePage$[ebp]
  0043b	e8 00 00 00 00	 call	 ?LocaleString_Skip@@YAPBDKPBD@Z ; LocaleString_Skip
  00440	59		 pop	 ecx
  00441	59		 pop	 ecx
  00442	89 45 c0	 mov	 DWORD PTR _arg$25[ebp], eax

; 365  : 
; 366  : 						int arg_len = data_len - (arg - box_data);

  00445	8b 45 c0	 mov	 eax, DWORD PTR _arg$25[ebp]
  00448	8d 8d b0 00 00
	00		 lea	 ecx, DWORD PTR _box_data$[ebp]
  0044e	2b c1		 sub	 eax, ecx
  00450	8b 4d ec	 mov	 ecx, DWORD PTR _data_len$36[ebp]
  00453	2b c8		 sub	 ecx, eax
  00455	89 4d a0	 mov	 DWORD PTR _arg_len$20[ebp], ecx

; 367  : 						
; 368  : 						if (!GetArg(arg, arg_len, cmd.argList))

  00458	8d 85 a8 00 00
	00		 lea	 eax, DWORD PTR _cmd$41[ebp+24]
  0045e	50		 push	 eax
  0045f	ff 75 a0	 push	 DWORD PTR _arg_len$20[ebp]
  00462	ff 75 c0	 push	 DWORD PTR _arg$25[ebp]
  00465	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00468	e8 00 00 00 00	 call	 ?GetArg@Group@script@@AAE_NPBDHAAV?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@@Z ; script::Group::GetArg
  0046d	0f b6 c0	 movzx	 eax, al
  00470	85 c0		 test	 eax, eax
  00472	75 39		 jne	 SHORT $LN18@Create

; 369  : 						{
; 370  : 							TraceError(" !! PARSING ERROR - Unknown Arguments : %d, %s\n", arg_len, arg);

  00474	ff 75 c0	 push	 DWORD PTR _arg$25[ebp]
  00477	ff 75 a0	 push	 DWORD PTR _arg_len$20[ebp]
  0047a	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@GPNGJHKH@?5?$CB?$CB?5PARSING?5ERROR?5?9?5Unknown?5Arg@
  0047f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00484	83 c4 0c	 add	 esp, 12			; 0000000cH

; 371  : 							return false;

  00487	c6 45 e8 00	 mov	 BYTE PTR $T32[ebp], 0
  0048b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0048f	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  00495	e8 00 00 00 00	 call	 ?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy
  0049a	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  004a0	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 371  : 							return false;

  004a5	8a 45 e8	 mov	 al, BYTE PTR $T32[ebp]
  004a8	e9 a4 01 00 00	 jmp	 $LN22@Create
$LN18@Create:

; 372  : 						}
; 373  : 					}

  004ad	eb 42		 jmp	 SHORT $LN17@Create
$LN16@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  004af	8d 85 b0 00 00
	00		 lea	 eax, DWORD PTR _box_data$[ebp]
  004b5	50		 push	 eax
  004b6	e8 00 00 00 00	 call	 _strlen
  004bb	59		 pop	 ecx
  004bc	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  004c2	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  004c8	89 85 58 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  004ce	ff b5 58 ff ff
	ff		 push	 DWORD PTR $T6[ebp]
  004d4	8d 85 b0 00 00
	00		 lea	 eax, DWORD PTR _box_data$[ebp]
  004da	50		 push	 eax
  004db	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp]
  004e1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 377  : 						cmd.argList.clear();

  004e6	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp+24]
  004ec	e8 00 00 00 00	 call	 ?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::clear
$LN17@Create:

; 378  : 					}
; 379  : 					
; 380  : 					m_cmdList.push_back(cmd);

  004f1	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  004f4	83 c0 18	 add	 eax, 24			; 00000018H
  004f7	89 45 9c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  004fa	8d 85 90 00 00
	00		 lea	 eax, DWORD PTR _cmd$41[ebp]
  00500	50		 push	 eax
  00501	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  00504	ff 30		 push	 DWORD PTR [eax]
  00506	8b 4d 9c	 mov	 ecx, DWORD PTR _this$[ebp]
  00509	e8 00 00 00 00	 call	 ??$_Emplace@ABUSCmd@script@@@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAEPAU?$_List_node@USCmd@script@@PAX@1@QAU21@ABUSCmd@script@@@Z ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Emplace<script::SCmd const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 382  : 			}

  0050e	e9 ff 00 00 00	 jmp	 $LN13@Create
$LN12@Create:

; 383  : 			else if (cur == '\r' || cur == '\n')

  00513	0f be 45 d0	 movsx	 eax, BYTE PTR _cur$29[ebp]
  00517	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  0051a	74 09		 je	 SHORT $LN21@Create
  0051c	0f be 45 d0	 movsx	 eax, BYTE PTR _cur$29[ebp]
  00520	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00523	75 0c		 jne	 SHORT $LN19@Create
$LN21@Create:

; 384  : 			{
; 385  : 				++str_pos;

  00525	8b 45 f0	 mov	 eax, DWORD PTR _str_pos$[ebp]
  00528	40		 inc	 eax
  00529	89 45 f0	 mov	 DWORD PTR _str_pos$[ebp], eax

; 386  : 			}

  0052c	e9 e1 00 00 00	 jmp	 $LN13@Create
$LN19@Create:

; 387  : 			else
; 388  : 			{
; 389  : 				++str_pos;

  00531	8b 45 f0	 mov	 eax, DWORD PTR _str_pos$[ebp]
  00534	40		 inc	 eax
  00535	89 45 f0	 mov	 DWORD PTR _str_pos$[ebp], eax

; 390  : 				
; 391  : 				{
; 392  : 					stLetter.assign(1, cur);

  00538	ff 75 d0	 push	 DWORD PTR _cur$29[ebp]
  0053b	6a 01		 push	 1
  0053d	b9 00 00 00 00	 mov	 ecx, OFFSET ?stLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4V45@A
  00542	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00547	68 00 00 00 00	 push	 OFFSET ??_C@_06MJINCFFA@LETTER@
  0054c	e8 00 00 00 00	 call	 _strlen
  00551	59		 pop	 ecx
  00552	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00558	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T10[ebp]
  0055e	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00564	ff b5 68 ff ff
	ff		 push	 DWORD PTR $T9[ebp]
  0056a	68 00 00 00 00	 push	 OFFSET ??_C@_06MJINCFFA@LETTER@
  0056f	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp]
  00575	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 394  : 					cmd.argList.push_back(TArg("value", stLetter));

  0057a	68 00 00 00 00	 push	 OFFSET ??_C@_05MFEJDJP@value@
  0057f	8d 4d 60	 lea	 ecx, DWORD PTR $T39[ebp]
  00582	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00587	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0058b	68 00 00 00 00	 push	 OFFSET ?stLetter@?1??Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4V45@A
  00590	8d 45 60	 lea	 eax, DWORD PTR $T39[ebp]
  00593	50		 push	 eax
  00594	8d 4d 00	 lea	 ecx, DWORD PTR $T37[ebp]
  00597	e8 00 00 00 00	 call	 ??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; script::SArgumet::SArgumet
  0059c	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv234[ebp], eax
  005a2	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv234[ebp]
  005a8	89 85 60 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
  005ae	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  005b2	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  005b8	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 973  :         _Emplace(_Mypair._Myval2._Myhead, _STD move(_Val));

  005be	ff b5 5c ff ff
	ff		 push	 DWORD PTR $T7[ebp]
  005c4	ff b5 a8 00 00
	00		 push	 DWORD PTR _cmd$41[ebp+24]
  005ca	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp+24]
  005d0	e8 00 00 00 00	 call	 ??$_Emplace@USArgumet@script@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEPAU?$_List_node@USArgumet@script@@PAX@1@QAU21@$$QAUSArgumet@script@@@Z ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Emplace<script::SArgumet>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 394  : 					cmd.argList.push_back(TArg("value", stLetter));

  005d5	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  005d9	8d 4d 18	 lea	 ecx, DWORD PTR $T37[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  005dc	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  005e1	8d 4d 00	 lea	 ecx, DWORD PTR $T37[ebp]
  005e4	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 394  : 					cmd.argList.push_back(TArg("value", stLetter));

  005e9	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  005ed	8d 4d 60	 lea	 ecx, DWORD PTR $T39[ebp]
  005f0	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 395  : 					m_cmdList.push_back(cmd);

  005f5	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  005f8	83 c0 18	 add	 eax, 24			; 00000018H
  005fb	89 45 98	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  005fe	8d 85 90 00 00
	00		 lea	 eax, DWORD PTR _cmd$41[ebp]
  00604	50		 push	 eax
  00605	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00608	ff 30		 push	 DWORD PTR [eax]
  0060a	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  0060d	e8 00 00 00 00	 call	 ??$_Emplace@ABUSCmd@script@@@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAEPAU?$_List_node@USCmd@script@@PAX@1@QAU21@ABUSCmd@script@@@Z ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Emplace<script::SCmd const &>
$LN13@Create:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 398  : 		}

  00612	eb 1c		 jmp	 SHORT $LN9@Create
$LN10@Create:

; 401  : 			break;

  00614	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00618	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  0061e	e8 00 00 00 00	 call	 ?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy
  00623	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00629	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 401  : 			break;

  0062e	eb 1f		 jmp	 SHORT $LN4@Create
$LN9@Create:

; 403  :     }

  00630	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00634	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  0063a	e8 00 00 00 00	 call	 ?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy
  0063f	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00645	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 403  :     }

  0064a	e9 e7 fa ff ff	 jmp	 $LN3@Create
$LN4@Create:

; 404  : 
; 405  :     return true;

  0064f	b0 01		 mov	 al, 1
$LN22@Create:

; 406  : }

  00651	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00654	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0065b	59		 pop	 ecx
  0065c	8b 8d b4 04 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00662	33 cd		 xor	 ecx, ebp
  00664	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00669	81 c5 b8 04 00
	00		 add	 ebp, 1208		; 000004b8H
  0066f	c9		 leave
  00670	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$18:
  00000	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  0000b	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _cmd$41[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1SCmd@script@@QAE@XZ
__unwindfunclet$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
  00016	8d 4d 78	 lea	 ecx, DWORD PTR $T40[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
  0001e	8d 4d 30	 lea	 ecx, DWORD PTR $T38[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1SArgumet@script@@QAE@XZ
__unwindfunclet$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$3:
  00026	8d 4d 60	 lea	 ecx, DWORD PTR $T39[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$4:
  0002e	8d 4d 00	 lea	 ecx, DWORD PTR $T37[ebp]
  00031	e9 00 00 00 00	 jmp	 ??1SArgumet@script@@QAE@XZ
  00036	cc		 int	 3
  00037	cc		 int	 3
  00038	cc		 int	 3
  00039	cc		 int	 3
  0003a	cc		 int	 3
__ehhandler$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  0003b	90		 npad	 1
  0003c	90		 npad	 1
  0003d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00041	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00044	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  0004a	33 c8		 xor	 ecx, eax
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b 8a c0 04 00
	00		 mov	 ecx, DWORD PTR [edx+1216]
  00057	33 c8		 xor	 ecx, eax
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00063	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Create@Group@script@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; script::Group::Create
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ??1Group@script@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Group@script@@QAE@XZ PROC				; script::Group::~Group, COMDAT
; _this$ = ecx

; 442  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 443  : }

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 18	 add	 ecx, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  0000d	e8 00 00 00 00	 call	 ?_Tidy@?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@AAEXXZ ; std::list<script::SCmd,std::allocator<script::SCmd> >::_Tidy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp

; 443  : }

  0001a	c9		 leave
  0001b	c3		 ret	 0
??1Group@script@@QAE@XZ ENDP				; script::Group::~Group
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.cpp
;	COMDAT ??0Group@script@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Group@script@@QAE@XZ PROC				; script::Group::Group, COMDAT
; _this$ = ecx

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Group@script@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	83 c1 18	 add	 ecx, 24			; 00000018H
  00038	e8 00 00 00 00	 call	 ??0?$list@USCmd@script@@V?$allocator@USCmd@script@@@std@@@std@@QAE@XZ ; std::list<script::SCmd,std::allocator<script::SCmd> >::list<script::SCmd,std::allocator<script::SCmd> >

; 439  : }

  0003d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00041	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	59		 pop	 ecx
  0004f	c9		 leave
  00050	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Group@script@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0Group@script@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Group@script@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Group@script@@QAE@XZ ENDP				; script::Group::Group
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??_GSCmd@script@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSCmd@script@@QAEPAXI@Z PROC				; script::SCmd::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 18	 add	 ecx, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  0000d	e8 00 00 00 00	 call	 ?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001d	83 e0 01	 and	 eax, 1
  00020	74 0c		 je	 SHORT $LN2@scalar
  00022	6a 20		 push	 32			; 00000020H
  00024	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx
$LN2@scalar:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c9		 leave
  00032	c2 04 00	 ret	 4
??_GSCmd@script@@QAEPAXI@Z ENDP				; script::SCmd::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1SCmd@script@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SCmd@script@@QAE@XZ PROC				; script::SCmd::~SCmd, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 18	 add	 ecx, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  0000d	e8 00 00 00 00	 call	 ?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0001a	c9		 leave
  0001b	c3		 ret	 0
??1SCmd@script@@QAE@XZ ENDP				; script::SCmd::~SCmd
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
;	COMDAT ??4SCmd@script@@QAEXABU01@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 1
$T2 = -32						; size = 4
$T3 = -28						; size = 1
$T4 = -24						; size = 4
_this$ = -20						; size = 4
__Right$ = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
__Right$ = -4						; size = 4
_c_cmd$ = 8						; size = 4
??4SCmd@script@@QAEXABU01@@Z PROC			; script::SCmd::operator=, COMDAT
; _this$ = ecx

; 45   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 46   : 			name = c_cmd.name;

  00009	8b 45 08	 mov	 eax, DWORD PTR _c_cmd$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __Right$[ebp], eax
  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Right$[ebp]
  00018	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	3b 45 e8	 cmp	 eax, DWORD PTR $T4[ebp]
  00021	74 13		 je	 SHORT $LN3@operator

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00023	33 c0		 xor	 eax, eax
  00025	88 45 e4	 mov	 BYTE PTR $T3[ebp], al
  00028	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0002b	ff 75 fc	 push	 DWORD PTR __Right$[ebp]
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN3@operator:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h

; 47   : 			argList = c_cmd.argList;

  00036	8b 45 08	 mov	 eax, DWORD PTR _c_cmd$[ebp]
  00039	83 c0 18	 add	 eax, 24			; 00000018H
  0003c	89 45 f0	 mov	 DWORD PTR __Right$[ebp], eax
  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 c0 18	 add	 eax, 24			; 00000018H
  00045	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00048	8b 45 f0	 mov	 eax, DWORD PTR __Right$[ebp]
  0004b	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1084 :         if (this != _STD addressof(_Right)) {

  0004e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00051	3b 45 e0	 cmp	 eax, DWORD PTR $T2[ebp]
  00054	74 13		 je	 SHORT $LN1@operator

; 1085 :             _Copy_assign(_Right, _Choose_pocca<_Alnode>{});

  00056	33 c0		 xor	 eax, eax
  00058	88 45 dc	 mov	 BYTE PTR $T1[ebp], al
  0005b	ff 75 dc	 push	 DWORD PTR $T1[ebp]
  0005e	ff 75 f0	 push	 DWORD PTR __Right$[ebp]
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?_Copy_assign@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Copy_assign
$LN1@operator:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h

; 48   : 		}

  00069	c9		 leave
  0006a	c2 04 00	 ret	 4
??4SCmd@script@@QAEXABU01@@Z ENDP			; script::SCmd::operator=
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
;	COMDAT ??0SCmd@script@@QAE@ABU01@@Z
_TEXT	SEGMENT
$T2 = -48						; size = 1
$T3 = -44						; size = 4
$T4 = -40						; size = 1
$T5 = -36						; size = 4
_this$ = -32						; size = 4
__Right$ = -28						; size = 4
_this$ = -24						; size = 4
__Right$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_c_cmd$ = 8						; size = 4
??0SCmd@script@@QAE@ABU01@@Z PROC			; script::SCmd::SCmd, COMDAT
; _this$ = ecx

; 39   : 		SCmd(const SCmd& c_cmd)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SCmd@script@@QAE@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 18	 add	 ecx, 24			; 00000018H
  0003a	e8 00 00 00 00	 call	 ??0?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::list<script::SArgumet,std::allocator<script::SArgumet> >
  0003f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 40   : 		{
; 41   : 			name = c_cmd.name;

  00043	8b 45 08	 mov	 eax, DWORD PTR _c_cmd$[ebp]
  00046	89 45 ec	 mov	 DWORD PTR __Right$[ebp], eax
  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004f	8b 45 ec	 mov	 eax, DWORD PTR __Right$[ebp]
  00052	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  00055	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	3b 45 dc	 cmp	 eax, DWORD PTR $T5[ebp]
  0005b	74 13		 je	 SHORT $LN61@SCmd

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  0005d	33 c0		 xor	 eax, eax
  0005f	88 45 d8	 mov	 BYTE PTR $T4[ebp], al
  00062	ff 75 d8	 push	 DWORD PTR $T4[ebp]
  00065	ff 75 ec	 push	 DWORD PTR __Right$[ebp]
  00068	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN61@SCmd:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h

; 42   : 			argList = c_cmd.argList;

  00070	8b 45 08	 mov	 eax, DWORD PTR _c_cmd$[ebp]
  00073	83 c0 18	 add	 eax, 24			; 00000018H
  00076	89 45 e4	 mov	 DWORD PTR __Right$[ebp], eax
  00079	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	83 c0 18	 add	 eax, 24			; 00000018H
  0007f	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00082	8b 45 e4	 mov	 eax, DWORD PTR __Right$[ebp]
  00085	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1084 :         if (this != _STD addressof(_Right)) {

  00088	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	3b 45 d4	 cmp	 eax, DWORD PTR $T3[ebp]
  0008e	74 13		 je	 SHORT $LN1@SCmd

; 1085 :             _Copy_assign(_Right, _Choose_pocca<_Alnode>{});

  00090	33 c0		 xor	 eax, eax
  00092	88 45 d0	 mov	 BYTE PTR $T2[ebp], al
  00095	ff 75 d0	 push	 DWORD PTR $T2[ebp]
  00098	ff 75 e4	 push	 DWORD PTR __Right$[ebp]
  0009b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ?_Copy_assign@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Copy_assign
$LN1@SCmd:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h

; 43   : 		}

  000a3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000a7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b4	59		 pop	 ecx
  000b5	c9		 leave
  000b6	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SCmd@script@@QAE@ABU01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0SCmd@script@@QAE@ABU01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 18	 add	 ecx, 24			; 00000018H
  0000e	e9 00 00 00 00	 jmp	 ??1?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::~list<script::SArgumet,std::allocator<script::SArgumet> >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0SCmd@script@@QAE@ABU01@@Z:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SCmd@script@@QAE@ABU01@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SCmd@script@@QAE@ABU01@@Z ENDP			; script::SCmd::SCmd
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -36					; size = 4
__Al$ = -32						; size = 4
__Alproxy$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Newhead$ = -8						; size = 4
__Overflow_is_possible$5 = -2				; size = 1
_$S13$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00009	8d 45 ff	 lea	 eax, DWORD PTR _$S13$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 fe 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	c7 45 dc 24 49
	92 04		 mov	 DWORD PTR __Max_possible$1[ebp], 76695844 ; 04924924H

; 60   :         if (_Count > _Max_possible) {

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	3d 24 49 92 04	 cmp	 eax, 76695844		; 04924924H
  0002e	76 05		 jbe	 SHORT $LN15@Alloc_sent

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00030	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN15@Alloc_sent:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	6b c0 38	 imul	 eax, eax, 56
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003e	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00041	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00046	59		 pop	 ecx
  00047	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1775 :         auto _Newhead = _Al.allocate(1);

  0004a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00050	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00053	50		 push	 eax
  00054	ff 75 f8	 push	 DWORD PTR __Newhead$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0005e	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00061	50		 push	 eax
  00062	8b 45 f8	 mov	 eax, DWORD PTR __Newhead$[ebp]
  00065	83 c0 04	 add	 eax, 4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USArgumet@script@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USArgumet@script@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<script::SArgumet,void *> *,std::_List_node<script::SArgumet,void *> * &>
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
$LN18@Alloc_sent:

; 1779 :         _Proxy._Release();
; 1780 :     }

  00078	c9		 leave
  00079	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Al$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 1437 :         auto& _Al      = _Getal();
; 1438 :         auto& _My_data = _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();
; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SArgumet,void *>::_Free_non_head<std::allocator<std::_List_node<script::SArgumet,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	ff 30		 push	 DWORD PTR [eax]
  0002f	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SArgumet,void *>::_Freenode0<std::allocator<std::_List_node<script::SArgumet,void *> > >
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 1442 :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1428 :         _My_data._Orphan_non_end();
; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SArgumet,void *>::_Free_non_head<std::allocator<std::_List_node<script::SArgumet,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00032	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00034	89 08		 mov	 DWORD PTR [eax], ecx

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00036	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1432 :         _My_data._Mysize        = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00046	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1433 :     }

  0004a	c9		 leave
  0004b	c3		 ret	 0
?clear@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAEXXZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Unchecked_erase@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@QAU32@@Z
_TEXT	SEGMENT
__Next$1 = -28						; size = 4
__Al$ = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__Predecessor$ = -12					; size = 4
_this$ = -8						; size = 4
__Erasures$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Unchecked_erase@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@QAU32@@Z PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Unchecked_erase, COMDAT
; _this$ = ecx

; 1376 :     _Nodeptr _Unchecked_erase(_Nodeptr _First, const _Nodeptr _Last) noexcept { // erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1377 :         if (_First == _Last) {

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000f	75 05		 jne	 SHORT $LN5@Unchecked_

; 1378 :             return _Last;

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00014	eb 79		 jmp	 SHORT $LN6@Unchecked_
$LN5@Unchecked_:

; 1379 :         }
; 1380 : 
; 1381 :         const auto _Predecessor = _First->_Prev;

  00016	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00019	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001c	89 45 f4	 mov	 DWORD PTR __Predecessor$[ebp], eax

; 1382 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1383 :         const auto _Head = _Mypair._Myval2._Myhead;
; 1384 :         if (_First == _Head->_Next && _Last == _Head) { // orphan all non-end iterators
; 1385 :             _Mypair._Myval2._Orphan_non_end();
; 1386 :         } else { // orphan erased iterators
; 1387 :             _Lockit _Lock(_LOCK_DEBUG);
; 1388 :             for (auto _Marked = _First; _Marked != _Last; _Marked = _Marked->_Next) { // mark erased nodes
; 1389 :                 _Marked->_Prev = nullptr;
; 1390 :             }
; 1391 : 
; 1392 :             _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1393 :             while (*_Pnext) {
; 1394 :                 _Iterator_base12** _Pnextnext = &(*_Pnext)->_Mynextiter;
; 1395 :                 if (static_cast<const_iterator&>(**_Pnext)._Ptr->_Prev) { // node still has a _Prev, skip
; 1396 :                     _Pnext = _Pnextnext;
; 1397 :                 } else { // orphan the iterator
; 1398 :                     (*_Pnext)->_Myproxy = nullptr;
; 1399 :                     *_Pnext             = *_Pnextnext;
; 1400 :                 }
; 1401 :             }
; 1402 : 
; 1403 :             // _Prev pointers not restored because we're about to delete the nodes of which they are a member anyway
; 1404 :         }
; 1405 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1406 : 
; 1407 :         // snip out the removed range
; 1408 :         _Predecessor->_Next = _Last;

  0001f	8b 45 f4	 mov	 eax, DWORD PTR __Predecessor$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00025	89 08		 mov	 DWORD PTR [eax], ecx

; 1409 :         _Last->_Prev        = _Predecessor;

  00027	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002a	8b 4d f4	 mov	 ecx, DWORD PTR __Predecessor$[ebp]
  0002d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1787 :         return _Mypair._Get_first();

  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00033	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00036	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00039	89 45 e8	 mov	 DWORD PTR __Al$[ebp], eax

; 1410 : 
; 1411 :         // count and deallocate the removed nodes
; 1412 :         auto& _Al           = _Getal();
; 1413 :         size_type _Erasures = 0;

  0003c	83 65 fc 00	 and	 DWORD PTR __Erasures$[ebp], 0
$LN4@Unchecked_:

; 1414 :         do {
; 1415 :             const auto _Next = _First->_Next;

  00040	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	89 45 e4	 mov	 DWORD PTR __Next$1[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00048	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0004b	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004e	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 706  :         _Ptr->~_Uty();

  00051	6a 00		 push	 0
  00053	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  00056	e8 00 00 00 00	 call	 ??_GSArgumet@script@@QAEPAXI@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  0005b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0005e	ff 75 e8	 push	 DWORD PTR __Al$[ebp]
  00061	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@?$_List_node@USArgumet@script@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@1@PAU01@@Z ; std::_List_node<script::SArgumet,void *>::_Freenode0<std::allocator<std::_List_node<script::SArgumet,void *> > >
  00066	59		 pop	 ecx
  00067	59		 pop	 ecx

; 1416 :             _Node::_Freenode(_Al, _First);
; 1417 :             _First = _Next;

  00068	8b 45 e4	 mov	 eax, DWORD PTR __Next$1[ebp]
  0006b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 1418 :             ++_Erasures;

  0006e	8b 45 fc	 mov	 eax, DWORD PTR __Erasures$[ebp]
  00071	40		 inc	 eax
  00072	89 45 fc	 mov	 DWORD PTR __Erasures$[ebp], eax

; 1419 :         } while (_First != _Last);

  00075	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00078	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0007b	75 c3		 jne	 SHORT $LN4@Unchecked_

; 1420 : 
; 1421 :         _Mypair._Myval2._Mysize -= _Erasures;

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00083	2b 45 fc	 sub	 eax, DWORD PTR __Erasures$[ebp]
  00086	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1422 :         return _Last;

  0008c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
$LN6@Unchecked_:

; 1423 :     }

  0008f	c9		 leave
  00090	c2 08 00	 ret	 8
?_Unchecked_erase@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEPAU?$_List_node@USArgumet@script@@PAX@2@PAU32@QAU32@@Z ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Copy_assign@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
__First$ = -52						; size = 4
__Last$ = -48						; size = 4
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
__Pnode$ = -32						; size = 4
$T4 = -28						; size = 4
__Pnode$ = -24						; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
$T7 = -12						; size = 4
$T8 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Copy_assign, COMDAT
; _this$ = ecx

; 1069 :     void _Copy_assign(const list& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1791 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1791 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T8[ebp]
  00012	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 f4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0001b	8b 45 f4	 mov	 eax, DWORD PTR $T7[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax

; 1070 :         _Pocca(_Getal(), _Right._Getal());

  00021	ff 75 f0	 push	 DWORD PTR $T6[ebp]
  00024	ff 75 ec	 push	 DWORD PTR $T5[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@std@@@std@@YAXAAV?$allocator@U?$_List_node@USArgumet@script@@PAX@std@@@0@ABV10@@Z ; std::_Pocca<std::allocator<std::_List_node<script::SArgumet,void *> > >
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx

; 1120 :         return _Unchecked_const_iterator(_Mypair._Myval2._Myhead, nullptr);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	89 45 e8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00036	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00039	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax

; 1120 :         return _Unchecked_const_iterator(_Mypair._Myval2._Myhead, nullptr);

  0003c	8d 45 e4	 lea	 eax, DWORD PTR $T4[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax

; 1112 :         return _Unchecked_const_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00042	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	8b 00		 mov	 eax, DWORD PTR [eax]
  00049	89 45 e0	 mov	 DWORD PTR __Pnode$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0004c	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0004f	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax

; 1112 :         return _Unchecked_const_iterator(_Mypair._Myval2._Myhead->_Next, nullptr);

  00052	8d 45 dc	 lea	 eax, DWORD PTR $T3[ebp]
  00055	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 1071 :         assign(_Right._Unchecked_begin(), _Right._Unchecked_end());

  00058	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
  0005d	89 45 d0	 mov	 DWORD PTR __Last$[ebp], eax
  00060	8b 45 d4	 mov	 eax, DWORD PTR $T1[ebp]
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	89 45 cc	 mov	 DWORD PTR __First$[ebp], eax

; 1293 :         _Assign_cast<reference>(_Get_unwrapped(_First), _Get_unwrapped(_Last));

  00068	ff 75 d0	 push	 DWORD PTR __Last$[ebp]
  0006b	ff 75 cc	 push	 DWORD PTR __First$[ebp]
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ??$_Assign_cast@AAUSArgumet@script@@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@std@@@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@USArgumet@script@@@std@@@std@@U_Iterator_base0@2@@1@V21@@Z ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Assign_cast<script::SArgumet &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<script::SArgumet> >,std::_Iterator_base0> >

; 1072 :     }

  00076	c9		 leave
  00077	c2 08 00	 ret	 8
?_Copy_assign@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::~list<script::SArgumet,std::allocator<script::SArgumet> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::~list<script::SArgumet,std::allocator<script::SArgumet> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??0?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ PROC ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::list<script::SArgumet,std::allocator<script::SArgumet> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 805  :         _Alloc_sentinel_and_proxy();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@AAEXXZ ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::_Alloc_sentinel_and_proxy

; 806  :     }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0?$list@USArgumet@script@@V?$allocator@USArgumet@script@@@std@@@std@@QAE@XZ ENDP ; std::list<script::SArgumet,std::allocator<script::SArgumet> >::list<script::SArgumet,std::allocator<script::SArgumet> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??_GSArgumet@script@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSArgumet@script@@QAEPAXI@Z PROC			; script::SArgumet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 18	 add	 ecx, 24			; 00000018H

; 2801 :         _Tidy_deallocate();

  0000d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001d	83 e0 01	 and	 eax, 1
  00020	74 0c		 je	 SHORT $LN2@scalar
  00022	6a 30		 push	 48			; 00000030H
  00024	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx
$LN2@scalar:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c9		 leave
  00032	c2 04 00	 ret	 4
??_GSArgumet@script@@QAEPAXI@Z ENDP			; script::SArgumet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1SArgumet@script@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SArgumet@script@@QAE@XZ PROC				; script::SArgumet::~SArgumet, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 18	 add	 ecx, 24			; 00000018H

; 2801 :         _Tidy_deallocate();

  0000d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0001a	c9		 leave
  0001b	c3		 ret	 0
??1SArgumet@script@@QAE@XZ ENDP				; script::SArgumet::~SArgumet
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
;	COMDAT ??4SArgumet@script@@QAEXABU01@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 1
$T2 = -32						; size = 4
$T3 = -28						; size = 1
$T4 = -24						; size = 4
_this$ = -20						; size = 4
__Right$ = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
__Right$ = -4						; size = 4
_c_arg$ = 8						; size = 4
??4SArgumet@script@@QAEXABU01@@Z PROC			; script::SArgumet::operator=, COMDAT
; _this$ = ecx

; 22   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : 			strName = c_arg.strName;

  00009	8b 45 08	 mov	 eax, DWORD PTR _c_arg$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __Right$[ebp], eax
  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Right$[ebp]
  00018	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	3b 45 e8	 cmp	 eax, DWORD PTR $T4[ebp]
  00021	74 13		 je	 SHORT $LN3@operator

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00023	33 c0		 xor	 eax, eax
  00025	88 45 e4	 mov	 BYTE PTR $T3[ebp], al
  00028	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0002b	ff 75 fc	 push	 DWORD PTR __Right$[ebp]
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN3@operator:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h

; 24   : 			strValue = c_arg.strValue;

  00036	8b 45 08	 mov	 eax, DWORD PTR _c_arg$[ebp]
  00039	83 c0 18	 add	 eax, 24			; 00000018H
  0003c	89 45 f0	 mov	 DWORD PTR __Right$[ebp], eax
  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 c0 18	 add	 eax, 24			; 00000018H
  00045	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00048	8b 45 f0	 mov	 eax, DWORD PTR __Right$[ebp]
  0004b	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  0004e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00051	3b 45 e0	 cmp	 eax, DWORD PTR $T2[ebp]
  00054	74 13		 je	 SHORT $LN1@operator

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00056	33 c0		 xor	 eax, eax
  00058	88 45 dc	 mov	 BYTE PTR $T1[ebp], al
  0005b	ff 75 dc	 push	 DWORD PTR $T1[ebp]
  0005e	ff 75 f0	 push	 DWORD PTR __Right$[ebp]
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN1@operator:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h

; 25   : 		}		

  00069	c9		 leave
  0006a	c2 04 00	 ret	 4
??4SArgumet@script@@QAEXABU01@@Z ENDP			; script::SArgumet::operator=
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
;	COMDAT ??0SArgumet@script@@QAE@ABU01@@Z
_TEXT	SEGMENT
$T2 = -48						; size = 1
$T3 = -44						; size = 4
$T4 = -40						; size = 1
$T5 = -36						; size = 4
_this$ = -32						; size = 4
__Right$ = -28						; size = 4
_this$ = -24						; size = 4
__Right$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_c_arg$ = 8						; size = 4
??0SArgumet@script@@QAE@ABU01@@Z PROC			; script::SArgumet::SArgumet, COMDAT
; _this$ = ecx

; 16   : 		SArgumet(const SArgumet& c_arg)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SArgumet@script@@QAE@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 18	 add	 ecx, 24			; 00000018H
  0003a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 17   : 		{
; 18   : 			strName = c_arg.strName;

  00043	8b 45 08	 mov	 eax, DWORD PTR _c_arg$[ebp]
  00046	89 45 ec	 mov	 DWORD PTR __Right$[ebp], eax
  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004f	8b 45 ec	 mov	 eax, DWORD PTR __Right$[ebp]
  00052	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  00055	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	3b 45 dc	 cmp	 eax, DWORD PTR $T5[ebp]
  0005b	74 13		 je	 SHORT $LN53@SArgumet

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  0005d	33 c0		 xor	 eax, eax
  0005f	88 45 d8	 mov	 BYTE PTR $T4[ebp], al
  00062	ff 75 d8	 push	 DWORD PTR $T4[ebp]
  00065	ff 75 ec	 push	 DWORD PTR __Right$[ebp]
  00068	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN53@SArgumet:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h

; 19   : 			strValue = c_arg.strValue;

  00070	8b 45 08	 mov	 eax, DWORD PTR _c_arg$[ebp]
  00073	83 c0 18	 add	 eax, 24			; 00000018H
  00076	89 45 e4	 mov	 DWORD PTR __Right$[ebp], eax
  00079	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	83 c0 18	 add	 eax, 24			; 00000018H
  0007f	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00082	8b 45 e4	 mov	 eax, DWORD PTR __Right$[ebp]
  00085	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  00088	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	3b 45 d4	 cmp	 eax, DWORD PTR $T3[ebp]
  0008e	74 13		 je	 SHORT $LN1@SArgumet

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00090	33 c0		 xor	 eax, eax
  00092	88 45 d0	 mov	 BYTE PTR $T2[ebp], al
  00095	ff 75 d0	 push	 DWORD PTR $T2[ebp]
  00098	ff 75 e4	 push	 DWORD PTR __Right$[ebp]
  0009b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN1@SArgumet:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h

; 20   : 		}		

  000a3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000a7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b4	59		 pop	 ecx
  000b5	c9		 leave
  000b6	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SArgumet@script@@QAE@ABU01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0SArgumet@script@@QAE@ABU01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 18	 add	 ecx, 24			; 00000018H
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0SArgumet@script@@QAE@ABU01@@Z:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SArgumet@script@@QAE@ABU01@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SArgumet@script@@QAE@ABU01@@Z ENDP			; script::SArgumet::SArgumet
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h
;	COMDAT ??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
_TEXT	SEGMENT
$T2 = -40						; size = 1
$T3 = -36						; size = 4
$T4 = -32						; size = 1
$T5 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_c_stName$ = 8						; size = 4
_c_stValue$ = 12					; size = 4
??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC ; script::SArgumet::SArgumet, COMDAT
; _this$ = ecx

; 11   :         SArgumet(const std::string& c_stName, const std::string& c_stValue)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 18	 add	 ecx, 24			; 00000018H
  0003a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 12   :         {
; 13   :             strName = c_stName;

  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00049	8b 45 08	 mov	 eax, DWORD PTR _c_stName$[ebp]
  0004c	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  0004f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00052	3b 45 e4	 cmp	 eax, DWORD PTR $T5[ebp]
  00055	74 13		 je	 SHORT $LN53@SArgumet

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00057	33 c0		 xor	 eax, eax
  00059	88 45 e0	 mov	 BYTE PTR $T4[ebp], al
  0005c	ff 75 e0	 push	 DWORD PTR $T4[ebp]
  0005f	ff 75 08	 push	 DWORD PTR _c_stName$[ebp]
  00062	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN53@SArgumet:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h

; 14   :             strValue = c_stValue;

  0006a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	83 c0 18	 add	 eax, 24			; 00000018H
  00070	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00073	8b 45 0c	 mov	 eax, DWORD PTR _c_stValue$[ebp]
  00076	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  00079	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	3b 45 dc	 cmp	 eax, DWORD PTR $T3[ebp]
  0007f	74 13		 je	 SHORT $LN1@SArgumet

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00081	33 c0		 xor	 eax, eax
  00083	88 45 d8	 mov	 BYTE PTR $T2[ebp], al
  00086	ff 75 d8	 push	 DWORD PTR $T2[ebp]
  00089	ff 75 0c	 push	 DWORD PTR _c_stValue$[ebp]
  0008c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN1@SArgumet:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\parser.h

; 15   :         }

  00094	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00098	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a5	59		 pop	 ecx
  000a6	c9		 leave
  000a7	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 18	 add	 ecx, 24			; 00000018H
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0SArgumet@script@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; script::SArgumet::SArgumet
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 424  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	0f be 45 10	 movsx	 eax, BYTE PTR _<_Args_0>$[ebp]
  00075	50		 push	 eax
  00076	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00079	e8 00 00 00 00	 call	 _memset
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3078 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00081	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00085	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00088	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  0008b	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008e	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  00090	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00094	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00096	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00099	8b 00		 mov	 eax, DWORD PTR [eax]
  0009b	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009e	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000a1	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a2	50		 push	 eax
  000a3	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a6	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000ab	59		 pop	 ecx
  000ac	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ad	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b3	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b5	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b7	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000ba	50		 push	 eax
  000bb	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c3	59		 pop	 ecx
  000c4	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c8	c9		 leave
  000c9	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 14 00	 and	 DWORD PTR [eax+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c9		 leave
  00020	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3065 :     basic_string& assign(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // assign _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3066 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 3b		 ja	 SHORT $LN2@assign

; 3067 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3068 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 424  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00028	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0002b	0f be 45 0c	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0002f	50		 push	 eax
  00030	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00033	e8 00 00 00 00	 call	 _memset
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3069 :             _Traits::assign(_Old_ptr, _Count, _Ch);
; 3070 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0003b	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003f	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00042	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00045	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00048	88 08		 mov	 BYTE PTR [eax], cl

; 3071 :             return *this;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3072 :         }
; 3073 : 
; 3074 :         return _Reallocate_for(

  0004f	33 c0		 xor	 eax, eax
  00051	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00054	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00057	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  0005a	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
$LN1@assign:

; 3075 :             _Count,
; 3076 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
; 3077 :                 _Traits::assign(_New_ptr, _Count, _Ch);
; 3078 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3079 :             },
; 3080 :             _Ch);
; 3081 :     }

  00065	c9		 leave
  00066	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
__Ptr$ = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
__Result$6 = -16					; size = 4
tv134 = -12						; size = 4
_this$ = -8						; size = 4
$T7 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign, COMDAT
; _this$ = ecx

; 2826 :     void _Copy_assign(const basic_string& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0001b	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0001e	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2827 :         _Pocca(_Getal(), _Right._Getal());

  00021	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00024	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00041	72 09		 jb	 SHORT $LN21@Copy_assig
  00043	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv134[ebp], 1
  0004a	eb 04		 jmp	 SHORT $LN22@Copy_assig
$LN21@Copy_assig:
  0004c	83 65 f4 00	 and	 DWORD PTR tv134[ebp], 0
$LN22@Copy_assig:
  00050	8a 45 f4	 mov	 al, BYTE PTR tv134[ebp]
  00053	88 45 ff	 mov	 BYTE PTR $T7[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00056	0f b6 45 ff	 movzx	 eax, BYTE PTR $T7[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	74 0e		 je	 SHORT $LN16@Copy_assig

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00066	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00069	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax
$LN16@Copy_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR __Result$6[ebp]
  0006f	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00072	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00075	ff 70 10	 push	 DWORD PTR [eax+16]
  00078	ff 75 d4	 push	 DWORD PTR $T1[ebp]
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2829 :     }

  00083	c9		 leave
  00084	c2 08 00	 ret	 8
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S6$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0003b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00046	8d 45 f3	 lea	 eax, DWORD PTR _$S6$[ebp]
  00049	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00054	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	59		 pop	 ecx
  0005d	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00063	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00066	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00069	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }

  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
