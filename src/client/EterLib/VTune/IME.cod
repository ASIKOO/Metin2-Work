; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_ImmLockIMC@CIME@@1P6GPAU__MIDL___MIDL_itf_dimm_0000_0012@@PAUHIMC__@@@ZA ; CIME::_ImmLockIMC
PUBLIC	?_ImmUnlockIMC@CIME@@1P6GHPAUHIMC__@@@ZA	; CIME::_ImmUnlockIMC
PUBLIC	?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA	; CIME::_ImmLockIMCC
PUBLIC	?_ImmUnlockIMCC@CIME@@1P6GHPAUHIMCC__@@@ZA	; CIME::_ImmUnlockIMCC
PUBLIC	?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA ; CIME::_GetReadingString
PUBLIC	?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA	; CIME::_ShowReadingWindow
PUBLIC	?ms_bInitialized@CIME@@2_NA			; CIME::ms_bInitialized
PUBLIC	?ms_bDisableIMECompletely@CIME@@2_NA		; CIME::ms_bDisableIMECompletely
PUBLIC	?ms_bUILessMode@CIME@@2_NA			; CIME::ms_bUILessMode
PUBLIC	?ms_bImeEnabled@CIME@@2_NA			; CIME::ms_bImeEnabled
PUBLIC	?ms_bCaptureInput@CIME@@2_NA			; CIME::ms_bCaptureInput
PUBLIC	?ms_bChineseIME@CIME@@2_NA			; CIME::ms_bChineseIME
PUBLIC	?ms_bUseIMMCandidate@CIME@@2_NA			; CIME::ms_bUseIMMCandidate
PUBLIC	?ms_hWnd@CIME@@2PAUHWND__@@A			; CIME::ms_hWnd
PUBLIC	?ms_hklCurrent@CIME@@2PAUHKL__@@A		; CIME::ms_hklCurrent
PUBLIC	?ms_szKeyboardLayout@CIME@@2PADA		; CIME::ms_szKeyboardLayout
PUBLIC	?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A		; CIME::ms_stOSVI
PUBLIC	?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A		; CIME::ms_hImm32Dll
PUBLIC	?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A	; CIME::ms_hCurrentImeDll
PUBLIC	?ms_dwImeState@CIME@@2KA			; CIME::ms_dwImeState
PUBLIC	?ms_adwId@CIME@@2PAKA				; CIME::ms_adwId
PUBLIC	?ms_dwIMELevel@CIME@@2KA			; CIME::ms_dwIMELevel
PUBLIC	?ms_dwIMELevelSaved@CIME@@2KA			; CIME::ms_dwIMELevelSaved
PUBLIC	?ms_bCandidateList@CIME@@2_NA			; CIME::ms_bCandidateList
PUBLIC	?ms_dwCandidateCount@CIME@@2KA			; CIME::ms_dwCandidateCount
PUBLIC	?ms_bVerticalCandidate@CIME@@2_NA		; CIME::ms_bVerticalCandidate
PUBLIC	?ms_iCandListIndexBase@CIME@@2HA		; CIME::ms_iCandListIndexBase
PUBLIC	?ms_wszCandidate@CIME@@2PAY0BAA@_WA		; CIME::ms_wszCandidate
PUBLIC	?ms_dwCandidateSelection@CIME@@2KA		; CIME::ms_dwCandidateSelection
PUBLIC	?ms_dwCandidatePageSize@CIME@@2KA		; CIME::ms_dwCandidatePageSize
PUBLIC	?ms_bReadingInformation@CIME@@2_NA		; CIME::ms_bReadingInformation
PUBLIC	?ms_iReadingError@CIME@@2HA			; CIME::ms_iReadingError
PUBLIC	?ms_bHorizontalReading@CIME@@2_NA		; CIME::ms_bHorizontalReading
PUBLIC	?ms_wszCurrentIndicator@CIME@@2PA_WA		; CIME::ms_wszCurrentIndicator
PUBLIC	?ms_pEvent@CIME@@2PAVIIMEEventSink@@A		; CIME::ms_pEvent
PUBLIC	?m_wText@CIME@@2PA_WA				; CIME::m_wText
PUBLIC	?ms_compLen@CIME@@2HA				; CIME::ms_compLen
PUBLIC	?ms_curpos@CIME@@2HA				; CIME::ms_curpos
PUBLIC	?ms_lastpos@CIME@@2HA				; CIME::ms_lastpos
PUBLIC	?ms_ulbegin@CIME@@2HA				; CIME::ms_ulbegin
PUBLIC	?ms_ulend@CIME@@2HA				; CIME::ms_ulend
PUBLIC	?ms_uOutputCodePage@CIME@@2IA			; CIME::ms_uOutputCodePage
PUBLIC	?ms_uInputCodePage@CIME@@2IA			; CIME::ms_uInputCodePage
PUBLIC	?s_aszIndicator@@3PAY02_WA			; s_aszIndicator
PUBLIC	?gs_codePage@@3KA				; gs_codePage
PUBLIC	?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A	; CTsfUiLessMode::m_tm
PUBLIC	?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA	; CTsfUiLessMode::m_dwUIElementSinkCookie
PUBLIC	?m_dwAlpnSinkCookie@CTsfUiLessMode@@1KA		; CTsfUiLessMode::m_dwAlpnSinkCookie
PUBLIC	?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA	; CTsfUiLessMode::m_dwOpenModeSinkCookie
PUBLIC	?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA	; CTsfUiLessMode::m_dwConvModeSinkCookie
PUBLIC	?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
PUBLIC	?m_nCandidateRefCount@CTsfUiLessMode@@1HA	; CTsfUiLessMode::m_nCandidateRefCount
_BSS	SEGMENT
?_ImmLockIMC@CIME@@1P6GPAU__MIDL___MIDL_itf_dimm_0000_0012@@PAUHIMC__@@@ZA DD 01H DUP (?) ; CIME::_ImmLockIMC
?_ImmUnlockIMC@CIME@@1P6GHPAUHIMC__@@@ZA DD 01H DUP (?)	; CIME::_ImmUnlockIMC
?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA DD 01H DUP (?) ; CIME::_ImmLockIMCC
?_ImmUnlockIMCC@CIME@@1P6GHPAUHIMCC__@@@ZA DD 01H DUP (?) ; CIME::_ImmUnlockIMCC
?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA DD 01H DUP (?) ; CIME::_GetReadingString
?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA DD 01H DUP (?) ; CIME::_ShowReadingWindow
?ms_bInitialized@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bInitialized
	ALIGN	4

?ms_bDisableIMECompletely@CIME@@2_NA DB 01H DUP (?)	; CIME::ms_bDisableIMECompletely
	ALIGN	4

?ms_bUILessMode@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bUILessMode
	ALIGN	4

?ms_bImeEnabled@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bImeEnabled
	ALIGN	4

?ms_bCaptureInput@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bCaptureInput
	ALIGN	4

?ms_bChineseIME@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bChineseIME
	ALIGN	4

?ms_bUseIMMCandidate@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bUseIMMCandidate
	ALIGN	4

?ms_hWnd@CIME@@2PAUHWND__@@A DD 01H DUP (?)		; CIME::ms_hWnd
?ms_hklCurrent@CIME@@2PAUHKL__@@A DD 01H DUP (?)	; CIME::ms_hklCurrent
?ms_szKeyboardLayout@CIME@@2PADA DB 0aH DUP (?)		; CIME::ms_szKeyboardLayout
	ALIGN	4

?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A DB 094H DUP (?)	; CIME::ms_stOSVI
?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A DD 01H DUP (?)	; CIME::ms_hImm32Dll
?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A DD 01H DUP (?) ; CIME::ms_hCurrentImeDll
?ms_dwImeState@CIME@@2KA DD 01H DUP (?)			; CIME::ms_dwImeState
?ms_adwId@CIME@@2PAKA DD 02H DUP (?)			; CIME::ms_adwId
?ms_dwIMELevel@CIME@@2KA DD 01H DUP (?)			; CIME::ms_dwIMELevel
?ms_dwIMELevelSaved@CIME@@2KA DD 01H DUP (?)		; CIME::ms_dwIMELevelSaved
?ms_bCandidateList@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bCandidateList
	ALIGN	4

?ms_dwCandidateCount@CIME@@2KA DD 01H DUP (?)		; CIME::ms_dwCandidateCount
?ms_bVerticalCandidate@CIME@@2_NA DB 01H DUP (?)	; CIME::ms_bVerticalCandidate
	ALIGN	4

?ms_iCandListIndexBase@CIME@@2HA DD 01H DUP (?)		; CIME::ms_iCandListIndexBase
?ms_wszCandidate@CIME@@2PAY0BAA@_WA DW 0a00H DUP (?)	; CIME::ms_wszCandidate
?ms_dwCandidateSelection@CIME@@2KA DD 01H DUP (?)	; CIME::ms_dwCandidateSelection
?ms_dwCandidatePageSize@CIME@@2KA DD 01H DUP (?)	; CIME::ms_dwCandidatePageSize
?ms_bReadingInformation@CIME@@2_NA DB 01H DUP (?)	; CIME::ms_bReadingInformation
	ALIGN	4

?ms_iReadingError@CIME@@2HA DD 01H DUP (?)		; CIME::ms_iReadingError
?ms_bHorizontalReading@CIME@@2_NA DB 01H DUP (?)	; CIME::ms_bHorizontalReading
	ALIGN	4

?ms_wszCurrentIndicator@CIME@@2PA_WA DD 01H DUP (?)	; CIME::ms_wszCurrentIndicator
?ms_pEvent@CIME@@2PAVIIMEEventSink@@A DD 01H DUP (?)	; CIME::ms_pEvent
?m_wText@CIME@@2PA_WA DW 0400H DUP (?)			; CIME::m_wText
?ms_compLen@CIME@@2HA DD 01H DUP (?)			; CIME::ms_compLen
?ms_curpos@CIME@@2HA DD 01H DUP (?)			; CIME::ms_curpos
?ms_lastpos@CIME@@2HA DD 01H DUP (?)			; CIME::ms_lastpos
?ms_ulbegin@CIME@@2HA DD 01H DUP (?)			; CIME::ms_ulbegin
?ms_ulend@CIME@@2HA DD 01H DUP (?)			; CIME::ms_ulend
?ms_uOutputCodePage@CIME@@2IA DD 01H DUP (?)		; CIME::ms_uOutputCodePage
?ms_uInputCodePage@CIME@@2IA DD 01H DUP (?)		; CIME::ms_uInputCodePage
?gs_codePage@@3KA DD 01H DUP (?)			; gs_codePage
?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A DD 01H DUP (?) ; CTsfUiLessMode::m_tm
?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A DD 01H DUP (?) ; CTsfUiLessMode::m_TsfSink
?m_nCandidateRefCount@CTsfUiLessMode@@1HA DD 01H DUP (?) ; CTsfUiLessMode::m_nCandidateRefCount
_BSS	ENDS
_DATA	SEGMENT
?s_aszIndicator@@3PAY02_WA DB 'E', 00H, 'n', 00H, 00H, 00H ; s_aszIndicator
	DB	080H, '{', 00H, 00H
	ORG $+2
	DB	'A~', 00H, 00H
	ORG $+2
	DB	00H, 0acH, 00H, 00H
	ORG $+2
	DB	'B0', 00H, 00H
	ORG $+2
	ORG $+2
?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA DD 0ffffffffH ; CTsfUiLessMode::m_dwUIElementSinkCookie
?m_dwAlpnSinkCookie@CTsfUiLessMode@@1KA DD 0ffffffffH	; CTsfUiLessMode::m_dwAlpnSinkCookie
?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA DD 0ffffffffH ; CTsfUiLessMode::m_dwOpenModeSinkCookie
?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA DD 0ffffffffH ; CTsfUiLessMode::m_dwConvModeSinkCookie
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0CIME@@QAE@XZ					; CIME::CIME
PUBLIC	??1CIME@@UAE@XZ					; CIME::~CIME
PUBLIC	?Initialize@CIME@@QAE_NPAUHWND__@@@Z		; CIME::Initialize
PUBLIC	?Uninitialize@CIME@@QAEXXZ			; CIME::Uninitialize
PUBLIC	?Clear@CIME@@SAXXZ				; CIME::Clear
PUBLIC	?SetMax@CIME@@QAEXH@Z				; CIME::SetMax
PUBLIC	?SetUserMax@CIME@@QAEXH@Z			; CIME::SetUserMax
PUBLIC	?SetText@CIME@@QAEXPBDH@Z			; CIME::SetText
PUBLIC	?GetText@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CIME::GetText
PUBLIC	?GetCodePageText@CIME@@QAEPBDXZ			; CIME::GetCodePageText
PUBLIC	?GetCodePage@CIME@@QAEHXZ			; CIME::GetCodePage
PUBLIC	?GetCandidateCount@CIME@@QAEHXZ			; CIME::GetCandidateCount
PUBLIC	?GetCandidatePageCount@CIME@@QAEHXZ		; CIME::GetCandidatePageCount
PUBLIC	?GetCandidate@CIME@@QAEHKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CIME::GetCandidate
PUBLIC	?GetCandidateSelection@CIME@@QAEHXZ		; CIME::GetCandidateSelection
PUBLIC	?GetReading@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CIME::GetReading
PUBLIC	?GetReadingError@CIME@@QAEHXZ			; CIME::GetReadingError
PUBLIC	?SetInputMode@CIME@@QAEXK@Z			; CIME::SetInputMode
PUBLIC	?GetInputMode@CIME@@QAEKXZ			; CIME::GetInputMode
PUBLIC	?IsIMEEnabled@CIME@@QAE_NXZ			; CIME::IsIMEEnabled
PUBLIC	?EnableIME@CIME@@QAEX_N@Z			; CIME::EnableIME
PUBLIC	?DisableIME@CIME@@QAEXXZ			; CIME::DisableIME
PUBLIC	?EnableCaptureInput@CIME@@QAEXXZ		; CIME::EnableCaptureInput
PUBLIC	?DisableCaptureInput@CIME@@QAEXXZ		; CIME::DisableCaptureInput
PUBLIC	?IsCaptureEnabled@CIME@@QAE_NXZ			; CIME::IsCaptureEnabled
PUBLIC	?SetNumberMode@CIME@@QAEXXZ			; CIME::SetNumberMode
PUBLIC	?SetStringMode@CIME@@QAEXXZ			; CIME::SetStringMode
PUBLIC	?__IsWritable@CIME@@QAE_N_W@Z			; CIME::__IsWritable
PUBLIC	?AddExceptKey@CIME@@QAEX_W@Z			; CIME::AddExceptKey
PUBLIC	?ClearExceptKey@CIME@@QAEXXZ			; CIME::ClearExceptKey
PUBLIC	?PasteTextFromClipBoard@CIME@@QAEXXZ		; CIME::PasteTextFromClipBoard
PUBLIC	?EnablePaste@CIME@@QAEX_N@Z			; CIME::EnablePaste
PUBLIC	?PasteString@CIME@@QAEXPBD@Z			; CIME::PasteString
PUBLIC	?FinalizeString@CIME@@SAX_N@Z			; CIME::FinalizeString
PUBLIC	?UseDefaultIME@CIME@@QAEXXZ			; CIME::UseDefaultIME
PUBLIC	?GetCurPos@CIME@@SAHXZ				; CIME::GetCurPos
PUBLIC	?GetCompLen@CIME@@SAHXZ				; CIME::GetCompLen
PUBLIC	?GetULBegin@CIME@@SAHXZ				; CIME::GetULBegin
PUBLIC	?GetULEnd@CIME@@SAHXZ				; CIME::GetULEnd
PUBLIC	?CloseCandidateList@CIME@@SAXXZ			; CIME::CloseCandidateList
PUBLIC	?CloseReadingInformation@CIME@@SAXXZ		; CIME::CloseReadingInformation
PUBLIC	?ChangeInputLanguage@CIME@@SAXXZ		; CIME::ChangeInputLanguage
PUBLIC	?ChangeInputLanguageWorker@CIME@@SAXXZ		; CIME::ChangeInputLanguageWorker
PUBLIC	?WMInputLanguage@CIME@@QAEJPAUHWND__@@IIJ@Z	; CIME::WMInputLanguage
PUBLIC	?WMStartComposition@CIME@@QAEJPAUHWND__@@IIJ@Z	; CIME::WMStartComposition
PUBLIC	?WMComposition@CIME@@QAEJPAUHWND__@@IIJ@Z	; CIME::WMComposition
PUBLIC	?WMEndComposition@CIME@@QAEJPAUHWND__@@IIJ@Z	; CIME::WMEndComposition
PUBLIC	?WMNotify@CIME@@QAEJPAUHWND__@@IIJ@Z		; CIME::WMNotify
PUBLIC	?WMChar@CIME@@QAEJPAUHWND__@@IIJ@Z		; CIME::WMChar
PUBLIC	?IncCurPos@CIME@@IAEXXZ				; CIME::IncCurPos
PUBLIC	?DecCurPos@CIME@@IAEXXZ				; CIME::DecCurPos
PUBLIC	?SetCurPos@CIME@@IAEXH@Z			; CIME::SetCurPos
PUBLIC	?DelCurPos@CIME@@IAEXXZ				; CIME::DelCurPos
PUBLIC	?CheckInputLocale@CIME@@KAXXZ			; CIME::CheckInputLocale
PUBLIC	?CheckToggleState@CIME@@KAXXZ			; CIME::CheckToggleState
PUBLIC	?SetSupportLevel@CIME@@KAXK@Z			; CIME::SetSupportLevel
PUBLIC	?InsertString@CIME@@IAEXPA_WH@Z			; CIME::InsertString
PUBLIC	?OnChar@CIME@@IAEX_W@Z				; CIME::OnChar
PUBLIC	?GetCodePageFromLang@CIME@@IAEIG@Z		; CIME::GetCodePageFromLang
PUBLIC	?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z		; CIME::ResultProcess
PUBLIC	?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CompositionProcessBuilding
PUBLIC	?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z	; CIME::CompositionProcess
PUBLIC	?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z	; CIME::AttributeProcess
PUBLIC	?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z	; CIME::CandidateProcess
PUBLIC	?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z		; CIME::ReadingProcess
PUBLIC	?IsMax@CIME@@IAE_NPB_WH@Z			; CIME::IsMax
PUBLIC	?GetImeId@CIME@@IAEKI@Z				; CIME::GetImeId
PUBLIC	?GetReadingWindowOrientation@CIME@@IAE_NXZ	; CIME::GetReadingWindowOrientation
PUBLIC	?SetupImeApi@CIME@@KAXXZ			; CIME::SetupImeApi
PUBLIC	??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ	; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> >
PUBLIC	??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ	; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
PUBLIC	?_Clear_and_reserve_geometric@?$vector@_WV?$allocator@_W@std@@@std@@AAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Clear_and_reserve_geometric
PUBLIC	?clear@?$vector@_WV?$allocator@_W@std@@@std@@QAEXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::clear
PUBLIC	?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size
PUBLIC	?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@ABEII@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@_WV?$allocator@_W@std@@@std@@AAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy_raw
PUBLIC	?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AAEXQA_WII@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array
PUBLIC	?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy
PUBLIC	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
PUBLIC	?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AAEAAV?$allocator@_W@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
PUBLIC	??_GCIME@@UAEPAXI@Z				; CIME::`scalar deleting destructor'
PUBLIC	??0CUIElementSink@CTsfUiLessMode@@QAE@XZ	; CTsfUiLessMode::CUIElementSink::CUIElementSink
PUBLIC	??1CUIElementSink@CTsfUiLessMode@@QAE@XZ	; CTsfUiLessMode::CUIElementSink::~CUIElementSink
PUBLIC	?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z ; CTsfUiLessMode::CUIElementSink::QueryInterface
PUBLIC	?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ	; CTsfUiLessMode::CUIElementSink::AddRef
PUBLIC	?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ	; CTsfUiLessMode::CUIElementSink::Release
PUBLIC	?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z ; CTsfUiLessMode::CUIElementSink::BeginUIElement
PUBLIC	?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z ; CTsfUiLessMode::CUIElementSink::UpdateUIElement
PUBLIC	?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z ; CTsfUiLessMode::CUIElementSink::EndUIElement
PUBLIC	?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z ; CTsfUiLessMode::CUIElementSink::OnActivated
PUBLIC	?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z ; CTsfUiLessMode::CUIElementSink::OnChange
PUBLIC	?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z ; CTsfUiLessMode::MakeReadingInformationString
PUBLIC	?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z ; CTsfUiLessMode::MakeCandidateStrings
PUBLIC	?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ; CTsfUiLessMode::GetUIElement
PUBLIC	?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z ; CTsfUiLessMode::GetCompartments
PUBLIC	?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ; CTsfUiLessMode::SetupCompartmentSinks
PUBLIC	?SetupSinks@CTsfUiLessMode@@SAHXZ		; CTsfUiLessMode::SetupSinks
PUBLIC	?ReleaseSinks@CTsfUiLessMode@@SAXXZ		; CTsfUiLessMode::ReleaseSinks
PUBLIC	?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ	; CTsfUiLessMode::CurrentInputLocaleIsIme
PUBLIC	?UpdateImeState@CTsfUiLessMode@@SAXH@Z		; CTsfUiLessMode::UpdateImeState
PUBLIC	?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z	; CTsfUiLessMode::EnableUiUpdates
PUBLIC	?Initialize@CDisableCicero@@QAEXXZ		; CDisableCicero::Initialize
PUBLIC	?Uninitialize@CDisableCicero@@QAEXXZ		; CDisableCicero::Uninitialize
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@_W@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@V10@V10@AB_W@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,wchar_t>
PUBLIC	?deallocate@?$allocator@E@std@@QAEXQAEI@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize<std::_Value_init_tag>
PUBLIC	??$emplace_back@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::emplace_back<wchar_t const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXAB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_back_with_unused_capacity<wchar_t const &>
PUBLIC	??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>
PUBLIC	??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$_Assign_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_range<wchar_t *>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
PUBLIC	??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@_W@std@@@std@@YAPA_WPA_WIAAV?$allocator@_W@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<wchar_t> >
PUBLIC	??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z	; std::_Copy_memmove<wchar_t *,wchar_t *>
PUBLIC	??$_Refancy@PA_W$0A@@std@@YAPA_WPA_W@Z		; std::_Refancy<wchar_t *,0>
PUBLIC	??$_Zero_range@PAE@std@@YAPAEQAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z		; std::_Zero_range<wchar_t *>
PUBLIC	??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{4}'
PUBLIC	?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{4}'
PUBLIC	?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{4}'
PUBLIC	?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{8}'
PUBLIC	?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{8}'
PUBLIC	?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{8}'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
PUBLIC	??_7CIME@@6B@					; CIME::`vftable'
PUBLIC	??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
PUBLIC	??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
PUBLIC	??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
PUBLIC	__GUID_aa80e801_2021_11d2_93e0_0060b067b86e
PUBLIC	??_C@_0L@LPOFADGE@?2imm32?4dll@			; `string'
PUBLIC	??_C@_0L@JGAMEFKO@ImmLockIMC@			; `string'
PUBLIC	??_C@_0N@PDIACEGP@ImmUnlockIMC@			; `string'
PUBLIC	??_C@_0M@OKKMJOGM@ImmLockIMCC@			; `string'
PUBLIC	??_C@_0O@GKKOACL@ImmUnlockIMCC@			; `string'
PUBLIC	??_C@_0BL@MBEANDFB@ImmDisableTextFrameService@	; `string'
PUBLIC	??_C@_05JKJMOPAK@?$EA?$CF04d@			; `string'
PUBLIC	??_C@_05EFEJGKEJ@?$EA9999@			; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_0N@FFMHCBAD@TINTLGNT?4IME@		; `string'
PUBLIC	??_C@_0N@JMLDIBIB@CINTLGNT?4IME@		; `string'
PUBLIC	??_C@_0N@FHDFFBN@MSTCIPHA?4IME@			; `string'
PUBLIC	??_C@_0N@JFHOELJF@PINTLGNT?4IME@		; `string'
PUBLIC	??_C@_0N@ONOBNHOE@MSSCIPYA?4IME@		; `string'
PUBLIC	??_C@_01KICIPPFI@?2@				; `string'
PUBLIC	??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@ ; `string'
PUBLIC	??_C@_07DEJAPC@MSTCIPH@				; `string'
PUBLIC	??_C@_08LMKCILHO@TINTLGNT@			; `string'
PUBLIC	??_C@_0BB@KFOMJFEN@Keyboard?5Mapping@		; `string'
PUBLIC	??_C@_0N@EMABPIGL@QQPINYIN?4IME@		; `string'
PUBLIC	??_C@_0M@IPABOCGB@SOGOUPY?4IME@			; `string'
PUBLIC	??_C@_0BC@KLAKFCEJ@GOOGLEPINYIN2?4IME@		; `string'
PUBLIC	??_C@_0BB@EOIFCLLM@GetReadingString@		; `string'
PUBLIC	??_C@_0BC@MEELNKEC@ShowReadingWindow@		; `string'
PUBLIC	__GUID_3e90ade3_7594_4cb0_bb58_69628f5f458c
PUBLIC	__GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
PUBLIC	__GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
PUBLIC	__GUID_71c6e74e_0f28_11d8_a82a_00065b84435c
PUBLIC	__GUID_743abd5f_f26d_48df_8cc5_238492419b64
PUBLIC	__GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
PUBLIC	__GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
PUBLIC	__GUID_ea1ea135_19df_11d7_a6d2_00065b84435c
PUBLIC	__GUID_1f02b6c5_7842_4ee6_8a0b_9a24183a95ca
PUBLIC	__GUID_71c6e74c_0f28_11d8_a82a_00065b84435c
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R0?AUIUnknown@@@8				; IUnknown `RTTI Type Descriptor'
PUBLIC	??_R3IUnknown@@8				; IUnknown::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IUnknown@@8				; IUnknown::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CIME@@6B@					; CIME::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCIME@@@8				; CIME `RTTI Type Descriptor'
PUBLIC	??_R3CIME@@8					; CIME::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CIME@@8					; CIME::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CIME@@8				; CIME::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUITfCompartmentEventSink@@@8		; ITfCompartmentEventSink `RTTI Type Descriptor'
PUBLIC	??_R3ITfCompartmentEventSink@@8			; ITfCompartmentEventSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITfCompartmentEventSink@@8			; ITfCompartmentEventSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITfCompartmentEventSink@@8	; ITfCompartmentEventSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUITfInputProcessorProfileActivationSink@@@8 ; ITfInputProcessorProfileActivationSink `RTTI Type Descriptor'
PUBLIC	??_R3ITfInputProcessorProfileActivationSink@@8	; ITfInputProcessorProfileActivationSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITfInputProcessorProfileActivationSink@@8	; ITfInputProcessorProfileActivationSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITfInputProcessorProfileActivationSink@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUITfUIElementSink@@@8			; ITfUIElementSink `RTTI Type Descriptor'
PUBLIC	??_R3ITfUIElementSink@@8			; ITfUIElementSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITfUIElementSink@@8			; ITfUIElementSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITfUIElementSink@@8		; ITfUIElementSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCUIElementSink@CTsfUiLessMode@@@8	; CTsfUiLessMode::CUIElementSink `RTTI Type Descriptor'
PUBLIC	??_R3CUIElementSink@CTsfUiLessMode@@8		; CTsfUiLessMode::CUIElementSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CUIElementSink@CTsfUiLessMode@@8		; CTsfUiLessMode::CUIElementSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CUIElementSink@CTsfUiLessMode@@8	; CTsfUiLessMode::CUIElementSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EC@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'
PUBLIC	??_R13?0A@EA@ITfInputProcessorProfileActivationSink@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R13?0A@EC@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (4,-1,0,66)'
PUBLIC	??_R17?0A@EA@ITfCompartmentEventSink@@8		; ITfCompartmentEventSink::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R17?0A@EC@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (8,-1,0,66)'
PUBLIC	??_R4CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
PUBLIC	??_R4CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_iswdigit:PROC
EXTRN	_towlower:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_wcscpy:PROC
EXTRN	_wcslen:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	__stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__GetSystemDirectoryA@8:PROC
EXTRN	__imp__GetVersionExA@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__GlobalUnlock@4:PROC
EXTRN	__imp__GlobalLock@4:PROC
EXTRN	__imp__lstrlenW@4:PROC
EXTRN	__imp__GetKeyboardLayoutNameA@4:PROC
EXTRN	__imp__GetKeyboardLayout@4:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__OpenClipboard@4:PROC
EXTRN	__imp__CloseClipboard@0:PROC
EXTRN	__imp__GetClipboardData@4:PROC
EXTRN	__imp__CharNextW@4:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__CompareStringA@24:PROC
EXTRN	__imp__GetLocaleInfoA@16:PROC
EXTRN	_GetFileVersionInfoSizeA@8:PROC
EXTRN	_GetFileVersionInfoA@16:PROC
EXTRN	_VerQueryValueA@16:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	_ImmGetIMEFileNameA@12:PROC
EXTRN	_ImmIsIME@4:PROC
EXTRN	_ImmGetContext@4:PROC
EXTRN	_ImmReleaseContext@8:PROC
EXTRN	_ImmAssociateContext@8:PROC
EXTRN	_ImmGetCompositionStringW@16:PROC
EXTRN	_ImmSetCompositionStringW@24:PROC
EXTRN	_ImmGetCandidateListW@16:PROC
EXTRN	_ImmGetConversionStatus@12:PROC
EXTRN	_ImmSetConversionStatus@12:PROC
EXTRN	_ImmGetOpenStatus@4:PROC
EXTRN	_ImmNotifyIME@16:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitializeEx@8:PROC
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??_ECIME@@UAEPAXI@Z:PROC			; CIME::`vector deleting destructor'
EXTRN	?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z:PROC ; GetTextTagOutputString
EXTRN	?GetTextTagOutputLen@@YAHPB_WH@Z:PROC		; GetTextTagOutputLen
EXTRN	?FindColorTagEndPosition@@YAHPB_WH@Z:PROC	; FindColorTagEndPosition
EXTRN	?FindColorTagStartPosition@@YAHPB_WH@Z:PROC	; FindColorTagStartPosition
EXTRN	?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z:PROC ; GetTextTagInternalPosFromRenderPos
EXTRN	?MIN@@YAHHH@Z:PROC				; MIN
EXTRN	__imp__SysFreeString@4:PROC
EXTRN	__imp__VariantClear@4:PROC
EXTRN	?GetDefaultCodePage@@YAKXZ:PROC			; GetDefaultCodePage
EXTRN	?ReadToken@@YAHPBD@Z:PROC			; ReadToken
EXTRN	?FindToken@@YAPBDPBD0@Z:PROC			; FindToken
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	_IID_IUnknown:BYTE
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	_CLSID_TF_ThreadMgr:BYTE
EXTRN	_CLSID_TF_InputProcessorProfiles:BYTE
EXTRN	_GUID_COMPARTMENT_KEYBOARD_OPENCLOSE:BYTE
EXTRN	_GUID_TFCAT_TIP_KEYBOARD:BYTE
EXTRN	_IID_ITfCompartmentEventSink:BYTE
EXTRN	_IID_ITfCompartmentMgr:BYTE
EXTRN	_IID_ITfSource:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A DB 0cH DUP (?) ; CIME::ms_wstrReading
	ALIGN	8

?g_disableCicero@@3VCDisableCicero@@A DQ 01H DUP (?)	; g_disableCicero
_BSS	ENDS
;	COMDAT ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA
_BSS	SEGMENT
?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA DB 010H DUP (?) ; `CIME::GetCodePageText'::`2'::szCodePage
_BSS	ENDS
;	COMDAT ?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA
_BSS	SEGMENT
?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA DB 01H DUP (?) ; `CIME::FinalizeString'::`2'::s_bProcessing
_BSS	ENDS
;	COMDAT ?hklPrev@?1??GetImeId@CIME@@IAEKI@Z@4PAUHKL__@@A
_BSS	SEGMENT
?hklPrev@?1??GetImeId@CIME@@IAEKI@Z@4PAUHKL__@@A DD 01H DUP (?) ; `CIME::GetImeId'::`2'::hklPrev
_BSS	ENDS
;	COMDAT ?s_hklPrev@?1??CheckInputLocale@CIME@@KAXXZ@4PAUHKL__@@A
_BSS	SEGMENT
?s_hklPrev@?1??CheckInputLocale@CIME@@KAXXZ@4PAUHKL__@@A DD 01H DUP (?) ; `CIME::CheckInputLocale'::`2'::s_hklPrev
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_wstrReading$initializer$@CIME@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ ; ??ms_wstrReading$initializer$@CIME@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT ??_R4CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@
rdata$r	SEGMENT
??_R4CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ DD 00H ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AVCUIElementSink@CTsfUiLessMode@@@8
	DD	FLAT:??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R4CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@
rdata$r	SEGMENT
??_R4CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ DD 00H ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVCUIElementSink@CTsfUiLessMode@@@8
	DD	FLAT:??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EC@IUnknown@@8
rdata$r	SEGMENT
??_R17?0A@EC@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (8,-1,0,66)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@ITfCompartmentEventSink@@8
rdata$r	SEGMENT
??_R17?0A@EA@ITfCompartmentEventSink@@8 DD FLAT:??_R0?AUITfCompartmentEventSink@@@8 ; ITfCompartmentEventSink::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	01H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfCompartmentEventSink@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EC@IUnknown@@8
rdata$r	SEGMENT
??_R13?0A@EC@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (4,-1,0,66)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@ITfInputProcessorProfileActivationSink@@8
rdata$r	SEGMENT
??_R13?0A@EA@ITfInputProcessorProfileActivationSink@@8 DD FLAT:??_R0?AUITfInputProcessorProfileActivationSink@@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	01H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfInputProcessorProfileActivationSink@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EC@IUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EC@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CUIElementSink@CTsfUiLessMode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CUIElementSink@CTsfUiLessMode@@8 DD FLAT:??_R0?AVCUIElementSink@CTsfUiLessMode@@@8 ; CTsfUiLessMode::CUIElementSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R2CUIElementSink@CTsfUiLessMode@@8
rdata$r	SEGMENT
??_R2CUIElementSink@CTsfUiLessMode@@8 DD FLAT:??_R1A@?0A@EA@CUIElementSink@CTsfUiLessMode@@8 ; CTsfUiLessMode::CUIElementSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ITfUIElementSink@@8
	DD	FLAT:??_R1A@?0A@EC@IUnknown@@8
	DD	FLAT:??_R13?0A@EA@ITfInputProcessorProfileActivationSink@@8
	DD	FLAT:??_R13?0A@EC@IUnknown@@8
	DD	FLAT:??_R17?0A@EA@ITfCompartmentEventSink@@8
	DD	FLAT:??_R17?0A@EC@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	SEGMENT
??_R3CUIElementSink@CTsfUiLessMode@@8 DD 00H		; CTsfUiLessMode::CUIElementSink::`RTTI Class Hierarchy Descriptor'
	DD	05H
	DD	07H
	DD	FLAT:??_R2CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCUIElementSink@CTsfUiLessMode@@@8
data$rs	SEGMENT
??_R0?AVCUIElementSink@CTsfUiLessMode@@@8 DD FLAT:??_7type_info@@6B@ ; CTsfUiLessMode::CUIElementSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCUIElementSink@CTsfUiLessMode@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@
rdata$r	SEGMENT
??_R4CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ DD 00H ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCUIElementSink@CTsfUiLessMode@@@8
	DD	FLAT:??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ITfUIElementSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITfUIElementSink@@8 DD FLAT:??_R0?AUITfUIElementSink@@@8 ; ITfUIElementSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfUIElementSink@@8
rdata$r	ENDS
;	COMDAT ??_R2ITfUIElementSink@@8
rdata$r	SEGMENT
??_R2ITfUIElementSink@@8 DD FLAT:??_R1A@?0A@EA@ITfUIElementSink@@8 ; ITfUIElementSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3ITfUIElementSink@@8
rdata$r	SEGMENT
??_R3ITfUIElementSink@@8 DD 00H				; ITfUIElementSink::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITfUIElementSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITfUIElementSink@@@8
data$rs	SEGMENT
??_R0?AUITfUIElementSink@@@8 DD FLAT:??_7type_info@@6B@	; ITfUIElementSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITfUIElementSink@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@ITfInputProcessorProfileActivationSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITfInputProcessorProfileActivationSink@@8 DD FLAT:??_R0?AUITfInputProcessorProfileActivationSink@@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfInputProcessorProfileActivationSink@@8
rdata$r	ENDS
;	COMDAT ??_R2ITfInputProcessorProfileActivationSink@@8
rdata$r	SEGMENT
??_R2ITfInputProcessorProfileActivationSink@@8 DD FLAT:??_R1A@?0A@EA@ITfInputProcessorProfileActivationSink@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3ITfInputProcessorProfileActivationSink@@8
rdata$r	SEGMENT
??_R3ITfInputProcessorProfileActivationSink@@8 DD 00H	; ITfInputProcessorProfileActivationSink::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITfInputProcessorProfileActivationSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITfInputProcessorProfileActivationSink@@@8
data$rs	SEGMENT
??_R0?AUITfInputProcessorProfileActivationSink@@@8 DD FLAT:??_7type_info@@6B@ ; ITfInputProcessorProfileActivationSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITfInputProcessorProfileActivationSink@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@ITfCompartmentEventSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITfCompartmentEventSink@@8 DD FLAT:??_R0?AUITfCompartmentEventSink@@@8 ; ITfCompartmentEventSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfCompartmentEventSink@@8
rdata$r	ENDS
;	COMDAT ??_R2ITfCompartmentEventSink@@8
rdata$r	SEGMENT
??_R2ITfCompartmentEventSink@@8 DD FLAT:??_R1A@?0A@EA@ITfCompartmentEventSink@@8 ; ITfCompartmentEventSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3ITfCompartmentEventSink@@8
rdata$r	SEGMENT
??_R3ITfCompartmentEventSink@@8 DD 00H			; ITfCompartmentEventSink::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITfCompartmentEventSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITfCompartmentEventSink@@@8
data$rs	SEGMENT
??_R0?AUITfCompartmentEventSink@@@8 DD FLAT:??_7type_info@@6B@ ; ITfCompartmentEventSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITfCompartmentEventSink@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CIME@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CIME@@8 DD FLAT:??_R0?AVCIME@@@8		; CIME::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CIME@@8
rdata$r	ENDS
;	COMDAT ??_R2CIME@@8
rdata$r	SEGMENT
??_R2CIME@@8 DD	FLAT:??_R1A@?0A@EA@CIME@@8		; CIME::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CIME@@8
rdata$r	SEGMENT
??_R3CIME@@8 DD	00H					; CIME::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CIME@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCIME@@@8
data$rs	SEGMENT
??_R0?AVCIME@@@8 DD FLAT:??_7type_info@@6B@		; CIME `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCIME@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CIME@@6B@
rdata$r	SEGMENT
??_R4CIME@@6B@ DD 00H					; CIME::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCIME@@@8
	DD	FLAT:??_R3CIME@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R2IUnknown@@8
rdata$r	SEGMENT
??_R2IUnknown@@8 DD FLAT:??_R1A@?0A@EA@IUnknown@@8	; IUnknown::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IUnknown@@8
rdata$r	SEGMENT
??_R3IUnknown@@8 DD 00H					; IUnknown::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknown@@@8
data$rs	SEGMENT
??_R0?AUIUnknown@@@8 DD FLAT:??_7type_info@@6B@		; IUnknown `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIUnknown@@', 00H
data$rs	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION@?1??GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z@4U_GUID@@A
_DATA	SEGMENT
?_GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION@?1??GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z@4U_GUID@@A DD 0ccf05dd8H ; `CTsfUiLessMode::GetCompartments'::`2'::_GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION
	DW	04a87H
	DW	011d7H
	DB	0a6H
	DB	0e2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
_DATA	ENDS
;	COMDAT __GUID_71c6e74c_0f28_11d8_a82a_00065b84435c
CONST	SEGMENT
__GUID_71c6e74c_0f28_11d8_a82a_00065b84435c DD 071c6e74cH
	DW	0f28H
	DW	011d8H
	DB	0a8H
	DB	02aH
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_1f02b6c5_7842_4ee6_8a0b_9a24183a95ca
CONST	SEGMENT
__GUID_1f02b6c5_7842_4ee6_8a0b_9a24183a95ca DD 01f02b6c5H
	DW	07842H
	DW	04ee6H
	DB	08aH
	DB	0bH
	DB	09aH
	DB	024H
	DB	018H
	DB	03aH
	DB	095H
	DB	0caH
CONST	ENDS
;	COMDAT __GUID_ea1ea135_19df_11d7_a6d2_00065b84435c
CONST	SEGMENT
__GUID_ea1ea135_19df_11d7_a6d2_00065b84435c DD 0ea1ea135H
	DW	019dfH
	DW	011d7H
	DB	0a6H
	DB	0d2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT ?TF_PROFILE_DAYI@?1??OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z@4U4@A
_DATA	SEGMENT
?TF_PROFILE_DAYI@?1??OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z@4U4@A DD 037b2c25H ; `CTsfUiLessMode::CUIElementSink::OnActivated'::`2'::TF_PROFILE_DAYI
	DW	0480cH
	DW	04d7fH
	DB	0b0H
	DB	027H
	DB	0d6H
	DB	0caH
	DB	06bH
	DB	069H
	DB	078H
	DB	08aH
_DATA	ENDS
;	COMDAT __GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
CONST	SEGMENT
__GUID_ea1ea138_19df_11d7_a6d2_00065b84435c DD 0ea1ea138H
	DW	019dfH
	DW	011d7H
	DB	0a6H
	DB	0d2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
CONST	SEGMENT
__GUID_ea1ea139_19df_11d7_a6d2_00065b84435c DD 0ea1ea139H
	DW	019dfH
	DW	011d7H
	DB	0a6H
	DB	0d2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_743abd5f_f26d_48df_8cc5_238492419b64
CONST	SEGMENT
__GUID_743abd5f_f26d_48df_8cc5_238492419b64 DD 0743abd5fH
	DW	0f26dH
	DW	048dfH
	DB	08cH
	DB	0c5H
	DB	023H
	DB	084H
	DB	092H
	DB	041H
	DB	09bH
	DB	064H
CONST	ENDS
;	COMDAT __GUID_71c6e74e_0f28_11d8_a82a_00065b84435c
CONST	SEGMENT
__GUID_71c6e74e_0f28_11d8_a82a_00065b84435c DD 071c6e74eH
	DW	0f28H
	DW	011d8H
	DB	0a8H
	DB	02aH
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
CONST	SEGMENT
__GUID_ea1ea136_19df_11d7_a6d2_00065b84435c DD 0ea1ea136H
	DW	019dfH
	DW	011d7H
	DB	0a6H
	DB	0d2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
CONST	SEGMENT
__GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7 DD 04ea48a35H
	DW	060aeH
	DW	0446fH
	DB	08fH
	DB	0d6H
	DB	0e6H
	DB	0a8H
	DB	0d8H
	DB	024H
	DB	059H
	DB	0f7H
CONST	ENDS
;	COMDAT __GUID_3e90ade3_7594_4cb0_bb58_69628f5f458c
CONST	SEGMENT
__GUID_3e90ade3_7594_4cb0_bb58_69628f5f458c DD 03e90ade3H
	DW	07594H
	DW	04cb0H
	DB	0bbH
	DB	058H
	DB	069H
	DB	062H
	DB	08fH
	DB	05fH
	DB	045H
	DB	08cH
CONST	ENDS
;	COMDAT ?s_uPrevCodePage@?1??CheckInputLocale@CIME@@KAXXZ@4IA
_DATA	SEGMENT
?s_uPrevCodePage@?1??CheckInputLocale@CIME@@KAXXZ@4IA DD 0ffffH ; `CIME::CheckInputLocale'::`2'::s_uPrevCodePage
_DATA	ENDS
;	COMDAT ??_C@_0BC@MEELNKEC@ShowReadingWindow@
CONST	SEGMENT
??_C@_0BC@MEELNKEC@ShowReadingWindow@ DB 'ShowReadingWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EOIFCLLM@GetReadingString@
CONST	SEGMENT
??_C@_0BB@EOIFCLLM@GetReadingString@ DB 'GetReadingString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KLAKFCEJ@GOOGLEPINYIN2?4IME@
CONST	SEGMENT
??_C@_0BC@KLAKFCEJ@GOOGLEPINYIN2?4IME@ DB 'GOOGLEPINYIN2.IME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IPABOCGB@SOGOUPY?4IME@
CONST	SEGMENT
??_C@_0M@IPABOCGB@SOGOUPY?4IME@ DB 'SOGOUPY.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EMABPIGL@QQPINYIN?4IME@
CONST	SEGMENT
??_C@_0N@EMABPIGL@QQPINYIN?4IME@ DB 'QQPINYIN.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KFOMJFEN@Keyboard?5Mapping@
CONST	SEGMENT
??_C@_0BB@KFOMJFEN@Keyboard?5Mapping@ DB 'Keyboard Mapping', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LMKCILHO@TINTLGNT@
CONST	SEGMENT
??_C@_08LMKCILHO@TINTLGNT@ DB 'TINTLGNT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DEJAPC@MSTCIPH@
CONST	SEGMENT
??_C@_07DEJAPC@MSTCIPH@ DB 'MSTCIPH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@
CONST	SEGMENT
??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@ DB 'software\micro'
	DB	'soft\windows\currentversion\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2@
CONST	SEGMENT
??_C@_01KICIPPFI@?2@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ONOBNHOE@MSSCIPYA?4IME@
CONST	SEGMENT
??_C@_0N@ONOBNHOE@MSSCIPYA?4IME@ DB 'MSSCIPYA.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JFHOELJF@PINTLGNT?4IME@
CONST	SEGMENT
??_C@_0N@JFHOELJF@PINTLGNT?4IME@ DB 'PINTLGNT.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FHDFFBN@MSTCIPHA?4IME@
CONST	SEGMENT
??_C@_0N@FHDFFBN@MSTCIPHA?4IME@ DB 'MSTCIPHA.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JMLDIBIB@CINTLGNT?4IME@
CONST	SEGMENT
??_C@_0N@JMLDIBIB@CINTLGNT?4IME@ DB 'CINTLGNT.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FFMHCBAD@TINTLGNT?4IME@
CONST	SEGMENT
??_C@_0N@FFMHCBAD@TINTLGNT?4IME@ DB 'TINTLGNT.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05EFEJGKEJ@?$EA9999@
CONST	SEGMENT
??_C@_05EFEJGKEJ@?$EA9999@ DB '@9999', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKJMOPAK@?$EA?$CF04d@
CONST	SEGMENT
??_C@_05JKJMOPAK@?$EA?$CF04d@ DB '@%04d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MBEANDFB@ImmDisableTextFrameService@
CONST	SEGMENT
??_C@_0BL@MBEANDFB@ImmDisableTextFrameService@ DB 'ImmDisableTextFrameSer'
	DB	'vice', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKKOACL@ImmUnlockIMCC@
CONST	SEGMENT
??_C@_0O@GKKOACL@ImmUnlockIMCC@ DB 'ImmUnlockIMCC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OKKMJOGM@ImmLockIMCC@
CONST	SEGMENT
??_C@_0M@OKKMJOGM@ImmLockIMCC@ DB 'ImmLockIMCC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PDIACEGP@ImmUnlockIMC@
CONST	SEGMENT
??_C@_0N@PDIACEGP@ImmUnlockIMC@ DB 'ImmUnlockIMC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JGAMEFKO@ImmLockIMC@
CONST	SEGMENT
??_C@_0L@JGAMEFKO@ImmLockIMC@ DB 'ImmLockIMC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LPOFADGE@?2imm32?4dll@
CONST	SEGMENT
??_C@_0L@LPOFADGE@?2imm32?4dll@ DB '\imm32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT __GUID_aa80e801_2021_11d2_93e0_0060b067b86e
CONST	SEGMENT
__GUID_aa80e801_2021_11d2_93e0_0060b067b86e DD 0aa80e801H
	DW	02021H
	DW	011d2H
	DB	093H
	DB	0e0H
	DB	00H
	DB	060H
	DB	0b0H
	DB	067H
	DB	0b8H
	DB	06eH
CONST	ENDS
;	COMDAT ??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@
CONST	SEGMENT
??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ DD FLAT:??_R4CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
	DD	FLAT:?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ
	DD	FLAT:?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ
	DD	FLAT:?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z
CONST	ENDS
;	COMDAT ??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@
CONST	SEGMENT
??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ DD FLAT:??_R4CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
	DD	FLAT:?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ
	DD	FLAT:?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ
	DD	FLAT:?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z
CONST	ENDS
;	COMDAT ??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@
CONST	SEGMENT
??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ DD FLAT:??_R4CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
	DD	FLAT:?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ
	DD	FLAT:?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ
	DD	FLAT:?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z
	DD	FLAT:?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z
	DD	FLAT:?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z
CONST	ENDS
;	COMDAT ??_7CIME@@6B@
CONST	SEGMENT
??_7CIME@@6B@ DD FLAT:??_R4CIME@@6B@			; CIME::`vftable'
	DD	FLAT:??_ECIME@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z$0
__unwindtable$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z$32
__ehfuncinfo$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Fg_disableCicero@@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__Fg_disableCicero@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Fg_disableCicero@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetupSinks@CTsfUiLessMode@@SAHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupSinks@CTsfUiLessMode@@SAHXZ$0
__ehfuncinfo$?SetupSinks@CTsfUiLessMode@@SAHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetupSinks@CTsfUiLessMode@@SAHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IsMax@CIME@@IAE_NPB_WH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsMax@CIME@@IAE_NPB_WH@Z$0
__ehfuncinfo$?IsMax@CIME@@IAE_NPB_WH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsMax@CIME@@IAE_NPB_WH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z$0
__ehfuncinfo$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PasteTextFromClipBoard@CIME@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PasteTextFromClipBoard@CIME@@QAEXXZ$0
__ehfuncinfo$?PasteTextFromClipBoard@CIME@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PasteTextFromClipBoard@CIME@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CIME@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CIME@@QAE@XZ$0
__ehfuncinfo$??0CIME@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CIME@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?g_disableCicero$initializer$@@3P6AXXZA DD FLAT:??__Eg_disableCicero@@YAXXZ ; g_disableCicero$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odspy
;	COMDAT ?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ
_TEXT	SEGMENT
?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ PROC	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{8}', COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ ; CTsfUiLessMode::CUIElementSink::Release
?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ ENDP	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{8}'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ
_TEXT	SEGMENT
?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ PROC	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{8}', COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ ; CTsfUiLessMode::CUIElementSink::AddRef
?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ ENDP	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{8}'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{8}', COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z ; CTsfUiLessMode::CUIElementSink::QueryInterface
?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{8}'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ
_TEXT	SEGMENT
?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ PROC	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{4}', COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ ; CTsfUiLessMode::CUIElementSink::Release
?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ ENDP	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ
_TEXT	SEGMENT
?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ PROC	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{4}', COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ ; CTsfUiLessMode::CUIElementSink::AddRef
?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ ENDP	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{4}', COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z ; CTsfUiLessMode::CUIElementSink::QueryInterface
?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z PROC		; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ; std::_Copy_memmove<unsigned char *,unsigned char *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	03 45 10	 add	 eax, DWORD PTR __Dest$[ebp]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00032	c9		 leave
  00033	c3		 ret	 0
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z
_TEXT	SEGMENT
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z PROC		; std::_Zero_range<wchar_t *>, COMDAT

; 1852 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1853 :     char* const _First_ch = reinterpret_cast<char*>(_First);

  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 1854 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 1855 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00011	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00014	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  0001d	e8 00 00 00 00	 call	 _memset
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1856 :     return _Last;

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 1857 : }

  00028	c9		 leave
  00029	c3		 ret	 0
??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z ENDP		; std::_Zero_range<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Zero_range@PAE@std@@YAPAEQAE0@Z
_TEXT	SEGMENT
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAE@std@@YAPAEQAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT

; 1852 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1853 :     char* const _First_ch = reinterpret_cast<char*>(_First);

  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 1854 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 1855 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00011	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00014	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  0001d	e8 00 00 00 00	 call	 _memset
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1856 :     return _Last;

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 1857 : }

  00028	c9		 leave
  00029	c3		 ret	 0
??$_Zero_range@PAE@std@@YAPAEQAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PA_W$0A@@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PA_W$0A@@std@@YAPA_WPA_W@Z PROC		; std::_Refancy<wchar_t *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PA_W$0A@@std@@YAPA_WPA_W@Z ENDP		; std::_Refancy<wchar_t *,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z PROC	; std::_Copy_memmove<wchar_t *,wchar_t *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z ENDP	; std::_Copy_memmove<wchar_t *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@_W@std@@@std@@YAPA_WPA_WIAAV?$allocator@_W@0@@Z
_TEXT	SEGMENT
__PFirst$1 = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@_W@std@@@std@@YAPA_WPA_WIAAV?$allocator@_W@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<wchar_t> >, COMDAT

; 1862 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR __PFirst$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1867 :         _Zero_range(_PFirst, _PFirst + _Count);

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR __PFirst$1[ebp]
  00010	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00013	50		 push	 eax
  00014	ff 75 fc	 push	 DWORD PTR __PFirst$1[ebp]
  00017	e8 00 00 00 00	 call	 ??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z ; std::_Zero_range<wchar_t *>
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx

; 1868 :         return _First + _Count;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00024	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 1869 :     } else {
; 1870 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1871 :         for (; 0 < _Count; --_Count) {
; 1872 :             _Backout._Emplace_back();
; 1873 :         }
; 1874 : 
; 1875 :         return _Backout._Release();
; 1876 :     }
; 1877 : }

  00027	c9		 leave
  00028	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@_W@std@@@std@@YAPA_WPA_WIAAV?$allocator@_W@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z PROC ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z ; std::_Copy_memmove<wchar_t *,wchar_t *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	d1 f8		 sar	 eax, 1
  00031	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00034	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00037	c9		 leave
  00038	c3		 ret	 0
??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z ENDP ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__PFirst$1 = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >, COMDAT

; 1862 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR __PFirst$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1867 :         _Zero_range(_PFirst, _PFirst + _Count);

  0000a	8b 45 fc	 mov	 eax, DWORD PTR __PFirst$1[ebp]
  0000d	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00010	50		 push	 eax
  00011	ff 75 fc	 push	 DWORD PTR __PFirst$1[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Zero_range@PAE@std@@YAPAEQAE0@Z ; std::_Zero_range<unsigned char *>
  00019	59		 pop	 ecx
  0001a	59		 pop	 ecx

; 1868 :         return _First + _Count;

  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]

; 1869 :     } else {
; 1870 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1871 :         for (; 0 < _Count; --_Count) {
; 1872 :             _Backout._Emplace_back();
; 1873 :         }
; 1874 : 
; 1875 :         return _Backout._Release();
; 1876 :     }
; 1877 : }

  00021	c9		 leave
  00022	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Max_possible$2 = -148					; size = 4
$T3 = -144						; size = 4
$T4 = -140						; size = 4
__First$ = -136						; size = 4
__Last$ = -132						; size = 4
$T5 = -128						; size = 4
$T6 = -124						; size = 4
tv244 = -120						; size = 4
$T7 = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
$T12 = -96						; size = 4
$T13 = -92						; size = 4
$T14 = -88						; size = 4
$T15 = -84						; size = 4
__Appended_last$ = -80					; size = 4
__Myfirst$ = -76					; size = 4
__Mylast$ = -72						; size = 4
__Oldsize$ = -68					; size = 4
__My_data$ = -64					; size = 4
tv147 = -60						; size = 4
$T16 = -56						; size = 4
$T17 = -52						; size = 4
__Appended_first$ = -48					; size = 4
___formal$ = -44					; size = 1
___formal$ = -40					; size = 1
__Overflow_is_possible$18 = -33				; size = 1
__Newvec$ = -32						; size = 4
__Newcapacity$ = -28					; size = 4
$T19 = -21						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00035	89 45 ac	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00038	8b 45 ac	 mov	 eax, DWORD PTR $T15[ebp]
  0003b	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00041	c7 45 cc ff ff
	ff 7f		 mov	 DWORD PTR $T17[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00048	c7 45 a8 ff ff
	ff 7f		 mov	 DWORD PTR $T14[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0004f	8b 45 a8	 mov	 eax, DWORD PTR $T14[ebp]
  00052	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00055	8b 45 cc	 mov	 eax, DWORD PTR $T17[ebp]
  00058	3b 45 c8	 cmp	 eax, DWORD PTR $T16[ebp]
  0005b	73 08		 jae	 SHORT $LN26@Resize_rea
  0005d	8d 45 cc	 lea	 eax, DWORD PTR $T17[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
  00063	eb 06		 jmp	 SHORT $LN27@Resize_rea
$LN26@Resize_rea:
  00065	8d 45 c8	 lea	 eax, DWORD PTR $T16[ebp]
  00068	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
$LN27@Resize_rea:
  0006b	8b 45 c4	 mov	 eax, DWORD PTR tv147[ebp]
  0006e	89 45 a4	 mov	 DWORD PTR $T13[ebp], eax
  00071	8b 45 a4	 mov	 eax, DWORD PTR $T13[ebp]
  00074	89 45 a0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00077	8b 45 a0	 mov	 eax, DWORD PTR $T12[ebp]
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	89 45 9c	 mov	 DWORD PTR $T11[ebp], eax

; 1183 :         if (_Newsize > max_size()) {

  0007f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00082	3b 45 9c	 cmp	 eax, DWORD PTR $T11[ebp]
  00085	76 05		 jbe	 SHORT $LN2@Resize_rea

; 1184 :             _Xlength();

  00087	e8 00 00 00 00	 call	 ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN2@Resize_rea:

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;

  0008c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	89 45 c0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1188 :         pointer& _Myfirst = _My_data._Myfirst;

  00092	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00095	89 45 b4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1189 :         pointer& _Mylast  = _My_data._Mylast;

  00098	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0009b	83 c0 04	 add	 eax, 4
  0009e	89 45 b8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  000a1	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a4	8b 4d b4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	2b 01		 sub	 eax, DWORD PTR [ecx]
  000ab	d1 f8		 sar	 eax, 1
  000ad	89 45 bc	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000b0	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  000b3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@ABEII@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth
  000bb	89 45 e4	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  000be	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c1	89 45 98	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000c4	8b 45 98	 mov	 eax, DWORD PTR $T10[ebp]
  000c7	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000cd	c6 45 df 01	 mov	 BYTE PTR __Overflow_is_possible$18[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000d1	c7 85 6c ff ff
	ff ff ff ff 7f	 mov	 DWORD PTR __Max_possible$2[ebp], 2147483647 ; 7fffffffH

; 60   :         if (_Count > _Max_possible) {

  000db	81 7d e4 ff ff
	ff 7f		 cmp	 DWORD PTR __Newcapacity$[ebp], 2147483647 ; 7fffffffH
  000e2	76 05		 jbe	 SHORT $LN65@Resize_rea

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000e4	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN65@Resize_rea:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000e9	8b 45 e4	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000ec	d1 e0		 shl	 eax, 1
  000ee	89 45 94	 mov	 DWORD PTR $T9[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000f1	ff 75 94	 push	 DWORD PTR $T9[ebp]
  000f4	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000f9	59		 pop	 ecx
  000fa	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000fd	8b 45 bc	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  00100	8b 4d e0	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00103	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00106	89 45 d0	 mov	 DWORD PTR __Appended_first$[ebp], eax

; 1196 :         pointer _Appended_last        = _Appended_first;

  00109	8b 45 d0	 mov	 eax, DWORD PTR __Appended_first$[ebp]
  0010c	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1197 : 
; 1198 :         _TRY_BEGIN

  0010f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00113	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00116	8a 00		 mov	 al, BYTE PTR [eax]
  00118	88 45 d8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0011b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0011e	89 45 90	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00121	8b 45 90	 mov	 eax, DWORD PTR $T8[ebp]
  00124	89 45 8c	 mov	 DWORD PTR $T7[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00127	ff 75 8c	 push	 DWORD PTR $T7[ebp]

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  0012a	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0012d	2b 45 bc	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00130	50		 push	 eax
  00131	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00134	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@_W@std@@@std@@YAPA_WPA_WIAAV?$allocator@_W@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<wchar_t> >
  00139	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013c	89 45 88	 mov	 DWORD PTR tv244[ebp], eax

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  0013f	8b 45 88	 mov	 eax, DWORD PTR tv244[ebp]
  00142	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00145	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00148	8b 00		 mov	 eax, DWORD PTR [eax]
  0014a	89 85 7c ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00150	8b 45 b4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00153	8b 00		 mov	 eax, DWORD PTR [eax]
  00155	89 85 78 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0015b	33 c0		 xor	 eax, eax
  0015d	88 45 eb	 mov	 BYTE PTR $T19[ebp], al
  00160	8a 45 eb	 mov	 al, BYTE PTR $T19[ebp]
  00163	88 45 d4	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00166	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00169	89 45 84	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0016c	8b 45 84	 mov	 eax, DWORD PTR $T6[ebp]
  0016f	89 45 80	 mov	 DWORD PTR $T5[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00172	ff 75 80	 push	 DWORD PTR $T5[ebp]
  00175	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  00178	ff b5 7c ff ff
	ff		 push	 DWORD PTR __Last$[ebp]
  0017e	ff b5 78 ff ff
	ff		 push	 DWORD PTR __First$[ebp]
  00184	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
  00189	83 c4 10	 add	 esp, 16			; 00000010H

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0018c	eb 32		 jmp	 SHORT $LN5@Resize_rea
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);

  0018e	ff 75 b0	 push	 DWORD PTR __Appended_last$[ebp]
  00191	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00194	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	e8 00 00 00 00	 call	 ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Destroy

; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);

  0019c	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  0019f	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001a2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	e8 00 00 00 00	 call	 ?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AAEAAV?$allocator@_W@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
  001aa	8b c8		 mov	 ecx, eax
  001ac	e8 00 00 00 00	 call	 ?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z ; std::allocator<wchar_t>::deallocate

; 1204 :         _RERAISE;

  001b1	6a 00		 push	 0
  001b3	6a 00		 push	 0
  001b5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1205 :         _CATCH_END

  001ba	b8 00 00 00 00	 mov	 eax, $LN8@Resize_rea
  001bf	c3		 ret	 0
$LN5@Resize_rea:
  001c0	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  001c4	eb 04		 jmp	 SHORT __tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1
$LN8@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  001c6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001ca	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001cd	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  001d0	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001d3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001d6	e8 00 00 00 00	 call	 ?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AAEXQA_WII@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array
$LN68@Resize_rea:

; 1208 :     }

  001db	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001de	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e5	59		 pop	 ecx
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx
  001e9	c9		 leave
  001ea	c2 08 00	 ret	 8
  001ed	cc		 int	 3
  001ee	cc		 int	 3
  001ef	cc		 int	 3
  001f0	cc		 int	 3
  001f1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
$T2 = -136						; size = 4
$T3 = -132						; size = 4
__First$ = -128						; size = 4
__Last$ = -124						; size = 4
$T4 = -120						; size = 4
$T5 = -116						; size = 4
tv238 = -112						; size = 4
$T6 = -108						; size = 4
$T7 = -104						; size = 4
$T8 = -100						; size = 4
$T9 = -96						; size = 4
$T10 = -92						; size = 4
$T11 = -88						; size = 4
$T12 = -84						; size = 4
$T13 = -80						; size = 4
__Appended_last$ = -76					; size = 4
__Myfirst$ = -72					; size = 4
__Mylast$ = -68						; size = 4
__Oldsize$ = -64					; size = 4
__My_data$ = -60					; size = 4
tv145 = -56						; size = 4
$T14 = -52						; size = 4
$T15 = -48						; size = 4
__Newcapacity$ = -44					; size = 4
__Appended_first$ = -40					; size = 4
__Newvec$ = -36						; size = 4
_this$ = -32						; size = 4
___formal$ = -28					; size = 1
___formal$ = -24					; size = 1
__Overflow_is_possible$16 = -18				; size = 1
$T17 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 78	 sub	 esp, 120		; 00000078H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  0002f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00032	89 45 b0	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00035	8b 45 b0	 mov	 eax, DWORD PTR $T13[ebp]
  00038	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0003e	83 4d d0 ff	 or	 DWORD PTR $T15[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00042	c7 45 ac ff ff
	ff 7f		 mov	 DWORD PTR $T12[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00049	8b 45 ac	 mov	 eax, DWORD PTR $T12[ebp]
  0004c	89 45 cc	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0004f	8b 45 d0	 mov	 eax, DWORD PTR $T15[ebp]
  00052	3b 45 cc	 cmp	 eax, DWORD PTR $T14[ebp]
  00055	73 08		 jae	 SHORT $LN26@Resize_rea
  00057	8d 45 d0	 lea	 eax, DWORD PTR $T15[ebp]
  0005a	89 45 c8	 mov	 DWORD PTR tv145[ebp], eax
  0005d	eb 06		 jmp	 SHORT $LN27@Resize_rea
$LN26@Resize_rea:
  0005f	8d 45 cc	 lea	 eax, DWORD PTR $T14[ebp]
  00062	89 45 c8	 mov	 DWORD PTR tv145[ebp], eax
$LN27@Resize_rea:
  00065	8b 45 c8	 mov	 eax, DWORD PTR tv145[ebp]
  00068	89 45 a8	 mov	 DWORD PTR $T11[ebp], eax
  0006b	8b 45 a8	 mov	 eax, DWORD PTR $T11[ebp]
  0006e	89 45 a4	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00071	8b 45 a4	 mov	 eax, DWORD PTR $T10[ebp]
  00074	8b 00		 mov	 eax, DWORD PTR [eax]
  00076	89 45 a0	 mov	 DWORD PTR $T9[ebp], eax

; 1183 :         if (_Newsize > max_size()) {

  00079	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0007c	3b 45 a0	 cmp	 eax, DWORD PTR $T9[ebp]
  0007f	76 05		 jbe	 SHORT $LN2@Resize_rea

; 1184 :             _Xlength();

  00081	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN2@Resize_rea:

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;

  00086	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	89 45 c4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1188 :         pointer& _Myfirst = _My_data._Myfirst;

  0008c	8b 45 c4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0008f	89 45 b8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1189 :         pointer& _Mylast  = _My_data._Mylast;

  00092	8b 45 c4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00095	83 c0 04	 add	 eax, 4
  00098	89 45 bc	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  0009b	8b 45 bc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009e	8b 4d b8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	2b 01		 sub	 eax, DWORD PTR [ecx]
  000a5	89 45 c0	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000a8	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  000ab	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
  000b3	89 45 d4	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  000b6	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b9	89 45 9c	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000bc	8b 45 9c	 mov	 eax, DWORD PTR $T8[ebp]
  000bf	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000c5	c6 45 ee 00	 mov	 BYTE PTR __Overflow_is_possible$16[ebp], 0

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000c9	ff 75 d4	 push	 DWORD PTR __Newcapacity$[ebp]
  000cc	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000d1	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1194 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

  000d2	89 45 dc	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000d5	8b 45 dc	 mov	 eax, DWORD PTR __Newvec$[ebp]
  000d8	03 45 c0	 add	 eax, DWORD PTR __Oldsize$[ebp]
  000db	89 45 d8	 mov	 DWORD PTR __Appended_first$[ebp], eax

; 1196 :         pointer _Appended_last        = _Appended_first;

  000de	8b 45 d8	 mov	 eax, DWORD PTR __Appended_first$[ebp]
  000e1	89 45 b4	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1197 : 
; 1198 :         _TRY_BEGIN

  000e4	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000e8	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000eb	8a 00		 mov	 al, BYTE PTR [eax]
  000ed	88 45 e8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000f0	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000f3	89 45 98	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000f6	8b 45 98	 mov	 eax, DWORD PTR $T7[ebp]
  000f9	89 45 94	 mov	 DWORD PTR $T6[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000fc	ff 75 94	 push	 DWORD PTR $T6[ebp]

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000ff	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00102	2b 45 c0	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00105	50		 push	 eax
  00106	ff 75 d8	 push	 DWORD PTR __Appended_first$[ebp]
  00109	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00111	89 45 90	 mov	 DWORD PTR tv238[ebp], eax

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00114	8b 45 90	 mov	 eax, DWORD PTR tv238[ebp]
  00117	89 45 b4	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0011a	8b 45 bc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0011d	8b 00		 mov	 eax, DWORD PTR [eax]
  0011f	89 45 84	 mov	 DWORD PTR __Last$[ebp], eax
  00122	8b 45 b8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00125	8b 00		 mov	 eax, DWORD PTR [eax]
  00127	89 45 80	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0012a	33 c0		 xor	 eax, eax
  0012c	88 45 ef	 mov	 BYTE PTR $T17[ebp], al
  0012f	8a 45 ef	 mov	 al, BYTE PTR $T17[ebp]
  00132	88 45 e4	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00135	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00138	89 45 8c	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0013b	8b 45 8c	 mov	 eax, DWORD PTR $T5[ebp]
  0013e	89 45 88	 mov	 DWORD PTR $T4[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00141	ff 75 88	 push	 DWORD PTR $T4[ebp]
  00144	ff 75 dc	 push	 DWORD PTR __Newvec$[ebp]
  00147	ff 75 84	 push	 DWORD PTR __Last$[ebp]
  0014a	ff 75 80	 push	 DWORD PTR __First$[ebp]
  0014d	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
  00152	83 c4 10	 add	 esp, 16			; 00000010H

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00155	eb 32		 jmp	 SHORT $LN5@Resize_rea
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);

  00157	ff 75 b4	 push	 DWORD PTR __Appended_last$[ebp]
  0015a	ff 75 d8	 push	 DWORD PTR __Appended_first$[ebp]
  0015d	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00160	e8 00 00 00 00	 call	 ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy

; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);

  00165	ff 75 d4	 push	 DWORD PTR __Newcapacity$[ebp]
  00168	ff 75 dc	 push	 DWORD PTR __Newvec$[ebp]
  0016b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	e8 00 00 00 00	 call	 ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
  00173	8b c8		 mov	 ecx, eax
  00175	e8 00 00 00 00	 call	 ?deallocate@?$allocator@E@std@@QAEXQAEI@Z ; std::allocator<unsigned char>::deallocate

; 1204 :         _RERAISE;

  0017a	6a 00		 push	 0
  0017c	6a 00		 push	 0
  0017e	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1205 :         _CATCH_END

  00183	b8 00 00 00 00	 mov	 eax, $LN8@Resize_rea
  00188	c3		 ret	 0
$LN5@Resize_rea:
  00189	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0018d	eb 04		 jmp	 SHORT __tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1
$LN8@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  0018f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00193	ff 75 d4	 push	 DWORD PTR __Newcapacity$[ebp]
  00196	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00199	ff 75 dc	 push	 DWORD PTR __Newvec$[ebp]
  0019c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0019f	e8 00 00 00 00	 call	 ?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
$LN4@Resize_rea:

; 1208 :     }

  001a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ae	59		 pop	 ecx
  001af	5f		 pop	 edi
  001b0	5e		 pop	 esi
  001b1	5b		 pop	 ebx
  001b2	c9		 leave
  001b3	c2 08 00	 ret	 8
  001b6	cc		 int	 3
  001b7	cc		 int	 3
  001b8	cc		 int	 3
  001b9	cc		 int	 3
  001ba	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 74 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-140]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Assign_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__Mylast$ = -36						; size = 4
$T1 = -32						; size = 4
__Ptr$ = -28						; size = 4
__Oldcapacity$2 = -24					; size = 4
__Myend$ = -20						; size = 4
__Myfirst$ = -16					; size = 4
_this$ = -12						; size = 4
__Newsize$ = -8						; size = 4
__My_data$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_range<wchar_t *>, COMDAT
; _this$ = ecx

; 1094 :     void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) { // assign forward range [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	d1 f8		 sar	 eax, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00011	89 45 f8	 mov	 DWORD PTR __Newsize$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1096 :         auto& _My_data      = _Mypair._Myval2;

  00014	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00017	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1097 :         pointer& _Myfirst   = _My_data._Myfirst;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001d	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1098 :         pointer& _Mylast    = _My_data._Mylast;

  00020	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00023	83 c0 04	 add	 eax, 4
  00026	89 45 dc	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1099 :         pointer& _Myend     = _My_data._Myend;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002c	83 c0 08	 add	 eax, 8
  0002f	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1100 : 
; 1101 :         _My_data._Orphan_all();
; 1102 : 
; 1103 : #if _HAS_IF_CONSTEXPR
; 1104 :         if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Iter, _Ty*>::_Trivially_copyable>,
; 1105 :                           _Uses_default_construct<_Alty, _Ty*, decltype(*_First)>,
; 1106 :                           _Uses_default_destroy<_Alty, _Ty*>>) {
; 1107 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

  00032	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00035	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00038	8b 00		 mov	 eax, DWORD PTR [eax]
  0003a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003c	d1 f8		 sar	 eax, 1
  0003e	89 45 e8	 mov	 DWORD PTR __Oldcapacity$2[ebp], eax

; 1108 :             if (_Newsize > _Oldcapacity) {

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00044	3b 45 e8	 cmp	 eax, DWORD PTR __Oldcapacity$2[ebp]
  00047	76 0b		 jbe	 SHORT $LN2@Assign_ran

; 1109 :                 _Clear_and_reserve_geometric(_Newsize);

  00049	ff 75 f8	 push	 DWORD PTR __Newsize$[ebp]
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Clear_and_reserve_geometric@?$vector@_WV?$allocator@_W@std@@@std@@AAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Clear_and_reserve_geometric
$LN2@Assign_ran:

; 1112 :             _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));

  00054	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0005c	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005f	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1112 :             _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));

  00062	ff 75 e0	 push	 DWORD PTR $T1[ebp]
  00065	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00068	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0006b	e8 00 00 00 00	 call	 ??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z ; std::_Copy_memmove<wchar_t *,wchar_t *>
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ??$_Refancy@PA_W$0A@@std@@YAPA_WPA_W@Z ; std::_Refancy<wchar_t *,0>
  00079	59		 pop	 ecx
  0007a	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0007d	89 01		 mov	 DWORD PTR [ecx], eax

; 1113 :         } else
; 1114 : #endif // _HAS_IF_CONSTEXPR
; 1115 :         {
; 1116 :             auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1117 : 
; 1118 :             if (_Newsize > _Oldsize) {
; 1119 :                 const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
; 1120 :                 if (_Newsize > _Oldcapacity) { // reallocate
; 1121 :                     _Clear_and_reserve_geometric(_Newsize);
; 1122 :                     _Oldsize = 0;
; 1123 :                 }
; 1124 : 
; 1125 :                 // performance note: traversing [_First, _Mid) twice
; 1126 :                 const _Iter _Mid = _STD next(_First, static_cast<difference_type>(_Oldsize));
; 1127 :                 _Copy_unchecked(_First, _Mid, _Myfirst);
; 1128 :                 _Mylast = _Ucopy(_Mid, _Last, _Mylast);
; 1129 :             } else {
; 1130 :                 const pointer _Newlast = _Myfirst + _Newsize;
; 1131 :                 _Copy_unchecked(_First, _Last, _Myfirst);
; 1132 :                 _Destroy(_Newlast, _Mylast);
; 1133 :                 _Mylast = _Newlast;
; 1134 :             }
; 1135 :         }
; 1136 :     }

  0007f	c9		 leave
  00080	c2 0c 00	 ret	 12			; 0000000cH
??$_Assign_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_range<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Al$ = -64						; size = 4
__First1$ = -60						; size = 4
__First1$ = -56						; size = 4
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T2 = -44						; size = 4
__Old_ptr$3 = -40					; size = 4
__Old_capacity$ = -36					; size = 4
__New_capacity$ = -32					; size = 4
__New_size$ = -28					; size = 4
__New_ptr$ = -24					; size = 4
_this$ = -20						; size = 4
__Raw_new$ = -16					; size = 4
__My_data$ = -12					; size = 4
__Old_size$ = -8					; size = 4
__Overflow_is_possible$4 = -3				; size = 1
$T5 = -2						; size = 1
$T6 = -1						; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 e4	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 dc	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 e4	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 e0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 c0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 fd 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 e0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 e8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d e4	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 e8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d dc 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 65		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 d8	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 d8	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ac	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  000af	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  000b2	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  000bd	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c0	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c6	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000c9	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000cc	ff 75 c8	 push	 DWORD PTR __First1$[ebp]
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000d7	c6 45 ff 00	 mov	 BYTE PTR $T6[ebp], 0
  000db	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000de	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  000e1	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000e4	8a 55 ff	 mov	 dl, BYTE PTR $T6[ebp]
  000e7	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ea	8b 45 dc	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000ed	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ee	50		 push	 eax
  000ef	ff 75 d8	 push	 DWORD PTR __Old_ptr$3[ebp]
  000f2	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000f7	59		 pop	 ecx
  000f8	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000fc	8b 4d e8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000ff	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  00101	eb 4c		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00103	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  00106	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00109	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  0010c	e8 00 00 00 00	 call	 _memcpy
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00114	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00117	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  0011a	89 45 c4	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00120	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00123	ff 75 c4	 push	 DWORD PTR __First1$[ebp]
  00126	e8 00 00 00 00	 call	 _memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0012e	c6 45 fe 00	 mov	 BYTE PTR $T5[ebp], 0
  00132	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00135	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  00138	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  0013b	8a 55 fe	 mov	 dl, BYTE PTR $T5[ebp]
  0013e	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00141	8d 45 e8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00144	50		 push	 eax
  00145	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00148	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0014d	59		 pop	 ecx
  0014e	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  0014f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  00152	c9		 leave
  00153	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z PROC ; std::_Destroy_range<std::allocator<wchar_t> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z ENDP ; std::_Destroy_range<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	d1 f9		 sar	 ecx, 1
  0005f	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00062	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00065	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006c	d1 f8		 sar	 eax, 1
  0006e	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00071	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00074	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00077	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007a	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007d	c7 45 40 ff ff
	ff 7f		 mov	 DWORD PTR $T22[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00084	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008b	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  0008e	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00091	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00094	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00097	73 08		 jae	 SHORT $LN34@Emplace_re
  00099	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009c	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  0009f	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a1	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a4	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a7	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000aa	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000ad	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b0	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b3	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b6	8b 00		 mov	 eax, DWORD PTR [eax]
  000b8	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bb	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000be	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c1	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c3	e8 00 00 00 00	 call	 ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000c8	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cb	40		 inc	 eax
  000cc	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000cf	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d2	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@ABEII@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth
  000da	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000dd	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e1	c7 45 bc ff ff
	ff 7f		 mov	 DWORD PTR __Max_possible$2[ebp], 2147483647 ; 7fffffffH

; 60   :         if (_Count > _Max_possible) {

  000e8	81 7d 54 ff ff
	ff 7f		 cmp	 DWORD PTR __Newcapacity$[ebp], 2147483647 ; 7fffffffH
  000ef	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f1	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f6	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000f9	d1 e0		 shl	 eax, 1
  000fb	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000fe	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00101	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00106	59		 pop	 ecx
  00107	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0010d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00110	8d 44 41 02	 lea	 eax, DWORD PTR [ecx+eax*2+2]
  00114	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  00117	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011a	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  0011d	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00121	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00124	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00127	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012a	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0012d	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00130	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00133	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00136	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00139	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013c	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0013f	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00142	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00145	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00148	66 89 08	 mov	 WORD PTR [eax], cx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014b	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014e	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00151	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00154	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00157	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015a	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0015f	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00161	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00169	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016c	8b 00		 mov	 eax, DWORD PTR [eax]
  0016e	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00171	33 c0		 xor	 eax, eax
  00173	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00176	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  00179	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017c	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0017f	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00182	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00185	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00188	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018b	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018e	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00191	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00194	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
  00199	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019c	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019e	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a1	8b 00		 mov	 eax, DWORD PTR [eax]
  001a3	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a6	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001a9	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ac	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001af	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b2	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b5	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b8	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bb	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001be	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
  001c3	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c6	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001c9	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cc	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001cf	8b 00		 mov	 eax, DWORD PTR [eax]
  001d1	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d4	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d7	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001da	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001dd	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e0	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e3	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e6	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001e9	8d 44 41 02	 lea	 eax, DWORD PTR [ecx+eax*2+2]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ed	50		 push	 eax
  001ee	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f1	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f4	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
  001f9	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fc	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001fe	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00201	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00204	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00207	e8 00 00 00 00	 call	 ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020c	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0020f	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00212	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00215	e8 00 00 00 00	 call	 ?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z ; std::allocator<wchar_t>::deallocate

; 762  :         _RERAISE;

  0021a	6a 00		 push	 0
  0021c	6a 00		 push	 0
  0021e	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00223	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00228	c3		 ret	 0
$LN7@Emplace_re:
  00229	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022d	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  0022f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00233	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00236	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  00239	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023c	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0023f	e8 00 00 00 00	 call	 ?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AAEXQA_WII@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00244	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00247	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024a	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
$LN70@Emplace_re:

; 767  :     }

  0024d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00250	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00257	59		 pop	 ecx
  00258	5f		 pop	 edi
  00259	5e		 pop	 esi
  0025a	5b		 pop	 ebx
  0025b	83 c5 70	 add	 ebp, 112		; 00000070H
  0025e	c9		 leave
  0025f	c2 08 00	 ret	 8
  00262	cc		 int	 3
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXAB_W@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXAB_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_back_with_unused_capacity<wchar_t const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	66 8b 09	 mov	 cx, WORD PTR [ecx]
  0004d	66 89 08	 mov	 WORD PTR [eax], cx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  00050	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
  0005d	40		 inc	 eax
  0005e	40		 inc	 eax
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00064	c9		 leave
  00065	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXAB_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_back_with_unused_capacity<wchar_t const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::emplace_back<wchar_t const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXAB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_back_with_unused_capacity<wchar_t const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::emplace_back<wchar_t const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldlast$1 = -56					; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
__Oldcapacity$4 = -44					; size = 4
__Last$ = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
__Newlast$7 = -28					; size = 4
__Oldsize$ = -24					; size = 4
__Myfirst$ = -20					; size = 4
__My_data$ = -16					; size = 4
_this$ = -12						; size = 4
__Mylast$ = -8						; size = 4
___formal$ = -4						; size = 1
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1211 :     void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1212 :         auto& _My_data      = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1213 :         pointer& _Myfirst   = _My_data._Myfirst;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1214 :         pointer& _Mylast    = _My_data._Mylast;

  00015	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	2b 01		 sub	 eax, DWORD PTR [ecx]
  00028	d1 f8		 sar	 eax, 1
  0002a	89 45 e8	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1216 :         if (_Newsize < _Oldsize) { // trim

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00030	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00033	73 3d		 jae	 SHORT $LN2@Resize

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00035	8b 45 ec	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00038	8b 00		 mov	 eax, DWORD PTR [eax]
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0003d	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00040	89 45 e4	 mov	 DWORD PTR __Newlast$7[ebp], eax

; 1218 :             _Orphan_range(_Newlast, _Mylast);
; 1219 :             _Destroy(_Newlast, _Mylast);

  00043	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 45 d8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0004b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0004e	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00051	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  00054	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00057	ff 75 dc	 push	 DWORD PTR $T5[ebp]
  0005a	ff 75 d8	 push	 DWORD PTR __Last$[ebp]
  0005d	ff 75 e4	 push	 DWORD PTR __Newlast$7[ebp]
  00060	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1220 :             _Mylast = _Newlast;

  00068	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 4d e4	 mov	 ecx, DWORD PTR __Newlast$7[ebp]
  0006e	89 08		 mov	 DWORD PTR [eax], ecx

; 1221 :             return;

  00070	eb 66		 jmp	 SHORT $LN1@Resize
$LN2@Resize:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  00072	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00075	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00078	76 5e		 jbe	 SHORT $LN1@Resize

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0007a	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00080	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00083	2b 01		 sub	 eax, DWORD PTR [ecx]
  00085	d1 f8		 sar	 eax, 1
  00087	89 45 d4	 mov	 DWORD PTR __Oldcapacity$4[ebp], eax

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  0008a	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0008d	3b 45 d4	 cmp	 eax, DWORD PTR __Oldcapacity$4[ebp]
  00090	76 10		 jbe	 SHORT $LN4@Resize

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  00092	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00095	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00098	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  000a0	eb 36		 jmp	 SHORT $LN1@Resize
$LN4@Resize:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;

  000a2	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a5	8b 00		 mov	 eax, DWORD PTR [eax]
  000a7	89 45 c8	 mov	 DWORD PTR __Oldlast$1[ebp], eax

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000aa	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000ad	8a 00		 mov	 al, BYTE PTR [eax]
  000af	88 45 fc	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000b2	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b5	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000b8	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  000bb	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000be	ff 75 cc	 push	 DWORD PTR $T2[ebp]

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000c1	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000c4	2b 45 e8	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c7	50		 push	 eax
  000c8	ff 75 c8	 push	 DWORD PTR __Oldlast$1[ebp]
  000cb	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@_W@std@@@std@@YAPA_WPA_WIAAV?$allocator@_W@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<wchar_t> >
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000d3	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000d6	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Resize:

; 1233 :             _Orphan_range(_Oldlast, _Oldlast);
; 1234 :         }
; 1235 : 
; 1236 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1237 :     }

  000d8	c9		 leave
  000d9	c2 08 00	 ret	 8
??$_Resize@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldlast$1 = -56					; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
__Oldcapacity$4 = -44					; size = 4
__Last$ = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
__Newlast$7 = -28					; size = 4
__Oldsize$ = -24					; size = 4
__Myfirst$ = -20					; size = 4
__My_data$ = -16					; size = 4
_this$ = -12						; size = 4
__Mylast$ = -8						; size = 4
___formal$ = -4						; size = 1
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1211 :     void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1212 :         auto& _My_data      = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1213 :         pointer& _Myfirst   = _My_data._Myfirst;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1214 :         pointer& _Mylast    = _My_data._Mylast;

  00015	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	2b 01		 sub	 eax, DWORD PTR [ecx]
  00028	89 45 e8	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1216 :         if (_Newsize < _Oldsize) { // trim

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0002e	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00031	73 3a		 jae	 SHORT $LN2@Resize

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00033	8b 45 ec	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  0003b	89 45 e4	 mov	 DWORD PTR __Newlast$7[ebp], eax

; 1218 :             _Orphan_range(_Newlast, _Mylast);
; 1219 :             _Destroy(_Newlast, _Mylast);

  0003e	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	89 45 d8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00046	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00049	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0004c	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  0004f	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00052	ff 75 dc	 push	 DWORD PTR $T5[ebp]
  00055	ff 75 d8	 push	 DWORD PTR __Last$[ebp]
  00058	ff 75 e4	 push	 DWORD PTR __Newlast$7[ebp]
  0005b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1220 :             _Mylast = _Newlast;

  00063	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d e4	 mov	 ecx, DWORD PTR __Newlast$7[ebp]
  00069	89 08		 mov	 DWORD PTR [eax], ecx

; 1221 :             return;

  0006b	eb 64		 jmp	 SHORT $LN1@Resize
$LN2@Resize:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  0006d	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00070	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00073	76 5c		 jbe	 SHORT $LN1@Resize

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00075	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00078	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0007b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007e	2b 01		 sub	 eax, DWORD PTR [ecx]
  00080	89 45 d4	 mov	 DWORD PTR __Oldcapacity$4[ebp], eax

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  00083	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00086	3b 45 d4	 cmp	 eax, DWORD PTR __Oldcapacity$4[ebp]
  00089	76 10		 jbe	 SHORT $LN4@Resize

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  0008b	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0008e	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00091	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  00099	eb 36		 jmp	 SHORT $LN1@Resize
$LN4@Resize:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;

  0009b	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009e	8b 00		 mov	 eax, DWORD PTR [eax]
  000a0	89 45 c8	 mov	 DWORD PTR __Oldlast$1[ebp], eax

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000a3	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000a6	8a 00		 mov	 al, BYTE PTR [eax]
  000a8	88 45 fc	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000ab	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000ae	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000b1	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  000b4	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000b7	ff 75 cc	 push	 DWORD PTR $T2[ebp]

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000ba	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000bd	2b 45 e8	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c0	50		 push	 eax
  000c1	ff 75 c8	 push	 DWORD PTR __Oldlast$1[ebp]
  000c4	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000cc	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000cf	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Resize:

; 1233 :             _Orphan_range(_Oldlast, _Oldlast);
; 1234 :         }
; 1235 : 
; 1236 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1237 :     }

  000d1	c9		 leave
  000d2	c2 08 00	 ret	 8
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?_strtoul@@YAKPBDPAPADH@Z
_TEXT	SEGMENT
_ul$1 = -8						; size = 4
_ulRet$ = -4						; size = 4
_psz$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?_strtoul@@YAKPBDPAPADH@Z PROC				; _strtoul, COMDAT

; 1405 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1406 : 	if ( !psz )

  00005	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  00009	75 07		 jne	 SHORT $LN6@strtoul

; 1407 : 		return 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	e9 21 01 00 00	 jmp	 $LN1@strtoul
$LN6@strtoul:

; 1408 : 
; 1409 : 	ULONG ulRet = 0;

  00012	83 65 fc 00	 and	 DWORD PTR _ulRet$[ebp], 0

; 1410 : 	if ( psz[0] == '0' && ( psz[1] == 'x' || psz[1] == 'X' ) )

  00016	33 c0		 xor	 eax, eax
  00018	40		 inc	 eax
  00019	6b c0 00	 imul	 eax, eax, 0
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001f	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  00023	83 f8 30	 cmp	 eax, 48			; 00000030H
  00026	0f 85 ca 00 00
	00		 jne	 $LN4@strtoul
  0002c	33 c0		 xor	 eax, eax
  0002e	40		 inc	 eax
  0002f	c1 e0 00	 shl	 eax, 0
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  00035	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  00039	83 f8 78	 cmp	 eax, 120		; 00000078H
  0003c	74 16		 je	 SHORT $LN9@strtoul
  0003e	33 c0		 xor	 eax, eax
  00040	40		 inc	 eax
  00041	c1 e0 00	 shl	 eax, 0
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  00047	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  0004b	83 f8 58	 cmp	 eax, 88			; 00000058H
  0004e	0f 85 a2 00 00
	00		 jne	 $LN4@strtoul
$LN9@strtoul:

; 1411 : 	{
; 1412 : 		psz += 2;

  00054	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00057	40		 inc	 eax
  00058	40		 inc	 eax
  00059	89 45 08	 mov	 DWORD PTR _psz$[ebp], eax

; 1413 : 		ULONG ul = 0;

  0005c	83 65 f8 00	 and	 DWORD PTR _ul$1[ebp], 0
$LN2@strtoul:

; 1414 : 		while ( *psz )

  00060	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00063	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00066	85 c0		 test	 eax, eax
  00068	0f 84 86 00 00
	00		 je	 $LN3@strtoul

; 1415 : 		{
; 1416 : 			if ( '0' <= *psz && *psz <= '9' )

  0006e	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00071	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00074	83 f8 30	 cmp	 eax, 48			; 00000030H
  00077	7c 19		 jl	 SHORT $LN10@strtoul
  00079	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  0007c	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0007f	83 f8 39	 cmp	 eax, 57			; 00000039H
  00082	7f 0e		 jg	 SHORT $LN10@strtoul

; 1417 : 				ul = *psz - '0';

  00084	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00087	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0008a	83 e8 30	 sub	 eax, 48			; 00000030H
  0008d	89 45 f8	 mov	 DWORD PTR _ul$1[ebp], eax
  00090	eb 4a		 jmp	 SHORT $LN11@strtoul
$LN10@strtoul:

; 1418 : 			else if ( 'A' <= *psz && *psz <= 'F' )

  00092	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00095	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00098	83 f8 41	 cmp	 eax, 65			; 00000041H
  0009b	7c 19		 jl	 SHORT $LN12@strtoul
  0009d	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  000a0	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000a3	83 f8 46	 cmp	 eax, 70			; 00000046H
  000a6	7f 0e		 jg	 SHORT $LN12@strtoul

; 1419 : 				ul = *psz - 'A' + 10;

  000a8	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  000ab	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000ae	83 e8 37	 sub	 eax, 55			; 00000037H
  000b1	89 45 f8	 mov	 DWORD PTR _ul$1[ebp], eax
  000b4	eb 26		 jmp	 SHORT $LN11@strtoul
$LN12@strtoul:

; 1420 : 			else if ( 'a' <= *psz && *psz <= 'f' )

  000b6	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  000b9	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000bc	83 f8 61	 cmp	 eax, 97			; 00000061H
  000bf	7c 19		 jl	 SHORT $LN14@strtoul
  000c1	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  000c4	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000c7	83 f8 66	 cmp	 eax, 102		; 00000066H
  000ca	7f 0e		 jg	 SHORT $LN14@strtoul

; 1421 : 				ul = *psz - 'a' + 10;

  000cc	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  000cf	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000d2	83 e8 57	 sub	 eax, 87			; 00000057H
  000d5	89 45 f8	 mov	 DWORD PTR _ul$1[ebp], eax
  000d8	eb 02		 jmp	 SHORT $LN11@strtoul
$LN14@strtoul:

; 1422 : 			else
; 1423 : 				break;

  000da	eb 18		 jmp	 SHORT $LN3@strtoul
$LN11@strtoul:

; 1424 : 			ulRet = ulRet * 16 + ul;

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _ulRet$[ebp]
  000df	c1 e0 04	 shl	 eax, 4
  000e2	03 45 f8	 add	 eax, DWORD PTR _ul$1[ebp]
  000e5	89 45 fc	 mov	 DWORD PTR _ulRet$[ebp], eax

; 1425 : 			psz++;

  000e8	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  000eb	40		 inc	 eax
  000ec	89 45 08	 mov	 DWORD PTR _psz$[ebp], eax

; 1426 : 		}

  000ef	e9 6c ff ff ff	 jmp	 $LN2@strtoul
$LN3@strtoul:

; 1427 : 	}

  000f4	eb 3a		 jmp	 SHORT $LN8@strtoul
$LN4@strtoul:

; 1428 : 	else {
; 1429 : 		while ( *psz && ( '0' <= *psz && *psz <= '9' ) )

  000f6	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  000f9	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000fc	85 c0		 test	 eax, eax
  000fe	74 30		 je	 SHORT $LN8@strtoul
  00100	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00103	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00106	83 f8 30	 cmp	 eax, 48			; 00000030H
  00109	7c 25		 jl	 SHORT $LN8@strtoul
  0010b	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  0010e	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00111	83 f8 39	 cmp	 eax, 57			; 00000039H
  00114	7f 1a		 jg	 SHORT $LN8@strtoul

; 1430 : 		{
; 1431 : 			ulRet = ulRet * 10 + ( *psz - '0' );

  00116	6b 45 fc 0a	 imul	 eax, DWORD PTR _ulRet$[ebp], 10
  0011a	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0011d	0f be 09	 movsx	 ecx, BYTE PTR [ecx]
  00120	8d 44 08 d0	 lea	 eax, DWORD PTR [eax+ecx-48]
  00124	89 45 fc	 mov	 DWORD PTR _ulRet$[ebp], eax

; 1432 : 			psz++;

  00127	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  0012a	40		 inc	 eax
  0012b	89 45 08	 mov	 DWORD PTR _psz$[ebp], eax

; 1433 : 		}

  0012e	eb c6		 jmp	 SHORT $LN4@strtoul
$LN8@strtoul:

; 1434 : 	}
; 1435 : 	return ulRet;

  00130	8b 45 fc	 mov	 eax, DWORD PTR _ulRet$[ebp]
$LN1@strtoul:

; 1436 : }

  00133	c9		 leave
  00134	c3		 ret	 0
?_strtoul@@YAKPBDPAPADH@Z ENDP				; _strtoul
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 6d		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00075	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0007d	ff 75 d4	 push	 DWORD PTR __Count$[ebp]
  00080	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  00083	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00088	59		 pop	 ecx
  00089	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  0008a	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0008d	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00090	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00093	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  00096	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00099	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  0009c	c9		 leave
  0009d	c3		 ret	 0
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 5b		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00075	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0007d	ff 75 d4	 push	 DWORD PTR __Count$[ebp]
  00080	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  00083	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00088	59		 pop	 ecx
  00089	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00090	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00092	8b 45 08	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00095	03 45 0c	 add	 eax, DWORD PTR __Newsize$[ebp]
  00098	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0009b	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  0009d	8b 45 08	 mov	 eax, DWORD PTR __Newvec$[ebp]
  000a0	03 45 10	 add	 eax, DWORD PTR __Newcapacity$[ebp]
  000a3	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000a6	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000a8	c9		 leave
  000a9	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv81 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00020	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00026	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00029	83 4d f0 ff	 or	 DWORD PTR $T7[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0002d	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00034	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00037	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0003a	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  0003d	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00040	73 08		 jae	 SHORT $LN25@Calculate_
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  00045	89 45 e8	 mov	 DWORD PTR tv81[ebp], eax
  00048	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  0004a	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0004d	89 45 e8	 mov	 DWORD PTR tv81[ebp], eax
$LN26@Calculate_:
  00050	8b 45 e8	 mov	 eax, DWORD PTR tv81[ebp]
  00053	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00059	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0005c	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00064	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00067	d1 e8		 shr	 eax, 1
  00069	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  0006c	2b c8		 sub	 ecx, eax
  0006e	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00071	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00073	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  00076	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00078	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0007b	d1 e8		 shr	 eax, 1
  0007d	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00080	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00083	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  00086	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00089	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  0008b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0008e	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00090	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00093	c9		 leave
  00094	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXQAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@E@std@@QAEXQAEI@Z PROC		; std::allocator<unsigned char>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00012	59		 pop	 ecx
  00013	59		 pop	 ecx

; 811  :     }

  00014	c9		 leave
  00015	c2 08 00	 ret	 8
?deallocate@?$allocator@E@std@@QAEXQAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@_W@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@V10@V10@AB_W@Z
_TEXT	SEGMENT
__It$ = -40						; size = 4
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Ptr$5 = -20						; size = 4
$T6 = -16						; size = 4
__Ptr$7 = -12						; size = 4
__First$ = -8						; size = 4
$T8 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@_W@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@V10@V10@AB_W@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,wchar_t>, COMDAT

; 5478 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR __Ptr$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$7[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  00015	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00018	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0001b	89 45 ec	 mov	 DWORD PTR __Ptr$5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0001e	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$5[ebp]
  00021	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00024	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00027	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5474 :     return _Find_unchecked1(_First, _Last, _Val, _Memchr_opt{});

  0002a	33 c0		 xor	 eax, eax
  0002c	88 45 ff	 mov	 BYTE PTR $T8[ebp], al
  0002f	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00032	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax

; 5439 :     for (; _First != _Last; ++_First) {

  00035	eb 08		 jmp	 SHORT $LN26@find
$LN24@find:
  00037	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  0003a	40		 inc	 eax
  0003b	40		 inc	 eax
  0003c	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax
$LN26@find:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00042	3b 45 e0	 cmp	 eax, DWORD PTR $T2[ebp]
  00045	74 14		 je	 SHORT $LN21@find

; 5440 :         if (*_First == _Val) {

  00047	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  0004a	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0004d	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00050	0f b7 09	 movzx	 ecx, WORD PTR [ecx]
  00053	3b c1		 cmp	 eax, ecx
  00055	75 02		 jne	 SHORT $LN27@find

; 5441 :             break;

  00057	eb 02		 jmp	 SHORT $LN21@find
$LN27@find:

; 5442 :         }
; 5443 :     }

  00059	eb dc		 jmp	 SHORT $LN24@find
$LN21@find:

; 5479 :     _Adl_verify_range(_First, _Last);
; 5480 :     _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

  0005b	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  0005e	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax

; 1490 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  00061	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  00064	89 45 d8	 mov	 DWORD PTR __It$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  00067	ff 75 d8	 push	 DWORD PTR __It$[ebp]
  0006a	e8 00 00 00 00	 call	 ??$_Refancy@PA_W$0A@@std@@YAPA_WPA_W@Z ; std::_Refancy<wchar_t *,0>
  0006f	59		 pop	 ecx
  00070	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5481 :     return _First;

  00073	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00076	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00079	89 08		 mov	 DWORD PTR [eax], ecx
  0007b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5482 : }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@_W@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@V10@V10@AB_W@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??__Fg_disableCicero@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Fg_disableCicero@@YAXXZ PROC			; `dynamic atexit destructor for 'g_disableCicero'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??__Fg_disableCicero@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 221  : 	{

  00022	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 222  : 		Uninitialize();

  00026	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_disableCicero@@3VCDisableCicero@@A
  0002b	e8 00 00 00 00	 call	 ?Uninitialize@CDisableCicero@@QAEXXZ ; CDisableCicero::Uninitialize

; 223  : 	}

  00030	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00034	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00037	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003e	59		 pop	 ecx
  0003f	c9		 leave
  00040	c3		 ret	 0
  00041	cc		 int	 3
  00042	cc		 int	 3
  00043	cc		 int	 3
  00044	cc		 int	 3
  00045	cc		 int	 3
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__Fg_disableCicero@@YAXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__Fg_disableCicero@@YAXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__Fg_disableCicero@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_disableCicero''
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??__Eg_disableCicero@@YAXXZ
text$di	SEGMENT
??__Eg_disableCicero@@YAXXZ PROC			; `dynamic initializer for 'g_disableCicero'', COMDAT

; 272  : static CDisableCicero g_disableCicero;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 217  : 	CDisableCicero() : m_ptim( NULL ), m_bComInit( false )

  00003	83 25 00 00 00
	00 00		 and	 DWORD PTR ?g_disableCicero@@3VCDisableCicero@@A, 0
  0000a	c6 05 04 00 00
	00 00		 mov	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 0

; 272  : static CDisableCicero g_disableCicero;

  00011	68 00 00 00 00	 push	 OFFSET ??__Fg_disableCicero@@YAXXZ ; `dynamic atexit destructor for 'g_disableCicero''
  00016	e8 00 00 00 00	 call	 _atexit
  0001b	59		 pop	 ecx
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??__Eg_disableCicero@@YAXXZ ENDP			; `dynamic initializer for 'g_disableCicero''
text$di	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?Uninitialize@CDisableCicero@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Uninitialize@CDisableCicero@@QAEXXZ PROC		; CDisableCicero::Uninitialize, COMDAT
; _this$ = ecx

; 243  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 244  : 		if ( m_ptim )

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 15		 je	 SHORT $LN2@Uninitiali

; 245  : 		{
; 246  : 			m_ptim->Release();

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	ff 31		 push	 DWORD PTR [ecx]
  0001b	ff 50 08	 call	 DWORD PTR [eax+8]

; 247  : 			m_ptim = NULL;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 20 00	 and	 DWORD PTR [eax], 0
$LN2@Uninitiali:

; 248  : 		}
; 249  : 		if ( m_bComInit )

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0002b	85 c0		 test	 eax, eax
  0002d	74 06		 je	 SHORT $LN3@Uninitiali

; 250  : 			CoUninitialize();

  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0
$LN3@Uninitiali:

; 251  : 		m_bComInit = false;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 252  : 	}

  0003c	c9		 leave
  0003d	c3		 ret	 0
?Uninitialize@CDisableCicero@@QAEXXZ ENDP		; CDisableCicero::Uninitialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?Initialize@CDisableCicero@@QAEXXZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
?Initialize@CDisableCicero@@QAEXXZ PROC			; CDisableCicero::Initialize, COMDAT
; _this$ = ecx

; 225  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 226  : 		if ( m_bComInit )

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0000f	85 c0		 test	 eax, eax
  00011	74 02		 je	 SHORT $LN2@Initialize

; 227  : 		{
; 228  : 			return;

  00013	eb 34		 jmp	 SHORT $LN1@Initialize
$LN2@Initialize:

; 229  : 		}
; 230  : 		HRESULT hr;
; 231  : 		hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );

  00015	6a 02		 push	 2
  00017	6a 00		 push	 0
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitializeEx@8
  0001f	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 232  : 	    if ( SUCCEEDED( hr ) )

  00022	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00026	7c 21		 jl	 SHORT $LN1@Initialize

; 233  : 		{
; 234  : 			m_bComInit = true;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 235  : 			hr = CoCreateInstance( CLSID_TF_ThreadMgr,

  0002f	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00032	68 00 00 00 00	 push	 OFFSET __GUID_aa80e801_2021_11d2_93e0_0060b067b86e
  00037	6a 01		 push	 1
  00039	6a 00		 push	 0
  0003b	68 00 00 00 00	 push	 OFFSET _CLSID_TF_ThreadMgr
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20
  00046	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
$LN1@Initialize:

; 236  : 				NULL,
; 237  : 				CLSCTX_INPROC_SERVER,
; 238  : 				__uuidof(ITfThreadMgr),
; 239  : 				(void**)&m_ptim );
; 240  : 		}
; 241  : 	}

  00049	c9		 leave
  0004a	c3		 ret	 0
?Initialize@CDisableCicero@@QAEXXZ ENDP			; CDisableCicero::Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_srcTm$ = -4						; size = 4
_bEnable$ = 8						; size = 1
?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z PROC		; CTsfUiLessMode::EnableUiUpdates, COMDAT

; 2006 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 2007 : 	if ( m_tm == NULL ||
; 2008 : 		 ( bEnable && m_dwUIElementSinkCookie != TF_INVALID_COOKIE )  ||

  00005	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A, 0 ; CTsfUiLessMode::m_tm
  0000c	74 22		 je	 SHORT $LN3@EnableUiUp
  0000e	0f b6 45 08	 movzx	 eax, BYTE PTR _bEnable$[ebp]
  00012	85 c0		 test	 eax, eax
  00014	74 09		 je	 SHORT $LN4@EnableUiUp
  00016	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwUIElementSinkCookie
  0001d	75 11		 jne	 SHORT $LN3@EnableUiUp
$LN4@EnableUiUp:
  0001f	0f b6 45 08	 movzx	 eax, BYTE PTR _bEnable$[ebp]
  00023	85 c0		 test	 eax, eax
  00025	75 0b		 jne	 SHORT $LN2@EnableUiUp
  00027	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwUIElementSinkCookie
  0002e	75 02		 jne	 SHORT $LN2@EnableUiUp
$LN3@EnableUiUp:

; 2009 : 		 ( !bEnable && m_dwUIElementSinkCookie == TF_INVALID_COOKIE ) )
; 2010 : 	{
; 2011 : 		return;

  00030	eb 7a		 jmp	 SHORT $LN1@EnableUiUp
$LN2@EnableUiUp:

; 2012 : 	}
; 2013 : 	ITfSource *srcTm = NULL;

  00032	83 65 fc 00	 and	 DWORD PTR _srcTm$[ebp], 0

; 2014 : 	HRESULT hr = E_FAIL;

  00036	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 2015 : 	if (SUCCEEDED(hr = m_tm->QueryInterface(__uuidof(ITfSource), (void **)&srcTm)))

  0003d	8d 45 fc	 lea	 eax, DWORD PTR _srcTm$[ebp]
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET __GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00053	ff 10		 call	 DWORD PTR [eax]
  00055	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
  00058	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0005c	7c 4e		 jl	 SHORT $LN1@EnableUiUp

; 2016 : 	{
; 2017 : 		if ( bEnable )

  0005e	0f b6 45 08	 movzx	 eax, BYTE PTR _bEnable$[ebp]
  00062	85 c0		 test	 eax, eax
  00064	74 20		 je	 SHORT $LN6@EnableUiUp

; 2018 : 		{
; 2019 : 			hr = srcTm->AdviseSink(__uuidof(ITfUIElementSink), (ITfUIElementSink*)m_TsfSink, &m_dwUIElementSinkCookie);

  00066	68 00 00 00 00	 push	 OFFSET ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwUIElementSinkCookie
  0006b	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  00071	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
  00076	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$[ebp]
  00079	8b 00		 mov	 eax, DWORD PTR [eax]
  0007b	ff 75 fc	 push	 DWORD PTR _srcTm$[ebp]
  0007e	ff 50 0c	 call	 DWORD PTR [eax+12]
  00081	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2020 : 		}

  00084	eb 1b		 jmp	 SHORT $LN7@EnableUiUp
$LN6@EnableUiUp:

; 2021 : 		else
; 2022 : 		{
; 2023 : 			hr = srcTm->UnadviseSink(m_dwUIElementSinkCookie);

  00086	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwUIElementSinkCookie
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$[ebp]
  0008f	8b 00		 mov	 eax, DWORD PTR [eax]
  00091	ff 75 fc	 push	 DWORD PTR _srcTm$[ebp]
  00094	ff 50 10	 call	 DWORD PTR [eax+16]
  00097	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 2024 : 			m_dwUIElementSinkCookie = TF_INVALID_COOKIE;

  0009a	83 0d 00 00 00
	00 ff		 or	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwUIElementSinkCookie
$LN7@EnableUiUp:

; 2025 : 		}
; 2026 : 		srcTm->Release();

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$[ebp]
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
  000a6	ff 75 fc	 push	 DWORD PTR _srcTm$[ebp]
  000a9	ff 50 08	 call	 DWORD PTR [eax+8]
$LN1@EnableUiUp:

; 2027 : 	}
; 2028 : }

  000ac	c9		 leave
  000ad	c3		 ret	 0
?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z ENDP		; CTsfUiLessMode::EnableUiUpdates
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?UpdateImeState@CTsfUiLessMode@@SAXH@Z
_TEXT	SEGMENT
_valConvMode$1 = -52					; size = 16
_valOpenMode$2 = -36					; size = 16
_pcm$ = -20						; size = 4
tv85 = -16						; size = 4
tv83 = -12						; size = 4
_pTfConvMode$ = -8					; size = 4
_pTfOpenMode$ = -4					; size = 4
_bResetCompartmentEventSink$ = 8			; size = 4
?UpdateImeState@CTsfUiLessMode@@SAXH@Z PROC		; CTsfUiLessMode::UpdateImeState, COMDAT

; 1791 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 1792 : 	ITfCompartmentMgr* pcm;
; 1793 : 	ITfCompartment* pTfOpenMode = NULL;

  00006	83 65 fc 00	 and	 DWORD PTR _pTfOpenMode$[ebp], 0

; 1794 : 	ITfCompartment* pTfConvMode = NULL;

  0000a	83 65 f8 00	 and	 DWORD PTR _pTfConvMode$[ebp], 0

; 1795 : 	if ( GetCompartments( &pcm, &pTfOpenMode, &pTfConvMode ) )

  0000e	8d 45 f8	 lea	 eax, DWORD PTR _pTfConvMode$[ebp]
  00011	50		 push	 eax
  00012	8d 45 fc	 lea	 eax, DWORD PTR _pTfOpenMode$[ebp]
  00015	50		 push	 eax
  00016	8d 45 ec	 lea	 eax, DWORD PTR _pcm$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z ; CTsfUiLessMode::GetCompartments
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	85 c0		 test	 eax, eax
  00024	0f 84 be 00 00
	00		 je	 $LN1@UpdateImeS

; 1796 : 	{
; 1797 : 		VARIANT valOpenMode;
; 1798 : 		VARIANT valConvMode;
; 1799 : 		pTfOpenMode->GetValue( &valOpenMode );

  0002a	8d 45 dc	 lea	 eax, DWORD PTR _valOpenMode$2[ebp]
  0002d	50		 push	 eax
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _pTfOpenMode$[ebp]
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	ff 75 fc	 push	 DWORD PTR _pTfOpenMode$[ebp]
  00036	ff 50 10	 call	 DWORD PTR [eax+16]

; 1800 : 		pTfConvMode->GetValue( &valConvMode );

  00039	8d 45 cc	 lea	 eax, DWORD PTR _valConvMode$1[ebp]
  0003c	50		 push	 eax
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _pTfConvMode$[ebp]
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
  00042	ff 75 f8	 push	 DWORD PTR _pTfConvMode$[ebp]
  00045	ff 50 10	 call	 DWORD PTR [eax+16]

; 1801 : 		if ( valOpenMode.vt == VT_I4 )

  00048	0f b7 45 dc	 movzx	 eax, WORD PTR _valOpenMode$2[ebp]
  0004c	83 f8 03	 cmp	 eax, 3
  0004f	75 4c		 jne	 SHORT $LN3@UpdateImeS

; 1802 : 		{
; 1803 : 			if ( CIME::ms_bChineseIME )

  00051	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bChineseIME@CIME@@2_NA ; CIME::ms_bChineseIME
  00058	85 c0		 test	 eax, eax
  0005a	74 26		 je	 SHORT $LN4@UpdateImeS

; 1804 : 			{
; 1805 : 				CIME::ms_dwImeState = valOpenMode.lVal != 0 && valConvMode.lVal != 0 ? IMEUI_STATE_ON : IMEUI_STATE_ENGLISH;

  0005c	83 7d e4 00	 cmp	 DWORD PTR _valOpenMode$2[ebp+8], 0
  00060	74 0f		 je	 SHORT $LN8@UpdateImeS
  00062	83 7d d4 00	 cmp	 DWORD PTR _valConvMode$1[ebp+8], 0
  00066	74 09		 je	 SHORT $LN8@UpdateImeS
  00068	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
  0006f	eb 07		 jmp	 SHORT $LN9@UpdateImeS
$LN8@UpdateImeS:
  00071	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR tv83[ebp], 2
$LN9@UpdateImeS:
  00078	8b 45 f4	 mov	 eax, DWORD PTR tv83[ebp]
  0007b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwImeState@CIME@@2KA, eax ; CIME::ms_dwImeState

; 1806 : 			}

  00080	eb 1b		 jmp	 SHORT $LN3@UpdateImeS
$LN4@UpdateImeS:

; 1807 : 			else
; 1808 : 			{
; 1809 : 				CIME::ms_dwImeState = valOpenMode.lVal != 0 ? IMEUI_STATE_ON : IMEUI_STATE_OFF;

  00082	83 7d e4 00	 cmp	 DWORD PTR _valOpenMode$2[ebp+8], 0
  00086	74 09		 je	 SHORT $LN10@UpdateImeS
  00088	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv85[ebp], 1
  0008f	eb 04		 jmp	 SHORT $LN11@UpdateImeS
$LN10@UpdateImeS:
  00091	83 65 f0 00	 and	 DWORD PTR tv85[ebp], 0
$LN11@UpdateImeS:
  00095	8b 45 f0	 mov	 eax, DWORD PTR tv85[ebp]
  00098	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwImeState@CIME@@2KA, eax ; CIME::ms_dwImeState
$LN3@UpdateImeS:

; 1810 : 			}
; 1811 : 		}
; 1812 : 		VariantClear( &valOpenMode );

  0009d	8d 45 dc	 lea	 eax, DWORD PTR _valOpenMode$2[ebp]
  000a0	50		 push	 eax
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 1813 : 		VariantClear( &valConvMode );

  000a7	8d 45 cc	 lea	 eax, DWORD PTR _valConvMode$1[ebp]
  000aa	50		 push	 eax
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 1814 : 
; 1815 : 		if ( bResetCompartmentEventSink )

  000b1	83 7d 08 00	 cmp	 DWORD PTR _bResetCompartmentEventSink$[ebp], 0
  000b5	74 10		 je	 SHORT $LN6@UpdateImeS

; 1816 : 		{
; 1817 : 			SetupCompartmentSinks( FALSE, pTfOpenMode, pTfConvMode );	// Reset compartment sinks

  000b7	ff 75 f8	 push	 DWORD PTR _pTfConvMode$[ebp]
  000ba	ff 75 fc	 push	 DWORD PTR _pTfOpenMode$[ebp]
  000bd	6a 00		 push	 0
  000bf	e8 00 00 00 00	 call	 ?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ; CTsfUiLessMode::SetupCompartmentSinks
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@UpdateImeS:

; 1818 : 		}
; 1819 : 		pTfOpenMode->Release();

  000c7	8b 45 fc	 mov	 eax, DWORD PTR _pTfOpenMode$[ebp]
  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
  000cc	ff 75 fc	 push	 DWORD PTR _pTfOpenMode$[ebp]
  000cf	ff 50 08	 call	 DWORD PTR [eax+8]

; 1820 : 		pTfConvMode->Release();

  000d2	8b 45 f8	 mov	 eax, DWORD PTR _pTfConvMode$[ebp]
  000d5	8b 00		 mov	 eax, DWORD PTR [eax]
  000d7	ff 75 f8	 push	 DWORD PTR _pTfConvMode$[ebp]
  000da	ff 50 08	 call	 DWORD PTR [eax+8]

; 1821 : 		pcm->Release();

  000dd	8b 45 ec	 mov	 eax, DWORD PTR _pcm$[ebp]
  000e0	8b 00		 mov	 eax, DWORD PTR [eax]
  000e2	ff 75 ec	 push	 DWORD PTR _pcm$[ebp]
  000e5	ff 50 08	 call	 DWORD PTR [eax+8]
$LN1@UpdateImeS:

; 1822 : 	}
; 1823 : }

  000e8	c9		 leave
  000e9	c3		 ret	 0
?UpdateImeState@CTsfUiLessMode@@SAXH@Z ENDP		; CTsfUiLessMode::UpdateImeState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ
_TEXT	SEGMENT
_ret$ = -96						; size = 4
tv91 = -92						; size = 4
_pProfiles$ = -88					; size = 4
_pProfileMgr$1 = -84					; size = 4
_hr$ = -80						; size = 4
_tip$2 = -76						; size = 72
__$ArrayPad$ = -4					; size = 4
?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ PROC	; CTsfUiLessMode::CurrentInputLocaleIsIme, COMDAT

; 1977 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1978 : 	BOOL ret = FALSE;

  00010	83 65 a0 00	 and	 DWORD PTR _ret$[ebp], 0

; 1979 : 	HRESULT hr;
; 1980 : 
; 1981 : 	ITfInputProcessorProfiles *pProfiles;
; 1982 : 	hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, __uuidof(ITfInputProcessorProfiles), (LPVOID*)&pProfiles);

  00014	8d 45 a8	 lea	 eax, DWORD PTR _pProfiles$[ebp]
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET __GUID_1f02b6c5_7842_4ee6_8a0b_9a24183a95ca
  0001d	6a 01		 push	 1
  0001f	6a 00		 push	 0
  00021	68 00 00 00 00	 push	 OFFSET _CLSID_TF_InputProcessorProfiles
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20
  0002c	89 45 b0	 mov	 DWORD PTR _hr$[ebp], eax

; 1983 : 	if (SUCCEEDED(hr))

  0002f	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00033	7c 6a		 jl	 SHORT $LN2@CurrentInp

; 1984 : 	{
; 1985 : 		ITfInputProcessorProfileMgr *pProfileMgr;
; 1986 : 		hr = pProfiles->QueryInterface(__uuidof(ITfInputProcessorProfileMgr), (LPVOID*)&pProfileMgr);

  00035	8d 45 ac	 lea	 eax, DWORD PTR _pProfileMgr$1[ebp]
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET __GUID_71c6e74c_0f28_11d8_a82a_00065b84435c
  0003e	8b 45 a8	 mov	 eax, DWORD PTR _pProfiles$[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	ff 75 a8	 push	 DWORD PTR _pProfiles$[ebp]
  00046	ff 10		 call	 DWORD PTR [eax]
  00048	89 45 b0	 mov	 DWORD PTR _hr$[ebp], eax

; 1987 : 		if (SUCCEEDED(hr))

  0004b	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004f	7c 43		 jl	 SHORT $LN3@CurrentInp

; 1988 : 		{
; 1989 : 			TF_INPUTPROCESSORPROFILE tip;
; 1990 : 			hr = pProfileMgr->GetActiveProfile( GUID_TFCAT_TIP_KEYBOARD, &tip );

  00051	8d 45 b4	 lea	 eax, DWORD PTR _tip$2[ebp]
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET _GUID_TFCAT_TIP_KEYBOARD
  0005a	8b 45 ac	 mov	 eax, DWORD PTR _pProfileMgr$1[ebp]
  0005d	8b 00		 mov	 eax, DWORD PTR [eax]
  0005f	ff 75 ac	 push	 DWORD PTR _pProfileMgr$1[ebp]
  00062	ff 50 28	 call	 DWORD PTR [eax+40]
  00065	89 45 b0	 mov	 DWORD PTR _hr$[ebp], eax

; 1991 : 			if (SUCCEEDED(hr))

  00068	83 7d b0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006c	7c 1b		 jl	 SHORT $LN4@CurrentInp

; 1992 : 			{
; 1993 : 				ret = ( tip.dwProfileType & TF_PROFILETYPE_INPUTPROCESSOR ) != 0;

  0006e	8b 45 b4	 mov	 eax, DWORD PTR _tip$2[ebp]
  00071	83 e0 01	 and	 eax, 1
  00074	74 09		 je	 SHORT $LN6@CurrentInp
  00076	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  0007d	eb 04		 jmp	 SHORT $LN7@CurrentInp
$LN6@CurrentInp:
  0007f	83 65 a4 00	 and	 DWORD PTR tv91[ebp], 0
$LN7@CurrentInp:
  00083	8b 45 a4	 mov	 eax, DWORD PTR tv91[ebp]
  00086	89 45 a0	 mov	 DWORD PTR _ret$[ebp], eax
$LN4@CurrentInp:

; 1994 : 			}
; 1995 : 			pProfileMgr->Release();

  00089	8b 45 ac	 mov	 eax, DWORD PTR _pProfileMgr$1[ebp]
  0008c	8b 00		 mov	 eax, DWORD PTR [eax]
  0008e	ff 75 ac	 push	 DWORD PTR _pProfileMgr$1[ebp]
  00091	ff 50 08	 call	 DWORD PTR [eax+8]
$LN3@CurrentInp:

; 1996 : 		}
; 1997 : 		pProfiles->Release();

  00094	8b 45 a8	 mov	 eax, DWORD PTR _pProfiles$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	ff 75 a8	 push	 DWORD PTR _pProfiles$[ebp]
  0009c	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@CurrentInp:

; 1998 : 	}
; 1999 : 	return ret;

  0009f	8b 45 a0	 mov	 eax, DWORD PTR _ret$[ebp]

; 2000 : }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	c9		 leave
  000ad	c3		 ret	 0
?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ ENDP	; CTsfUiLessMode::CurrentInputLocaleIsIme
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?ReleaseSinks@CTsfUiLessMode@@SAXXZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_source$ = -4						; size = 4
?ReleaseSinks@CTsfUiLessMode@@SAXXZ PROC		; CTsfUiLessMode::ReleaseSinks, COMDAT

; 1611 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1612 : 	HRESULT hr;
; 1613 : 	ITfSource *source;
; 1614 : 
; 1615 : 	// Remove all sinks
; 1616 : 	if ( m_tm && SUCCEEDED(m_tm->QueryInterface(__uuidof(ITfSource), (void **)&source)))

  00005	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A, 0 ; CTsfUiLessMode::m_tm
  0000c	0f 84 b1 00 00
	00		 je	 $LN1@ReleaseSin
  00012	8d 45 fc	 lea	 eax, DWORD PTR _source$[ebp]
  00015	50		 push	 eax
  00016	68 00 00 00 00	 push	 OFFSET __GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00028	ff 10		 call	 DWORD PTR [eax]
  0002a	85 c0		 test	 eax, eax
  0002c	0f 8c 91 00 00
	00		 jl	 $LN1@ReleaseSin

; 1617 : 	{
; 1618 :         hr = source->UnadviseSink(m_dwUIElementSinkCookie);

  00032	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwUIElementSinkCookie
  00038	8b 45 fc	 mov	 eax, DWORD PTR _source$[ebp]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	ff 75 fc	 push	 DWORD PTR _source$[ebp]
  00040	ff 50 10	 call	 DWORD PTR [eax+16]
  00043	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1619 : 		hr = source->UnadviseSink(m_dwAlpnSinkCookie);

  00046	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwAlpnSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwAlpnSinkCookie
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _source$[ebp]
  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
  00051	ff 75 fc	 push	 DWORD PTR _source$[ebp]
  00054	ff 50 10	 call	 DWORD PTR [eax+16]
  00057	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1620 :         source->Release();

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _source$[ebp]
  0005d	8b 00		 mov	 eax, DWORD PTR [eax]
  0005f	ff 75 fc	 push	 DWORD PTR _source$[ebp]
  00062	ff 50 08	 call	 DWORD PTR [eax+8]

; 1621 : 		SetupCompartmentSinks(TRUE);	// Remove all compartment sinks

  00065	6a 00		 push	 0
  00067	6a 00		 push	 0
  00069	6a 01		 push	 1
  0006b	e8 00 00 00 00	 call	 ?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ; CTsfUiLessMode::SetupCompartmentSinks
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1622 : 		m_tm->Deactivate();

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00080	ff 50 10	 call	 DWORD PTR [eax+16]

; 1623 : 		SAFE_RELEASE(m_tm);

  00083	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A, 0 ; CTsfUiLessMode::m_tm
  0008a	74 17		 je	 SHORT $LN3@ReleaseSin
  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00091	8b 00		 mov	 eax, DWORD PTR [eax]
  00093	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00099	ff 50 08	 call	 DWORD PTR [eax+8]
  0009c	83 25 00 00 00
	00 00		 and	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A, 0 ; CTsfUiLessMode::m_tm
$LN3@ReleaseSin:

; 1624 : 		SAFE_RELEASE(m_TsfSink);

  000a3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, 0 ; CTsfUiLessMode::m_TsfSink
  000aa	74 17		 je	 SHORT $LN1@ReleaseSin
  000ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  000b1	8b 00		 mov	 eax, DWORD PTR [eax]
  000b3	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  000b9	ff 50 08	 call	 DWORD PTR [eax+8]
  000bc	83 25 00 00 00
	00 00		 and	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, 0 ; CTsfUiLessMode::m_TsfSink
$LN1@ReleaseSin:

; 1625 : 	}	
; 1626 : }

  000c3	c9		 leave
  000c4	c3		 ret	 0
?ReleaseSinks@CTsfUiLessMode@@SAXXZ ENDP		; CTsfUiLessMode::ReleaseSinks
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetupSinks@CTsfUiLessMode@@SAHXZ
_TEXT	SEGMENT
_cid$ = -44						; size = 4
$T2 = -40						; size = 4
_bRc$ = -36						; size = 4
tv161 = -32						; size = 4
tv89 = -28						; size = 4
$T3 = -24						; size = 4
_srcTm$4 = -20						; size = 4
_hr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetupSinks@CTsfUiLessMode@@SAHXZ PROC			; CTsfUiLessMode::SetupSinks, COMDAT

; 1563 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetupSinks@CTsfUiLessMode@@SAHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1564 : 	// ITfThreadMgrEx is available on Vista or later.
; 1565 : 	HRESULT hr;
; 1566 :     hr = CoCreateInstance(CLSID_TF_ThreadMgr, 

  00025	68 00 00 00 00	 push	 OFFSET ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0002a	68 00 00 00 00	 push	 OFFSET __GUID_3e90ade3_7594_4cb0_bb58_69628f5f458c
  0002f	6a 01		 push	 1
  00031	6a 00		 push	 0
  00033	68 00 00 00 00	 push	 OFFSET _CLSID_TF_ThreadMgr
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20
  0003e	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax

; 1567 :                           NULL, 
; 1568 :                           CLSCTX_INPROC_SERVER, 
; 1569 :                           __uuidof(ITfThreadMgrEx), 
; 1570 :                           (void**)&m_tm);
; 1571 : 
; 1572 :     if (hr != S_OK)

  00041	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00045	74 07		 je	 SHORT $LN2@SetupSinks

; 1573 :     {
; 1574 :         return FALSE;

  00047	33 c0		 xor	 eax, eax
  00049	e9 15 01 00 00	 jmp	 $LN1@SetupSinks
$LN2@SetupSinks:

; 1575 :     }
; 1576 : 
; 1577 :     // ready to start interacting
; 1578 : 	TfClientId cid;	// not used
; 1579 :     if (FAILED(m_tm->ActivateEx(&cid, TF_TMAE_UIELEMENTENABLEDONLY)))

  0004e	6a 04		 push	 4
  00050	8d 45 d4	 lea	 eax, DWORD PTR _cid$[ebp]
  00053	50		 push	 eax
  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00061	ff 50 38	 call	 DWORD PTR [eax+56]
  00064	85 c0		 test	 eax, eax
  00066	7d 07		 jge	 SHORT $LN3@SetupSinks

; 1580 :     {
; 1581 :         return FALSE;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 f4 00 00 00	 jmp	 $LN1@SetupSinks
$LN3@SetupSinks:

; 1582 :     }
; 1583 : 
; 1584 : 	// Setup sinks
; 1585 : 	BOOL bRc = FALSE;

  0006f	83 65 dc 00	 and	 DWORD PTR _bRc$[ebp], 0

; 1586 :     m_TsfSink = new CUIElementSink();

  00073	6a 10		 push	 16			; 00000010H
  00075	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007a	59		 pop	 ecx
  0007b	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
  0007e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00082	83 7d e8 00	 cmp	 DWORD PTR $T3[ebp], 0
  00086	74 0d		 je	 SHORT $LN10@SetupSinks
  00088	8b 4d e8	 mov	 ecx, DWORD PTR $T3[ebp]
  0008b	e8 00 00 00 00	 call	 ??0CUIElementSink@CTsfUiLessMode@@QAE@XZ ; CTsfUiLessMode::CUIElementSink::CUIElementSink
  00090	89 45 e4	 mov	 DWORD PTR tv89[ebp], eax
  00093	eb 04		 jmp	 SHORT $LN11@SetupSinks
$LN10@SetupSinks:
  00095	83 65 e4 00	 and	 DWORD PTR tv89[ebp], 0
$LN11@SetupSinks:
  00099	8b 45 e4	 mov	 eax, DWORD PTR tv89[ebp]
  0009c	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
  0009f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000a3	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  000a6	a3 00 00 00 00	 mov	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, eax ; CTsfUiLessMode::m_TsfSink

; 1587 : 	if (m_TsfSink)

  000ab	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, 0 ; CTsfUiLessMode::m_TsfSink
  000b2	0f 84 a8 00 00
	00		 je	 $LN4@SetupSinks

; 1588 : 	{
; 1589 : 		ITfSource *srcTm;
; 1590 : 		if (SUCCEEDED(hr = m_tm->QueryInterface(__uuidof(ITfSource), (void **)&srcTm)))

  000b8	8d 45 ec	 lea	 eax, DWORD PTR _srcTm$4[ebp]
  000bb	50		 push	 eax
  000bc	68 00 00 00 00	 push	 OFFSET __GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  000c6	8b 00		 mov	 eax, DWORD PTR [eax]
  000c8	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  000ce	ff 10		 call	 DWORD PTR [eax]
  000d0	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
  000d3	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000d7	0f 8c 83 00 00
	00		 jl	 $LN4@SetupSinks

; 1591 : 		{
; 1592 : 			// Sink for reading window change
; 1593 : 			if (SUCCEEDED(hr = srcTm->AdviseSink(__uuidof(ITfUIElementSink), (ITfUIElementSink*)m_TsfSink, &m_dwUIElementSinkCookie)))

  000dd	68 00 00 00 00	 push	 OFFSET ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwUIElementSinkCookie
  000e2	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  000e8	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
  000ed	8b 45 ec	 mov	 eax, DWORD PTR _srcTm$4[ebp]
  000f0	8b 00		 mov	 eax, DWORD PTR [eax]
  000f2	ff 75 ec	 push	 DWORD PTR _srcTm$4[ebp]
  000f5	ff 50 0c	 call	 DWORD PTR [eax+12]
  000f8	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
  000fb	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ff	7c 54		 jl	 SHORT $LN6@SetupSinks

; 1594 : 			{
; 1595 : 				// Sink for input locale change
; 1596 : 				if (SUCCEEDED(hr = srcTm->AdviseSink(__uuidof(ITfInputProcessorProfileActivationSink), (ITfInputProcessorProfileActivationSink*)m_TsfSink, &m_dwAlpnSinkCookie)))

  00101	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, 0 ; CTsfUiLessMode::m_TsfSink
  00108	74 0d		 je	 SHORT $LN12@SetupSinks
  0010a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  0010f	83 c0 04	 add	 eax, 4
  00112	89 45 e0	 mov	 DWORD PTR tv161[ebp], eax
  00115	eb 04		 jmp	 SHORT $LN13@SetupSinks
$LN12@SetupSinks:
  00117	83 65 e0 00	 and	 DWORD PTR tv161[ebp], 0
$LN13@SetupSinks:
  0011b	68 00 00 00 00	 push	 OFFSET ?m_dwAlpnSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwAlpnSinkCookie
  00120	ff 75 e0	 push	 DWORD PTR tv161[ebp]
  00123	68 00 00 00 00	 push	 OFFSET __GUID_71c6e74e_0f28_11d8_a82a_00065b84435c
  00128	8b 45 ec	 mov	 eax, DWORD PTR _srcTm$4[ebp]
  0012b	8b 00		 mov	 eax, DWORD PTR [eax]
  0012d	ff 75 ec	 push	 DWORD PTR _srcTm$4[ebp]
  00130	ff 50 0c	 call	 DWORD PTR [eax+12]
  00133	89 45 f0	 mov	 DWORD PTR _hr$[ebp], eax
  00136	83 7d f0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0013a	7c 19		 jl	 SHORT $LN6@SetupSinks

; 1597 : 				{
; 1598 : 					if (SetupCompartmentSinks())	// Setup compartment sinks for the first time

  0013c	6a 00		 push	 0
  0013e	6a 00		 push	 0
  00140	6a 00		 push	 0
  00142	e8 00 00 00 00	 call	 ?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ; CTsfUiLessMode::SetupCompartmentSinks
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014a	85 c0		 test	 eax, eax
  0014c	74 07		 je	 SHORT $LN6@SetupSinks

; 1599 : 					{
; 1600 : 						bRc = TRUE;

  0014e	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _bRc$[ebp], 1
$LN6@SetupSinks:

; 1601 : 					}
; 1602 : 				}
; 1603 : 			}
; 1604 : 			srcTm->Release();

  00155	8b 45 ec	 mov	 eax, DWORD PTR _srcTm$4[ebp]
  00158	8b 00		 mov	 eax, DWORD PTR [eax]
  0015a	ff 75 ec	 push	 DWORD PTR _srcTm$4[ebp]
  0015d	ff 50 08	 call	 DWORD PTR [eax+8]
$LN4@SetupSinks:

; 1605 : 		}
; 1606 : 	}
; 1607 : 	return bRc;

  00160	8b 45 dc	 mov	 eax, DWORD PTR _bRc$[ebp]
$LN1@SetupSinks:

; 1608 : }

  00163	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00166	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016d	59		 pop	 ecx
  0016e	c9		 leave
  0016f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetupSinks@CTsfUiLessMode@@SAHXZ$0:
  00000	6a 10		 push	 16			; 00000010H
  00002	ff 75 e8	 push	 DWORD PTR $T3[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?SetupSinks@CTsfUiLessMode@@SAHXZ:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetupSinks@CTsfUiLessMode@@SAHXZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetupSinks@CTsfUiLessMode@@SAHXZ ENDP			; CTsfUiLessMode::SetupSinks
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z
_TEXT	SEGMENT
_bRc$ = -32						; size = 4
tv167 = -28						; size = 4
tv132 = -24						; size = 4
_pcm$ = -20						; size = 4
_srcOpenMode$ = -16					; size = 4
_srcConvMode$1 = -12					; size = 4
_hr$ = -8						; size = 4
_bLocalCompartments$ = -1				; size = 1
_bRemoveOnly$ = 8					; size = 4
_pTfOpenMode$ = 12					; size = 4
_pTfConvMode$ = 16					; size = 4
?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z PROC ; CTsfUiLessMode::SetupCompartmentSinks, COMDAT

; 2064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 2065 : 	bool bLocalCompartments = false;

  00006	c6 45 ff 00	 mov	 BYTE PTR _bLocalCompartments$[ebp], 0

; 2066 : 	ITfCompartmentMgr* pcm = NULL;

  0000a	83 65 ec 00	 and	 DWORD PTR _pcm$[ebp], 0

; 2067 : 	BOOL bRc = FALSE;

  0000e	83 65 e0 00	 and	 DWORD PTR _bRc$[ebp], 0

; 2068 : 	HRESULT hr = E_FAIL;

  00012	c7 45 f8 05 40
	00 80		 mov	 DWORD PTR _hr$[ebp], -2147467259 ; 80004005H

; 2069 : 
; 2070 : 	if ( !pTfOpenMode && !pTfConvMode )

  00019	83 7d 0c 00	 cmp	 DWORD PTR _pTfOpenMode$[ebp], 0
  0001d	75 1e		 jne	 SHORT $LN2@SetupCompa
  0001f	83 7d 10 00	 cmp	 DWORD PTR _pTfConvMode$[ebp], 0
  00023	75 18		 jne	 SHORT $LN2@SetupCompa

; 2071 : 	{
; 2072 : 		bLocalCompartments = true;

  00025	c6 45 ff 01	 mov	 BYTE PTR _bLocalCompartments$[ebp], 1

; 2073 : 		GetCompartments( &pcm, &pTfOpenMode, &pTfConvMode );

  00029	8d 45 10	 lea	 eax, DWORD PTR _pTfConvMode$[ebp]
  0002c	50		 push	 eax
  0002d	8d 45 0c	 lea	 eax, DWORD PTR _pTfOpenMode$[ebp]
  00030	50		 push	 eax
  00031	8d 45 ec	 lea	 eax, DWORD PTR _pcm$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z ; CTsfUiLessMode::GetCompartments
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SetupCompa:

; 2074 : 	}
; 2075 : 	if ( !( pTfOpenMode && pTfConvMode ) )

  0003d	83 7d 0c 00	 cmp	 DWORD PTR _pTfOpenMode$[ebp], 0
  00041	74 06		 je	 SHORT $LN4@SetupCompa
  00043	83 7d 10 00	 cmp	 DWORD PTR _pTfConvMode$[ebp], 0
  00047	75 07		 jne	 SHORT $LN3@SetupCompa
$LN4@SetupCompa:

; 2076 : 	{
; 2077 : 		// Invalid parameters or GetCompartments() has failed.
; 2078 : 		return FALSE;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 55 01 00 00	 jmp	 $LN1@SetupCompa
$LN3@SetupCompa:

; 2079 : 	}
; 2080 : 	ITfSource *srcOpenMode = NULL;

  00050	83 65 f0 00	 and	 DWORD PTR _srcOpenMode$[ebp], 0

; 2081 : 	if (SUCCEEDED(hr = pTfOpenMode->QueryInterface( IID_ITfSource, (void**)&srcOpenMode )))

  00054	8d 45 f0	 lea	 eax, DWORD PTR _srcOpenMode$[ebp]
  00057	50		 push	 eax
  00058	68 00 00 00 00	 push	 OFFSET _IID_ITfSource
  0005d	8b 45 0c	 mov	 eax, DWORD PTR _pTfOpenMode$[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	ff 75 0c	 push	 DWORD PTR _pTfOpenMode$[ebp]
  00065	ff 10		 call	 DWORD PTR [eax]
  00067	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
  0006a	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006e	0f 8c 05 01 00
	00		 jl	 $LN5@SetupCompa

; 2082 : 	{
; 2083 : 		// Remove existing sink for open mode
; 2084 : 		if ( m_dwOpenModeSinkCookie != TF_INVALID_COOKIE )

  00074	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwOpenModeSinkCookie
  0007b	74 18		 je	 SHORT $LN6@SetupCompa

; 2085 : 		{
; 2086 : 			srcOpenMode->UnadviseSink( m_dwOpenModeSinkCookie );

  0007d	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwOpenModeSinkCookie
  00083	8b 45 f0	 mov	 eax, DWORD PTR _srcOpenMode$[ebp]
  00086	8b 00		 mov	 eax, DWORD PTR [eax]
  00088	ff 75 f0	 push	 DWORD PTR _srcOpenMode$[ebp]
  0008b	ff 50 10	 call	 DWORD PTR [eax+16]

; 2087 : 			m_dwOpenModeSinkCookie = TF_INVALID_COOKIE;

  0008e	83 0d 00 00 00
	00 ff		 or	 DWORD PTR ?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwOpenModeSinkCookie
$LN6@SetupCompa:

; 2088 : 		}
; 2089 : 		// Setup sink for open mode (toggle state) change
; 2090 : 		if ( bRemoveOnly || SUCCEEDED(hr = srcOpenMode->AdviseSink( IID_ITfCompartmentEventSink, (ITfCompartmentEventSink*)m_TsfSink, &m_dwOpenModeSinkCookie )))

  00095	83 7d 08 00	 cmp	 DWORD PTR _bRemoveOnly$[ebp], 0
  00099	75 3f		 jne	 SHORT $LN8@SetupCompa
  0009b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, 0 ; CTsfUiLessMode::m_TsfSink
  000a2	74 0d		 je	 SHORT $LN15@SetupCompa
  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  000a9	83 c0 08	 add	 eax, 8
  000ac	89 45 e8	 mov	 DWORD PTR tv132[ebp], eax
  000af	eb 04		 jmp	 SHORT $LN16@SetupCompa
$LN15@SetupCompa:
  000b1	83 65 e8 00	 and	 DWORD PTR tv132[ebp], 0
$LN16@SetupCompa:
  000b5	68 00 00 00 00	 push	 OFFSET ?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwOpenModeSinkCookie
  000ba	ff 75 e8	 push	 DWORD PTR tv132[ebp]
  000bd	68 00 00 00 00	 push	 OFFSET _IID_ITfCompartmentEventSink
  000c2	8b 45 f0	 mov	 eax, DWORD PTR _srcOpenMode$[ebp]
  000c5	8b 00		 mov	 eax, DWORD PTR [eax]
  000c7	ff 75 f0	 push	 DWORD PTR _srcOpenMode$[ebp]
  000ca	ff 50 0c	 call	 DWORD PTR [eax+12]
  000cd	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
  000d0	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000d4	0f 8c 94 00 00
	00		 jl	 $LN7@SetupCompa
$LN8@SetupCompa:

; 2091 : 		{
; 2092 : 			ITfSource *srcConvMode = NULL;

  000da	83 65 f4 00	 and	 DWORD PTR _srcConvMode$1[ebp], 0

; 2093 : 			if (SUCCEEDED(hr = pTfConvMode->QueryInterface( IID_ITfSource, (void**)&srcConvMode )))

  000de	8d 45 f4	 lea	 eax, DWORD PTR _srcConvMode$1[ebp]
  000e1	50		 push	 eax
  000e2	68 00 00 00 00	 push	 OFFSET _IID_ITfSource
  000e7	8b 45 10	 mov	 eax, DWORD PTR _pTfConvMode$[ebp]
  000ea	8b 00		 mov	 eax, DWORD PTR [eax]
  000ec	ff 75 10	 push	 DWORD PTR _pTfConvMode$[ebp]
  000ef	ff 10		 call	 DWORD PTR [eax]
  000f1	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
  000f4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000f8	7c 74		 jl	 SHORT $LN7@SetupCompa

; 2094 : 			{
; 2095 : 				// Remove existing sink for open mode
; 2096 : 				if ( m_dwConvModeSinkCookie != TF_INVALID_COOKIE )

  000fa	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwConvModeSinkCookie
  00101	74 18		 je	 SHORT $LN10@SetupCompa

; 2097 : 				{
; 2098 : 					srcConvMode->UnadviseSink( m_dwConvModeSinkCookie );

  00103	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwConvModeSinkCookie
  00109	8b 45 f4	 mov	 eax, DWORD PTR _srcConvMode$1[ebp]
  0010c	8b 00		 mov	 eax, DWORD PTR [eax]
  0010e	ff 75 f4	 push	 DWORD PTR _srcConvMode$1[ebp]
  00111	ff 50 10	 call	 DWORD PTR [eax+16]

; 2099 : 					m_dwConvModeSinkCookie = TF_INVALID_COOKIE;

  00114	83 0d 00 00 00
	00 ff		 or	 DWORD PTR ?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwConvModeSinkCookie
$LN10@SetupCompa:

; 2100 : 				}
; 2101 : 				// Setup sink for open mode (toggle state) change
; 2102 : 				if ( bRemoveOnly || SUCCEEDED(hr = srcConvMode->AdviseSink( IID_ITfCompartmentEventSink, (ITfCompartmentEventSink*)m_TsfSink, &m_dwConvModeSinkCookie )))

  0011b	83 7d 08 00	 cmp	 DWORD PTR _bRemoveOnly$[ebp], 0
  0011f	75 3b		 jne	 SHORT $LN12@SetupCompa
  00121	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, 0 ; CTsfUiLessMode::m_TsfSink
  00128	74 0d		 je	 SHORT $LN17@SetupCompa
  0012a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  0012f	83 c0 08	 add	 eax, 8
  00132	89 45 e4	 mov	 DWORD PTR tv167[ebp], eax
  00135	eb 04		 jmp	 SHORT $LN18@SetupCompa
$LN17@SetupCompa:
  00137	83 65 e4 00	 and	 DWORD PTR tv167[ebp], 0
$LN18@SetupCompa:
  0013b	68 00 00 00 00	 push	 OFFSET ?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwConvModeSinkCookie
  00140	ff 75 e4	 push	 DWORD PTR tv167[ebp]
  00143	68 00 00 00 00	 push	 OFFSET _IID_ITfCompartmentEventSink
  00148	8b 45 f4	 mov	 eax, DWORD PTR _srcConvMode$1[ebp]
  0014b	8b 00		 mov	 eax, DWORD PTR [eax]
  0014d	ff 75 f4	 push	 DWORD PTR _srcConvMode$1[ebp]
  00150	ff 50 0c	 call	 DWORD PTR [eax+12]
  00153	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
  00156	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0015a	7c 07		 jl	 SHORT $LN11@SetupCompa
$LN12@SetupCompa:

; 2103 : 				{
; 2104 : 					bRc = TRUE;

  0015c	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _bRc$[ebp], 1
$LN11@SetupCompa:

; 2105 : 				}
; 2106 : 				srcConvMode->Release();

  00163	8b 45 f4	 mov	 eax, DWORD PTR _srcConvMode$1[ebp]
  00166	8b 00		 mov	 eax, DWORD PTR [eax]
  00168	ff 75 f4	 push	 DWORD PTR _srcConvMode$1[ebp]
  0016b	ff 50 08	 call	 DWORD PTR [eax+8]
$LN7@SetupCompa:

; 2107 : 			}
; 2108 : 		}
; 2109 : 		srcOpenMode->Release();

  0016e	8b 45 f0	 mov	 eax, DWORD PTR _srcOpenMode$[ebp]
  00171	8b 00		 mov	 eax, DWORD PTR [eax]
  00173	ff 75 f0	 push	 DWORD PTR _srcOpenMode$[ebp]
  00176	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@SetupCompa:

; 2110 : 	}
; 2111 : 	if ( bLocalCompartments )

  00179	0f b6 45 ff	 movzx	 eax, BYTE PTR _bLocalCompartments$[ebp]
  0017d	85 c0		 test	 eax, eax
  0017f	74 21		 je	 SHORT $LN13@SetupCompa

; 2112 : 	{
; 2113 : 		pTfOpenMode->Release();

  00181	8b 45 0c	 mov	 eax, DWORD PTR _pTfOpenMode$[ebp]
  00184	8b 00		 mov	 eax, DWORD PTR [eax]
  00186	ff 75 0c	 push	 DWORD PTR _pTfOpenMode$[ebp]
  00189	ff 50 08	 call	 DWORD PTR [eax+8]

; 2114 : 		pTfConvMode->Release();

  0018c	8b 45 10	 mov	 eax, DWORD PTR _pTfConvMode$[ebp]
  0018f	8b 00		 mov	 eax, DWORD PTR [eax]
  00191	ff 75 10	 push	 DWORD PTR _pTfConvMode$[ebp]
  00194	ff 50 08	 call	 DWORD PTR [eax+8]

; 2115 : 		pcm->Release();

  00197	8b 45 ec	 mov	 eax, DWORD PTR _pcm$[ebp]
  0019a	8b 00		 mov	 eax, DWORD PTR [eax]
  0019c	ff 75 ec	 push	 DWORD PTR _pcm$[ebp]
  0019f	ff 50 08	 call	 DWORD PTR [eax+8]
$LN13@SetupCompa:

; 2116 : 	}
; 2117 : 	return bRc;

  001a2	8b 45 e0	 mov	 eax, DWORD PTR _bRc$[ebp]
$LN1@SetupCompa:

; 2118 : }

  001a5	c9		 leave
  001a6	c3		 ret	 0
?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ENDP ; CTsfUiLessMode::SetupCompartmentSinks
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z
_TEXT	SEGMENT
_pTfConvMode$ = -16					; size = 4
_pTfOpenMode$ = -12					; size = 4
_hr$ = -8						; size = 4
_pcm$ = -4						; size = 4
_ppcm$ = 8						; size = 4
_ppTfOpenMode$ = 12					; size = 4
_ppTfConvMode$ = 16					; size = 4
?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z PROC ; CTsfUiLessMode::GetCompartments, COMDAT

; 2033 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2034 : 	ITfCompartmentMgr* pcm = NULL;

  00006	83 65 fc 00	 and	 DWORD PTR _pcm$[ebp], 0

; 2035 : 	ITfCompartment* pTfOpenMode = NULL;

  0000a	83 65 f4 00	 and	 DWORD PTR _pTfOpenMode$[ebp], 0

; 2036 : 	ITfCompartment* pTfConvMode = NULL;

  0000e	83 65 f0 00	 and	 DWORD PTR _pTfConvMode$[ebp], 0

; 2037 : 
; 2038 : 	static GUID _GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION = { 0xCCF05DD8, 0x4A87, 0x11D7, 0xA6, 0xE2, 0x00, 0x06, 0x5B, 0x84, 0x43, 0x5C };
; 2039 : 
; 2040 : 	HRESULT hr;
; 2041 : 	if (SUCCEEDED(hr = m_tm->QueryInterface( IID_ITfCompartmentMgr, (void**)&pcm )))

  00012	8d 45 fc	 lea	 eax, DWORD PTR _pcm$[ebp]
  00015	50		 push	 eax
  00016	68 00 00 00 00	 push	 OFFSET _IID_ITfCompartmentMgr
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00028	ff 10		 call	 DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
  0002d	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00031	7c 6d		 jl	 SHORT $LN2@GetCompart

; 2042 : 	{
; 2043 : 		if (SUCCEEDED(hr = pcm->GetCompartment( GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, &pTfOpenMode )))

  00033	8d 45 f4	 lea	 eax, DWORD PTR _pTfOpenMode$[ebp]
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET _GUID_COMPARTMENT_KEYBOARD_OPENCLOSE
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _pcm$[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	ff 75 fc	 push	 DWORD PTR _pcm$[ebp]
  00044	ff 50 0c	 call	 DWORD PTR [eax+12]
  00047	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
  0004a	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004e	7c 45		 jl	 SHORT $LN3@GetCompart

; 2044 : 		{
; 2045 : 			if (SUCCEEDED(hr = pcm->GetCompartment( _GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION, &pTfConvMode )))

  00050	8d 45 f0	 lea	 eax, DWORD PTR _pTfConvMode$[ebp]
  00053	50		 push	 eax
  00054	68 00 00 00 00	 push	 OFFSET ?_GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION@?1??GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z@4U_GUID@@A
  00059	8b 45 fc	 mov	 eax, DWORD PTR _pcm$[ebp]
  0005c	8b 00		 mov	 eax, DWORD PTR [eax]
  0005e	ff 75 fc	 push	 DWORD PTR _pcm$[ebp]
  00061	ff 50 0c	 call	 DWORD PTR [eax+12]
  00064	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax
  00067	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0006b	7c 1d		 jl	 SHORT $LN4@GetCompart

; 2046 : 			{
; 2047 : 				*ppcm = pcm;

  0006d	8b 45 08	 mov	 eax, DWORD PTR _ppcm$[ebp]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _pcm$[ebp]
  00073	89 08		 mov	 DWORD PTR [eax], ecx

; 2048 : 				*ppTfOpenMode = pTfOpenMode;

  00075	8b 45 0c	 mov	 eax, DWORD PTR _ppTfOpenMode$[ebp]
  00078	8b 4d f4	 mov	 ecx, DWORD PTR _pTfOpenMode$[ebp]
  0007b	89 08		 mov	 DWORD PTR [eax], ecx

; 2049 : 				*ppTfConvMode = pTfConvMode;

  0007d	8b 45 10	 mov	 eax, DWORD PTR _ppTfConvMode$[ebp]
  00080	8b 4d f0	 mov	 ecx, DWORD PTR _pTfConvMode$[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx

; 2050 : 				return TRUE;

  00085	33 c0		 xor	 eax, eax
  00087	40		 inc	 eax
  00088	eb 18		 jmp	 SHORT $LN1@GetCompart
$LN4@GetCompart:

; 2051 : 			}
; 2052 : 			pTfOpenMode->Release();

  0008a	8b 45 f4	 mov	 eax, DWORD PTR _pTfOpenMode$[ebp]
  0008d	8b 00		 mov	 eax, DWORD PTR [eax]
  0008f	ff 75 f4	 push	 DWORD PTR _pTfOpenMode$[ebp]
  00092	ff 50 08	 call	 DWORD PTR [eax+8]
$LN3@GetCompart:

; 2053 : 		}
; 2054 : 		pcm->Release();

  00095	8b 45 fc	 mov	 eax, DWORD PTR _pcm$[ebp]
  00098	8b 00		 mov	 eax, DWORD PTR [eax]
  0009a	ff 75 fc	 push	 DWORD PTR _pcm$[ebp]
  0009d	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@GetCompart:

; 2055 : 	}
; 2056 : 	return FALSE;

  000a0	33 c0		 xor	 eax, eax
$LN1@GetCompart:

; 2057 : }

  000a2	c9		 leave
  000a3	c3		 ret	 0
?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z ENDP ; CTsfUiLessMode::GetCompartments
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z
_TEXT	SEGMENT
_pElement$ = -8						; size = 4
_puiem$ = -4						; size = 4
_dwUIElementId$ = 8					; size = 4
?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z PROC ; CTsfUiLessMode::GetUIElement, COMDAT

; 1963 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1964 :     ITfUIElementMgr *puiem;
; 1965 :     ITfUIElement *pElement = NULL;

  00005	83 65 f8 00	 and	 DWORD PTR _pElement$[ebp], 0

; 1966 : 
; 1967 :     if (SUCCEEDED(m_tm->QueryInterface(__uuidof(ITfUIElementMgr), (void **)&puiem)))

  00009	8d 45 fc	 lea	 eax, DWORD PTR _puiem$[ebp]
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea135_19df_11d7_a6d2_00065b84435c
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0001f	ff 10		 call	 DWORD PTR [eax]
  00021	85 c0		 test	 eax, eax
  00023	7c 1d		 jl	 SHORT $LN2@GetUIEleme

; 1968 :     {
; 1969 :         puiem->GetUIElement(dwUIElementId, &pElement);

  00025	8d 45 f8	 lea	 eax, DWORD PTR _pElement$[ebp]
  00028	50		 push	 eax
  00029	ff 75 08	 push	 DWORD PTR _dwUIElementId$[ebp]
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _puiem$[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	ff 75 fc	 push	 DWORD PTR _puiem$[ebp]
  00034	ff 50 18	 call	 DWORD PTR [eax+24]

; 1970 :         puiem->Release();

  00037	8b 45 fc	 mov	 eax, DWORD PTR _puiem$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	ff 75 fc	 push	 DWORD PTR _puiem$[ebp]
  0003f	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@GetUIEleme:

; 1971 :     }
; 1972 : 
; 1973 :     return pElement;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _pElement$[ebp]

; 1974 : }

  00045	c9		 leave
  00046	c3		 ret	 0
?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ENDP ; CTsfUiLessMode::GetUIElement
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z
_TEXT	SEGMENT
tv144 = -52						; size = 4
tv142 = -48						; size = 4
tv139 = -44						; size = 4
_uIndex$ = -40						; size = 4
_bstr$ = -36						; size = 4
_dwPageSize$ = -32					; size = 4
_j$1 = -28						; size = 4
_i$2 = -24						; size = 4
_dwPageStart$ = -20					; size = 4
_uCount$ = -16						; size = 4
_uCurrentPage$ = -12					; size = 4
_uPageCnt$ = -8						; size = 4
_IndexList$ = -4					; size = 4
_pcandidate$ = 8					; size = 4
?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z PROC ; CTsfUiLessMode::MakeCandidateStrings, COMDAT

; 1903 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 1904 : 	UINT uIndex = 0;

  00006	83 65 d8 00	 and	 DWORD PTR _uIndex$[ebp], 0

; 1905 : 	UINT uCount = 0;

  0000a	83 65 f0 00	 and	 DWORD PTR _uCount$[ebp], 0

; 1906 : 	UINT uCurrentPage = 0;

  0000e	83 65 f4 00	 and	 DWORD PTR _uCurrentPage$[ebp], 0

; 1907 : 	UINT *IndexList = NULL;

  00012	83 65 fc 00	 and	 DWORD PTR _IndexList$[ebp], 0

; 1908 : 	UINT uPageCnt = 0;

  00016	83 65 f8 00	 and	 DWORD PTR _uPageCnt$[ebp], 0

; 1909 : 	DWORD dwPageStart = 0;

  0001a	83 65 ec 00	 and	 DWORD PTR _dwPageStart$[ebp], 0

; 1910 : 	DWORD dwPageSize = 0;

  0001e	83 65 e0 00	 and	 DWORD PTR _dwPageSize$[ebp], 0

; 1911 : 	BSTR bstr;
; 1912 : 
; 1913 : 	pcandidate->GetSelection(&uIndex);

  00022	8d 45 d8	 lea	 eax, DWORD PTR _uIndex$[ebp]
  00025	50		 push	 eax
  00026	8b 45 08	 mov	 eax, DWORD PTR _pcandidate$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	ff 75 08	 push	 DWORD PTR _pcandidate$[ebp]
  0002e	ff 50 28	 call	 DWORD PTR [eax+40]

; 1914 : 	pcandidate->GetCount(&uCount);

  00031	8d 45 f0	 lea	 eax, DWORD PTR _uCount$[ebp]
  00034	50		 push	 eax
  00035	8b 45 08	 mov	 eax, DWORD PTR _pcandidate$[ebp]
  00038	8b 00		 mov	 eax, DWORD PTR [eax]
  0003a	ff 75 08	 push	 DWORD PTR _pcandidate$[ebp]
  0003d	ff 50 24	 call	 DWORD PTR [eax+36]

; 1915 : 	pcandidate->GetCurrentPage(&uCurrentPage);

  00040	8d 45 f4	 lea	 eax, DWORD PTR _uCurrentPage$[ebp]
  00043	50		 push	 eax
  00044	8b 45 08	 mov	 eax, DWORD PTR _pcandidate$[ebp]
  00047	8b 00		 mov	 eax, DWORD PTR [eax]
  00049	ff 75 08	 push	 DWORD PTR _pcandidate$[ebp]
  0004c	ff 50 38	 call	 DWORD PTR [eax+56]

; 1916 : 	CIME::ms_dwCandidateSelection = (DWORD)uIndex;

  0004f	8b 45 d8	 mov	 eax, DWORD PTR _uIndex$[ebp]
  00052	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection

; 1917 : 	CIME::ms_dwCandidateCount = (DWORD)uCount;

  00057	8b 45 f0	 mov	 eax, DWORD PTR _uCount$[ebp]
  0005a	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateCount@CIME@@2KA, eax ; CIME::ms_dwCandidateCount

; 1918 : 	CIME::ms_bCandidateList = true;

  0005f	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bCandidateList@CIME@@2_NA, 1 ; CIME::ms_bCandidateList

; 1919 : 
; 1920 : 	pcandidate->GetPageIndex(NULL, 0, &uPageCnt);

  00066	8d 45 f8	 lea	 eax, DWORD PTR _uPageCnt$[ebp]
  00069	50		 push	 eax
  0006a	6a 00		 push	 0
  0006c	6a 00		 push	 0
  0006e	8b 45 08	 mov	 eax, DWORD PTR _pcandidate$[ebp]
  00071	8b 00		 mov	 eax, DWORD PTR [eax]
  00073	ff 75 08	 push	 DWORD PTR _pcandidate$[ebp]
  00076	ff 50 30	 call	 DWORD PTR [eax+48]

; 1921 : 	if(uPageCnt > 0)

  00079	83 7d f8 00	 cmp	 DWORD PTR _uPageCnt$[ebp], 0
  0007d	76 7e		 jbe	 SHORT $LN5@MakeCandid

; 1922 : 	{
; 1923 : 		IndexList = (UINT *) malloc(sizeof(UINT)*uPageCnt);

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _uPageCnt$[ebp]
  00082	c1 e0 02	 shl	 eax, 2
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 _malloc
  0008b	59		 pop	 ecx
  0008c	89 45 fc	 mov	 DWORD PTR _IndexList$[ebp], eax

; 1924 : 		if(IndexList)

  0008f	83 7d fc 00	 cmp	 DWORD PTR _IndexList$[ebp], 0
  00093	74 68		 je	 SHORT $LN5@MakeCandid

; 1925 : 		{
; 1926 : 			pcandidate->GetPageIndex(IndexList, uPageCnt, &uPageCnt);

  00095	8d 45 f8	 lea	 eax, DWORD PTR _uPageCnt$[ebp]
  00098	50		 push	 eax
  00099	ff 75 f8	 push	 DWORD PTR _uPageCnt$[ebp]
  0009c	ff 75 fc	 push	 DWORD PTR _IndexList$[ebp]
  0009f	8b 45 08	 mov	 eax, DWORD PTR _pcandidate$[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	ff 75 08	 push	 DWORD PTR _pcandidate$[ebp]
  000a7	ff 50 30	 call	 DWORD PTR [eax+48]

; 1927 : 			dwPageStart = IndexList[uCurrentPage];

  000aa	8b 45 f4	 mov	 eax, DWORD PTR _uCurrentPage$[ebp]
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _IndexList$[ebp]
  000b0	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000b3	89 45 ec	 mov	 DWORD PTR _dwPageStart$[ebp], eax

; 1928 : 			dwPageSize = (uCurrentPage < uPageCnt-1) ? 

  000b6	8b 45 f8	 mov	 eax, DWORD PTR _uPageCnt$[ebp]
  000b9	48		 dec	 eax
  000ba	39 45 f4	 cmp	 DWORD PTR _uCurrentPage$[ebp], eax
  000bd	73 2f		 jae	 SHORT $LN14@MakeCandid
  000bf	8b 45 f4	 mov	 eax, DWORD PTR _uCurrentPage$[ebp]
  000c2	8b 4d fc	 mov	 ecx, DWORD PTR _IndexList$[ebp]
  000c5	8b 55 f0	 mov	 edx, DWORD PTR _uCount$[ebp]
  000c8	3b 54 81 04	 cmp	 edx, DWORD PTR [ecx+eax*4+4]
  000cc	73 08		 jae	 SHORT $LN12@MakeCandid
  000ce	8b 45 f0	 mov	 eax, DWORD PTR _uCount$[ebp]
  000d1	89 45 d4	 mov	 DWORD PTR tv139[ebp], eax
  000d4	eb 0d		 jmp	 SHORT $LN13@MakeCandid
$LN12@MakeCandid:
  000d6	8b 45 f4	 mov	 eax, DWORD PTR _uCurrentPage$[ebp]
  000d9	8b 4d fc	 mov	 ecx, DWORD PTR _IndexList$[ebp]
  000dc	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  000e0	89 45 d4	 mov	 DWORD PTR tv139[ebp], eax
$LN13@MakeCandid:
  000e3	8b 45 d4	 mov	 eax, DWORD PTR tv139[ebp]
  000e6	2b 45 ec	 sub	 eax, DWORD PTR _dwPageStart$[ebp]
  000e9	89 45 d0	 mov	 DWORD PTR tv142[ebp], eax
  000ec	eb 09		 jmp	 SHORT $LN15@MakeCandid
$LN14@MakeCandid:
  000ee	8b 45 f0	 mov	 eax, DWORD PTR _uCount$[ebp]
  000f1	2b 45 ec	 sub	 eax, DWORD PTR _dwPageStart$[ebp]
  000f4	89 45 d0	 mov	 DWORD PTR tv142[ebp], eax
$LN15@MakeCandid:
  000f7	8b 45 d0	 mov	 eax, DWORD PTR tv142[ebp]
  000fa	89 45 e0	 mov	 DWORD PTR _dwPageSize$[ebp], eax
$LN5@MakeCandid:

; 1929 : 				min(uCount, IndexList[uCurrentPage+1]) - dwPageStart:
; 1930 : 				uCount - dwPageStart;
; 1931 : 		}
; 1932 : 	}
; 1933 : 
; 1934 : 	CIME::ms_dwCandidatePageSize = min(dwPageSize, CIME::MAX_CANDLIST);

  000fd	83 7d e0 0a	 cmp	 DWORD PTR _dwPageSize$[ebp], 10 ; 0000000aH
  00101	73 08		 jae	 SHORT $LN16@MakeCandid
  00103	8b 45 e0	 mov	 eax, DWORD PTR _dwPageSize$[ebp]
  00106	89 45 cc	 mov	 DWORD PTR tv144[ebp], eax
  00109	eb 07		 jmp	 SHORT $LN17@MakeCandid
$LN16@MakeCandid:
  0010b	c7 45 cc 0a 00
	00 00		 mov	 DWORD PTR tv144[ebp], 10 ; 0000000aH
$LN17@MakeCandid:
  00112	8b 45 cc	 mov	 eax, DWORD PTR tv144[ebp]
  00115	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA, eax ; CIME::ms_dwCandidatePageSize

; 1935 : 	CIME::ms_dwCandidateSelection = CIME::ms_dwCandidateSelection - dwPageStart;

  0011a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection
  0011f	2b 45 ec	 sub	 eax, DWORD PTR _dwPageStart$[ebp]
  00122	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection

; 1936 : 
; 1937 : 	memset(&CIME::ms_wszCandidate, 0, sizeof(CIME::ms_wszCandidate));

  00127	68 00 14 00 00	 push	 5120			; 00001400H
  0012c	6a 00		 push	 0
  0012e	68 00 00 00 00	 push	 OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  00133	e8 00 00 00 00	 call	 _memset
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1938 : 	for (UINT i = dwPageStart, j = 0; (DWORD)i < CIME::ms_dwCandidateCount && j < CIME::ms_dwCandidatePageSize; i++, j++)

  0013b	8b 45 ec	 mov	 eax, DWORD PTR _dwPageStart$[ebp]
  0013e	89 45 e8	 mov	 DWORD PTR _i$2[ebp], eax
  00141	83 65 e4 00	 and	 DWORD PTR _j$1[ebp], 0
  00145	eb 0e		 jmp	 SHORT $LN4@MakeCandid
$LN2@MakeCandid:
  00147	8b 45 e8	 mov	 eax, DWORD PTR _i$2[ebp]
  0014a	40		 inc	 eax
  0014b	89 45 e8	 mov	 DWORD PTR _i$2[ebp], eax
  0014e	8b 45 e4	 mov	 eax, DWORD PTR _j$1[ebp]
  00151	40		 inc	 eax
  00152	89 45 e4	 mov	 DWORD PTR _j$1[ebp], eax
$LN4@MakeCandid:
  00155	8b 45 e8	 mov	 eax, DWORD PTR _i$2[ebp]
  00158	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_dwCandidateCount@CIME@@2KA ; CIME::ms_dwCandidateCount
  0015e	73 48		 jae	 SHORT $LN3@MakeCandid
  00160	8b 45 e4	 mov	 eax, DWORD PTR _j$1[ebp]
  00163	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA ; CIME::ms_dwCandidatePageSize
  00169	73 3d		 jae	 SHORT $LN3@MakeCandid

; 1939 : 	{
; 1940 : 		if (SUCCEEDED(pcandidate->GetString( i, &bstr )))

  0016b	8d 45 dc	 lea	 eax, DWORD PTR _bstr$[ebp]
  0016e	50		 push	 eax
  0016f	ff 75 e8	 push	 DWORD PTR _i$2[ebp]
  00172	8b 45 08	 mov	 eax, DWORD PTR _pcandidate$[ebp]
  00175	8b 00		 mov	 eax, DWORD PTR [eax]
  00177	ff 75 08	 push	 DWORD PTR _pcandidate$[ebp]
  0017a	ff 50 2c	 call	 DWORD PTR [eax+44]
  0017d	85 c0		 test	 eax, eax
  0017f	7c 25		 jl	 SHORT $LN7@MakeCandid

; 1941 : 		{
; 1942 : 			if(bstr)

  00181	83 7d dc 00	 cmp	 DWORD PTR _bstr$[ebp], 0
  00185	74 1f		 je	 SHORT $LN7@MakeCandid

; 1943 : 			{
; 1944 : 				wcscpy( CIME::ms_wszCandidate[j], bstr );

  00187	ff 75 dc	 push	 DWORD PTR _bstr$[ebp]
  0018a	8b 45 e4	 mov	 eax, DWORD PTR _j$1[ebp]
  0018d	c1 e0 09	 shl	 eax, 9
  00190	05 00 00 00 00	 add	 eax, OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 _wcscpy
  0019b	59		 pop	 ecx
  0019c	59		 pop	 ecx

; 1945 : 				SysFreeString(bstr);

  0019d	ff 75 dc	 push	 DWORD PTR _bstr$[ebp]
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN7@MakeCandid:

; 1946 : 			}
; 1947 : 		}
; 1948 : 	}

  001a6	eb 9f		 jmp	 SHORT $LN2@MakeCandid
$LN3@MakeCandid:

; 1949 : 	//OutputDebugStringW( L"\n" );
; 1950 : 
; 1951 : 	if (GETPRIMLANG() == LANG_KOREAN)

  001a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  001ad	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001b2	0f b7 c0	 movzx	 eax, ax
  001b5	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  001ba	0f b7 c0	 movzx	 eax, ax
  001bd	83 f8 12	 cmp	 eax, 18			; 00000012H
  001c0	75 07		 jne	 SHORT $LN9@MakeCandid

; 1952 : 	{
; 1953 : 		CIME::ms_dwCandidateSelection = (DWORD)-1;

  001c2	83 0d 00 00 00
	00 ff		 or	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, -1 ; CIME::ms_dwCandidateSelection
$LN9@MakeCandid:

; 1954 : 	}
; 1955 : 
; 1956 : 	if(IndexList)

  001c9	83 7d fc 00	 cmp	 DWORD PTR _IndexList$[ebp], 0
  001cd	74 09		 je	 SHORT $LN1@MakeCandid

; 1957 : 	{
; 1958 : 		free(IndexList);

  001cf	ff 75 fc	 push	 DWORD PTR _IndexList$[ebp]
  001d2	e8 00 00 00 00	 call	 _free
  001d7	59		 pop	 ecx
$LN1@MakeCandid:

; 1959 : 	}
; 1960 : }

  001d8	c9		 leave
  001d9	c3		 ret	 0
?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z ENDP ; CTsfUiLessMode::MakeCandidateStrings
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z
_TEXT	SEGMENT
$T1 = -72						; size = 1
_dwFlags$ = -68						; size = 4
__My_data$2 = -64					; size = 4
__First$ = -60						; size = 4
$T3 = -56						; size = 4
__Last$ = -52						; size = 4
_size$4 = -48						; size = 4
_pszNextSrc$5 = -44					; size = 4
_cchMax$ = -40						; size = 4
tv137 = -36						; size = 4
_fVertical$ = -32					; size = 4
tv83 = -28						; size = 4
_uErrorIndex$ = -24					; size = 4
_pszDest$6 = -20					; size = 4
_i$7 = -16						; size = 4
_bstr$ = -12						; size = 4
_pszSource$8 = -8					; size = 4
$T9 = -1						; size = 1
_preading$ = 8						; size = 4
?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z PROC ; CTsfUiLessMode::MakeReadingInformationString, COMDAT

; 1851 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H

; 1852 : 	UINT cchMax;
; 1853 : 	UINT uErrorIndex = 0;

  00006	83 65 e8 00	 and	 DWORD PTR _uErrorIndex$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  0000a	8d 45 ff	 lea	 eax, DWORD PTR $T9[ebp]
  0000d	50		 push	 eax
  0000e	6a 00		 push	 0
  00010	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  00015	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1858 : 	preading->GetUpdatedFlags(&dwFlags);

  0001a	8d 45 bc	 lea	 eax, DWORD PTR _dwFlags$[ebp]
  0001d	50		 push	 eax
  0001e	8b 45 08	 mov	 eax, DWORD PTR _preading$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	ff 75 08	 push	 DWORD PTR _preading$[ebp]
  00026	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1859 : 	preading->GetMaxReadingStringLength(&cchMax);

  00029	8d 45 d8	 lea	 eax, DWORD PTR _cchMax$[ebp]
  0002c	50		 push	 eax
  0002d	8b 45 08	 mov	 eax, DWORD PTR _preading$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	ff 75 08	 push	 DWORD PTR _preading$[ebp]
  00035	ff 50 28	 call	 DWORD PTR [eax+40]

; 1860 : 	preading->GetErrorIndex(&uErrorIndex);	// errorIndex is zero-based

  00038	8d 45 e8	 lea	 eax, DWORD PTR _uErrorIndex$[ebp]
  0003b	50		 push	 eax
  0003c	8b 45 08	 mov	 eax, DWORD PTR _preading$[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	ff 75 08	 push	 DWORD PTR _preading$[ebp]
  00044	ff 50 2c	 call	 DWORD PTR [eax+44]

; 1861 : 	preading->IsVerticalOrderPreferred(&fVertical);

  00047	8d 45 e0	 lea	 eax, DWORD PTR _fVertical$[ebp]
  0004a	50		 push	 eax
  0004b	8b 45 08	 mov	 eax, DWORD PTR _preading$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]
  00050	ff 75 08	 push	 DWORD PTR _preading$[ebp]
  00053	ff 50 30	 call	 DWORD PTR [eax+48]

; 1862 : 	CIME::ms_iReadingError = (int)uErrorIndex;

  00056	8b 45 e8	 mov	 eax, DWORD PTR _uErrorIndex$[ebp]
  00059	a3 00 00 00 00	 mov	 DWORD PTR ?ms_iReadingError@CIME@@2HA, eax ; CIME::ms_iReadingError

; 1863 : 	CIME::ms_bHorizontalReading = !fVertical;

  0005e	83 7d e0 00	 cmp	 DWORD PTR _fVertical$[ebp], 0
  00062	75 09		 jne	 SHORT $LN10@MakeReadin
  00064	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
  0006b	eb 04		 jmp	 SHORT $LN11@MakeReadin
$LN10@MakeReadin:
  0006d	83 65 e4 00	 and	 DWORD PTR tv83[ebp], 0
$LN11@MakeReadin:
  00071	8a 45 e4	 mov	 al, BYTE PTR tv83[ebp]
  00074	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bHorizontalReading@CIME@@2_NA, al ; CIME::ms_bHorizontalReading

; 1864 : 	CIME::ms_bReadingInformation = true;

  00079	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bReadingInformation@CIME@@2_NA, 1 ; CIME::ms_bReadingInformation

; 1865 : 	BSTR bstr;
; 1866 : 	if (SUCCEEDED(preading->GetString(&bstr)))

  00080	8d 45 f4	 lea	 eax, DWORD PTR _bstr$[ebp]
  00083	50		 push	 eax
  00084	8b 45 08	 mov	 eax, DWORD PTR _preading$[ebp]
  00087	8b 00		 mov	 eax, DWORD PTR [eax]
  00089	ff 75 08	 push	 DWORD PTR _preading$[ebp]
  0008c	ff 50 24	 call	 DWORD PTR [eax+36]
  0008f	85 c0		 test	 eax, eax
  00091	0f 8c 02 01 00
	00		 jl	 $LN1@MakeReadin

; 1867 : 	{
; 1868 : 		if (bstr)

  00097	83 7d f4 00	 cmp	 DWORD PTR _bstr$[ebp], 0
  0009b	0f 84 f8 00 00
	00		 je	 $LN1@MakeReadin

; 1869 : 		{
; 1870 : 			CIME::ms_wstrReading.assign( (wchar_t *) bstr, (wchar_t *) bstr+lstrlenW(bstr) );

  000a1	ff 75 f4	 push	 DWORD PTR _bstr$[ebp]
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  000aa	8b 4d f4	 mov	 ecx, DWORD PTR _bstr$[ebp]
  000ad	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000b0	89 45 cc	 mov	 DWORD PTR __Last$[ebp], eax
  000b3	8b 45 f4	 mov	 eax, DWORD PTR _bstr$[ebp]
  000b6	89 45 c4	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1303 :         return _It + 0;

  000b9	8b 45 cc	 mov	 eax, DWORD PTR __Last$[ebp]
  000bc	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1142 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

  000bf	ff 75 b8	 push	 DWORD PTR $T1[ebp]
  000c2	ff 75 c8	 push	 DWORD PTR $T3[ebp]
  000c5	ff 75 c4	 push	 DWORD PTR __First$[ebp]
  000c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  000cd	e8 00 00 00 00	 call	 ??$_Assign_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_range<wchar_t *>

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000d2	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR __My_data$2[ebp], OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  000d9	33 c0		 xor	 eax, eax
  000db	d1 e0		 shl	 eax, 1
  000dd	8b 4d c0	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  000e0	03 01		 add	 eax, DWORD PTR [ecx]
  000e2	89 45 f8	 mov	 DWORD PTR _pszSource$8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1872 : 			if ( fVertical )

  000e5	83 7d e0 00	 cmp	 DWORD PTR _fVertical$[ebp], 0
  000e9	0f 84 a1 00 00
	00		 je	 $LN7@MakeReadin

; 1873 : 			{
; 1874 : 				CIME::ms_dwCandidatePageSize = CIME::MAX_CANDLIST;

  000ef	c7 05 00 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA, 10 ; CIME::ms_dwCandidatePageSize, 0000000aH

; 1875 : 				// ms_iReadingError is used only in horizontal window, and has to be -1 if there's no error.
; 1876 : 				CIME::ms_dwCandidateSelection = CIME::ms_iReadingError ? CIME::ms_iReadingError - 1 : (DWORD)-1;

  000f9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_iReadingError@CIME@@2HA, 0 ; CIME::ms_iReadingError
  00100	74 0b		 je	 SHORT $LN12@MakeReadin
  00102	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_iReadingError@CIME@@2HA ; CIME::ms_iReadingError
  00107	48		 dec	 eax
  00108	89 45 dc	 mov	 DWORD PTR tv137[ebp], eax
  0010b	eb 04		 jmp	 SHORT $LN13@MakeReadin
$LN12@MakeReadin:
  0010d	83 4d dc ff	 or	 DWORD PTR tv137[ebp], -1
$LN13@MakeReadin:
  00111	8b 45 dc	 mov	 eax, DWORD PTR tv137[ebp]
  00114	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection

; 1877 : 				CIME::ms_dwCandidateCount = cchMax;

  00119	8b 45 d8	 mov	 eax, DWORD PTR _cchMax$[ebp]
  0011c	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateCount@CIME@@2KA, eax ; CIME::ms_dwCandidateCount

; 1878 : 				// for vertical reading window, copy each character to g_szCandidate array.
; 1879 : 				for ( UINT i = 0; i < cchMax; i++ )

  00121	83 65 f0 00	 and	 DWORD PTR _i$7[ebp], 0
  00125	eb 07		 jmp	 SHORT $LN4@MakeReadin
$LN2@MakeReadin:
  00127	8b 45 f0	 mov	 eax, DWORD PTR _i$7[ebp]
  0012a	40		 inc	 eax
  0012b	89 45 f0	 mov	 DWORD PTR _i$7[ebp], eax
$LN4@MakeReadin:
  0012e	8b 45 f0	 mov	 eax, DWORD PTR _i$7[ebp]
  00131	3b 45 d8	 cmp	 eax, DWORD PTR _cchMax$[ebp]
  00134	73 5a		 jae	 SHORT $LN7@MakeReadin

; 1880 : 				{
; 1881 : 					LPWSTR pszDest = CIME::ms_wszCandidate[i];

  00136	8b 45 f0	 mov	 eax, DWORD PTR _i$7[ebp]
  00139	c1 e0 09	 shl	 eax, 9
  0013c	05 00 00 00 00	 add	 eax, OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  00141	89 45 ec	 mov	 DWORD PTR _pszDest$6[ebp], eax

; 1882 : 					if ( *pszSource )

  00144	8b 45 f8	 mov	 eax, DWORD PTR _pszSource$8[ebp]
  00147	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0014a	85 c0		 test	 eax, eax
  0014c	74 38		 je	 SHORT $LN8@MakeReadin

; 1883 : 					{
; 1884 : 						LPWSTR pszNextSrc = CharNextW(pszSource);

  0014e	ff 75 f8	 push	 DWORD PTR _pszSource$8[ebp]
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  00157	89 45 d4	 mov	 DWORD PTR _pszNextSrc$5[ebp], eax

; 1885 : 						SIZE_T size = (LPSTR)pszNextSrc - (LPSTR)pszSource;

  0015a	8b 45 d4	 mov	 eax, DWORD PTR _pszNextSrc$5[ebp]
  0015d	2b 45 f8	 sub	 eax, DWORD PTR _pszSource$8[ebp]
  00160	89 45 d0	 mov	 DWORD PTR _size$4[ebp], eax

; 1886 : 						CopyMemory( pszDest, pszSource, size );

  00163	ff 75 d0	 push	 DWORD PTR _size$4[ebp]
  00166	ff 75 f8	 push	 DWORD PTR _pszSource$8[ebp]
  00169	ff 75 ec	 push	 DWORD PTR _pszDest$6[ebp]
  0016c	e8 00 00 00 00	 call	 _memcpy
  00171	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1887 : 						pszSource = pszNextSrc;

  00174	8b 45 d4	 mov	 eax, DWORD PTR _pszNextSrc$5[ebp]
  00177	89 45 f8	 mov	 DWORD PTR _pszSource$8[ebp], eax

; 1888 : 						pszDest += size;

  0017a	8b 45 d0	 mov	 eax, DWORD PTR _size$4[ebp]
  0017d	8b 4d ec	 mov	 ecx, DWORD PTR _pszDest$6[ebp]
  00180	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00183	89 45 ec	 mov	 DWORD PTR _pszDest$6[ebp], eax
$LN8@MakeReadin:

; 1889 : 					}
; 1890 : 					*pszDest = 0;

  00186	33 c0		 xor	 eax, eax
  00188	8b 4d ec	 mov	 ecx, DWORD PTR _pszDest$6[ebp]
  0018b	66 89 01	 mov	 WORD PTR [ecx], ax

; 1891 : 				}

  0018e	eb 97		 jmp	 SHORT $LN2@MakeReadin
$LN7@MakeReadin:

; 1892 : 			}
; 1893 : 			//else
; 1894 : 			//{
; 1895 : 			//	CIME::ms_wszCandidate[0][0] = L' ';	// hack to make rendering happen
; 1896 : 			//}
; 1897 : 			SysFreeString(bstr);

  00190	ff 75 f4	 push	 DWORD PTR _bstr$[ebp]
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN1@MakeReadin:

; 1898 : 		}
; 1899 : 	}
; 1900 : }

  00199	c9		 leave
  0019a	c3		 ret	 0
?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z ENDP ; CTsfUiLessMode::MakeReadingInformationString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_rguid$ = 12						; size = 4
?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z PROC ; CTsfUiLessMode::CUIElementSink::OnChange, COMDAT

; 1845 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1846 : 	UpdateImeState();

  00003	6a 00		 push	 0
  00005	e8 00 00 00 00	 call	 ?UpdateImeState@CTsfUiLessMode@@SAXH@Z ; CTsfUiLessMode::UpdateImeState
  0000a	59		 pop	 ecx

; 1847 :     return S_OK;

  0000b	33 c0		 xor	 eax, eax

; 1848 : }

  0000d	5d		 pop	 ebp
  0000e	c2 08 00	 ret	 8
?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z ENDP ; CTsfUiLessMode::CUIElementSink::OnChange
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z
_TEXT	SEGMENT
tv79 = -16						; size = 4
tv93 = -12						; size = 4
tv68 = -8						; size = 4
tv89 = -4						; size = 4
_this$ = 8						; size = 4
_dwProfileType$ = 12					; size = 4
_langid$ = 16						; size = 2
_clsid$ = 20						; size = 4
_catid$ = 24						; size = 4
_guidProfile$ = 28					; size = 4
_hkl$ = 32						; size = 4
_dwFlags$ = 36						; size = 4
?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z PROC ; CTsfUiLessMode::CUIElementSink::OnActivated, COMDAT

; 1827 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00006	6a 10		 push	 16			; 00000010H
  00008	ff 75 1c	 push	 DWORD PTR _guidProfile$[ebp]
  0000b	68 00 00 00 00	 push	 OFFSET ?TF_PROFILE_DAYI@?1??OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z@4U4@A
  00010	e8 00 00 00 00	 call	 _memcmp
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	85 c0		 test	 eax, eax
  0001a	75 09		 jne	 SHORT $LN12@OnActivate
  0001c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv89[ebp], 1
  00023	eb 04		 jmp	 SHORT $LN10@OnActivate
$LN12@OnActivate:
  00025	83 65 fc 00	 and	 DWORD PTR tv89[ebp], 0
$LN10@OnActivate:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1829 : 	CIME::ms_iCandListIndexBase = IsEqualGUID( TF_PROFILE_DAYI, guidProfile ) ? 0 : 1;   

  00029	83 7d fc 00	 cmp	 DWORD PTR tv89[ebp], 0
  0002d	74 06		 je	 SHORT $LN6@OnActivate
  0002f	83 65 f8 00	 and	 DWORD PTR tv68[ebp], 0
  00033	eb 07		 jmp	 SHORT $LN7@OnActivate
$LN6@OnActivate:
  00035	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
$LN7@OnActivate:
  0003c	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]
  0003f	a3 00 00 00 00	 mov	 DWORD PTR ?ms_iCandListIndexBase@CIME@@2HA, eax ; CIME::ms_iCandListIndexBase
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00044	6a 10		 push	 16			; 00000010H
  00046	68 00 00 00 00	 push	 OFFSET _GUID_TFCAT_TIP_KEYBOARD
  0004b	ff 75 18	 push	 DWORD PTR _catid$[ebp]
  0004e	e8 00 00 00 00	 call	 _memcmp
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	85 c0		 test	 eax, eax
  00058	75 09		 jne	 SHORT $LN16@OnActivate
  0005a	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv93[ebp], 1
  00061	eb 04		 jmp	 SHORT $LN14@OnActivate
$LN16@OnActivate:
  00063	83 65 f4 00	 and	 DWORD PTR tv93[ebp], 0
$LN14@OnActivate:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1830 : 	if ( IsEqualIID( catid, GUID_TFCAT_TIP_KEYBOARD ) && ( dwFlags & TF_IPSINK_FLAG_ACTIVE ) )

  00067	83 7d f4 00	 cmp	 DWORD PTR tv93[ebp], 0
  0006b	74 4e		 je	 SHORT $LN2@OnActivate
  0006d	8b 45 24	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00070	83 e0 01	 and	 eax, 1
  00073	74 46		 je	 SHORT $LN2@OnActivate

; 1831 : 	{
; 1832 : 		CIME::ms_bChineseIME = ( dwProfileType & TF_PROFILETYPE_INPUTPROCESSOR ) && langid == LANG_CHT;

  00075	8b 45 0c	 mov	 eax, DWORD PTR _dwProfileType$[ebp]
  00078	83 e0 01	 and	 eax, 1
  0007b	74 14		 je	 SHORT $LN8@OnActivate
  0007d	0f b7 45 10	 movzx	 eax, WORD PTR _langid$[ebp]
  00081	3d 04 04 00 00	 cmp	 eax, 1028		; 00000404H
  00086	75 09		 jne	 SHORT $LN8@OnActivate
  00088	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  0008f	eb 04		 jmp	 SHORT $LN9@OnActivate
$LN8@OnActivate:
  00091	83 65 f0 00	 and	 DWORD PTR tv79[ebp], 0
$LN9@OnActivate:
  00095	8a 45 f0	 mov	 al, BYTE PTR tv79[ebp]
  00098	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, al ; CIME::ms_bChineseIME

; 1833 : 		if ( dwProfileType & TF_PROFILETYPE_INPUTPROCESSOR )

  0009d	8b 45 0c	 mov	 eax, DWORD PTR _dwProfileType$[ebp]
  000a0	83 e0 01	 and	 eax, 1
  000a3	74 0a		 je	 SHORT $LN3@OnActivate

; 1834 : 		{
; 1835 : 			UpdateImeState(TRUE);

  000a5	6a 01		 push	 1
  000a7	e8 00 00 00 00	 call	 ?UpdateImeState@CTsfUiLessMode@@SAXH@Z ; CTsfUiLessMode::UpdateImeState
  000ac	59		 pop	 ecx

; 1836 : 		}

  000ad	eb 07		 jmp	 SHORT $LN4@OnActivate
$LN3@OnActivate:

; 1837 : 		else
; 1838 : 			CIME::ms_dwImeState = IMEUI_STATE_OFF;

  000af	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_dwImeState@CIME@@2KA, 0 ; CIME::ms_dwImeState
$LN4@OnActivate:

; 1839 : 		CIME::ChangeInputLanguage();

  000b6	e8 00 00 00 00	 call	 ?ChangeInputLanguage@CIME@@SAXXZ ; CIME::ChangeInputLanguage
$LN2@OnActivate:

; 1840 : 	}
; 1841 :     return S_OK;

  000bb	33 c0		 xor	 eax, eax

; 1842 : }

  000bd	c9		 leave
  000be	c2 20 00	 ret	 32			; 00000020H
?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z ENDP ; CTsfUiLessMode::CUIElementSink::OnActivated
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z
_TEXT	SEGMENT
_pcandidate$ = -12					; size = 4
_preading$ = -8						; size = 4
_pElement$ = -4						; size = 4
_this$ = 8						; size = 4
_dwUIElementId$ = 12					; size = 4
?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z PROC ; CTsfUiLessMode::CUIElementSink::EndUIElement, COMDAT

; 1759 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1760 :     ITfUIElement *pElement = GetUIElement(dwUIElementId);

  00006	ff 75 0c	 push	 DWORD PTR _dwUIElementId$[ebp]
  00009	e8 00 00 00 00	 call	 ?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ; CTsfUiLessMode::GetUIElement
  0000e	59		 pop	 ecx
  0000f	89 45 fc	 mov	 DWORD PTR _pElement$[ebp], eax

; 1761 :     if (!pElement)

  00012	83 7d fc 00	 cmp	 DWORD PTR _pElement$[ebp], 0
  00016	75 07		 jne	 SHORT $LN2@EndUIEleme

; 1762 :         return E_INVALIDARG;

  00018	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001d	eb 70		 jmp	 SHORT $LN1@EndUIEleme
$LN2@EndUIEleme:

; 1763 : 
; 1764 : 	//BSTR bstrDesc;
; 1765 : 	//OutputDebugStringW(L"ENDUI: ");
; 1766 : 	//pElement->GetDescription(&bstrDesc);
; 1767 : 	//OutputDebugStringW(bstrDesc);
; 1768 : 	//OutputDebugStringW(L"\n");
; 1769 : 
; 1770 : 	ITfReadingInformationUIElement   *preading = NULL;

  0001f	83 65 f8 00	 and	 DWORD PTR _preading$[ebp], 0

; 1771 : 	if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfReadingInformationUIElement), (void **)&preading)))

  00023	8d 45 f8	 lea	 eax, DWORD PTR _preading$[ebp]
  00026	50		 push	 eax
  00027	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _pElement$[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	ff 75 fc	 push	 DWORD PTR _pElement$[ebp]
  00034	ff 10		 call	 DWORD PTR [eax]
  00036	85 c0		 test	 eax, eax
  00038	7c 10		 jl	 SHORT $LN3@EndUIEleme

; 1772 :     {
; 1773 : 		CIME::CloseReadingInformation();

  0003a	e8 00 00 00 00	 call	 ?CloseReadingInformation@CIME@@SAXXZ ; CIME::CloseReadingInformation

; 1774 :         preading->Release();

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _preading$[ebp]
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	ff 75 f8	 push	 DWORD PTR _preading$[ebp]
  00047	ff 50 08	 call	 DWORD PTR [eax+8]
$LN3@EndUIEleme:

; 1775 :     }
; 1776 : 
; 1777 : 	ITfCandidateListUIElement   *pcandidate = NULL;

  0004a	83 65 f4 00	 and	 DWORD PTR _pcandidate$[ebp], 0

; 1778 : 	if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfCandidateListUIElement), (void **)&pcandidate)))

  0004e	8d 45 f4	 lea	 eax, DWORD PTR _pcandidate$[ebp]
  00051	50		 push	 eax
  00052	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
  00057	8b 45 fc	 mov	 eax, DWORD PTR _pElement$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	ff 75 fc	 push	 DWORD PTR _pElement$[ebp]
  0005f	ff 10		 call	 DWORD PTR [eax]
  00061	85 c0		 test	 eax, eax
  00063	7c 1d		 jl	 SHORT $LN4@EndUIEleme

; 1779 : 	{
; 1780 : 		m_nCandidateRefCount--;

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nCandidateRefCount@CTsfUiLessMode@@1HA ; CTsfUiLessMode::m_nCandidateRefCount
  0006a	48		 dec	 eax
  0006b	a3 00 00 00 00	 mov	 DWORD PTR ?m_nCandidateRefCount@CTsfUiLessMode@@1HA, eax ; CTsfUiLessMode::m_nCandidateRefCount

; 1781 : 		if (m_nCandidateRefCount == 0)

  00070	75 05		 jne	 SHORT $LN5@EndUIEleme

; 1782 : 			CIME::CloseCandidateList();

  00072	e8 00 00 00 00	 call	 ?CloseCandidateList@CIME@@SAXXZ ; CIME::CloseCandidateList
$LN5@EndUIEleme:

; 1783 : 		pcandidate->Release();

  00077	8b 45 f4	 mov	 eax, DWORD PTR _pcandidate$[ebp]
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	ff 75 f4	 push	 DWORD PTR _pcandidate$[ebp]
  0007f	ff 50 08	 call	 DWORD PTR [eax+8]
$LN4@EndUIEleme:

; 1784 : 	}
; 1785 : 
; 1786 :     pElement->Release();

  00082	8b 45 fc	 mov	 eax, DWORD PTR _pElement$[ebp]
  00085	8b 00		 mov	 eax, DWORD PTR [eax]
  00087	ff 75 fc	 push	 DWORD PTR _pElement$[ebp]
  0008a	ff 50 08	 call	 DWORD PTR [eax+8]

; 1787 :     return S_OK;

  0008d	33 c0		 xor	 eax, eax
$LN1@EndUIEleme:

; 1788 : }

  0008f	c9		 leave
  00090	c2 08 00	 ret	 8
?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z ENDP ; CTsfUiLessMode::CUIElementSink::EndUIElement
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z
_TEXT	SEGMENT
_pcandidate$ = -12					; size = 4
_preading$ = -8						; size = 4
_pElement$ = -4						; size = 4
_this$ = 8						; size = 4
_dwUIElementId$ = 12					; size = 4
?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z PROC ; CTsfUiLessMode::CUIElementSink::UpdateUIElement, COMDAT

; 1725 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1726 :     ITfUIElement *pElement = GetUIElement(dwUIElementId);

  00006	ff 75 0c	 push	 DWORD PTR _dwUIElementId$[ebp]
  00009	e8 00 00 00 00	 call	 ?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ; CTsfUiLessMode::GetUIElement
  0000e	59		 pop	 ecx
  0000f	89 45 fc	 mov	 DWORD PTR _pElement$[ebp], eax

; 1727 :     if (!pElement)

  00012	83 7d fc 00	 cmp	 DWORD PTR _pElement$[ebp], 0
  00016	75 0a		 jne	 SHORT $LN2@UpdateUIEl

; 1728 :         return E_INVALIDARG;

  00018	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001d	e9 9f 00 00 00	 jmp	 $LN1@UpdateUIEl
$LN2@UpdateUIEl:

; 1729 : 
; 1730 :     ITfReadingInformationUIElement   *preading = NULL;

  00022	83 65 f8 00	 and	 DWORD PTR _preading$[ebp], 0

; 1731 :     ITfCandidateListUIElement		*pcandidate = NULL;

  00026	83 65 f4 00	 and	 DWORD PTR _pcandidate$[ebp], 0

; 1732 : 
; 1733 : 	//BSTR bstrDesc;
; 1734 : 	//pElement->GetDescription(&bstrDesc);
; 1735 : 	//OutputDebugStringW(L"UPDATEUI: ");
; 1736 : 	//OutputDebugStringW(bstrDesc);
; 1737 : 	//OutputDebugStringW(L"\n");
; 1738 : 
; 1739 : 	if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfReadingInformationUIElement), (void **)&preading)))

  0002a	8d 45 f8	 lea	 eax, DWORD PTR _preading$[ebp]
  0002d	50		 push	 eax
  0002e	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
  00033	8b 45 fc	 mov	 eax, DWORD PTR _pElement$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	ff 75 fc	 push	 DWORD PTR _pElement$[ebp]
  0003b	ff 10		 call	 DWORD PTR [eax]
  0003d	85 c0		 test	 eax, eax
  0003f	7c 2f		 jl	 SHORT $LN3@UpdateUIEl

; 1740 :     {
; 1741 : 		MakeReadingInformationString(preading);

  00041	ff 75 f8	 push	 DWORD PTR _preading$[ebp]
  00044	e8 00 00 00 00	 call	 ?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z ; CTsfUiLessMode::MakeReadingInformationString
  00049	59		 pop	 ecx

; 1742 : 		if(CIME::ms_pEvent)

  0004a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  00051	74 10		 je	 SHORT $LN5@UpdateUIEl

; 1743 : 			CIME::ms_pEvent->OnOpenReadingWnd();

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00060	ff 50 14	 call	 DWORD PTR [eax+20]
$LN5@UpdateUIEl:

; 1744 :         preading->Release();

  00063	8b 45 f8	 mov	 eax, DWORD PTR _preading$[ebp]
  00066	8b 00		 mov	 eax, DWORD PTR [eax]
  00068	ff 75 f8	 push	 DWORD PTR _preading$[ebp]
  0006b	ff 50 08	 call	 DWORD PTR [eax+8]

; 1745 :     }

  0006e	eb 44		 jmp	 SHORT $LN4@UpdateUIEl
$LN3@UpdateUIEl:

; 1746 : 	else if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfCandidateListUIElement), (void **)&pcandidate)))

  00070	8d 45 f4	 lea	 eax, DWORD PTR _pcandidate$[ebp]
  00073	50		 push	 eax
  00074	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
  00079	8b 45 fc	 mov	 eax, DWORD PTR _pElement$[ebp]
  0007c	8b 00		 mov	 eax, DWORD PTR [eax]
  0007e	ff 75 fc	 push	 DWORD PTR _pElement$[ebp]
  00081	ff 10		 call	 DWORD PTR [eax]
  00083	85 c0		 test	 eax, eax
  00085	7c 2d		 jl	 SHORT $LN4@UpdateUIEl

; 1747 : 	{
; 1748 : 		MakeCandidateStrings(pcandidate);

  00087	ff 75 f4	 push	 DWORD PTR _pcandidate$[ebp]
  0008a	e8 00 00 00 00	 call	 ?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z ; CTsfUiLessMode::MakeCandidateStrings
  0008f	59		 pop	 ecx

; 1749 : 		if(CIME::ms_pEvent)

  00090	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  00097	74 10		 je	 SHORT $LN7@UpdateUIEl

; 1750 : 			CIME::ms_pEvent->OnOpenCandidateList();

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0009e	8b 00		 mov	 eax, DWORD PTR [eax]
  000a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  000a6	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN7@UpdateUIEl:

; 1751 : 		pcandidate->Release();

  000a9	8b 45 f4	 mov	 eax, DWORD PTR _pcandidate$[ebp]
  000ac	8b 00		 mov	 eax, DWORD PTR [eax]
  000ae	ff 75 f4	 push	 DWORD PTR _pcandidate$[ebp]
  000b1	ff 50 08	 call	 DWORD PTR [eax+8]
$LN4@UpdateUIEl:

; 1752 :     }
; 1753 : 
; 1754 :     pElement->Release();

  000b4	8b 45 fc	 mov	 eax, DWORD PTR _pElement$[ebp]
  000b7	8b 00		 mov	 eax, DWORD PTR [eax]
  000b9	ff 75 fc	 push	 DWORD PTR _pElement$[ebp]
  000bc	ff 50 08	 call	 DWORD PTR [eax+8]

; 1755 :     return S_OK;

  000bf	33 c0		 xor	 eax, eax
$LN1@UpdateUIEl:

; 1756 : }

  000c1	c9		 leave
  000c2	c2 08 00	 ret	 8
?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z ENDP ; CTsfUiLessMode::CUIElementSink::UpdateUIElement
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z
_TEXT	SEGMENT
_pcandidate$ = -12					; size = 4
_preading$ = -8						; size = 4
_pElement$ = -4						; size = 4
_this$ = 8						; size = 4
_dwUIElementId$ = 12					; size = 4
_pbShow$ = 16						; size = 4
?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z PROC ; CTsfUiLessMode::CUIElementSink::BeginUIElement, COMDAT

; 1689 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1690 :     ITfUIElement *pElement = GetUIElement(dwUIElementId);

  00006	ff 75 0c	 push	 DWORD PTR _dwUIElementId$[ebp]
  00009	e8 00 00 00 00	 call	 ?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ; CTsfUiLessMode::GetUIElement
  0000e	59		 pop	 ecx
  0000f	89 45 fc	 mov	 DWORD PTR _pElement$[ebp], eax

; 1691 :     if (!pElement)

  00012	83 7d fc 00	 cmp	 DWORD PTR _pElement$[ebp], 0
  00016	75 0a		 jne	 SHORT $LN2@BeginUIEle

; 1692 :         return E_INVALIDARG;

  00018	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001d	e9 b0 00 00 00	 jmp	 $LN1@BeginUIEle
$LN2@BeginUIEle:

; 1693 : 
; 1694 :     ITfReadingInformationUIElement   *preading = NULL;

  00022	83 65 f8 00	 and	 DWORD PTR _preading$[ebp], 0

; 1695 : 	ITfCandidateListUIElement		*pcandidate = NULL;

  00026	83 65 f4 00	 and	 DWORD PTR _pcandidate$[ebp], 0

; 1696 : 	*pbShow = FALSE;

  0002a	8b 45 10	 mov	 eax, DWORD PTR _pbShow$[ebp]
  0002d	83 20 00	 and	 DWORD PTR [eax], 0

; 1697 : 
; 1698 : 	//BSTR bstrDesc;
; 1699 : 	//OutputDebugStringW(L"BEGINUI: ");
; 1700 : 	//pElement->GetDescription(&bstrDesc);
; 1701 : 	//OutputDebugStringW(bstrDesc);
; 1702 : 	//OutputDebugStringW(L"\n");
; 1703 : 
; 1704 : 	if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfReadingInformationUIElement), (void **)&preading)))

  00030	8d 45 f8	 lea	 eax, DWORD PTR _preading$[ebp]
  00033	50		 push	 eax
  00034	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
  00039	8b 45 fc	 mov	 eax, DWORD PTR _pElement$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	ff 75 fc	 push	 DWORD PTR _pElement$[ebp]
  00041	ff 10		 call	 DWORD PTR [eax]
  00043	85 c0		 test	 eax, eax
  00045	7c 2f		 jl	 SHORT $LN3@BeginUIEle

; 1705 :     {
; 1706 : 		MakeReadingInformationString(preading);

  00047	ff 75 f8	 push	 DWORD PTR _preading$[ebp]
  0004a	e8 00 00 00 00	 call	 ?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z ; CTsfUiLessMode::MakeReadingInformationString
  0004f	59		 pop	 ecx

; 1707 : 		if(CIME::ms_pEvent)

  00050	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  00057	74 10		 je	 SHORT $LN5@BeginUIEle

; 1708 : 			CIME::ms_pEvent->OnOpenReadingWnd();

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00066	ff 50 14	 call	 DWORD PTR [eax+20]
$LN5@BeginUIEle:

; 1709 :         preading->Release();

  00069	8b 45 f8	 mov	 eax, DWORD PTR _preading$[ebp]
  0006c	8b 00		 mov	 eax, DWORD PTR [eax]
  0006e	ff 75 f8	 push	 DWORD PTR _preading$[ebp]
  00071	ff 50 08	 call	 DWORD PTR [eax+8]

; 1710 :     }

  00074	eb 4f		 jmp	 SHORT $LN4@BeginUIEle
$LN3@BeginUIEle:

; 1711 : 	else if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfCandidateListUIElement), (void **)&pcandidate)))

  00076	8d 45 f4	 lea	 eax, DWORD PTR _pcandidate$[ebp]
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
  0007f	8b 45 fc	 mov	 eax, DWORD PTR _pElement$[ebp]
  00082	8b 00		 mov	 eax, DWORD PTR [eax]
  00084	ff 75 fc	 push	 DWORD PTR _pElement$[ebp]
  00087	ff 10		 call	 DWORD PTR [eax]
  00089	85 c0		 test	 eax, eax
  0008b	7c 38		 jl	 SHORT $LN4@BeginUIEle

; 1712 : 	{
; 1713 : 		m_nCandidateRefCount++;

  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nCandidateRefCount@CTsfUiLessMode@@1HA ; CTsfUiLessMode::m_nCandidateRefCount
  00092	40		 inc	 eax
  00093	a3 00 00 00 00	 mov	 DWORD PTR ?m_nCandidateRefCount@CTsfUiLessMode@@1HA, eax ; CTsfUiLessMode::m_nCandidateRefCount

; 1714 : 		MakeCandidateStrings(pcandidate);

  00098	ff 75 f4	 push	 DWORD PTR _pcandidate$[ebp]
  0009b	e8 00 00 00 00	 call	 ?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z ; CTsfUiLessMode::MakeCandidateStrings
  000a0	59		 pop	 ecx

; 1715 : 		if(CIME::ms_pEvent)

  000a1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  000a8	74 10		 je	 SHORT $LN7@BeginUIEle

; 1716 : 			CIME::ms_pEvent->OnOpenCandidateList();

  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  000af	8b 00		 mov	 eax, DWORD PTR [eax]
  000b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  000b7	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN7@BeginUIEle:

; 1717 : 		pcandidate->Release();

  000ba	8b 45 f4	 mov	 eax, DWORD PTR _pcandidate$[ebp]
  000bd	8b 00		 mov	 eax, DWORD PTR [eax]
  000bf	ff 75 f4	 push	 DWORD PTR _pcandidate$[ebp]
  000c2	ff 50 08	 call	 DWORD PTR [eax+8]
$LN4@BeginUIEle:

; 1718 :     }
; 1719 : 
; 1720 :     pElement->Release();

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _pElement$[ebp]
  000c8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ca	ff 75 fc	 push	 DWORD PTR _pElement$[ebp]
  000cd	ff 50 08	 call	 DWORD PTR [eax+8]

; 1721 :     return S_OK;

  000d0	33 c0		 xor	 eax, eax
$LN1@BeginUIEle:

; 1722 : }

  000d2	c9		 leave
  000d3	c2 0c 00	 ret	 12			; 0000000cH
?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z ENDP ; CTsfUiLessMode::CUIElementSink::BeginUIElement
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
_cr$ = -16						; size = 4
tv73 = -12						; size = 4
tv66 = -8						; size = 4
$T2 = -4						; size = 4
_this$ = 8						; size = 4
?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ PROC	; CTsfUiLessMode::CUIElementSink::Release, COMDAT

; 1677 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1678 :     LONG cr = --_cRef;

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000c	48		 dec	 eax
  0000d	89 45 f8	 mov	 DWORD PTR tv66[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d f8	 mov	 ecx, DWORD PTR tv66[ebp]
  00016	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00019	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  0001c	89 45 f0	 mov	 DWORD PTR _cr$[ebp], eax

; 1679 : 
; 1680 :     if (_cRef == 0)

  0001f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00026	75 3a		 jne	 SHORT $LN2@Release

; 1681 :     {
; 1682 :         delete this;

  00028	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  0002e	83 7d fc 00	 cmp	 DWORD PTR $T2[ebp], 0
  00032	74 2a		 je	 SHORT $LN4@Release
  00034	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00037	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  0003d	e8 00 00 00 00	 call	 ??1CUIElementSink@CTsfUiLessMode@@QAE@XZ ; CTsfUiLessMode::CUIElementSink::~CUIElementSink
  00042	33 c0		 xor	 eax, eax
  00044	40		 inc	 eax
  00045	83 e0 01	 and	 eax, 1
  00048	74 0c		 je	 SHORT $LN7@Release
  0004a	6a 10		 push	 16			; 00000010H
  0004c	ff 75 fc	 push	 DWORD PTR $T2[ebp]
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	59		 pop	 ecx
  00055	59		 pop	 ecx
$LN7@Release:
  00056	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  00059	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  0005c	eb 04		 jmp	 SHORT $LN2@Release
$LN4@Release:
  0005e	83 65 f4 00	 and	 DWORD PTR tv73[ebp], 0
$LN2@Release:

; 1683 :     }
; 1684 : 
; 1685 :     return cr;

  00062	8b 45 f0	 mov	 eax, DWORD PTR _cr$[ebp]

; 1686 : }

  00065	c9		 leave
  00066	c2 04 00	 ret	 4
?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ ENDP	; CTsfUiLessMode::CUIElementSink::Release
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ
_TEXT	SEGMENT
tv66 = -4						; size = 4
_this$ = 8						; size = 4
?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ PROC	; CTsfUiLessMode::CUIElementSink::AddRef, COMDAT

; 1672 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1673 :     return ++_cRef;

  00004	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00007	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000a	40		 inc	 eax
  0000b	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  00014	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00017	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]

; 1674 : }

  0001a	c9		 leave
  0001b	c2 04 00	 ret	 4
?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ ENDP	; CTsfUiLessMode::CUIElementSink::AddRef
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
tv95 = -24						; size = 4
tv154 = -20						; size = 4
tv85 = -16						; size = 4
tv150 = -12						; size = 4
tv146 = -8						; size = 4
tv142 = -4						; size = 4
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppvObj$ = 16						; size = 4
?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z PROC ; CTsfUiLessMode::CUIElementSink::QueryInterface, COMDAT

; 1639 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 1640 :     if (ppvObj == NULL)

  00006	83 7d 10 00	 cmp	 DWORD PTR _ppvObj$[ebp], 0
  0000a	75 0a		 jne	 SHORT $LN2@QueryInter

; 1641 :         return E_INVALIDARG;

  0000c	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00011	e9 1c 01 00 00	 jmp	 $LN1@QueryInter
$LN2@QueryInter:

; 1642 : 
; 1643 :     *ppvObj = NULL;

  00016	8b 45 10	 mov	 eax, DWORD PTR _ppvObj$[ebp]
  00019	83 20 00	 and	 DWORD PTR [eax], 0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  0001c	6a 10		 push	 16			; 00000010H
  0001e	68 00 00 00 00	 push	 OFFSET _IID_IUnknown
  00023	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  00026	e8 00 00 00 00	 call	 _memcmp
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	85 c0		 test	 eax, eax
  00030	75 09		 jne	 SHORT $LN18@QueryInter
  00032	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv142[ebp], 1
  00039	eb 04		 jmp	 SHORT $LN16@QueryInter
$LN18@QueryInter:
  0003b	83 65 fc 00	 and	 DWORD PTR tv142[ebp], 0
$LN16@QueryInter:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1645 :     if (IsEqualIID(riid, IID_IUnknown))

  0003f	83 7d fc 00	 cmp	 DWORD PTR tv142[ebp], 0
  00043	74 0d		 je	 SHORT $LN3@QueryInter

; 1646 : 	{
; 1647 :         *ppvObj = reinterpret_cast<IUnknown *>(this);

  00045	8b 45 10	 mov	 eax, DWORD PTR _ppvObj$[ebp]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	89 08		 mov	 DWORD PTR [eax], ecx

; 1648 : 	}

  0004d	e9 c4 00 00 00	 jmp	 $LN4@QueryInter
$LN3@QueryInter:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00052	6a 10		 push	 16			; 00000010H
  00054	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
  00059	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  0005c	e8 00 00 00 00	 call	 _memcmp
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	85 c0		 test	 eax, eax
  00066	75 09		 jne	 SHORT $LN22@QueryInter
  00068	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv146[ebp], 1
  0006f	eb 04		 jmp	 SHORT $LN20@QueryInter
$LN22@QueryInter:
  00071	83 65 f8 00	 and	 DWORD PTR tv146[ebp], 0
$LN20@QueryInter:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1649 : 	else if (IsEqualIID(riid, __uuidof(ITfUIElementSink)))

  00075	83 7d f8 00	 cmp	 DWORD PTR tv146[ebp], 0
  00079	74 0d		 je	 SHORT $LN5@QueryInter

; 1650 :     {
; 1651 :         *ppvObj = (ITfUIElementSink *)this;

  0007b	8b 45 10	 mov	 eax, DWORD PTR _ppvObj$[ebp]
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	89 08		 mov	 DWORD PTR [eax], ecx

; 1652 :     }

  00083	e9 8e 00 00 00	 jmp	 $LN4@QueryInter
$LN5@QueryInter:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00088	6a 10		 push	 16			; 00000010H
  0008a	68 00 00 00 00	 push	 OFFSET __GUID_71c6e74e_0f28_11d8_a82a_00065b84435c
  0008f	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  00092	e8 00 00 00 00	 call	 _memcmp
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	85 c0		 test	 eax, eax
  0009c	75 09		 jne	 SHORT $LN26@QueryInter
  0009e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv150[ebp], 1
  000a5	eb 04		 jmp	 SHORT $LN24@QueryInter
$LN26@QueryInter:
  000a7	83 65 f4 00	 and	 DWORD PTR tv150[ebp], 0
$LN24@QueryInter:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1653 : 	else if (IsEqualIID(riid, __uuidof(ITfInputProcessorProfileActivationSink)))

  000ab	83 7d f4 00	 cmp	 DWORD PTR tv150[ebp], 0
  000af	74 1f		 je	 SHORT $LN7@QueryInter

; 1654 : 	{
; 1655 : 		*ppvObj = (ITfInputProcessorProfileActivationSink*)this;

  000b1	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  000b5	74 0b		 je	 SHORT $LN12@QueryInter
  000b7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	83 c0 04	 add	 eax, 4
  000bd	89 45 f0	 mov	 DWORD PTR tv85[ebp], eax
  000c0	eb 04		 jmp	 SHORT $LN13@QueryInter
$LN12@QueryInter:
  000c2	83 65 f0 00	 and	 DWORD PTR tv85[ebp], 0
$LN13@QueryInter:
  000c6	8b 45 10	 mov	 eax, DWORD PTR _ppvObj$[ebp]
  000c9	8b 4d f0	 mov	 ecx, DWORD PTR tv85[ebp]
  000cc	89 08		 mov	 DWORD PTR [eax], ecx

; 1656 : 	}

  000ce	eb 46		 jmp	 SHORT $LN4@QueryInter
$LN7@QueryInter:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  000d0	6a 10		 push	 16			; 00000010H
  000d2	68 00 00 00 00	 push	 OFFSET __GUID_743abd5f_f26d_48df_8cc5_238492419b64
  000d7	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  000da	e8 00 00 00 00	 call	 _memcmp
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e2	85 c0		 test	 eax, eax
  000e4	75 09		 jne	 SHORT $LN30@QueryInter
  000e6	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv154[ebp], 1
  000ed	eb 04		 jmp	 SHORT $LN28@QueryInter
$LN30@QueryInter:
  000ef	83 65 ec 00	 and	 DWORD PTR tv154[ebp], 0
$LN28@QueryInter:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1657 : 	else if (IsEqualIID(riid, __uuidof(ITfCompartmentEventSink)))

  000f3	83 7d ec 00	 cmp	 DWORD PTR tv154[ebp], 0
  000f7	74 1d		 je	 SHORT $LN4@QueryInter

; 1658 : 	{
; 1659 : 		*ppvObj = (ITfCompartmentEventSink*)this;

  000f9	83 7d 08 00	 cmp	 DWORD PTR _this$[ebp], 0
  000fd	74 0b		 je	 SHORT $LN14@QueryInter
  000ff	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00102	83 c0 08	 add	 eax, 8
  00105	89 45 e8	 mov	 DWORD PTR tv95[ebp], eax
  00108	eb 04		 jmp	 SHORT $LN15@QueryInter
$LN14@QueryInter:
  0010a	83 65 e8 00	 and	 DWORD PTR tv95[ebp], 0
$LN15@QueryInter:
  0010e	8b 45 10	 mov	 eax, DWORD PTR _ppvObj$[ebp]
  00111	8b 4d e8	 mov	 ecx, DWORD PTR tv95[ebp]
  00114	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@QueryInter:

; 1660 : 	}
; 1661 : 
; 1662 :     if (*ppvObj)

  00116	8b 45 10	 mov	 eax, DWORD PTR _ppvObj$[ebp]
  00119	83 38 00	 cmp	 DWORD PTR [eax], 0
  0011c	74 0f		 je	 SHORT $LN10@QueryInter

; 1663 :     {
; 1664 :         AddRef();

  0011e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00121	8b 00		 mov	 eax, DWORD PTR [eax]
  00123	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00126	ff 50 04	 call	 DWORD PTR [eax+4]

; 1665 :         return S_OK;

  00129	33 c0		 xor	 eax, eax
  0012b	eb 05		 jmp	 SHORT $LN1@QueryInter
$LN10@QueryInter:

; 1666 :     }
; 1667 : 
; 1668 :     return E_NOINTERFACE;

  0012d	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
$LN1@QueryInter:

; 1669 : }

  00132	c9		 leave
  00133	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z ENDP ; CTsfUiLessMode::CUIElementSink::QueryInterface
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??1CUIElementSink@CTsfUiLessMode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CUIElementSink@CTsfUiLessMode@@QAE@XZ PROC		; CTsfUiLessMode::CUIElementSink::~CUIElementSink, COMDAT
; _this$ = ecx

; 1635 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@

; 1636 : }

  00024	c9		 leave
  00025	c3		 ret	 0
??1CUIElementSink@CTsfUiLessMode@@QAE@XZ ENDP		; CTsfUiLessMode::CUIElementSink::~CUIElementSink
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??0CUIElementSink@CTsfUiLessMode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CUIElementSink@CTsfUiLessMode@@QAE@XZ PROC		; CTsfUiLessMode::CUIElementSink::CUIElementSink, COMDAT
; _this$ = ecx

; 1629 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@

; 1630 :     _cRef = 1;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1

; 1631 : }

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c9		 leave
  00032	c3		 ret	 0
??0CUIElementSink@CTsfUiLessMode@@QAE@XZ ENDP		; CTsfUiLessMode::CUIElementSink::CUIElementSink
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??__F?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CIME::ms_wstrReading'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 673  :         _Tidy();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  00008	e8 00 00 00 00	 call	 ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CIME::ms_wstrReading''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??__E?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'CIME::ms_wstrReading'', COMDAT

; 120  : std::vector<wchar_t>	CIME::ms_wstrReading;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  00008	e8 00 00 00 00	 call	 ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> >
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'CIME::ms_wstrReading''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'CIME::ms_wstrReading''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCIME@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCIME@@UAEPAXI@Z PROC				; CIME::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CIME@@UAE@XZ		; CIME::~CIME
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 24 08 00 00	 push	 2084			; 00000824H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCIME@@UAEPAXI@Z ENDP				; CIME::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AAEAAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AAEAAV?$allocator@_W@2@XZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AAEAAV?$allocator@_W@2@XZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 72		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	d1 f8		 sar	 eax, 1
  00074	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00077	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0007f	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00082	d1 e0		 shl	 eax, 1
  00084	50		 push	 eax
  00085	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  00088	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008d	59		 pop	 ecx
  0008e	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  0008f	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00092	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00095	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00098	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009b	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0009e	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a1	c9		 leave
  000a2	c3		 ret	 0
?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AAEXQA_WII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AAEXQA_WII@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 60		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	d1 f8		 sar	 eax, 1
  00074	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00077	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0007f	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00082	d1 e0		 shl	 eax, 1
  00084	50		 push	 eax
  00085	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  00088	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008d	59		 pop	 ecx
  0008e	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00092	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00097	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009d	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000a0	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a3	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a5	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000a8	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ab	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000ae	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b3	c9		 leave
  000b4	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AAEXQA_WII@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Buy_raw@?$vector@_WV?$allocator@_W@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Max_possible$1 = -44					; size = 4
$T2 = -40						; size = 4
__Myend$ = -36						; size = 4
__Mylast$ = -32						; size = 4
__Myfirst$ = -28					; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
_this$ = -16						; size = 4
__Newvec$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$5 = -1				; size = 1
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@_WV?$allocator@_W@std@@@std@@AAEXI@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1633 :     void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1634 :         // allocate array with _Newcapacity elements
; 1635 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1636 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 e4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1637 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 e0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1638 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 dc	 mov	 DWORD PTR __Myend$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002a	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002d	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00030	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00033	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00037	c7 45 d4 ff ff
	ff 7f		 mov	 DWORD PTR __Max_possible$1[ebp], 2147483647 ; 7fffffffH

; 60   :         if (_Count > _Max_possible) {

  0003e	81 7d 08 ff ff
	ff 7f		 cmp	 DWORD PTR __Newcapacity$[ebp], 2147483647 ; 7fffffffH
  00045	76 05		 jbe	 SHORT $LN12@Buy_raw

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00047	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Buy_raw:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0004f	d1 e0		 shl	 eax, 1
  00051	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00054	ff 75 e8	 push	 DWORD PTR $T3[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0005c	59		 pop	 ecx
  0005d	89 45 f4	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1644 :         _Myfirst           = _Newvec;

  00060	8b 45 e4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00063	8b 4d f4	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00066	89 08		 mov	 DWORD PTR [eax], ecx

; 1645 :         _Mylast            = _Newvec;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0006e	89 08		 mov	 DWORD PTR [eax], ecx

; 1646 :         _Myend             = _Newvec + _Newcapacity;

  00070	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00076	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00079	8b 4d dc	 mov	 ecx, DWORD PTR __Myend$[ebp]
  0007c	89 01		 mov	 DWORD PTR [ecx], eax
$LN15@Buy_raw:

; 1647 :     }

  0007e	c9		 leave
  0007f	c2 04 00	 ret	 4
?_Buy_raw@?$vector@_WV?$allocator@_W@std@@@std@@AAEXI@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@ABEII@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	d1 f8		 sar	 eax, 1
  0001c	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0001f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00022	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00025	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00028	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002b	c7 45 f0 ff ff
	ff 7f		 mov	 DWORD PTR $T7[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00032	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00039	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003c	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0003f	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00042	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00045	73 08		 jae	 SHORT $LN25@Calculate_
  00047	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004a	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004d	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  0004f	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00052	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00055	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00058	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005b	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005e	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00061	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00064	8b 00		 mov	 eax, DWORD PTR [eax]
  00066	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00069	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006c	d1 e8		 shr	 eax, 1
  0006e	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00071	2b c8		 sub	 ecx, eax
  00073	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00076	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00078	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007b	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00080	d1 e8		 shr	 eax, 1
  00082	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00085	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00088	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008b	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008e	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00090	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00093	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00095	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00098	c9		 leave
  00099	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@ABEII@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1487 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc ff ff
	ff 7f		 mov	 DWORD PTR $T7[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@_WV?$allocator@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@_WV?$allocator@_W@std@@@std@@QAEXXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@_WV?$allocator@_W@std@@@std@@QAEXXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@_WV?$allocator@_W@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
$T1 = -56						; size = 4
__Newcapacity$ = -52					; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__My_data$ = -12					; size = 4
__Myfirst$ = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Clear_and_reserve_geometric@?$vector@_WV?$allocator@_W@std@@@std@@AAEXI@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Clear_and_reserve_geometric, COMDAT
; _this$ = ecx

; 1271 :     void _Clear_and_reserve_geometric(const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1272 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1273 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1274 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1275 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1276 : 
; 1277 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1278 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1279 :         {
; 1280 :             _Lockit _Lock(_LOCK_DEBUG);
; 1281 :             _STL_INTERNAL_CHECK(!_My_data._Myproxy->_Myfirstiter); // asserts that all iterators are orphaned
; 1282 :         } // unlock
; 1283 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1284 : 
; 1285 :         if (_Newsize > max_size()) {

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size
  0002f	39 45 08	 cmp	 DWORD PTR __Newsize$[ebp], eax
  00032	76 05		 jbe	 SHORT $LN2@Clear_and_

; 1286 :             _Xlength();

  00034	e8 00 00 00 00	 call	 ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN2@Clear_and_:

; 1287 :         }
; 1288 : 
; 1289 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  00039	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@ABEII@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth
  00044	89 45 cc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1290 : 
; 1291 :         if (_Myfirst) { // destroy and deallocate old array

  00047	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0004a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004d	74 72		 je	 SHORT $LN3@Clear_and_

; 1292 :             _Destroy(_Myfirst, _Mylast);

  0004f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00057	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00062	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00065	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00068	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0006b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0006e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00071	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00074	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0007f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00082	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00085	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax

; 1293 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00088	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0008e	8b 00		 mov	 eax, DWORD PTR [eax]
  00090	2b 01		 sub	 eax, DWORD PTR [ecx]
  00092	d1 f8		 sar	 eax, 1
  00094	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00097	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0009a	8b 00		 mov	 eax, DWORD PTR [eax]
  0009c	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0009f	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  000a2	d1 e0		 shl	 eax, 1
  000a4	50		 push	 eax
  000a5	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  000a8	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000ad	59		 pop	 ecx
  000ae	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1295 :             _Myfirst = pointer();

  000af	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000b2	83 20 00	 and	 DWORD PTR [eax], 0

; 1296 :             _Mylast  = pointer();

  000b5	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000b8	83 20 00	 and	 DWORD PTR [eax], 0

; 1297 :             _Myend   = pointer();

  000bb	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000be	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Clear_and_:

; 1298 :         }
; 1299 : 
; 1300 :         _Buy_raw(_Newcapacity);

  000c1	ff 75 cc	 push	 DWORD PTR __Newcapacity$[ebp]
  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@_WV?$allocator@_W@std@@@std@@AAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Buy_raw
$LN4@Clear_and_:

; 1301 :     }

  000cc	c9		 leave
  000cd	c2 04 00	 ret	 4
?_Clear_and_reserve_geometric@?$vector@_WV?$allocator@_W@std@@@std@@AAEXI@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 447  :     }

  00029	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c9		 leave
  0002d	c3		 ret	 0
??0?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetupImeApi@CIME@@KAXXZ
_TEXT	SEGMENT
_hImc$1 = -128						; size = 4
_szImeFile$ = -124					; size = 261
__$ArrayPad$ = 140					; size = 4
?SetupImeApi@CIME@@KAXXZ PROC				; CIME::SetupImeApi, COMDAT

; 1374 : {

  00000	55		 push	 ebp
  00001	8d ac 24 70 ff
	ff ff		 lea	 ebp, DWORD PTR [esp-144]
  00008	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 8c 00 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1375 :     char szImeFile[MAX_PATH + 1];
; 1376 : 
; 1377 : 	_GetReadingString = NULL;

  0001b	83 25 00 00 00
	00 00		 and	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, 0 ; CIME::_GetReadingString

; 1378 :     _ShowReadingWindow = NULL;

  00022	83 25 00 00 00
	00 00		 and	 DWORD PTR ?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA, 0 ; CIME::_ShowReadingWindow

; 1379 : 	ms_bUseIMMCandidate = false;

  00029	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bUseIMMCandidate@CIME@@2_NA, 0 ; CIME::ms_bUseIMMCandidate

; 1380 : 
; 1381 : 	if(ImmGetIMEFileNameA(ms_hklCurrent, szImeFile, COUNTOF(szImeFile) - 1) == 0)

  00030	68 04 01 00 00	 push	 260			; 00000104H
  00035	8d 45 84	 lea	 eax, DWORD PTR _szImeFile$[ebp]
  00038	50		 push	 eax
  00039	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0003f	e8 00 00 00 00	 call	 _ImmGetIMEFileNameA@12
  00044	85 c0		 test	 eax, eax
  00046	75 05		 jne	 SHORT $LN2@SetupImeAp

; 1382 : 		return;

  00048	e9 e9 00 00 00	 jmp	 $LN1@SetupImeAp
$LN2@SetupImeAp:

; 1383 : 	if(stricmp(szImeFile, CHS_IMEFILENAME_QQPINYIN) == 0 || stricmp(szImeFile, CHS_IMEFILENAME_SOGOUPY) == 0 || stricmp(szImeFile, CHS_IMEFILENAME_GOOGLEPINYIN2) == 0)

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EMABPIGL@QQPINYIN?4IME@
  00052	8d 45 84	 lea	 eax, DWORD PTR _szImeFile$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 __stricmp
  0005b	59		 pop	 ecx
  0005c	59		 pop	 ecx
  0005d	85 c0		 test	 eax, eax
  0005f	74 28		 je	 SHORT $LN4@SetupImeAp
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IPABOCGB@SOGOUPY?4IME@
  00066	8d 45 84	 lea	 eax, DWORD PTR _szImeFile$[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 __stricmp
  0006f	59		 pop	 ecx
  00070	59		 pop	 ecx
  00071	85 c0		 test	 eax, eax
  00073	74 14		 je	 SHORT $LN4@SetupImeAp
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KLAKFCEJ@GOOGLEPINYIN2?4IME@
  0007a	8d 45 84	 lea	 eax, DWORD PTR _szImeFile$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 __stricmp
  00083	59		 pop	 ecx
  00084	59		 pop	 ecx
  00085	85 c0		 test	 eax, eax
  00087	75 07		 jne	 SHORT $LN3@SetupImeAp
$LN4@SetupImeAp:

; 1384 : 		ms_bUseIMMCandidate = true;

  00089	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bUseIMMCandidate@CIME@@2_NA, 1 ; CIME::ms_bUseIMMCandidate
$LN3@SetupImeAp:

; 1385 : 	if (ms_bUILessMode)

  00090	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode
  00097	85 c0		 test	 eax, eax
  00099	74 05		 je	 SHORT $LN5@SetupImeAp

; 1386 : 		return;

  0009b	e9 96 00 00 00	 jmp	 $LN1@SetupImeAp
$LN5@SetupImeAp:

; 1387 : 	SAFE_FREE_LIBRARY(ms_hCurrentImeDll);

  000a0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
  000a7	74 13		 je	 SHORT $LN6@SetupImeAp
  000a9	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  000b5	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
$LN6@SetupImeAp:

; 1388 : 	ms_hCurrentImeDll = LoadLibraryA(szImeFile);

  000bc	8d 45 84	 lea	 eax, DWORD PTR _szImeFile$[ebp]
  000bf	50		 push	 eax
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  000c6	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, eax ; CIME::ms_hCurrentImeDll

; 1389 : 
; 1390 : 	if (ms_hCurrentImeDll) {

  000cb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
  000d2	74 62		 je	 SHORT $LN1@SetupImeAp

; 1391 : 		_GetReadingString = (UINT (WINAPI*)(HIMC, UINT, LPWSTR, PINT, BOOL*, PUINT)) (GetProcAddress(ms_hCurrentImeDll, "GetReadingString"));

  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EOIFCLLM@GetReadingString@
  000d9	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  000e5	a3 00 00 00 00	 mov	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, eax ; CIME::_GetReadingString

; 1392 : 		_ShowReadingWindow =(BOOL (WINAPI*)(HIMC, BOOL)) (GetProcAddress(ms_hCurrentImeDll, "ShowReadingWindow"));

  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MEELNKEC@ShowReadingWindow@
  000ef	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  000fb	a3 00 00 00 00	 mov	 DWORD PTR ?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA, eax ; CIME::_ShowReadingWindow

; 1393 : 
; 1394 : 		if(_ShowReadingWindow) {

  00100	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA, 0 ; CIME::_ShowReadingWindow
  00107	74 2d		 je	 SHORT $LN1@SetupImeAp

; 1395 : 			HIMC hImc = ImmGetContext(ms_hWnd);

  00109	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0010f	e8 00 00 00 00	 call	 _ImmGetContext@4
  00114	89 45 80	 mov	 DWORD PTR _hImc$1[ebp], eax

; 1396 : 			if(hImc) {

  00117	83 7d 80 00	 cmp	 DWORD PTR _hImc$1[ebp], 0
  0011b	74 19		 je	 SHORT $LN1@SetupImeAp

; 1397 : 				_ShowReadingWindow(hImc, false);

  0011d	6a 00		 push	 0
  0011f	ff 75 80	 push	 DWORD PTR _hImc$1[ebp]
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA ; CIME::_ShowReadingWindow

; 1398 : 				ImmReleaseContext(ms_hWnd, hImc);

  00128	ff 75 80	 push	 DWORD PTR _hImc$1[ebp]
  0012b	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00131	e8 00 00 00 00	 call	 _ImmReleaseContext@8
$LN1@SetupImeAp:

; 1399 : 			}
; 1400 : 		}
; 1401 : 	}
; 1402 : }

  00136	8b 8d 8c 00 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013c	33 cd		 xor	 ecx, ebp
  0013e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00143	81 c5 90 00 00
	00		 add	 ebp, 144		; 00000090H
  00149	c9		 leave
  0014a	c3		 ret	 0
?SetupImeApi@CIME@@KAXXZ ENDP				; CIME::SetupImeApi
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetReadingWindowOrientation@CIME@@IAE_NXZ
_TEXT	SEGMENT
_dwType$1 = -128					; size = 4
_this$ = -124						; size = 4
_dwSize$2 = -120					; size = 4
_hKey$3 = -116						; size = 4
tv84 = -112						; size = 4
tv69 = -108						; size = 4
_lRc$4 = -104						; size = 4
_dwMapping$5 = -100					; size = 4
_dwVer$6 = -96						; size = 4
_bHorizontalReading$ = -89				; size = 1
_szRegPath$7 = -88					; size = 260
__$ArrayPad$ = 172					; size = 4
?GetReadingWindowOrientation@CIME@@IAE_NXZ PROC		; CIME::GetReadingWindowOrientation, COMDAT
; _this$ = ecx

; 1340 : {

  00000	55		 push	 ebp
  00001	8d ac 24 50 ff
	ff ff		 lea	 ebp, DWORD PTR [esp-176]
  00008	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 ac 00 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 84	 mov	 DWORD PTR _this$[ebp], ecx

; 1341 :     bool bHorizontalReading = (ms_hklCurrent == _CHS_HKL) || (ms_hklCurrent == _CHT_HKL_NEW_CHANG_JIE) || (ms_adwId[0] == 0);

  0001e	81 3d 00 00 00
	00 04 08 0e e0	 cmp	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, -535951356 ; CIME::ms_hklCurrent, e00e0804H
  00028	74 21		 je	 SHORT $LN10@GetReading
  0002a	81 3d 00 00 00
	00 04 04 09 e0	 cmp	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, -536280060 ; CIME::ms_hklCurrent, e0090404H
  00034	74 15		 je	 SHORT $LN10@GetReading
  00036	6a 04		 push	 4
  00038	58		 pop	 eax
  00039	6b c0 00	 imul	 eax, eax, 0
  0003c	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 0
  00043	74 06		 je	 SHORT $LN10@GetReading
  00045	83 65 94 00	 and	 DWORD PTR tv69[ebp], 0
  00049	eb 07		 jmp	 SHORT $LN11@GetReading
$LN10@GetReading:
  0004b	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
$LN11@GetReading:
  00052	8a 45 94	 mov	 al, BYTE PTR tv69[ebp]
  00055	88 45 a7	 mov	 BYTE PTR _bHorizontalReading$[ebp], al

; 1342 :     if(!bHorizontalReading && (GETLANG() == LANG_CHT))

  00058	0f b6 45 a7	 movzx	 eax, BYTE PTR _bHorizontalReading$[ebp]
  0005c	85 c0		 test	 eax, eax
  0005e	0f 85 fe 00 00
	00		 jne	 $LN2@GetReading
  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00069	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0006e	0f b7 c0	 movzx	 eax, ax
  00071	3d 04 04 00 00	 cmp	 eax, 1028		; 00000404H
  00076	0f 85 e6 00 00
	00		 jne	 $LN2@GetReading

; 1343 :     {
; 1344 :         char szRegPath[MAX_PATH];
; 1345 :         HKEY hKey;
; 1346 :         DWORD dwVer = ms_adwId[0] & 0xFFFF0000;

  0007c	6a 04		 push	 4
  0007e	58		 pop	 eax
  0007f	6b c0 00	 imul	 eax, eax, 0
  00082	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR ?ms_adwId@CIME@@2PAKA[eax]
  00088	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  0008d	89 45 a0	 mov	 DWORD PTR _dwVer$6[ebp], eax

; 1347 :         strcpy(szRegPath, "software\\microsoft\\windows\\currentversion\\");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@
  00095	8d 45 a8	 lea	 eax, DWORD PTR _szRegPath$7[ebp]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _strcpy
  0009e	59		 pop	 ecx
  0009f	59		 pop	 ecx

; 1348 :         strcat(szRegPath, (dwVer >= MAKEIMEVERSION(5, 1)) ? "MSTCIPH" : "TINTLGNT");

  000a0	81 7d a0 00 00
	01 05		 cmp	 DWORD PTR _dwVer$6[ebp], 83951616 ; 05010000H
  000a7	72 09		 jb	 SHORT $LN12@GetReading
  000a9	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], OFFSET ??_C@_07DEJAPC@MSTCIPH@
  000b0	eb 07		 jmp	 SHORT $LN13@GetReading
$LN12@GetReading:
  000b2	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], OFFSET ??_C@_08LMKCILHO@TINTLGNT@
$LN13@GetReading:
  000b9	ff 75 90	 push	 DWORD PTR tv84[ebp]
  000bc	8d 45 a8	 lea	 eax, DWORD PTR _szRegPath$7[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 _strcat
  000c5	59		 pop	 ecx
  000c6	59		 pop	 ecx

; 1349 :         LONG lRc = RegOpenKeyExA(HKEY_CURRENT_USER, szRegPath, 0, KEY_READ, &hKey);

  000c7	8d 45 8c	 lea	 eax, DWORD PTR _hKey$3[ebp]
  000ca	50		 push	 eax
  000cb	68 19 00 02 00	 push	 131097			; 00020019H
  000d0	6a 00		 push	 0
  000d2	8d 45 a8	 lea	 eax, DWORD PTR _szRegPath$7[ebp]
  000d5	50		 push	 eax
  000d6	68 01 00 00 80	 push	 -2147483647		; 80000001H
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  000e1	89 45 98	 mov	 DWORD PTR _lRc$4[ebp], eax

; 1350 :         if (lRc == ERROR_SUCCESS)

  000e4	83 7d 98 00	 cmp	 DWORD PTR _lRc$4[ebp], 0
  000e8	75 78		 jne	 SHORT $LN2@GetReading

; 1351 :         {
; 1352 :             DWORD dwSize = sizeof(DWORD), dwMapping, dwType;

  000ea	c7 45 88 04 00
	00 00		 mov	 DWORD PTR _dwSize$2[ebp], 4

; 1353 :             lRc = RegQueryValueExA(hKey, "Keyboard Mapping", NULL, &dwType, (PBYTE)&dwMapping, &dwSize);

  000f1	8d 45 88	 lea	 eax, DWORD PTR _dwSize$2[ebp]
  000f4	50		 push	 eax
  000f5	8d 45 9c	 lea	 eax, DWORD PTR _dwMapping$5[ebp]
  000f8	50		 push	 eax
  000f9	8d 45 80	 lea	 eax, DWORD PTR _dwType$1[ebp]
  000fc	50		 push	 eax
  000fd	6a 00		 push	 0
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KFOMJFEN@Keyboard?5Mapping@
  00104	ff 75 8c	 push	 DWORD PTR _hKey$3[ebp]
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  0010d	89 45 98	 mov	 DWORD PTR _lRc$4[ebp], eax

; 1354 :             if (lRc == ERROR_SUCCESS)

  00110	83 7d 98 00	 cmp	 DWORD PTR _lRc$4[ebp], 0
  00114	75 43		 jne	 SHORT $LN4@GetReading

; 1355 :             {
; 1356 :                 if ((dwVer <= MAKEIMEVERSION(5, 0) && 
; 1357 :                        ((BYTE)dwMapping == 0x22 || (BYTE)dwMapping == 0x23))
; 1358 :                      ||

  00116	81 7d a0 00 00
	00 05		 cmp	 DWORD PTR _dwVer$6[ebp], 83886080 ; 05000000H
  0011d	77 12		 ja	 SHORT $LN7@GetReading
  0011f	0f b6 45 9c	 movzx	 eax, BYTE PTR _dwMapping$5[ebp]
  00123	83 f8 22	 cmp	 eax, 34			; 00000022H
  00126	74 2d		 je	 SHORT $LN6@GetReading
  00128	0f b6 45 9c	 movzx	 eax, BYTE PTR _dwMapping$5[ebp]
  0012c	83 f8 23	 cmp	 eax, 35			; 00000023H
  0012f	74 24		 je	 SHORT $LN6@GetReading
$LN7@GetReading:
  00131	81 7d a0 00 00
	01 05		 cmp	 DWORD PTR _dwVer$6[ebp], 83951616 ; 05010000H
  00138	74 09		 je	 SHORT $LN8@GetReading
  0013a	81 7d a0 00 00
	02 05		 cmp	 DWORD PTR _dwVer$6[ebp], 84017152 ; 05020000H
  00141	75 16		 jne	 SHORT $LN4@GetReading
$LN8@GetReading:
  00143	0f b6 45 9c	 movzx	 eax, BYTE PTR _dwMapping$5[ebp]
  00147	83 f8 22	 cmp	 eax, 34			; 00000022H
  0014a	7c 0d		 jl	 SHORT $LN4@GetReading
  0014c	0f b6 45 9c	 movzx	 eax, BYTE PTR _dwMapping$5[ebp]
  00150	83 f8 24	 cmp	 eax, 36			; 00000024H
  00153	7f 04		 jg	 SHORT $LN4@GetReading
$LN6@GetReading:

; 1359 :                      ((dwVer == MAKEIMEVERSION(5, 1) || dwVer == MAKEIMEVERSION(5, 2)) &&
; 1360 :                        (BYTE)dwMapping >= 0x22 && (BYTE)dwMapping <= 0x24)
; 1361 :                   )
; 1362 :                 {
; 1363 :                     bHorizontalReading = true;

  00155	c6 45 a7 01	 mov	 BYTE PTR _bHorizontalReading$[ebp], 1
$LN4@GetReading:

; 1364 :                 }
; 1365 :             }
; 1366 :             RegCloseKey(hKey);

  00159	ff 75 8c	 push	 DWORD PTR _hKey$3[ebp]
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN2@GetReading:

; 1367 :         }
; 1368 :     }
; 1369 : 
; 1370 : 	return bHorizontalReading;

  00162	8a 45 a7	 mov	 al, BYTE PTR _bHorizontalReading$[ebp]

; 1371 : }

  00165	8b 8d ac 00 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016b	33 cd		 xor	 ecx, ebp
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	81 c5 b0 00 00
	00		 add	 ebp, 176		; 000000b0H
  00178	c9		 leave
  00179	c3		 ret	 0
?GetReadingWindowOrientation@CIME@@IAE_NXZ ENDP		; CIME::GetReadingWindowOrientation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetImeId@CIME@@IAEKI@Z
_TEXT	SEGMENT
_cbVerData$1 = -128					; size = 4
_dwLang$ = -124						; size = 4
_this$ = -120						; size = 4
_dwVerHandle$ = -116					; size = 4
tv184 = -112						; size = 4
_lpVerData$2 = -108					; size = 4
_lpVerBuffer$3 = -104					; size = 4
_dwVerSize$ = -100					; size = 4
_hkl$ = -96						; size = 4
_langId$ = -92						; size = 2
_dwVer$4 = -88						; size = 4
_szTmp$ = -84						; size = 1024
__$ArrayPad$ = 940					; size = 4
_uIndex$ = 952						; size = 4
?GetImeId@CIME@@IAEKI@Z PROC				; CIME::GetImeId, COMDAT
; _this$ = ecx

; 1251 : {

  00000	55		 push	 ebp
  00001	8d ac 24 50 fc
	ff ff		 lea	 ebp, DWORD PTR [esp-944]
  00008	81 ec 30 04 00
	00		 sub	 esp, 1072		; 00000430H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 ac 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 88	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 : 	static HKL hklPrev = 0;
; 1253 :     char szTmp[1024];
; 1254 : 
; 1255 : 	if (uIndex >= COUNTOF(ms_adwId))

  0001e	83 bd b8 03 00
	00 02		 cmp	 DWORD PTR _uIndex$[ebp], 2
  00025	72 07		 jb	 SHORT $LN2@GetImeId

; 1256 : 		return 0;

  00027	33 c0		 xor	 eax, eax
  00029	e9 4f 03 00 00	 jmp	 $LN1@GetImeId
$LN2@GetImeId:

; 1257 : 	HKL hkl = ms_hklCurrent;

  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00033	89 45 a0	 mov	 DWORD PTR _hkl$[ebp], eax

; 1258 : 	if(hklPrev == hkl)

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hklPrev@?1??GetImeId@CIME@@IAEKI@Z@4PAUHKL__@@A
  0003b	3b 45 a0	 cmp	 eax, DWORD PTR _hkl$[ebp]
  0003e	75 12		 jne	 SHORT $LN3@GetImeId

; 1259 : 		return ms_adwId[uIndex];

  00040	8b 85 b8 03 00
	00		 mov	 eax, DWORD PTR _uIndex$[ebp]
  00046	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?ms_adwId@CIME@@2PAKA[eax*4]
  0004d	e9 2b 03 00 00	 jmp	 $LN1@GetImeId
$LN3@GetImeId:

; 1260 : 	hklPrev = hkl;

  00052	8b 45 a0	 mov	 eax, DWORD PTR _hkl$[ebp]
  00055	a3 00 00 00 00	 mov	 DWORD PTR ?hklPrev@?1??GetImeId@CIME@@IAEKI@Z@4PAUHKL__@@A, eax

; 1261 : 
; 1262 : 	DWORD dwLang = ((DWORD)hkl & 0xffff);

  0005a	8b 45 a0	 mov	 eax, DWORD PTR _hkl$[ebp]
  0005d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00062	89 45 84	 mov	 DWORD PTR _dwLang$[ebp], eax

; 1263 : 
; 1264 : 	if ( ms_bUILessMode && GETLANG() == LANG_CHT ) {

  00065	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode
  0006c	85 c0		 test	 eax, eax
  0006e	74 42		 je	 SHORT $LN4@GetImeId
  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00075	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0007a	0f b7 c0	 movzx	 eax, ax
  0007d	3d 04 04 00 00	 cmp	 eax, 1028		; 00000404H
  00082	75 2e		 jne	 SHORT $LN4@GetImeId

; 1265 : 		// In case of Vista, artifitial value is returned so that it's not considered as older IME.
; 1266 : 		ms_adwId[0] = IMEID_CHT_VER_VISTA;

  00084	6a 04		 push	 4
  00086	58		 pop	 eax
  00087	6b c0 00	 imul	 eax, eax, 0
  0008a	c7 80 00 00 00
	00 04 04 00 07	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 117441540 ; 07000404H

; 1267 : 		ms_adwId[1] = 0;

  00094	6a 04		 push	 4
  00096	58		 pop	 eax
  00097	c1 e0 00	 shl	 eax, 0
  0009a	83 a0 00 00 00
	00 00		 and	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 0

; 1268 : 		return ms_adwId[0];

  000a1	6a 04		 push	 4
  000a3	58		 pop	 eax
  000a4	6b c0 00	 imul	 eax, eax, 0
  000a7	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR ?ms_adwId@CIME@@2PAKA[eax]
  000ad	e9 cb 02 00 00	 jmp	 $LN1@GetImeId
$LN4@GetImeId:

; 1269 : 	}
; 1270 : 
; 1271 : 	if (!((ms_hklCurrent == _CHT_HKL_NEW_PHONETIC) || (ms_hklCurrent == _CHT_HKL_NEW_CHANG_JIE) || (ms_hklCurrent == _CHT_HKL_NEW_QUICK) || (ms_hklCurrent == _CHT_HKL_HK_CANTONESE) || (ms_hklCurrent == _CHS_HKL))) {

  000b2	81 3d 00 00 00
	00 04 04 08 e0	 cmp	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, -536345596 ; CIME::ms_hklCurrent, e0080404H
  000bc	74 51		 je	 SHORT $LN5@GetImeId
  000be	81 3d 00 00 00
	00 04 04 09 e0	 cmp	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, -536280060 ; CIME::ms_hklCurrent, e0090404H
  000c8	74 45		 je	 SHORT $LN5@GetImeId
  000ca	81 3d 00 00 00
	00 04 04 0a e0	 cmp	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, -536214524 ; CIME::ms_hklCurrent, e00a0404H
  000d4	74 39		 je	 SHORT $LN5@GetImeId
  000d6	81 3d 00 00 00
	00 04 04 0b e0	 cmp	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, -536148988 ; CIME::ms_hklCurrent, e00b0404H
  000e0	74 2d		 je	 SHORT $LN5@GetImeId
  000e2	81 3d 00 00 00
	00 04 08 0e e0	 cmp	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, -535951356 ; CIME::ms_hklCurrent, e00e0804H
  000ec	74 21		 je	 SHORT $LN5@GetImeId

; 1272 : 		ms_adwId[0] = ms_adwId[1] = 0;

  000ee	6a 04		 push	 4
  000f0	58		 pop	 eax
  000f1	c1 e0 00	 shl	 eax, 0
  000f4	83 a0 00 00 00
	00 00		 and	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 0
  000fb	6a 04		 push	 4
  000fd	58		 pop	 eax
  000fe	6b c0 00	 imul	 eax, eax, 0
  00101	83 a0 00 00 00
	00 00		 and	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 0

; 1273 :         return 0;

  00108	33 c0		 xor	 eax, eax
  0010a	e9 6e 02 00 00	 jmp	 $LN1@GetImeId
$LN5@GetImeId:

; 1274 : 	}
; 1275 : 
; 1276 : 	if (!ImmGetIMEFileNameA(ms_hklCurrent, szTmp, (sizeof(szTmp) / sizeof(szTmp[0])) - 1)) {

  0010f	68 ff 03 00 00	 push	 1023			; 000003ffH
  00114	8d 45 ac	 lea	 eax, DWORD PTR _szTmp$[ebp]
  00117	50		 push	 eax
  00118	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0011e	e8 00 00 00 00	 call	 _ImmGetIMEFileNameA@12
  00123	85 c0		 test	 eax, eax
  00125	75 21		 jne	 SHORT $LN6@GetImeId

; 1277 : 		ms_adwId[0] = ms_adwId[1] = 0;

  00127	6a 04		 push	 4
  00129	58		 pop	 eax
  0012a	c1 e0 00	 shl	 eax, 0
  0012d	83 a0 00 00 00
	00 00		 and	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 0
  00134	6a 04		 push	 4
  00136	58		 pop	 eax
  00137	6b c0 00	 imul	 eax, eax, 0
  0013a	83 a0 00 00 00
	00 00		 and	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 0

; 1278 :         return 0;

  00141	33 c0		 xor	 eax, eax
  00143	e9 35 02 00 00	 jmp	 $LN1@GetImeId
$LN6@GetImeId:

; 1279 : 	}
; 1280 : 
; 1281 :     if (!_GetReadingString)

  00148	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, 0 ; CIME::_GetReadingString
  0014f	0f 85 c0 00 00
	00		 jne	 $LN7@GetImeId

; 1282 : 	{
; 1283 :         if ((CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHT_IMEFILENAME1, -1) != CSTR_EQUAL) &&
; 1284 :             (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHT_IMEFILENAME2, -1) != CSTR_EQUAL) &&
; 1285 :             (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHT_IMEFILENAME3, -1) != CSTR_EQUAL) &&
; 1286 :             (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHS_IMEFILENAME1, -1) != CSTR_EQUAL) &&

  00155	6a ff		 push	 -1
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FFMHCBAD@TINTLGNT?4IME@
  0015c	6a ff		 push	 -1
  0015e	8d 45 ac	 lea	 eax, DWORD PTR _szTmp$[ebp]
  00161	50		 push	 eax
  00162	6a 01		 push	 1
  00164	68 09 04 00 00	 push	 1033			; 00000409H
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CompareStringA@24
  0016f	83 f8 02	 cmp	 eax, 2
  00172	0f 84 9d 00 00
	00		 je	 $LN7@GetImeId
  00178	6a ff		 push	 -1
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JMLDIBIB@CINTLGNT?4IME@
  0017f	6a ff		 push	 -1
  00181	8d 45 ac	 lea	 eax, DWORD PTR _szTmp$[ebp]
  00184	50		 push	 eax
  00185	6a 01		 push	 1
  00187	68 09 04 00 00	 push	 1033			; 00000409H
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CompareStringA@24
  00192	83 f8 02	 cmp	 eax, 2
  00195	74 7e		 je	 SHORT $LN7@GetImeId
  00197	6a ff		 push	 -1
  00199	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FHDFFBN@MSTCIPHA?4IME@
  0019e	6a ff		 push	 -1
  001a0	8d 45 ac	 lea	 eax, DWORD PTR _szTmp$[ebp]
  001a3	50		 push	 eax
  001a4	6a 01		 push	 1
  001a6	68 09 04 00 00	 push	 1033			; 00000409H
  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CompareStringA@24
  001b1	83 f8 02	 cmp	 eax, 2
  001b4	74 5f		 je	 SHORT $LN7@GetImeId
  001b6	6a ff		 push	 -1
  001b8	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JFHOELJF@PINTLGNT?4IME@
  001bd	6a ff		 push	 -1
  001bf	8d 45 ac	 lea	 eax, DWORD PTR _szTmp$[ebp]
  001c2	50		 push	 eax
  001c3	6a 01		 push	 1
  001c5	68 09 04 00 00	 push	 1033			; 00000409H
  001ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CompareStringA@24
  001d0	83 f8 02	 cmp	 eax, 2
  001d3	74 40		 je	 SHORT $LN7@GetImeId
  001d5	6a ff		 push	 -1
  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ONOBNHOE@MSSCIPYA?4IME@
  001dc	6a ff		 push	 -1
  001de	8d 45 ac	 lea	 eax, DWORD PTR _szTmp$[ebp]
  001e1	50		 push	 eax
  001e2	6a 01		 push	 1
  001e4	68 09 04 00 00	 push	 1033			; 00000409H
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CompareStringA@24
  001ef	83 f8 02	 cmp	 eax, 2
  001f2	74 21		 je	 SHORT $LN7@GetImeId

; 1287 :             (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHS_IMEFILENAME2, -1) != CSTR_EQUAL))
; 1288 : 		{
; 1289 : 			ms_adwId[0] = ms_adwId[1] = 0;

  001f4	6a 04		 push	 4
  001f6	58		 pop	 eax
  001f7	c1 e0 00	 shl	 eax, 0
  001fa	83 a0 00 00 00
	00 00		 and	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 0
  00201	6a 04		 push	 4
  00203	58		 pop	 eax
  00204	6b c0 00	 imul	 eax, eax, 0
  00207	83 a0 00 00 00
	00 00		 and	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 0

; 1290 : 	        return 0;

  0020e	33 c0		 xor	 eax, eax
  00210	e9 68 01 00 00	 jmp	 $LN1@GetImeId
$LN7@GetImeId:

; 1291 :         }
; 1292 :     }
; 1293 : 
; 1294 :     DWORD   dwVerHandle;
; 1295 :     DWORD   dwVerSize = GetFileVersionInfoSize(szTmp, &dwVerHandle);

  00215	8d 45 8c	 lea	 eax, DWORD PTR _dwVerHandle$[ebp]
  00218	50		 push	 eax
  00219	8d 45 ac	 lea	 eax, DWORD PTR _szTmp$[ebp]
  0021c	50		 push	 eax
  0021d	e8 00 00 00 00	 call	 _GetFileVersionInfoSizeA@8
  00222	89 45 9c	 mov	 DWORD PTR _dwVerSize$[ebp], eax

; 1296 : 	LANGID	langId = LOWORD(ms_hklCurrent);

  00225	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0022a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0022f	66 89 45 a4	 mov	 WORD PTR _langId$[ebp], ax

; 1297 : 
; 1298 :     if (dwVerSize)

  00233	83 7d 9c 00	 cmp	 DWORD PTR _dwVerSize$[ebp], 0
  00237	0f 84 1a 01 00
	00		 je	 $LN9@GetImeId

; 1299 : 	{
; 1300 :         LPVOID lpVerBuffer = alloca(dwVerSize);

  0023d	8b 45 9c	 mov	 eax, DWORD PTR _dwVerSize$[ebp]
  00240	e8 00 00 00 00	 call	 __alloca_probe_16
  00245	89 65 90	 mov	 DWORD PTR tv184[ebp], esp
  00248	8b 45 90	 mov	 eax, DWORD PTR tv184[ebp]
  0024b	89 45 98	 mov	 DWORD PTR _lpVerBuffer$3[ebp], eax

; 1301 : 
; 1302 :         if (GetFileVersionInfo(szTmp, dwVerHandle, dwVerSize, lpVerBuffer))

  0024e	ff 75 98	 push	 DWORD PTR _lpVerBuffer$3[ebp]
  00251	ff 75 9c	 push	 DWORD PTR _dwVerSize$[ebp]
  00254	ff 75 8c	 push	 DWORD PTR _dwVerHandle$[ebp]
  00257	8d 45 ac	 lea	 eax, DWORD PTR _szTmp$[ebp]
  0025a	50		 push	 eax
  0025b	e8 00 00 00 00	 call	 _GetFileVersionInfoA@16
  00260	85 c0		 test	 eax, eax
  00262	0f 84 ef 00 00
	00		 je	 $LN9@GetImeId

; 1303 : 		{
; 1304 : 			LPVOID  lpVerData;
; 1305 : 			UINT    cbVerData;
; 1306 : 
; 1307 :             if(VerQueryValue(lpVerBuffer, "\\", &lpVerData, &cbVerData))

  00268	8d 45 80	 lea	 eax, DWORD PTR _cbVerData$1[ebp]
  0026b	50		 push	 eax
  0026c	8d 45 94	 lea	 eax, DWORD PTR _lpVerData$2[ebp]
  0026f	50		 push	 eax
  00270	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@
  00275	ff 75 98	 push	 DWORD PTR _lpVerBuffer$3[ebp]
  00278	e8 00 00 00 00	 call	 _VerQueryValueA@16
  0027d	85 c0		 test	 eax, eax
  0027f	0f 84 d2 00 00
	00		 je	 $LN9@GetImeId

; 1308 : 			{
; 1309 :                 DWORD dwVer = ((VS_FIXEDFILEINFO*) lpVerData)->dwFileVersionMS;

  00285	8b 45 94	 mov	 eax, DWORD PTR _lpVerData$2[ebp]
  00288	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0028b	89 45 a8	 mov	 DWORD PTR _dwVer$4[ebp], eax

; 1310 :                 dwVer = (dwVer & 0x00ff0000) << 8 | (dwVer & 0x000000ff) << 16;

  0028e	8b 45 a8	 mov	 eax, DWORD PTR _dwVer$4[ebp]
  00291	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00296	c1 e0 08	 shl	 eax, 8
  00299	8b 4d a8	 mov	 ecx, DWORD PTR _dwVer$4[ebp]
  0029c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002a2	c1 e1 10	 shl	 ecx, 16			; 00000010H
  002a5	0b c1		 or	 eax, ecx
  002a7	89 45 a8	 mov	 DWORD PTR _dwVer$4[ebp], eax

; 1311 : 
; 1312 :                 if (_GetReadingString
; 1313 :                     ||
; 1314 :                     (langId == LANG_CHT &&
; 1315 :                         (dwVer == MAKEIMEVERSION(4, 2) || 
; 1316 :                         dwVer == MAKEIMEVERSION(4, 3) || 
; 1317 :                         dwVer == MAKEIMEVERSION(4, 4) || 
; 1318 :                         dwVer == MAKEIMEVERSION(5, 0) ||
; 1319 :                         dwVer == MAKEIMEVERSION(5, 1) ||
; 1320 :                         dwVer == MAKEIMEVERSION(5, 2) ||
; 1321 :                         dwVer == MAKEIMEVERSION(6, 0)))
; 1322 :                     ||

  002aa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, 0 ; CIME::_GetReadingString
  002b1	75 70		 jne	 SHORT $LN13@GetImeId
  002b3	0f b7 45 a4	 movzx	 eax, WORD PTR _langId$[ebp]
  002b7	3d 04 04 00 00	 cmp	 eax, 1028		; 00000404H
  002bc	75 3f		 jne	 SHORT $LN14@GetImeId
  002be	81 7d a8 00 00
	02 04		 cmp	 DWORD PTR _dwVer$4[ebp], 67239936 ; 04020000H
  002c5	74 5c		 je	 SHORT $LN13@GetImeId
  002c7	81 7d a8 00 00
	03 04		 cmp	 DWORD PTR _dwVer$4[ebp], 67305472 ; 04030000H
  002ce	74 53		 je	 SHORT $LN13@GetImeId
  002d0	81 7d a8 00 00
	04 04		 cmp	 DWORD PTR _dwVer$4[ebp], 67371008 ; 04040000H
  002d7	74 4a		 je	 SHORT $LN13@GetImeId
  002d9	81 7d a8 00 00
	00 05		 cmp	 DWORD PTR _dwVer$4[ebp], 83886080 ; 05000000H
  002e0	74 41		 je	 SHORT $LN13@GetImeId
  002e2	81 7d a8 00 00
	01 05		 cmp	 DWORD PTR _dwVer$4[ebp], 83951616 ; 05010000H
  002e9	74 38		 je	 SHORT $LN13@GetImeId
  002eb	81 7d a8 00 00
	02 05		 cmp	 DWORD PTR _dwVer$4[ebp], 84017152 ; 05020000H
  002f2	74 2f		 je	 SHORT $LN13@GetImeId
  002f4	81 7d a8 00 00
	00 06		 cmp	 DWORD PTR _dwVer$4[ebp], 100663296 ; 06000000H
  002fb	74 26		 je	 SHORT $LN13@GetImeId
$LN14@GetImeId:
  002fd	0f b7 45 a4	 movzx	 eax, WORD PTR _langId$[ebp]
  00301	3d 04 08 00 00	 cmp	 eax, 2052		; 00000804H
  00306	75 4f		 jne	 SHORT $LN9@GetImeId
  00308	81 7d a8 00 00
	01 04		 cmp	 DWORD PTR _dwVer$4[ebp], 67174400 ; 04010000H
  0030f	74 12		 je	 SHORT $LN13@GetImeId
  00311	81 7d a8 00 00
	02 04		 cmp	 DWORD PTR _dwVer$4[ebp], 67239936 ; 04020000H
  00318	74 09		 je	 SHORT $LN13@GetImeId
  0031a	81 7d a8 00 00
	03 05		 cmp	 DWORD PTR _dwVer$4[ebp], 84082688 ; 05030000H
  00321	75 34		 jne	 SHORT $LN9@GetImeId
$LN13@GetImeId:

; 1323 :                     (langId == LANG_CHS &&
; 1324 :                         (dwVer == MAKEIMEVERSION(4, 1) ||
; 1325 :                         dwVer == MAKEIMEVERSION(4, 2) ||
; 1326 :                         dwVer == MAKEIMEVERSION(5, 3))))
; 1327 : 				{
; 1328 :                     ms_adwId[0] = dwVer | langId;

  00323	0f b7 45 a4	 movzx	 eax, WORD PTR _langId$[ebp]
  00327	0b 45 a8	 or	 eax, DWORD PTR _dwVer$4[ebp]
  0032a	6a 04		 push	 4
  0032c	59		 pop	 ecx
  0032d	6b c9 00	 imul	 ecx, ecx, 0
  00330	89 81 00 00 00
	00		 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA[ecx], eax

; 1329 :                     ms_adwId[1] = ((VS_FIXEDFILEINFO*)lpVerData)->dwFileVersionLS;

  00336	6a 04		 push	 4
  00338	58		 pop	 eax
  00339	c1 e0 00	 shl	 eax, 0
  0033c	8b 4d 94	 mov	 ecx, DWORD PTR _lpVerData$2[ebp]
  0033f	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00342	89 88 00 00 00
	00		 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], ecx

; 1330 : 					return ms_adwId[uIndex];

  00348	8b 85 b8 03 00
	00		 mov	 eax, DWORD PTR _uIndex$[ebp]
  0034e	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?ms_adwId@CIME@@2PAKA[eax*4]
  00355	eb 26		 jmp	 SHORT $LN1@GetImeId
$LN9@GetImeId:

; 1331 :                 }
; 1332 :             }
; 1333 :         }
; 1334 :     }
; 1335 : 	ms_adwId[0] = ms_adwId[1] = 0;

  00357	6a 04		 push	 4
  00359	58		 pop	 eax
  0035a	c1 e0 00	 shl	 eax, 0
  0035d	83 a0 00 00 00
	00 00		 and	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 0
  00364	6a 04		 push	 4
  00366	58		 pop	 eax
  00367	6b c0 00	 imul	 eax, eax, 0
  0036a	83 a0 00 00 00
	00 00		 and	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 0

; 1336 : 	return ms_adwId[0];

  00371	6a 04		 push	 4
  00373	58		 pop	 eax
  00374	6b c0 00	 imul	 eax, eax, 0
  00377	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR ?ms_adwId@CIME@@2PAKA[eax]
$LN1@GetImeId:

; 1337 : }

  0037d	8d 65 80	 lea	 esp, DWORD PTR [ebp-128]
  00380	8b 8d ac 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00386	33 cd		 xor	 ecx, ebp
  00388	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0038d	81 c5 b0 03 00
	00		 add	 ebp, 944		; 000003b0H
  00393	c9		 leave
  00394	c2 04 00	 ret	 4
?GetImeId@CIME@@IAEKI@Z ENDP				; CIME::GetImeId
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?IsMax@CIME@@IAE_NPB_WH@Z
_TEXT	SEGMENT
_inputLen$2 = -100					; size = 4
_textLen$3 = -96					; size = 4
$T4 = -92						; size = 4
$T5 = -88						; size = 4
_inputLen$ = -84					; size = 4
_textLen$ = -80						; size = 4
tv163 = -76						; size = 4
_this$ = -72						; size = 4
$T6 = -65						; size = 1
_str$7 = -64						; size = 24
_input$8 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_wInput$ = 8						; size = 4
_len$ = 12						; size = 4
?IsMax@CIME@@IAE_NPB_WH@Z PROC				; CIME::IsMax, COMDAT
; _this$ = ecx

; 1229 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?IsMax@CIME@@IAE_NPB_WH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx

; 1230 : 	if (ms_lastpos + len > IMESTR_MAXLEN)

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00030	03 45 0c	 add	 eax, DWORD PTR _len$[ebp]
  00033	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  00038	7e 07		 jle	 SHORT $LN2@IsMax

; 1231 : 		return true;

  0003a	b0 01		 mov	 al, 1
  0003c	e9 3b 01 00 00	 jmp	 $LN1@IsMax
$LN2@IsMax:

; 1232 : 
; 1233 : 	int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, m_wText, ms_lastpos, 0, 0, NULL, NULL);

  00041	6a 00		 push	 0
  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0004f	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  00054	6a 00		 push	 0
  00056	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00062	89 45 b0	 mov	 DWORD PTR _textLen$[ebp], eax

; 1234 : 	int inputLen = WideCharToMultiByte(ms_uOutputCodePage, 0, wInput, len, 0, 0, NULL, NULL);

  00065	6a 00		 push	 0
  00067	6a 00		 push	 0
  00069	6a 00		 push	 0
  0006b	6a 00		 push	 0
  0006d	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  00070	ff 75 08	 push	 DWORD PTR _wInput$[ebp]
  00073	6a 00		 push	 0
  00075	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00081	89 45 ac	 mov	 DWORD PTR _inputLen$[ebp], eax

; 1235 : 	//return textLen + inputLen > m_max;
; 1236 : 
; 1237 : 	if (textLen + inputLen > m_max)

  00084	8b 45 b0	 mov	 eax, DWORD PTR _textLen$[ebp]
  00087	03 45 ac	 add	 eax, DWORD PTR _inputLen$[ebp]
  0008a	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00090	7e 0c		 jle	 SHORT $LN3@IsMax

; 1238 : 		return true;

  00092	b0 01		 mov	 al, 1
  00094	e9 e3 00 00 00	 jmp	 $LN1@IsMax
  00099	e9 dc 00 00 00	 jmp	 $LN4@IsMax
$LN3@IsMax:

; 1239 : 	else if (m_userMax != 0 && m_max != m_userMax)

  0009e	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000a5	0f 84 cf 00 00
	00		 je	 $LN4@IsMax
  000ab	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000b4	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000b7	0f 84 bd 00 00
	00		 je	 $LN4@IsMax

; 1240 : 	{
; 1241 : 		std::wstring str = GetTextTagOutputString(m_wText, ms_lastpos);

  000bd	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  000c3	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  000c8	8d 45 c0	 lea	 eax, DWORD PTR _str$7[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z ; GetTextTagOutputString
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d4	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1242 : 		std::wstring input = GetTextTagOutputString(wInput, len);

  000d8	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  000db	ff 75 08	 push	 DWORD PTR _wInput$[ebp]
  000de	8d 45 d8	 lea	 eax, DWORD PTR _input$8[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z ; GetTextTagOutputString
  000e7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  000ea	8b 45 d0	 mov	 eax, DWORD PTR _str$7[ebp+16]
  000ed	89 45 a8	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1243 : 		int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, str.c_str(), str.length(), 0, 0, NULL, NULL);

  000f0	6a 00		 push	 0
  000f2	6a 00		 push	 0
  000f4	6a 00		 push	 0
  000f6	6a 00		 push	 0
  000f8	ff 75 a8	 push	 DWORD PTR $T5[ebp]
  000fb	8d 4d c0	 lea	 ecx, DWORD PTR _str$7[ebp]
  000fe	e8 00 00 00 00	 call	 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
  00103	50		 push	 eax
  00104	6a 00		 push	 0
  00106	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00112	89 45 a0	 mov	 DWORD PTR _textLen$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  00115	8b 45 e8	 mov	 eax, DWORD PTR _input$8[ebp+16]
  00118	89 45 a4	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1244 : 		int inputLen = WideCharToMultiByte(ms_uOutputCodePage, 0, input.c_str(), input.length(), 0, 0, NULL, NULL);

  0011b	6a 00		 push	 0
  0011d	6a 00		 push	 0
  0011f	6a 00		 push	 0
  00121	6a 00		 push	 0
  00123	ff 75 a4	 push	 DWORD PTR $T4[ebp]
  00126	8d 4d d8	 lea	 ecx, DWORD PTR _input$8[ebp]
  00129	e8 00 00 00 00	 call	 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
  0012e	50		 push	 eax
  0012f	6a 00		 push	 0
  00131	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  0013d	89 45 9c	 mov	 DWORD PTR _inputLen$2[ebp], eax

; 1245 : 		return textLen + inputLen > m_userMax;

  00140	8b 45 a0	 mov	 eax, DWORD PTR _textLen$3[ebp]
  00143	03 45 9c	 add	 eax, DWORD PTR _inputLen$2[ebp]
  00146	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00149	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  0014c	7e 09		 jle	 SHORT $LN7@IsMax
  0014e	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv163[ebp], 1
  00155	eb 04		 jmp	 SHORT $LN8@IsMax
$LN7@IsMax:
  00157	83 65 b4 00	 and	 DWORD PTR tv163[ebp], 0
$LN8@IsMax:
  0015b	8a 45 b4	 mov	 al, BYTE PTR tv163[ebp]
  0015e	88 45 bf	 mov	 BYTE PTR $T6[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00161	8d 4d d8	 lea	 ecx, DWORD PTR _input$8[ebp]
  00164	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1245 : 		return textLen + inputLen > m_userMax;

  00169	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0016d	8d 4d c0	 lea	 ecx, DWORD PTR _str$7[ebp]
  00170	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1245 : 		return textLen + inputLen > m_userMax;

  00175	8a 45 bf	 mov	 al, BYTE PTR $T6[ebp]
  00178	eb 02		 jmp	 SHORT $LN1@IsMax
$LN4@IsMax:

; 1246 : 	}
; 1247 : 	return false;

  0017a	32 c0		 xor	 al, al
$LN1@IsMax:

; 1248 : }

  0017c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00186	59		 pop	 ecx
  00187	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018a	33 cd		 xor	 ecx, ebp
  0018c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00191	c9		 leave
  00192	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsMax@CIME@@IAE_NPB_WH@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _str$7[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?IsMax@CIME@@IAE_NPB_WH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?IsMax@CIME@@IAE_NPB_WH@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?IsMax@CIME@@IAE_NPB_WH@Z ENDP				; CIME::IsMax
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
$T1 = -188						; size = 1
$T2 = -184						; size = 1
$T3 = -180						; size = 1
tv81 = -176						; size = 4
$T4 = -172						; size = 4
_this$ = -168						; size = 4
__First$ = -164						; size = 4
$T5 = -160						; size = 4
__Last$ = -156						; size = 4
tv259 = -152						; size = 4
__First$ = -148						; size = 4
$T6 = -144						; size = 4
__Last$ = -140						; size = 4
_nOffset$7 = -136					; size = 4
__First$ = -132						; size = 4
$T8 = -128						; size = 4
__Last$ = -124						; size = 4
_uMaxUiLen$9 = -120					; size = 4
__My_data$10 = -116					; size = 4
_nTcharSize$11 = -112					; size = 4
tv205 = -108						; size = 4
tv200 = -104						; size = 4
tv188 = -100						; size = 4
tv94 = -96						; size = 4
_bVertical$12 = -92					; size = 4
_wstr$13 = -88						; size = 4
_wstrLen$14 = -84					; size = 4
_wstr$15 = -80						; size = 4
$T16 = -74						; size = 1
$T17 = -73						; size = 1
_wstrLen$18 = -72					; size = 4
_lpIC$19 = -68						; size = 4
_dwErr$ = -64						; size = 4
tv133 = -60						; size = 4
_temp$20 = -56						; size = 4
tv228 = -49						; size = 1
_tempLen$21 = -48					; size = 4
_bUnicodeIme$22 = -41					; size = 1
_p$23 = -40						; size = 4
_osi$24 = -36						; size = 148
__$ArrayPad$ = 112					; size = 4
_hImc$ = 124						; size = 4
?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z PROC		; CIME::ReadingProcess, COMDAT
; _this$ = ecx

; 1084 : {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 70	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1085 :     if (!ms_adwId[0])

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 00	 imul	 eax, eax, 0
  00021	83 b8 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 0
  00028	75 05		 jne	 SHORT $LN4@ReadingPro

; 1086 : 	{
; 1087 : 		return;

  0002a	e9 05 05 00 00	 jmp	 $LN1@ReadingPro
$LN4@ReadingPro:

; 1088 :     }
; 1089 : 
; 1090 :     DWORD dwErr = 0;

  0002f	83 65 c0 00	 and	 DWORD PTR _dwErr$[ebp], 0

; 1091 : 
; 1092 :     if (_GetReadingString)

  00033	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, 0 ; CIME::_GetReadingString
  0003a	0f 84 bc 00 00
	00		 je	 $LN5@ReadingPro

; 1093 : 	{
; 1094 :         UINT uMaxUiLen;
; 1095 :         BOOL bVertical;
; 1096 :         // Obtain the reading string size
; 1097 :         int wstrLen = _GetReadingString(hImc, 0, NULL, (PINT)&dwErr, &bVertical, &uMaxUiLen);

  00040	8d 45 88	 lea	 eax, DWORD PTR _uMaxUiLen$9[ebp]
  00043	50		 push	 eax
  00044	8d 45 a4	 lea	 eax, DWORD PTR _bVertical$12[ebp]
  00047	50		 push	 eax
  00048	8d 45 c0	 lea	 eax, DWORD PTR _dwErr$[ebp]
  0004b	50		 push	 eax
  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	ff 75 7c	 push	 DWORD PTR _hImc$[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA ; CIME::_GetReadingString
  00059	89 45 b8	 mov	 DWORD PTR _wstrLen$18[ebp], eax

; 1098 : 
; 1099 : 		if(wstrLen == 0) {

  0005c	83 7d b8 00	 cmp	 DWORD PTR _wstrLen$18[ebp], 0
  00060	75 12		 jne	 SHORT $LN7@ReadingPro
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  00062	8d 45 b7	 lea	 eax, DWORD PTR $T17[ebp]
  00065	50		 push	 eax
  00066	6a 00		 push	 0
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  0006d	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1101 : 		} else {

  00072	eb 68		 jmp	 SHORT $LN8@ReadingPro
$LN7@ReadingPro:

; 1102 : 			wchar_t *wstr = (wchar_t*)alloca(sizeof(wchar_t) * wstrLen);

  00074	8b 45 b8	 mov	 eax, DWORD PTR _wstrLen$18[ebp]
  00077	d1 e0		 shl	 eax, 1
  00079	e8 00 00 00 00	 call	 __alloca_probe_16
  0007e	89 a5 50 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], esp
  00084	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv81[ebp]
  0008a	89 45 b0	 mov	 DWORD PTR _wstr$15[ebp], eax

; 1103 :             _GetReadingString(hImc, wstrLen, wstr, (PINT)&dwErr, &bVertical, &uMaxUiLen);

  0008d	8d 45 88	 lea	 eax, DWORD PTR _uMaxUiLen$9[ebp]
  00090	50		 push	 eax
  00091	8d 45 a4	 lea	 eax, DWORD PTR _bVertical$12[ebp]
  00094	50		 push	 eax
  00095	8d 45 c0	 lea	 eax, DWORD PTR _dwErr$[ebp]
  00098	50		 push	 eax
  00099	ff 75 b0	 push	 DWORD PTR _wstr$15[ebp]
  0009c	ff 75 b8	 push	 DWORD PTR _wstrLen$18[ebp]
  0009f	ff 75 7c	 push	 DWORD PTR _hImc$[ebp]
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA ; CIME::_GetReadingString

; 1104 : 			ms_wstrReading.assign(wstr, wstr+wstrLen);

  000a8	8b 45 b8	 mov	 eax, DWORD PTR _wstrLen$18[ebp]
  000ab	8b 4d b0	 mov	 ecx, DWORD PTR _wstr$15[ebp]
  000ae	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000b1	89 45 84	 mov	 DWORD PTR __Last$[ebp], eax
  000b4	8b 45 b0	 mov	 eax, DWORD PTR _wstr$15[ebp]
  000b7	89 85 7c ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1303 :         return _It + 0;

  000bd	8b 45 84	 mov	 eax, DWORD PTR __Last$[ebp]
  000c0	89 45 80	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1142 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

  000c3	ff b5 4c ff ff
	ff		 push	 DWORD PTR $T3[ebp]
  000c9	ff 75 80	 push	 DWORD PTR $T8[ebp]
  000cc	ff b5 7c ff ff
	ff		 push	 DWORD PTR __First$[ebp]
  000d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  000d7	e8 00 00 00 00	 call	 ??$_Assign_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_range<wchar_t *>
$LN8@ReadingPro:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1107 : 		ms_bHorizontalReading = (bVertical == 0);

  000dc	83 7d a4 00	 cmp	 DWORD PTR _bVertical$12[ebp], 0
  000e0	75 09		 jne	 SHORT $LN32@ReadingPro
  000e2	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv94[ebp], 1
  000e9	eb 04		 jmp	 SHORT $LN33@ReadingPro
$LN32@ReadingPro:
  000eb	83 65 a0 00	 and	 DWORD PTR tv94[ebp], 0
$LN33@ReadingPro:
  000ef	8a 45 a0	 mov	 al, BYTE PTR tv94[ebp]
  000f2	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bHorizontalReading@CIME@@2_NA, al ; CIME::ms_bHorizontalReading

; 1108 : 
; 1109 :     } else {

  000f7	e9 f5 03 00 00	 jmp	 $LN6@ReadingPro
$LN5@ReadingPro:

; 1110 : 
; 1111 :         // IMEs that doesn't implement Reading String API
; 1112 : 		wchar_t* temp = NULL;

  000fc	83 65 c8 00	 and	 DWORD PTR _temp$20[ebp], 0

; 1113 : 		DWORD tempLen = 0;

  00100	83 65 d0 00	 and	 DWORD PTR _tempLen$21[ebp], 0

; 1114 : 	    bool bUnicodeIme = false;

  00104	c6 45 d7 00	 mov	 BYTE PTR _bUnicodeIme$22[ebp], 0

; 1115 : 		INPUTCONTEXT *lpIC = _ImmLockIMC(hImc);

  00108	ff 75 7c	 push	 DWORD PTR _hImc$[ebp]
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmLockIMC@CIME@@1P6GPAU__MIDL___MIDL_itf_dimm_0000_0012@@PAUHIMC__@@@ZA ; CIME::_ImmLockIMC
  00111	89 45 bc	 mov	 DWORD PTR _lpIC$19[ebp], eax

; 1116 : 
; 1117 : 		if (lpIC == NULL)

  00114	83 7d bc 00	 cmp	 DWORD PTR _lpIC$19[ebp], 0
  00118	75 0d		 jne	 SHORT $LN9@ReadingPro

; 1118 : 		{
; 1119 : 			temp = NULL;

  0011a	83 65 c8 00	 and	 DWORD PTR _temp$20[ebp], 0

; 1120 : 			tempLen = 0;

  0011e	83 65 d0 00	 and	 DWORD PTR _tempLen$21[ebp], 0

; 1121 : 		}

  00122	e9 ac 02 00 00	 jmp	 $LN10@ReadingPro
$LN9@ReadingPro:

; 1122 : 		else
; 1123 : 		{
; 1124 : 			LPBYTE p = 0;

  00127	83 65 d8 00	 and	 DWORD PTR _p$23[ebp], 0

; 1125 : 			switch(ms_adwId[0])

  0012b	6a 04		 push	 4
  0012d	58		 pop	 eax
  0012e	6b c0 00	 imul	 eax, eax, 0
  00131	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR ?ms_adwId@CIME@@2PAKA[eax]
  00137	89 45 c4	 mov	 DWORD PTR tv133[ebp], eax
  0013a	81 7d c4 04 04
	04 04		 cmp	 DWORD PTR tv133[ebp], 67372036 ; 04040404H
  00141	77 3a		 ja	 SHORT $LN42@ReadingPro
  00143	81 7d c4 04 04
	04 04		 cmp	 DWORD PTR tv133[ebp], 67372036 ; 04040404H
  0014a	74 66		 je	 SHORT $LN11@ReadingPro
  0014c	81 7d c4 04 08
	01 04		 cmp	 DWORD PTR tv133[ebp], 67176452 ; 04010804H
  00153	0f 84 53 01 00
	00		 je	 $LN19@ReadingPro
  00159	81 7d c4 04 04
	02 04		 cmp	 DWORD PTR tv133[ebp], 67240964 ; 04020404H
  00160	74 50		 je	 SHORT $LN11@ReadingPro
  00162	81 7d c4 04 08
	02 04		 cmp	 DWORD PTR tv133[ebp], 67241988 ; 04020804H
  00169	0f 84 d1 01 00
	00		 je	 $LN21@ReadingPro
  0016f	81 7d c4 04 04
	03 04		 cmp	 DWORD PTR tv133[ebp], 67306500 ; 04030404H
  00176	74 3a		 je	 SHORT $LN11@ReadingPro
  00178	e9 4e 02 00 00	 jmp	 $LN23@ReadingPro
$LN42@ReadingPro:
  0017d	81 7d c4 04 04
	00 05		 cmp	 DWORD PTR tv133[ebp], 83887108 ; 05000404H
  00184	74 76		 je	 SHORT $LN13@ReadingPro
  00186	81 7d c4 04 04
	01 05		 cmp	 DWORD PTR tv133[ebp], 83952644 ; 05010404H
  0018d	0f 84 c1 00 00
	00		 je	 $LN16@ReadingPro
  00193	81 7d c4 04 04
	02 05		 cmp	 DWORD PTR tv133[ebp], 84018180 ; 05020404H
  0019a	0f 84 b4 00 00
	00		 je	 $LN16@ReadingPro
  001a0	81 7d c4 04 08
	03 05		 cmp	 DWORD PTR tv133[ebp], 84084740 ; 05030804H
  001a7	0f 84 a7 00 00
	00		 je	 $LN16@ReadingPro
  001ad	e9 19 02 00 00	 jmp	 $LN23@ReadingPro
$LN11@ReadingPro:

; 1126 : 			{
; 1127 : 				case IMEID_CHT_VER42: // New(Phonetic/ChanJie)IME98  : 4.2.x.x // Win98
; 1128 : 				case IMEID_CHT_VER43: // New(Phonetic/ChanJie)IME98a : 4.3.x.x // WinMe, Win2k
; 1129 : 				case IMEID_CHT_VER44: // New ChanJie IME98b          : 4.4.x.x // WinXP
; 1130 : 					p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + 24);

  001b2	8b 45 bc	 mov	 eax, DWORD PTR _lpIC$19[ebp]
  001b5	ff b0 24 01 00
	00		 push	 DWORD PTR [eax+292]
  001bb	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  001c1	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  001c4	89 45 d8	 mov	 DWORD PTR _p$23[ebp], eax

; 1131 : 					if (!p) break;

  001c7	83 7d d8 00	 cmp	 DWORD PTR _p$23[ebp], 0
  001cb	75 05		 jne	 SHORT $LN12@ReadingPro
  001cd	e9 01 02 00 00	 jmp	 $LN10@ReadingPro
$LN12@ReadingPro:

; 1132 : 					tempLen = *(DWORD *)(p + 7 * 4 + 32 * 4);

  001d2	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  001d5	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [eax+156]
  001db	89 45 d0	 mov	 DWORD PTR _tempLen$21[ebp], eax

; 1133 : 					dwErr = *(DWORD *)(p + 8 * 4 + 32 * 4);

  001de	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  001e1	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [eax+160]
  001e7	89 45 c0	 mov	 DWORD PTR _dwErr$[ebp], eax

; 1134 : 					temp = (wchar_t *)(p + 56);

  001ea	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  001ed	83 c0 38	 add	 eax, 56			; 00000038H
  001f0	89 45 c8	 mov	 DWORD PTR _temp$20[ebp], eax

; 1135 : 					bUnicodeIme = true;

  001f3	c6 45 d7 01	 mov	 BYTE PTR _bUnicodeIme$22[ebp], 1

; 1136 : 					break;

  001f7	e9 d7 01 00 00	 jmp	 $LN10@ReadingPro
$LN13@ReadingPro:

; 1137 : 
; 1138 : 				case IMEID_CHT_VER50: // 5.0.x.x // WinME
; 1139 : 					p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + 3 * 4);

  001fc	8b 45 bc	 mov	 eax, DWORD PTR _lpIC$19[ebp]
  001ff	ff b0 24 01 00
	00		 push	 DWORD PTR [eax+292]
  00205	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  0020b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0020e	89 45 d8	 mov	 DWORD PTR _p$23[ebp], eax

; 1140 : 					if(!p) break;

  00211	83 7d d8 00	 cmp	 DWORD PTR _p$23[ebp], 0
  00215	75 05		 jne	 SHORT $LN14@ReadingPro
  00217	e9 b7 01 00 00	 jmp	 $LN10@ReadingPro
$LN14@ReadingPro:

; 1141 : 					p = *(LPBYTE *)((LPBYTE)p + 1*4 + 5*4 + 4*2);

  0021c	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  0021f	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00222	89 45 d8	 mov	 DWORD PTR _p$23[ebp], eax

; 1142 : 					if(!p) break;

  00225	83 7d d8 00	 cmp	 DWORD PTR _p$23[ebp], 0
  00229	75 05		 jne	 SHORT $LN15@ReadingPro
  0022b	e9 a3 01 00 00	 jmp	 $LN10@ReadingPro
$LN15@ReadingPro:

; 1143 : 					tempLen = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16);

  00230	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  00233	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00236	89 45 d0	 mov	 DWORD PTR _tempLen$21[ebp], eax

; 1144 : 					dwErr = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 + 1*4);

  00239	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  0023c	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  0023f	89 45 c0	 mov	 DWORD PTR _dwErr$[ebp], eax

; 1145 : 					temp = (wchar_t *)(p + 1*4 + (16*2+2*4) + 5*4);

  00242	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  00245	83 c0 40	 add	 eax, 64			; 00000040H
  00248	89 45 c8	 mov	 DWORD PTR _temp$20[ebp], eax

; 1146 : 					bUnicodeIme = false;

  0024b	c6 45 d7 00	 mov	 BYTE PTR _bUnicodeIme$22[ebp], 0

; 1147 : 					break;

  0024f	e9 7f 01 00 00	 jmp	 $LN10@ReadingPro
$LN16@ReadingPro:

; 1148 : 
; 1149 : 				case IMEID_CHT_VER51: // 5.1.x.x // IME2002(w/OfficeXP)
; 1150 : 				case IMEID_CHT_VER52: // 5.2.x.x // (w/whistler)
; 1151 : 				case IMEID_CHS_VER53: // 5.3.x.x // SCIME2k or MSPY3 (w/OfficeXP and Whistler)
; 1152 : 					p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + 4);

  00254	8b 45 bc	 mov	 eax, DWORD PTR _lpIC$19[ebp]
  00257	ff b0 24 01 00
	00		 push	 DWORD PTR [eax+292]
  0025d	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  00263	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00266	89 45 d8	 mov	 DWORD PTR _p$23[ebp], eax

; 1153 : 					if(!p) break;

  00269	83 7d d8 00	 cmp	 DWORD PTR _p$23[ebp], 0
  0026d	75 05		 jne	 SHORT $LN17@ReadingPro
  0026f	e9 5f 01 00 00	 jmp	 $LN10@ReadingPro
$LN17@ReadingPro:

; 1154 : 					p = *(LPBYTE *)((LPBYTE)p + 1*4 + 5*4);

  00274	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  00277	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0027a	89 45 d8	 mov	 DWORD PTR _p$23[ebp], eax

; 1155 : 					if(!p) break;

  0027d	83 7d d8 00	 cmp	 DWORD PTR _p$23[ebp], 0
  00281	75 05		 jne	 SHORT $LN18@ReadingPro
  00283	e9 4b 01 00 00	 jmp	 $LN10@ReadingPro
$LN18@ReadingPro:

; 1156 : 					tempLen = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 * 2);

  00288	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  0028b	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0028e	89 45 d0	 mov	 DWORD PTR _tempLen$21[ebp], eax

; 1157 : 					dwErr = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 * 2 + 1*4);

  00291	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  00294	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  00297	89 45 c0	 mov	 DWORD PTR _dwErr$[ebp], eax

; 1158 : 					temp  = (wchar_t *) (p + 1*4 + (16*2+2*4) + 5*4);

  0029a	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  0029d	83 c0 40	 add	 eax, 64			; 00000040H
  002a0	89 45 c8	 mov	 DWORD PTR _temp$20[ebp], eax

; 1159 : 					bUnicodeIme = true;

  002a3	c6 45 d7 01	 mov	 BYTE PTR _bUnicodeIme$22[ebp], 1

; 1160 : 					break;

  002a7	e9 27 01 00 00	 jmp	 $LN10@ReadingPro
$LN19@ReadingPro:

; 1161 : 
; 1162 : 				// the code tested only with Win 98 SE (MSPY 1.5/ ver 4.1.0.21)
; 1163 : 				case IMEID_CHS_VER41:
; 1164 : 					{
; 1165 : 						int nOffset;
; 1166 : 						nOffset = (ms_adwId[1] >= 0x00000002) ? 8 : 7;

  002ac	6a 04		 push	 4
  002ae	58		 pop	 eax
  002af	c1 e0 00	 shl	 eax, 0
  002b2	83 b8 00 00 00
	00 02		 cmp	 DWORD PTR ?ms_adwId@CIME@@2PAKA[eax], 2
  002b9	72 09		 jb	 SHORT $LN34@ReadingPro
  002bb	c7 45 9c 08 00
	00 00		 mov	 DWORD PTR tv188[ebp], 8
  002c2	eb 07		 jmp	 SHORT $LN35@ReadingPro
$LN34@ReadingPro:
  002c4	c7 45 9c 07 00
	00 00		 mov	 DWORD PTR tv188[ebp], 7
$LN35@ReadingPro:
  002cb	8b 45 9c	 mov	 eax, DWORD PTR tv188[ebp]
  002ce	89 85 78 ff ff
	ff		 mov	 DWORD PTR _nOffset$7[ebp], eax

; 1167 : 
; 1168 : 						p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + nOffset * 4);

  002d4	8b 45 bc	 mov	 eax, DWORD PTR _lpIC$19[ebp]
  002d7	ff b0 24 01 00
	00		 push	 DWORD PTR [eax+292]
  002dd	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  002e3	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _nOffset$7[ebp]
  002e9	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  002ec	89 45 d8	 mov	 DWORD PTR _p$23[ebp], eax

; 1169 : 						if(!p) break;

  002ef	83 7d d8 00	 cmp	 DWORD PTR _p$23[ebp], 0
  002f3	75 05		 jne	 SHORT $LN20@ReadingPro
  002f5	e9 d9 00 00 00	 jmp	 $LN10@ReadingPro
$LN20@ReadingPro:

; 1170 : 						tempLen = *(DWORD *)(p + 7*4 + 16*2*4);

  002fa	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  002fd	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [eax+156]
  00303	89 45 d0	 mov	 DWORD PTR _tempLen$21[ebp], eax

; 1171 : 						dwErr = *(DWORD *)(p + 8*4 + 16*2*4);

  00306	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  00309	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [eax+160]
  0030f	89 45 c0	 mov	 DWORD PTR _dwErr$[ebp], eax

; 1172 : 						dwErr = min(dwErr, tempLen);

  00312	8b 45 c0	 mov	 eax, DWORD PTR _dwErr$[ebp]
  00315	3b 45 d0	 cmp	 eax, DWORD PTR _tempLen$21[ebp]
  00318	73 08		 jae	 SHORT $LN36@ReadingPro
  0031a	8b 45 c0	 mov	 eax, DWORD PTR _dwErr$[ebp]
  0031d	89 45 98	 mov	 DWORD PTR tv200[ebp], eax
  00320	eb 06		 jmp	 SHORT $LN37@ReadingPro
$LN36@ReadingPro:
  00322	8b 45 d0	 mov	 eax, DWORD PTR _tempLen$21[ebp]
  00325	89 45 98	 mov	 DWORD PTR tv200[ebp], eax
$LN37@ReadingPro:
  00328	8b 45 98	 mov	 eax, DWORD PTR tv200[ebp]
  0032b	89 45 c0	 mov	 DWORD PTR _dwErr$[ebp], eax

; 1173 : 						temp = (wchar_t *)(p + 6*4 + 16*2*1);

  0032e	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  00331	83 c0 38	 add	 eax, 56			; 00000038H
  00334	89 45 c8	 mov	 DWORD PTR _temp$20[ebp], eax

; 1174 : 						bUnicodeIme = true;

  00337	c6 45 d7 01	 mov	 BYTE PTR _bUnicodeIme$22[ebp], 1

; 1175 : 					}
; 1176 : 					break;

  0033b	e9 93 00 00 00	 jmp	 $LN10@ReadingPro
$LN21@ReadingPro:

; 1177 : 
; 1178 : 				case IMEID_CHS_VER42: // 4.2.x.x // SCIME98 or MSPY2 (w/Office2k, Win2k, WinME, etc)
; 1179 : 					{
; 1180 : 						OSVERSIONINFOA osi;
; 1181 : 						osi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

  00340	c7 45 dc 94 00
	00 00		 mov	 DWORD PTR _osi$24[ebp], 148 ; 00000094H

; 1182 : 						GetVersionExA(&osi);

  00347	8d 45 dc	 lea	 eax, DWORD PTR _osi$24[ebp]
  0034a	50		 push	 eax
  0034b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 1183 : 
; 1184 : 						int nTcharSize = (osi.dwPlatformId == VER_PLATFORM_WIN32_NT) ? sizeof(wchar_t) : sizeof(char);

  00351	83 7d ec 02	 cmp	 DWORD PTR _osi$24[ebp+16], 2
  00355	75 09		 jne	 SHORT $LN38@ReadingPro
  00357	c7 45 94 02 00
	00 00		 mov	 DWORD PTR tv205[ebp], 2
  0035e	eb 07		 jmp	 SHORT $LN39@ReadingPro
$LN38@ReadingPro:
  00360	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv205[ebp], 1
$LN39@ReadingPro:
  00367	8b 45 94	 mov	 eax, DWORD PTR tv205[ebp]
  0036a	89 45 90	 mov	 DWORD PTR _nTcharSize$11[ebp], eax

; 1185 : 						p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + 1*4 + 1*4 + 6*4);

  0036d	8b 45 bc	 mov	 eax, DWORD PTR _lpIC$19[ebp]
  00370	ff b0 24 01 00
	00		 push	 DWORD PTR [eax+292]
  00376	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  0037c	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0037f	89 45 d8	 mov	 DWORD PTR _p$23[ebp], eax

; 1186 : 						if(!p) break;

  00382	83 7d d8 00	 cmp	 DWORD PTR _p$23[ebp], 0
  00386	75 02		 jne	 SHORT $LN22@ReadingPro
  00388	eb 49		 jmp	 SHORT $LN10@ReadingPro
$LN22@ReadingPro:

; 1187 : 						tempLen = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 * nTcharSize);

  0038a	8b 45 90	 mov	 eax, DWORD PTR _nTcharSize$11[ebp]
  0038d	c1 e0 04	 shl	 eax, 4
  00390	8b 4d d8	 mov	 ecx, DWORD PTR _p$23[ebp]
  00393	8b 44 01 40	 mov	 eax, DWORD PTR [ecx+eax+64]
  00397	89 45 d0	 mov	 DWORD PTR _tempLen$21[ebp], eax

; 1188 : 						dwErr = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 * nTcharSize + 1*4);

  0039a	8b 45 90	 mov	 eax, DWORD PTR _nTcharSize$11[ebp]
  0039d	c1 e0 04	 shl	 eax, 4
  003a0	8b 4d d8	 mov	 ecx, DWORD PTR _p$23[ebp]
  003a3	8b 44 01 44	 mov	 eax, DWORD PTR [ecx+eax+68]
  003a7	89 45 c0	 mov	 DWORD PTR _dwErr$[ebp], eax

; 1189 : 						temp  = (wchar_t *) (p + 1*4 + (16*2+2*4) + 5*4);

  003aa	8b 45 d8	 mov	 eax, DWORD PTR _p$23[ebp]
  003ad	83 c0 40	 add	 eax, 64			; 00000040H
  003b0	89 45 c8	 mov	 DWORD PTR _temp$20[ebp], eax

; 1190 : 						bUnicodeIme = (osi.dwPlatformId == VER_PLATFORM_WIN32_NT) ? true : false;

  003b3	83 7d ec 02	 cmp	 DWORD PTR _osi$24[ebp+16], 2
  003b7	75 06		 jne	 SHORT $LN40@ReadingPro
  003b9	c6 45 cf 01	 mov	 BYTE PTR tv228[ebp], 1
  003bd	eb 04		 jmp	 SHORT $LN41@ReadingPro
$LN40@ReadingPro:
  003bf	c6 45 cf 00	 mov	 BYTE PTR tv228[ebp], 0
$LN41@ReadingPro:
  003c3	8a 45 cf	 mov	 al, BYTE PTR tv228[ebp]
  003c6	88 45 d7	 mov	 BYTE PTR _bUnicodeIme$22[ebp], al

; 1191 : 					}
; 1192 : 					break;

  003c9	eb 08		 jmp	 SHORT $LN10@ReadingPro
$LN23@ReadingPro:

; 1193 : 
; 1194 : 				default:
; 1195 : 					temp = NULL;

  003cb	83 65 c8 00	 and	 DWORD PTR _temp$20[ebp], 0

; 1196 : 					tempLen = 0;

  003cf	83 65 d0 00	 and	 DWORD PTR _tempLen$21[ebp], 0
$LN10@ReadingPro:

; 1197 : 					break;
; 1198 : 			}
; 1199 : 		}
; 1200 : 
; 1201 : 		if(tempLen == 0) {

  003d3	83 7d d0 00	 cmp	 DWORD PTR _tempLen$21[ebp], 0
  003d7	75 15		 jne	 SHORT $LN24@ReadingPro
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  003d9	8d 45 b6	 lea	 eax, DWORD PTR $T16[ebp]
  003dc	50		 push	 eax
  003dd	6a 00		 push	 0
  003df	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  003e4	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1203 : 		} else {

  003e9	e9 db 00 00 00	 jmp	 $LN25@ReadingPro
$LN24@ReadingPro:

; 1204 : 			if(bUnicodeIme) {

  003ee	0f b6 45 d7	 movzx	 eax, BYTE PTR _bUnicodeIme$22[ebp]
  003f2	85 c0		 test	 eax, eax
  003f4	74 45		 je	 SHORT $LN26@ReadingPro

; 1205 : 				ms_wstrReading.assign(temp, temp+tempLen);

  003f6	8b 45 d0	 mov	 eax, DWORD PTR _tempLen$21[ebp]
  003f9	8b 4d c8	 mov	 ecx, DWORD PTR _temp$20[ebp]
  003fc	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  003ff	89 85 74 ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00405	8b 45 c8	 mov	 eax, DWORD PTR _temp$20[ebp]
  00408	89 85 6c ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1303 :         return _It + 0;

  0040e	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR __Last$[ebp]
  00414	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1142 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

  0041a	ff b5 48 ff ff
	ff		 push	 DWORD PTR $T2[ebp]
  00420	ff b5 70 ff ff
	ff		 push	 DWORD PTR $T6[ebp]
  00426	ff b5 6c ff ff
	ff		 push	 DWORD PTR __First$[ebp]
  0042c	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  00431	e8 00 00 00 00	 call	 ??$_Assign_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_range<wchar_t *>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1206 : 			} else {

  00436	e9 8e 00 00 00	 jmp	 $LN25@ReadingPro
$LN26@ReadingPro:

; 1207 : 				int wstrLen = MultiByteToWideChar(ms_uInputCodePage, 0, (char*)temp, tempLen, NULL, 0); 

  0043b	6a 00		 push	 0
  0043d	6a 00		 push	 0
  0043f	ff 75 d0	 push	 DWORD PTR _tempLen$21[ebp]
  00442	ff 75 c8	 push	 DWORD PTR _temp$20[ebp]
  00445	6a 00		 push	 0
  00447	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  0044d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00453	89 45 ac	 mov	 DWORD PTR _wstrLen$14[ebp], eax

; 1208 : 				wchar_t* wstr = (wchar_t*)alloca(sizeof(wchar_t)*wstrLen);

  00456	8b 45 ac	 mov	 eax, DWORD PTR _wstrLen$14[ebp]
  00459	d1 e0		 shl	 eax, 1
  0045b	e8 00 00 00 00	 call	 __alloca_probe_16
  00460	89 a5 68 ff ff
	ff		 mov	 DWORD PTR tv259[ebp], esp
  00466	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv259[ebp]
  0046c	89 45 a8	 mov	 DWORD PTR _wstr$13[ebp], eax

; 1209 : 				MultiByteToWideChar(ms_uInputCodePage, 0, (char*)temp, tempLen, wstr, wstrLen); 

  0046f	ff 75 ac	 push	 DWORD PTR _wstrLen$14[ebp]
  00472	ff 75 a8	 push	 DWORD PTR _wstr$13[ebp]
  00475	ff 75 d0	 push	 DWORD PTR _tempLen$21[ebp]
  00478	ff 75 c8	 push	 DWORD PTR _temp$20[ebp]
  0047b	6a 00		 push	 0
  0047d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  00483	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 1210 : 				ms_wstrReading.assign(wstr, wstr+wstrLen);

  00489	8b 45 ac	 mov	 eax, DWORD PTR _wstrLen$14[ebp]
  0048c	8b 4d a8	 mov	 ecx, DWORD PTR _wstr$13[ebp]
  0048f	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00492	89 85 64 ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00498	8b 45 a8	 mov	 eax, DWORD PTR _wstr$13[ebp]
  0049b	89 85 5c ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1303 :         return _It + 0;

  004a1	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR __Last$[ebp]
  004a7	89 85 60 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1142 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

  004ad	ff b5 44 ff ff
	ff		 push	 DWORD PTR $T1[ebp]
  004b3	ff b5 60 ff ff
	ff		 push	 DWORD PTR $T5[ebp]
  004b9	ff b5 5c ff ff
	ff		 push	 DWORD PTR __First$[ebp]
  004bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  004c4	e8 00 00 00 00	 call	 ??$_Assign_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_W0Uforward_iterator_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_range<wchar_t *>
$LN25@ReadingPro:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1214 : 		_ImmUnlockIMCC(lpIC->hPrivate);

  004c9	8b 45 bc	 mov	 eax, DWORD PTR _lpIC$19[ebp]
  004cc	ff b0 24 01 00
	00		 push	 DWORD PTR [eax+292]
  004d2	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmUnlockIMCC@CIME@@1P6GHPAUHIMCC__@@@ZA ; CIME::_ImmUnlockIMCC

; 1215 : 		_ImmUnlockIMC(hImc);

  004d8	ff 75 7c	 push	 DWORD PTR _hImc$[ebp]
  004db	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmUnlockIMC@CIME@@1P6GHPAUHIMC__@@@ZA ; CIME::_ImmUnlockIMC

; 1216 : 
; 1217 : 		ms_bHorizontalReading = GetReadingWindowOrientation();

  004e1	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004e7	e8 00 00 00 00	 call	 ?GetReadingWindowOrientation@CIME@@IAE_NXZ ; CIME::GetReadingWindowOrientation
  004ec	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bHorizontalReading@CIME@@2_NA, al ; CIME::ms_bHorizontalReading
$LN6@ReadingPro:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  004f1	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR __My_data$10[ebp], OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  004f8	8b 45 8c	 mov	 eax, DWORD PTR __My_data$10[ebp]
  004fb	8b 4d 8c	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  004fe	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00501	2b 01		 sub	 eax, DWORD PTR [ecx]
  00503	d1 f8		 sar	 eax, 1
  00505	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1219 : 	if (ms_wstrReading.size()) {

  0050b	74 22		 je	 SHORT $LN28@ReadingPro

; 1220 : 		ms_bReadingInformation = true;

  0050d	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bReadingInformation@CIME@@2_NA, 1 ; CIME::ms_bReadingInformation

; 1221 : 		if(ms_pEvent)

  00514	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  0051b	74 10		 je	 SHORT $LN30@ReadingPro

; 1222 : 			ms_pEvent->OnOpenReadingWnd();

  0051d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00522	8b 00		 mov	 eax, DWORD PTR [eax]
  00524	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0052a	ff 50 14	 call	 DWORD PTR [eax+20]
$LN30@ReadingPro:

; 1223 : 	} else {

  0052d	eb 05		 jmp	 SHORT $LN1@ReadingPro
$LN28@ReadingPro:

; 1224 : 		CloseReadingInformation();

  0052f	e8 00 00 00 00	 call	 ?CloseReadingInformation@CIME@@SAXXZ ; CIME::CloseReadingInformation
$LN1@ReadingPro:

; 1225 : 	}
; 1226 : }

  00534	8d a5 44 ff ff
	ff		 lea	 esp, DWORD PTR [ebp-188]
  0053a	8b 4d 70	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0053d	33 cd		 xor	 ecx, ebp
  0053f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00544	83 c5 74	 add	 ebp, 116		; 00000074H
  00547	c9		 leave
  00548	c2 04 00	 ret	 4
?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP		; CIME::ReadingProcess
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_abyCandidate$ = -88					; size = 12
_maxCandChar$2 = -76					; size = 4
__My_data$3 = -72					; size = 4
_this$ = -68						; size = 4
_this$ = -64						; size = 4
tv154 = -60						; size = 4
tv144 = -56						; size = 4
_uLen$4 = -52						; size = 4
_this$5 = -48						; size = 4
_j$6 = -44						; size = 4
_i$7 = -40						; size = 4
_cChars$8 = -36						; size = 4
_dwCandidateLen$ = -32					; size = 4
_iStartOfPage$9 = -28					; size = 4
_i$10 = -24						; size = 4
_lpCandidateList$11 = -20				; size = 4
$T12 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_hImc$ = 8						; size = 4
?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z PROC		; CIME::CandidateProcess, COMDAT
; _this$ = ecx

; 1026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00028	8d 45 a8	 lea	 eax, DWORD PTR _abyCandidate$[ebp]
  0002b	89 45 bc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 d0	 mov	 DWORD PTR _this$5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00034	8b 45 d0	 mov	 eax, DWORD PTR _this$5[ebp]
  00037	83 20 00	 and	 DWORD PTR [eax], 0
  0003a	8b 45 d0	 mov	 eax, DWORD PTR _this$5[ebp]
  0003d	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00041	8b 45 d0	 mov	 eax, DWORD PTR _this$5[ebp]
  00044	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1027 : 	std::vector<BYTE>	abyCandidate;

  00048	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1028 : 	DWORD dwCandidateLen = ImmGetCandidateListW(hImc, 0, NULL, 0);

  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00055	e8 00 00 00 00	 call	 _ImmGetCandidateListW@16
  0005a	89 45 e0	 mov	 DWORD PTR _dwCandidateLen$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  0005d	8d 45 f3	 lea	 eax, DWORD PTR $T12[ebp]
  00060	50		 push	 eax
  00061	ff 75 e0	 push	 DWORD PTR _dwCandidateLen$[ebp]
  00064	8d 4d a8	 lea	 ecx, DWORD PTR _abyCandidate$[ebp]
  00067	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1030 : 	if(dwCandidateLen > 0) {

  0006c	83 7d e0 00	 cmp	 DWORD PTR _dwCandidateLen$[ebp], 0
  00070	0f 86 fb 01 00
	00		 jbe	 $LN8@CandidateP

; 1031 : 		ms_bCandidateList = true;

  00076	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bCandidateList@CIME@@2_NA, 1 ; CIME::ms_bCandidateList
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0007d	8d 45 a8	 lea	 eax, DWORD PTR _abyCandidate$[ebp]
  00080	89 45 b8	 mov	 DWORD PTR __My_data$3[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00083	33 c0		 xor	 eax, eax
  00085	c1 e0 00	 shl	 eax, 0
  00088	8b 4d b8	 mov	 ecx, DWORD PTR __My_data$3[ebp]
  0008b	03 01		 add	 eax, DWORD PTR [ecx]
  0008d	89 45 ec	 mov	 DWORD PTR _lpCandidateList$11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1034 : 		dwCandidateLen = ImmGetCandidateListW(hImc, 0, lpCandidateList, dwCandidateLen);

  00090	ff 75 e0	 push	 DWORD PTR _dwCandidateLen$[ebp]
  00093	ff 75 ec	 push	 DWORD PTR _lpCandidateList$11[ebp]
  00096	6a 00		 push	 0
  00098	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  0009b	e8 00 00 00 00	 call	 _ImmGetCandidateListW@16
  000a0	89 45 e0	 mov	 DWORD PTR _dwCandidateLen$[ebp], eax

; 1035 : 
; 1036 : 		ms_dwCandidateSelection	= lpCandidateList->dwSelection;

  000a3	8b 45 ec	 mov	 eax, DWORD PTR _lpCandidateList$11[ebp]
  000a6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000a9	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection

; 1037 : 		ms_dwCandidateCount		= lpCandidateList->dwCount;

  000ae	8b 45 ec	 mov	 eax, DWORD PTR _lpCandidateList$11[ebp]
  000b1	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000b4	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateCount@CIME@@2KA, eax ; CIME::ms_dwCandidateCount

; 1038 : 
; 1039 : 		int iStartOfPage = 0;

  000b9	83 65 e4 00	 and	 DWORD PTR _iStartOfPage$9[ebp], 0

; 1040 : 
; 1041 : 		if( GETLANG() == LANG_CHS ) {

  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  000c2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000c7	0f b7 c0	 movzx	 eax, ax
  000ca	3d 04 08 00 00	 cmp	 eax, 2052		; 00000804H
  000cf	75 79		 jne	 SHORT $LN9@CandidateP

; 1042 : 			// MSPY (CHS IME) has variable number of candidates in candidate window find where current page starts, and the size of current page
; 1043 : 			const int maxCandChar = 18 * (3 - sizeof(TCHAR));

  000d1	c7 45 b4 24 00
	00 00		 mov	 DWORD PTR _maxCandChar$2[ebp], 36 ; 00000024H

; 1044 : 			UINT cChars = 0;

  000d8	83 65 dc 00	 and	 DWORD PTR _cChars$8[ebp], 0

; 1045 : 			UINT i;
; 1046 : 			for (i = 0; i < ms_dwCandidateCount; i++)

  000dc	83 65 e8 00	 and	 DWORD PTR _i$10[ebp], 0
  000e0	eb 07		 jmp	 SHORT $LN4@CandidateP
$LN2@CandidateP:
  000e2	8b 45 e8	 mov	 eax, DWORD PTR _i$10[ebp]
  000e5	40		 inc	 eax
  000e6	89 45 e8	 mov	 DWORD PTR _i$10[ebp], eax
$LN4@CandidateP:
  000e9	8b 45 e8	 mov	 eax, DWORD PTR _i$10[ebp]
  000ec	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_dwCandidateCount@CIME@@2KA ; CIME::ms_dwCandidateCount
  000f2	73 49		 jae	 SHORT $LN3@CandidateP

; 1047 : 			{
; 1048 : 				UINT uLen = lstrlenW((LPWSTR)((DWORD)lpCandidateList + lpCandidateList->dwOffset[i])) + (3 - sizeof(WCHAR));

  000f4	8b 45 e8	 mov	 eax, DWORD PTR _i$10[ebp]
  000f7	8b 4d ec	 mov	 ecx, DWORD PTR _lpCandidateList$11[ebp]
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _lpCandidateList$11[ebp]
  000fd	03 54 81 18	 add	 edx, DWORD PTR [ecx+eax*4+24]
  00101	52		 push	 edx
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00108	40		 inc	 eax
  00109	89 45 cc	 mov	 DWORD PTR _uLen$4[ebp], eax

; 1049 : 				if (uLen + cChars > maxCandChar)

  0010c	8b 45 cc	 mov	 eax, DWORD PTR _uLen$4[ebp]
  0010f	03 45 dc	 add	 eax, DWORD PTR _cChars$8[ebp]
  00112	83 f8 24	 cmp	 eax, 36			; 00000024H
  00115	76 1b		 jbe	 SHORT $LN11@CandidateP

; 1050 : 				{
; 1051 : 					if (i > ms_dwCandidateSelection)

  00117	8b 45 e8	 mov	 eax, DWORD PTR _i$10[ebp]
  0011a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection
  00120	76 02		 jbe	 SHORT $LN13@CandidateP

; 1052 : 					{
; 1053 : 						break;

  00122	eb 19		 jmp	 SHORT $LN3@CandidateP
$LN13@CandidateP:

; 1054 : 					}
; 1055 : 					iStartOfPage = i;

  00124	8b 45 e8	 mov	 eax, DWORD PTR _i$10[ebp]
  00127	89 45 e4	 mov	 DWORD PTR _iStartOfPage$9[ebp], eax

; 1056 : 					cChars = uLen;

  0012a	8b 45 cc	 mov	 eax, DWORD PTR _uLen$4[ebp]
  0012d	89 45 dc	 mov	 DWORD PTR _cChars$8[ebp], eax

; 1057 : 				}

  00130	eb 09		 jmp	 SHORT $LN12@CandidateP
$LN11@CandidateP:

; 1058 : 				else
; 1059 : 				{
; 1060 : 					cChars += uLen;

  00132	8b 45 dc	 mov	 eax, DWORD PTR _cChars$8[ebp]
  00135	03 45 cc	 add	 eax, DWORD PTR _uLen$4[ebp]
  00138	89 45 dc	 mov	 DWORD PTR _cChars$8[ebp], eax
$LN12@CandidateP:

; 1061 : 				}
; 1062 : 			}

  0013b	eb a5		 jmp	 SHORT $LN2@CandidateP
$LN3@CandidateP:

; 1063 : 			ms_dwCandidatePageSize	= i - iStartOfPage;

  0013d	8b 45 e8	 mov	 eax, DWORD PTR _i$10[ebp]
  00140	2b 45 e4	 sub	 eax, DWORD PTR _iStartOfPage$9[ebp]
  00143	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA, eax ; CIME::ms_dwCandidatePageSize

; 1064 : 		} else {

  00148	eb 42		 jmp	 SHORT $LN10@CandidateP
$LN9@CandidateP:

; 1065 : 			ms_dwCandidatePageSize	= MIN( lpCandidateList->dwPageSize, MAX_CANDLIST );

  0014a	6a 0a		 push	 10			; 0000000aH
  0014c	8b 45 ec	 mov	 eax, DWORD PTR _lpCandidateList$11[ebp]
  0014f	ff 70 14	 push	 DWORD PTR [eax+20]
  00152	e8 00 00 00 00	 call	 ?MIN@@YAHHH@Z		; MIN
  00157	59		 pop	 ecx
  00158	59		 pop	 ecx
  00159	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA, eax ; CIME::ms_dwCandidatePageSize

; 1066 : 			iStartOfPage = ms_bUILessMode ? lpCandidateList->dwPageStart : (ms_dwCandidateSelection / (MAX_CANDLIST - 1)) * (MAX_CANDLIST - 1);

  0015e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode
  00165	85 c0		 test	 eax, eax
  00167	74 0b		 je	 SHORT $LN17@CandidateP
  00169	8b 45 ec	 mov	 eax, DWORD PTR _lpCandidateList$11[ebp]
  0016c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0016f	89 45 c8	 mov	 DWORD PTR tv144[ebp], eax
  00172	eb 12		 jmp	 SHORT $LN18@CandidateP
$LN17@CandidateP:
  00174	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection
  00179	33 d2		 xor	 edx, edx
  0017b	6a 09		 push	 9
  0017d	59		 pop	 ecx
  0017e	f7 f1		 div	 ecx
  00180	6b c0 09	 imul	 eax, eax, 9
  00183	89 45 c8	 mov	 DWORD PTR tv144[ebp], eax
$LN18@CandidateP:
  00186	8b 45 c8	 mov	 eax, DWORD PTR tv144[ebp]
  00189	89 45 e4	 mov	 DWORD PTR _iStartOfPage$9[ebp], eax
$LN10@CandidateP:

; 1067 : 		}
; 1068 : 
; 1069 : 		ms_dwCandidateSelection = ( GETLANG() == LANG_CHS && !GetImeId() ) ? (DWORD)-1 : ms_dwCandidateSelection - iStartOfPage;

  0018c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00191	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00196	0f b7 c0	 movzx	 eax, ax
  00199	3d 04 08 00 00	 cmp	 eax, 2052		; 00000804H
  0019e	75 14		 jne	 SHORT $LN19@CandidateP
  001a0	6a 00		 push	 0
  001a2	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	e8 00 00 00 00	 call	 ?GetImeId@CIME@@IAEKI@Z	; CIME::GetImeId
  001aa	85 c0		 test	 eax, eax
  001ac	75 06		 jne	 SHORT $LN19@CandidateP
  001ae	83 4d c4 ff	 or	 DWORD PTR tv154[ebp], -1
  001b2	eb 0b		 jmp	 SHORT $LN20@CandidateP
$LN19@CandidateP:
  001b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection
  001b9	2b 45 e4	 sub	 eax, DWORD PTR _iStartOfPage$9[ebp]
  001bc	89 45 c4	 mov	 DWORD PTR tv154[ebp], eax
$LN20@CandidateP:
  001bf	8b 45 c4	 mov	 eax, DWORD PTR tv154[ebp]
  001c2	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection

; 1070 : 
; 1071 : 		//printf( "SEL: %d, START: %d, PAGED: %d\n", ms_dwCandidateSelection, iStartOfPage, ms_dwCandidatePageSize );
; 1072 : 	    memset(&ms_wszCandidate, 0, sizeof(ms_wszCandidate));

  001c7	68 00 14 00 00	 push	 5120			; 00001400H
  001cc	6a 00		 push	 0
  001ce	68 00 00 00 00	 push	 OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  001d3	e8 00 00 00 00	 call	 _memset
  001d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1073 : 	    for(UINT i = iStartOfPage, j = 0; (DWORD)i < lpCandidateList->dwCount && j < ms_dwCandidatePageSize; i++, j++) {

  001db	8b 45 e4	 mov	 eax, DWORD PTR _iStartOfPage$9[ebp]
  001de	89 45 d8	 mov	 DWORD PTR _i$7[ebp], eax
  001e1	83 65 d4 00	 and	 DWORD PTR _j$6[ebp], 0
  001e5	eb 0e		 jmp	 SHORT $LN7@CandidateP
$LN5@CandidateP:
  001e7	8b 45 d8	 mov	 eax, DWORD PTR _i$7[ebp]
  001ea	40		 inc	 eax
  001eb	89 45 d8	 mov	 DWORD PTR _i$7[ebp], eax
  001ee	8b 45 d4	 mov	 eax, DWORD PTR _j$6[ebp]
  001f1	40		 inc	 eax
  001f2	89 45 d4	 mov	 DWORD PTR _j$6[ebp], eax
$LN7@CandidateP:
  001f5	8b 45 ec	 mov	 eax, DWORD PTR _lpCandidateList$11[ebp]
  001f8	8b 4d d8	 mov	 ecx, DWORD PTR _i$7[ebp]
  001fb	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  001fe	73 2e		 jae	 SHORT $LN6@CandidateP
  00200	8b 45 d4	 mov	 eax, DWORD PTR _j$6[ebp]
  00203	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA ; CIME::ms_dwCandidatePageSize
  00209	73 23		 jae	 SHORT $LN6@CandidateP

; 1074 : 			wcscpy( ms_wszCandidate[j], (LPWSTR)( (DWORD)lpCandidateList + lpCandidateList->dwOffset[i] ) );

  0020b	8b 45 d8	 mov	 eax, DWORD PTR _i$7[ebp]
  0020e	8b 4d ec	 mov	 ecx, DWORD PTR _lpCandidateList$11[ebp]
  00211	8b 55 ec	 mov	 edx, DWORD PTR _lpCandidateList$11[ebp]
  00214	03 54 81 18	 add	 edx, DWORD PTR [ecx+eax*4+24]
  00218	52		 push	 edx
  00219	8b 45 d4	 mov	 eax, DWORD PTR _j$6[ebp]
  0021c	c1 e0 09	 shl	 eax, 9
  0021f	05 00 00 00 00	 add	 eax, OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  00224	50		 push	 eax
  00225	e8 00 00 00 00	 call	 _wcscpy
  0022a	59		 pop	 ecx
  0022b	59		 pop	 ecx

; 1075 : 	    }

  0022c	eb b9		 jmp	 SHORT $LN5@CandidateP
$LN6@CandidateP:

; 1076 : 
; 1077 : 		// don't display selection in candidate list in case of Korean and old Chinese IME.
; 1078 : 		if ( GETPRIMLANG() == LANG_KOREAN || GETLANG() == LANG_CHT && !GetImeId() )

  0022e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00233	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00238	0f b7 c0	 movzx	 eax, ax
  0023b	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00240	0f b7 c0	 movzx	 eax, ax
  00243	83 f8 12	 cmp	 eax, 18			; 00000012H
  00246	74 22		 je	 SHORT $LN15@CandidateP
  00248	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0024d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00252	0f b7 c0	 movzx	 eax, ax
  00255	3d 04 04 00 00	 cmp	 eax, 1028		; 00000404H
  0025a	75 15		 jne	 SHORT $LN8@CandidateP
  0025c	6a 00		 push	 0
  0025e	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00261	e8 00 00 00 00	 call	 ?GetImeId@CIME@@IAEKI@Z	; CIME::GetImeId
  00266	85 c0		 test	 eax, eax
  00268	75 07		 jne	 SHORT $LN8@CandidateP
$LN15@CandidateP:

; 1079 : 			ms_dwCandidateSelection = (DWORD) -1;

  0026a	83 0d 00 00 00
	00 ff		 or	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, -1 ; CIME::ms_dwCandidateSelection
$LN8@CandidateP:

; 1081 : }

  00271	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00275	8d 4d a8	 lea	 ecx, DWORD PTR _abyCandidate$[ebp]
  00278	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1081 : }

  0027d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00280	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00287	59		 pop	 ecx
  00288	c9		 leave
  00289	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z$0:
  00000	8d 4d a8	 lea	 ecx, DWORD PTR _abyCandidate$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP		; CIME::CandidateProcess
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_this$ = -128						; size = 4
_attributeLen$ = -124					; size = 4
_end$ = -120						; size = 4
_start$ = -116						; size = 4
_attribute$ = -112					; size = 1024
__$ArrayPad$ = 912					; size = 4
_hImc$ = 924						; size = 4
?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z PROC		; CIME::AttributeProcess, COMDAT
; _this$ = ecx

; 1013 : {

  00000	55		 push	 ebp
  00001	8d ac 24 6c fc
	ff ff		 lea	 ebp, DWORD PTR [esp-916]
  00008	81 ec 14 04 00
	00		 sub	 esp, 1044		; 00000414H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 90 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 80	 mov	 DWORD PTR _this$[ebp], ecx

; 1014 : 	BYTE	attribute[IMESTR_MAXLEN];
; 1015 : 	LONG	attributeLen = ImmGetCompositionStringW(hImc, GCS_COMPATTR, &attribute, sizeof(attribute)) / sizeof(BYTE);

  0001e	68 00 04 00 00	 push	 1024			; 00000400H
  00023	8d 45 90	 lea	 eax, DWORD PTR _attribute$[ebp]
  00026	50		 push	 eax
  00027	6a 10		 push	 16			; 00000010H
  00029	ff b5 9c 03 00
	00		 push	 DWORD PTR _hImc$[ebp]
  0002f	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  00034	89 45 84	 mov	 DWORD PTR _attributeLen$[ebp], eax

; 1016 : 
; 1017 : 	int start,end;
; 1018 : 	for(start=0; start<attributeLen; ++start) if(attribute[start]==ATTR_TARGET_CONVERTED || attribute[start]==ATTR_TARGET_NOTCONVERTED) break;

  00037	83 65 8c 00	 and	 DWORD PTR _start$[ebp], 0
  0003b	eb 07		 jmp	 SHORT $LN4@AttributeP
$LN2@AttributeP:
  0003d	8b 45 8c	 mov	 eax, DWORD PTR _start$[ebp]
  00040	40		 inc	 eax
  00041	89 45 8c	 mov	 DWORD PTR _start$[ebp], eax
$LN4@AttributeP:
  00044	8b 45 8c	 mov	 eax, DWORD PTR _start$[ebp]
  00047	3b 45 84	 cmp	 eax, DWORD PTR _attributeLen$[ebp]
  0004a	7d 1e		 jge	 SHORT $LN3@AttributeP
  0004c	8b 45 8c	 mov	 eax, DWORD PTR _start$[ebp]
  0004f	0f b6 44 05 90	 movzx	 eax, BYTE PTR _attribute$[ebp+eax]
  00054	83 f8 01	 cmp	 eax, 1
  00057	74 0d		 je	 SHORT $LN9@AttributeP
  00059	8b 45 8c	 mov	 eax, DWORD PTR _start$[ebp]
  0005c	0f b6 44 05 90	 movzx	 eax, BYTE PTR _attribute$[ebp+eax]
  00061	83 f8 03	 cmp	 eax, 3
  00064	75 02		 jne	 SHORT $LN8@AttributeP
$LN9@AttributeP:
  00066	eb 02		 jmp	 SHORT $LN3@AttributeP
$LN8@AttributeP:
  00068	eb d3		 jmp	 SHORT $LN2@AttributeP
$LN3@AttributeP:

; 1019 : 	for(end=start; end<attributeLen; ++end) if(attribute[end]!=attribute[start]) break;

  0006a	8b 45 8c	 mov	 eax, DWORD PTR _start$[ebp]
  0006d	89 45 88	 mov	 DWORD PTR _end$[ebp], eax
  00070	eb 07		 jmp	 SHORT $LN7@AttributeP
$LN5@AttributeP:
  00072	8b 45 88	 mov	 eax, DWORD PTR _end$[ebp]
  00075	40		 inc	 eax
  00076	89 45 88	 mov	 DWORD PTR _end$[ebp], eax
$LN7@AttributeP:
  00079	8b 45 88	 mov	 eax, DWORD PTR _end$[ebp]
  0007c	3b 45 84	 cmp	 eax, DWORD PTR _attributeLen$[ebp]
  0007f	7d 18		 jge	 SHORT $LN6@AttributeP
  00081	8b 45 88	 mov	 eax, DWORD PTR _end$[ebp]
  00084	0f b6 44 05 90	 movzx	 eax, BYTE PTR _attribute$[ebp+eax]
  00089	8b 4d 8c	 mov	 ecx, DWORD PTR _start$[ebp]
  0008c	0f b6 4c 0d 90	 movzx	 ecx, BYTE PTR _attribute$[ebp+ecx]
  00091	3b c1		 cmp	 eax, ecx
  00093	74 02		 je	 SHORT $LN10@AttributeP
  00095	eb 02		 jmp	 SHORT $LN6@AttributeP
$LN10@AttributeP:
  00097	eb d9		 jmp	 SHORT $LN5@AttributeP
$LN6@AttributeP:

; 1020 : 
; 1021 : 	ms_ulbegin = start;

  00099	8b 45 8c	 mov	 eax, DWORD PTR _start$[ebp]
  0009c	a3 00 00 00 00	 mov	 DWORD PTR ?ms_ulbegin@CIME@@2HA, eax ; CIME::ms_ulbegin

; 1022 : 	ms_ulend = end;

  000a1	8b 45 88	 mov	 eax, DWORD PTR _end$[ebp]
  000a4	a3 00 00 00 00	 mov	 DWORD PTR ?ms_ulend@CIME@@2HA, eax ; CIME::ms_ulend

; 1023 : }

  000a9	8b 8d 90 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000af	33 cd		 xor	 ecx, ebp
  000b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b6	81 c5 94 03 00
	00		 add	 ebp, 916		; 00000394H
  000bc	c9		 leave
  000bd	c2 04 00	 ret	 4
?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP		; CIME::AttributeProcess
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hImc$ = 8						; size = 4
?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z PROC	; CIME::CompositionProcess, COMDAT
; _this$ = ecx

; 952  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 953  : 	ms_compLen = ImmGetCompositionStringW(hImc, GCS_COMPSTR, m_wszComposition, sizeof(m_wszComposition))/sizeof(wchar_t);

  00007	68 00 08 00 00	 push	 2048			; 00000800H
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 22	 add	 eax, 34			; 00000022H
  00012	50		 push	 eax
  00013	6a 08		 push	 8
  00015	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00018	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  0001d	d1 e8		 shr	 eax, 1
  0001f	a3 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, eax ; CIME::ms_compLen

; 954  : 
; 955  : 	//OutputDebugStringW( L"Composition: " );
; 956  : 	//OutputDebugStringW( m_wszComposition );
; 957  : 	//for( int i=0; i < (int) ms_compLen * 2; i++ ) {
; 958  : 	//	LPBYTE pbyData = (LPBYTE) m_wszComposition;
; 959  : 	//	pbyData += i;
; 960  : 	//	WCHAR tszName[32];
; 961  : 
; 962  : 	//	swprintf_s( tszName, L"%02X ", (unsigned int) *pbyData );
; 963  : 	//	OutputDebugStringW( tszName );
; 964  : 	//}
; 965  : 	//OutputDebugStringW( L"\n" );
; 966  : 
; 967  : 	if (IsMax(m_wszComposition, ms_compLen))

  00024	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_compLen@CIME@@2HA ; CIME::ms_compLen
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c0 22	 add	 eax, 34			; 00000022H
  00030	50		 push	 eax
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?IsMax@CIME@@IAE_NPB_WH@Z ; CIME::IsMax
  00039	0f b6 c0	 movzx	 eax, al
  0003c	85 c0		 test	 eax, eax
  0003e	74 15		 je	 SHORT $LN1@Compositio

; 968  : 	{
; 969  : 		ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);

  00040	6a 00		 push	 0
  00042	6a 04		 push	 4
  00044	6a 15		 push	 21			; 00000015H
  00046	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00049	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 970  : 		ms_compLen = 0;

  0004e	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen
$LN1@Compositio:

; 971  : 	}
; 972  : }

  00055	c9		 leave
  00056	c2 04 00	 ret	 4
?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP	; CIME::CompositionProcess
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_textLen$ = -8						; size = 4
_this$ = -4						; size = 4
_hImc$ = 8						; size = 4
?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z PROC ; CIME::CompositionProcessBuilding, COMDAT
; _this$ = ecx

; 975  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 976  : 	int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, m_wText, ms_lastpos, 0, 0, NULL, NULL);

  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00016	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  0001b	6a 00		 push	 0
  0001d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00029	89 45 f8	 mov	 DWORD PTR _textLen$[ebp], eax

; 977  : 
; 978  : 	if (textLen >= m_max)

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _textLen$[ebp]
  00032	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00035	7c 17		 jl	 SHORT $LN2@Compositio

; 979  : 	{
; 980  : 		ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);

  00037	6a 00		 push	 0
  00039	6a 04		 push	 4
  0003b	6a 15		 push	 21			; 00000015H
  0003d	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00040	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 981  : 		ms_compLen = 0;

  00045	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen

; 982  : 		return;

  0004c	eb 1d		 jmp	 SHORT $LN1@Compositio
$LN2@Compositio:

; 983  : 	}
; 984  : 	
; 985  : 	ms_compLen = ImmGetCompositionStringW(hImc, GCS_COMPSTR, m_wszComposition, sizeof(m_wszComposition))/sizeof(wchar_t);

  0004e	68 00 08 00 00	 push	 2048			; 00000800H
  00053	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00056	83 c0 22	 add	 eax, 34			; 00000022H
  00059	50		 push	 eax
  0005a	6a 08		 push	 8
  0005c	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  0005f	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  00064	d1 e8		 shr	 eax, 1
  00066	a3 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, eax ; CIME::ms_compLen
$LN1@Compositio:

; 986  : 
; 987  : 	//OutputDebugStringW( L"Composition: " );
; 988  : 	//OutputDebugStringW( m_wszComposition );
; 989  : 	//for( int i=0; i < (int) ms_compLen * 2; i++ ) {
; 990  : 	//	LPBYTE pbyData = (LPBYTE) m_wszComposition;
; 991  : 	//	pbyData += i;
; 992  : 	//	WCHAR tszName[32];
; 993  : 
; 994  : 	//	swprintf_s( tszName, L"%02X ", (unsigned int) *pbyData );
; 995  : 	//	OutputDebugStringW( tszName );
; 996  : 	//}
; 997  : 	//OutputDebugStringW( L"\n" );
; 998  : }

  0006b	c9		 leave
  0006c	c2 04 00	 ret	 4
?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z ENDP ; CIME::CompositionProcessBuilding
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_this$ = -128						; size = 4
_len$ = -124						; size = 4
_temp$ = -120						; size = 2048
__$ArrayPad$ = 1928					; size = 4
_hImc$ = 1940						; size = 4
?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z PROC		; CIME::ResultProcess, COMDAT
; _this$ = ecx

; 1001 : {

  00000	55		 push	 ebp
  00001	8d ac 24 74 f8
	ff ff		 lea	 ebp, DWORD PTR [esp-1932]
  00008	81 ec 0c 08 00
	00		 sub	 esp, 2060		; 0000080cH
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 88 07 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 80	 mov	 DWORD PTR _this$[ebp], ecx

; 1002 : 	wchar_t temp[IMESTR_MAXLEN];
; 1003 : 
; 1004 : 	int len = ImmGetCompositionStringW(hImc, GCS_RESULTSTR, temp, sizeof(temp))/sizeof(wchar_t);

  0001e	68 00 08 00 00	 push	 2048			; 00000800H
  00023	8d 45 88	 lea	 eax, DWORD PTR _temp$[ebp]
  00026	50		 push	 eax
  00027	68 00 08 00 00	 push	 2048			; 00000800H
  0002c	ff b5 94 07 00
	00		 push	 DWORD PTR _hImc$[ebp]
  00032	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  00037	d1 e8		 shr	 eax, 1
  00039	89 45 84	 mov	 DWORD PTR _len$[ebp], eax

; 1005 : 
; 1006 : 	if (len <= 0)

  0003c	83 7d 84 00	 cmp	 DWORD PTR _len$[ebp], 0
  00040	7f 02		 jg	 SHORT $LN2@ResultProc

; 1007 : 		return;

  00042	eb 0f		 jmp	 SHORT $LN1@ResultProc
$LN2@ResultProc:

; 1008 : 
; 1009 : 	InsertString(temp, len);

  00044	ff 75 84	 push	 DWORD PTR _len$[ebp]
  00047	8d 45 88	 lea	 eax, DWORD PTR _temp$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?InsertString@CIME@@IAEXPA_WH@Z ; CIME::InsertString
$LN1@ResultProc:

; 1010 : }

  00053	8b 8d 88 07 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00059	33 cd		 xor	 ecx, ebp
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	81 c5 8c 07 00
	00		 add	 ebp, 1932		; 0000078cH
  00066	c9		 leave
  00067	c2 04 00	 ret	 4
?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP		; CIME::ResultProcess
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCodePageFromLang@CIME@@IAEIG@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pri_langid$ = -12					; size = 4
tv66 = -8						; size = 4
tv69 = -4						; size = 4
_langid$ = 8						; size = 2
?GetCodePageFromLang@CIME@@IAEIG@Z PROC			; CIME::GetCodePageFromLang, COMDAT
; _this$ = ecx

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 879  : 	unsigned pri_langid = PRIMARYLANGID(langid);

  00009	0f b7 45 08	 movzx	 eax, WORD PTR _langid$[ebp]
  0000d	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00012	89 45 f4	 mov	 DWORD PTR _pri_langid$[ebp], eax

; 880  : 	switch (pri_langid)

  00015	8b 45 f4	 mov	 eax, DWORD PTR _pri_langid$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR tv66[ebp], eax
  0001b	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  0001e	48		 dec	 eax
  0001f	89 45 f8	 mov	 DWORD PTR tv66[ebp], eax
  00022	83 7d f8 2e	 cmp	 DWORD PTR tv66[ebp], 46	; 0000002eH
  00026	0f 87 aa 00 00
	00		 ja	 $LN21@GetCodePag
  0002c	8b 45 f8	 mov	 eax, DWORD PTR tv66[ebp]
  0002f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN23@GetCodePag[eax]
  00036	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN24@GetCodePag[eax*4]
$LN6@GetCodePag:

; 881  : 	{
; 882  : 		case LANG_JAPANESE:
; 883  : 			//setlocale(LC_ALL, ".932");
; 884  : 			return 932;

  0003d	b8 a4 03 00 00	 mov	 eax, 932		; 000003a4H
  00042	e9 94 00 00 00	 jmp	 $LN1@GetCodePag
$LN7@GetCodePag:

; 885  : 		case LANG_KOREAN:
; 886  : 			//setlocale(LC_ALL, ".949");
; 887  : 			return 949;

  00047	b8 b5 03 00 00	 mov	 eax, 949		; 000003b5H
  0004c	e9 8a 00 00 00	 jmp	 $LN1@GetCodePag
$LN8@GetCodePag:

; 888  : 		case LANG_CHINESE:
; 889  : 			{
; 890  : 				switch (SUBLANGID(langid))

  00051	0f b7 45 08	 movzx	 eax, WORD PTR _langid$[ebp]
  00055	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00058	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
  0005b	83 7d fc 01	 cmp	 DWORD PTR tv69[ebp], 1
  0005f	74 21		 je	 SHORT $LN10@GetCodePag
  00061	83 7d fc 02	 cmp	 DWORD PTR tv69[ebp], 2
  00065	74 14		 je	 SHORT $LN9@GetCodePag
  00067	83 7d fc 03	 cmp	 DWORD PTR tv69[ebp], 3
  0006b	74 15		 je	 SHORT $LN10@GetCodePag
  0006d	83 7d fc 04	 cmp	 DWORD PTR tv69[ebp], 4
  00071	74 08		 je	 SHORT $LN9@GetCodePag
  00073	83 7d fc 05	 cmp	 DWORD PTR tv69[ebp], 5
  00077	74 09		 je	 SHORT $LN10@GetCodePag
  00079	eb 0e		 jmp	 SHORT $LN4@GetCodePag
$LN9@GetCodePag:

; 891  : 				{
; 892  : 					case SUBLANG_CHINESE_SIMPLIFIED:
; 893  : 					case SUBLANG_CHINESE_SINGAPORE:
; 894  : 						//setlocale(LC_ALL, ".936");
; 895  : 						return 936;

  0007b	b8 a8 03 00 00	 mov	 eax, 936		; 000003a8H
  00080	eb 59		 jmp	 SHORT $LN1@GetCodePag
$LN10@GetCodePag:

; 896  : 					case SUBLANG_CHINESE_TRADITIONAL:
; 897  : 					case SUBLANG_CHINESE_MACAU:
; 898  : 					case SUBLANG_CHINESE_HONGKONG:
; 899  : 						//setlocale(LC_ALL, ".950");
; 900  : 						return 950;

  00082	b8 b6 03 00 00	 mov	 eax, 950		; 000003b6H
  00087	eb 52		 jmp	 SHORT $LN1@GetCodePag
$LN4@GetCodePag:

; 901  : 				}
; 902  : 			}
; 903  : 			//setlocale(LC_ALL, ".936");
; 904  : 			return 936;

  00089	b8 a8 03 00 00	 mov	 eax, 936		; 000003a8H
  0008e	eb 4b		 jmp	 SHORT $LN1@GetCodePag
$LN11@GetCodePag:

; 905  : 		case LANG_ARABIC:
; 906  : 			return 1256;

  00090	b8 e8 04 00 00	 mov	 eax, 1256		; 000004e8H
  00095	eb 44		 jmp	 SHORT $LN1@GetCodePag
$LN12@GetCodePag:

; 907  : 		case LANG_GREEK:
; 908  : 			//setlocale(LC_ALL, ".1253");
; 909  : 			return 1253;

  00097	b8 e5 04 00 00	 mov	 eax, 1253		; 000004e5H
  0009c	eb 3d		 jmp	 SHORT $LN1@GetCodePag
$LN13@GetCodePag:

; 910  : 		case LANG_TURKISH:
; 911  : 			//setlocale(LC_ALL, ".1254");
; 912  : 			return 1254;

  0009e	b8 e6 04 00 00	 mov	 eax, 1254		; 000004e6H
  000a3	eb 36		 jmp	 SHORT $LN1@GetCodePag
$LN14@GetCodePag:

; 913  : 		case LANG_HEBREW:
; 914  : 			//setlocale(LC_ALL, ".1255");
; 915  : 			return 1255;

  000a5	b8 e7 04 00 00	 mov	 eax, 1255		; 000004e7H
  000aa	eb 2f		 jmp	 SHORT $LN1@GetCodePag
$LN15@GetCodePag:

; 916  : 		case LANG_ESTONIAN:
; 917  : 		case LANG_LATVIAN:
; 918  : 		case LANG_LITHUANIAN:
; 919  : 			//setlocale(LC_ALL, ".1257");
; 920  : 			return 1257;

  000ac	b8 e9 04 00 00	 mov	 eax, 1257		; 000004e9H
  000b1	eb 28		 jmp	 SHORT $LN1@GetCodePag
$LN16@GetCodePag:

; 921  : 		case LANG_VIETNAMESE:
; 922  : 			return 1258;

  000b3	b8 ea 04 00 00	 mov	 eax, 1258		; 000004eaH
  000b8	eb 21		 jmp	 SHORT $LN1@GetCodePag
$LN17@GetCodePag:

; 923  : 		case LANG_THAI:
; 924  : 			//setlocale(LC_ALL, ".874");
; 925  : 			return 874;

  000ba	b8 6a 03 00 00	 mov	 eax, 874		; 0000036aH
  000bf	eb 1a		 jmp	 SHORT $LN1@GetCodePag
$LN18@GetCodePag:

; 926  : 		case LANG_CZECH:
; 927  : 		case LANG_HUNGARIAN:
; 928  : 		case LANG_POLISH:
; 929  : 		case LANG_CROATIAN:
; 930  : 		case LANG_MACEDONIAN:
; 931  : 		case LANG_ROMANIAN:
; 932  : 		case LANG_SLOVAK:
; 933  : 		case LANG_SLOVENIAN:
; 934  : 			//setlocale(LC_ALL, ".1250");
; 935  : 			return 1250;

  000c1	b8 e2 04 00 00	 mov	 eax, 1250		; 000004e2H
  000c6	eb 13		 jmp	 SHORT $LN1@GetCodePag
$LN19@GetCodePag:

; 936  : 		case LANG_RUSSIAN:
; 937  : 		case LANG_BELARUSIAN:
; 938  : 		case LANG_BULGARIAN:
; 939  : 		case LANG_UKRAINIAN:
; 940  : 			return 1251;

  000c8	b8 e3 04 00 00	 mov	 eax, 1251		; 000004e3H
  000cd	eb 0c		 jmp	 SHORT $LN1@GetCodePag
$LN20@GetCodePag:

; 941  : 		case LANG_GERMAN:
; 942  : 			//_wsetlocale(LC_ALL, ".1252");
; 943  : 			return 1252;

  000cf	b8 e4 04 00 00	 mov	 eax, 1252		; 000004e4H
  000d4	eb 05		 jmp	 SHORT $LN1@GetCodePag
$LN21@GetCodePag:

; 944  : 		default:
; 945  : 			//TraceError("UNKNOWN IME[%d]\n", langid);
; 946  : 			//setlocale(LC_ALL, ".949");
; 947  : 			return 1252;

  000d6	b8 e4 04 00 00	 mov	 eax, 1252		; 000004e4H
$LN1@GetCodePag:

; 948  : 	}
; 949  : }

  000db	c9		 leave
  000dc	c2 04 00	 ret	 4
  000df	90		 npad	 1
$LN24@GetCodePag:
  000e0	00 00 00 00	 DD	 $LN11@GetCodePag
  000e4	00 00 00 00	 DD	 $LN19@GetCodePag
  000e8	00 00 00 00	 DD	 $LN8@GetCodePag
  000ec	00 00 00 00	 DD	 $LN18@GetCodePag
  000f0	00 00 00 00	 DD	 $LN20@GetCodePag
  000f4	00 00 00 00	 DD	 $LN12@GetCodePag
  000f8	00 00 00 00	 DD	 $LN14@GetCodePag
  000fc	00 00 00 00	 DD	 $LN6@GetCodePag
  00100	00 00 00 00	 DD	 $LN7@GetCodePag
  00104	00 00 00 00	 DD	 $LN17@GetCodePag
  00108	00 00 00 00	 DD	 $LN13@GetCodePag
  0010c	00 00 00 00	 DD	 $LN15@GetCodePag
  00110	00 00 00 00	 DD	 $LN16@GetCodePag
  00114	00 00 00 00	 DD	 $LN21@GetCodePag
$LN23@GetCodePag:
  00118	00		 DB	 0
  00119	01		 DB	 1
  0011a	0d		 DB	 13			; 0000000dH
  0011b	02		 DB	 2
  0011c	03		 DB	 3
  0011d	0d		 DB	 13			; 0000000dH
  0011e	04		 DB	 4
  0011f	05		 DB	 5
  00120	0d		 DB	 13			; 0000000dH
  00121	0d		 DB	 13			; 0000000dH
  00122	0d		 DB	 13			; 0000000dH
  00123	0d		 DB	 13			; 0000000dH
  00124	06		 DB	 6
  00125	03		 DB	 3
  00126	0d		 DB	 13			; 0000000dH
  00127	0d		 DB	 13			; 0000000dH
  00128	07		 DB	 7
  00129	08		 DB	 8
  0012a	0d		 DB	 13			; 0000000dH
  0012b	0d		 DB	 13			; 0000000dH
  0012c	03		 DB	 3
  0012d	0d		 DB	 13			; 0000000dH
  0012e	0d		 DB	 13			; 0000000dH
  0012f	03		 DB	 3
  00130	01		 DB	 1
  00131	03		 DB	 3
  00132	03		 DB	 3
  00133	0d		 DB	 13			; 0000000dH
  00134	0d		 DB	 13			; 0000000dH
  00135	09		 DB	 9
  00136	0a		 DB	 10			; 0000000aH
  00137	0d		 DB	 13			; 0000000dH
  00138	0d		 DB	 13			; 0000000dH
  00139	01		 DB	 1
  0013a	01		 DB	 1
  0013b	03		 DB	 3
  0013c	0b		 DB	 11			; 0000000bH
  0013d	0b		 DB	 11			; 0000000bH
  0013e	0b		 DB	 11			; 0000000bH
  0013f	0d		 DB	 13			; 0000000dH
  00140	0d		 DB	 13			; 0000000dH
  00141	0c		 DB	 12			; 0000000cH
  00142	0d		 DB	 13			; 0000000dH
  00143	0d		 DB	 13			; 0000000dH
  00144	0d		 DB	 13			; 0000000dH
  00145	0d		 DB	 13			; 0000000dH
  00146	03		 DB	 3
?GetCodePageFromLang@CIME@@IAEIG@Z ENDP			; CIME::GetCodePageFromLang
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?OnChar@CIME@@IAEX_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c$ = 8							; size = 2
?OnChar@CIME@@IAEX_W@Z PROC				; CIME::OnChar, COMDAT
; _this$ = ecx

; 866  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 867  : 	if (m_bOnlyNumberMode)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0000e	74 0f		 je	 SHORT $LN2@OnChar

; 868  : 		if (!iswdigit(c))

  00010	ff 75 08	 push	 DWORD PTR _c$[ebp]
  00013	e8 00 00 00 00	 call	 _iswdigit
  00018	59		 pop	 ecx
  00019	85 c0		 test	 eax, eax
  0001b	75 02		 jne	 SHORT $LN2@OnChar

; 869  : 			return;

  0001d	eb 22		 jmp	 SHORT $LN1@OnChar
$LN2@OnChar:

; 870  : 
; 871  : 	if (!__IsWritable(c))

  0001f	ff 75 08	 push	 DWORD PTR _c$[ebp]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?__IsWritable@CIME@@QAE_N_W@Z ; CIME::__IsWritable
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	75 02		 jne	 SHORT $LN4@OnChar

; 872  : 		return;

  00031	eb 0e		 jmp	 SHORT $LN1@OnChar
$LN4@OnChar:

; 873  : 
; 874  : 	InsertString(&c, 1);

  00033	6a 01		 push	 1
  00035	8d 45 08	 lea	 eax, DWORD PTR _c$[ebp]
  00038	50		 push	 eax
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?InsertString@CIME@@IAEXPA_WH@Z ; CIME::InsertString
$LN1@OnChar:

; 875  : }

  00041	c9		 leave
  00042	c2 04 00	 ret	 4
?OnChar@CIME@@IAEX_W@Z ENDP				; CIME::OnChar
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?InsertString@CIME@@IAEXPA_WH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wString$ = 8						; size = 4
_iSize$ = 12						; size = 4
?InsertString@CIME@@IAEXPA_WH@Z PROC			; CIME::InsertString, COMDAT
; _this$ = ecx

; 852  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 853  : 	if (IsMax(wString, iSize))

  00007	ff 75 0c	 push	 DWORD PTR _iSize$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _wString$[ebp]
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?IsMax@CIME@@IAE_NPB_WH@Z ; CIME::IsMax
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 02		 je	 SHORT $LN2@InsertStri

; 854  : 		return;

  0001c	eb 7b		 jmp	 SHORT $LN1@InsertStri
$LN2@InsertStri:

; 855  : 
; 856  : 	if (ms_curpos < ms_lastpos)

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00023	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00029	7d 36		 jge	 SHORT $LN3@InsertStri

; 857  : 		memmove(m_wText+ms_curpos+iSize, m_wText+ms_curpos, sizeof(wchar_t)*(ms_lastpos-ms_curpos));

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00030	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00036	d1 e0		 shl	 eax, 1
  00038	50		 push	 eax
  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0003e	8d 04 45 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax*2]
  00045	50		 push	 eax
  00046	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  00049	d1 e0		 shl	 eax, 1
  0004b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00051	8d 84 48 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax+ecx*2]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _memmove
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@InsertStri:

; 858  : 
; 859  : 	memcpy(m_wText+ms_curpos, wString, sizeof(wchar_t)*iSize);

  00061	8b 45 0c	 mov	 eax, DWORD PTR _iSize$[ebp]
  00064	d1 e0		 shl	 eax, 1
  00066	50		 push	 eax
  00067	ff 75 08	 push	 DWORD PTR _wString$[ebp]
  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0006f	8d 04 45 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax*2]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 860  : 
; 861  : 	ms_curpos += iSize;

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00084	03 45 0c	 add	 eax, DWORD PTR _iSize$[ebp]
  00087	a3 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, eax ; CIME::ms_curpos

; 862  : 	ms_lastpos += iSize;

  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00091	03 45 0c	 add	 eax, DWORD PTR _iSize$[ebp]
  00094	a3 00 00 00 00	 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, eax ; CIME::ms_lastpos
$LN1@InsertStri:

; 863  : }

  00099	c9		 leave
  0009a	c2 08 00	 ret	 8
?InsertString@CIME@@IAEXPA_WH@Z ENDP			; CIME::InsertString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetSupportLevel@CIME@@KAXK@Z
_TEXT	SEGMENT
_dwImeLevel$ = 8					; size = 4
?SetSupportLevel@CIME@@KAXK@Z PROC			; CIME::SetSupportLevel, COMDAT

; 764  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 765  : 	if ( dwImeLevel < 2 || 3 < dwImeLevel )

  00003	83 7d 08 02	 cmp	 DWORD PTR _dwImeLevel$[ebp], 2
  00007	72 06		 jb	 SHORT $LN3@SetSupport
  00009	83 7d 08 03	 cmp	 DWORD PTR _dwImeLevel$[ebp], 3
  0000d	76 02		 jbe	 SHORT $LN2@SetSupport
$LN3@SetSupport:

; 766  : 		return;

  0000f	eb 31		 jmp	 SHORT $LN1@SetSupport
$LN2@SetSupport:

; 767  : 	if ( GETPRIMLANG() == LANG_KOREAN )

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00016	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0001b	0f b7 c0	 movzx	 eax, ax
  0001e	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00023	0f b7 c0	 movzx	 eax, ax
  00026	83 f8 12	 cmp	 eax, 18			; 00000012H
  00029	75 07		 jne	 SHORT $LN4@SetSupport

; 768  : 	{
; 769  : 		dwImeLevel = 3;

  0002b	c7 45 08 03 00
	00 00		 mov	 DWORD PTR _dwImeLevel$[ebp], 3
$LN4@SetSupport:

; 770  : 	}
; 771  : 	ms_dwIMELevel = dwImeLevel;

  00032	8b 45 08	 mov	 eax, DWORD PTR _dwImeLevel$[ebp]
  00035	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwIMELevel@CIME@@2KA, eax ; CIME::ms_dwIMELevel

; 772  : 	// cancel current composition string.
; 773  : 	FinalizeString();

  0003a	6a 00		 push	 0
  0003c	e8 00 00 00 00	 call	 ?FinalizeString@CIME@@SAX_N@Z ; CIME::FinalizeString
  00041	59		 pop	 ecx
$LN1@SetSupport:

; 774  : 	//SetCompStringColor();
; 775  : }

  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?SetSupportLevel@CIME@@KAXK@Z ENDP			; CIME::SetSupportLevel
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CheckToggleState@CIME@@KAXXZ
_TEXT	SEGMENT
_dwSentMode$1 = -32					; size = 4
_dwConvMode$2 = -28					; size = 4
tv132 = -24						; size = 4
tv94 = -20						; size = 4
tv82 = -16						; size = 4
tv71 = -12						; size = 4
_himc$ = -8						; size = 4
_bIme$ = -1						; size = 1
?CheckToggleState@CIME@@KAXXZ PROC			; CIME::CheckToggleState, COMDAT

; 1520 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 1521 : 	CheckInputLocale();

  00006	e8 00 00 00 00	 call	 ?CheckInputLocale@CIME@@KAXXZ ; CIME::CheckInputLocale

; 1522 : 
; 1523 : 	// In Vista, we have to use TSF since few IMM functions don't work as expected.
; 1524 : 	// WARNING: Because of timing, g_dwState and g_bChineseIME may not be updated 
; 1525 : 	// immediately after the change on IME states by user.
; 1526 : 	if ( ms_bUILessMode )

  0000b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode
  00012	85 c0		 test	 eax, eax
  00014	74 05		 je	 SHORT $LN2@CheckToggl

; 1527 : 		return;

  00016	e9 fb 00 00 00	 jmp	 $LN1@CheckToggl
$LN2@CheckToggl:

; 1528 : 
; 1529 : 	/* Check Toggle State */ 
; 1530 : 	bool bIme = ImmIsIME( ms_hklCurrent ) != 0

  0001b	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00021	e8 00 00 00 00	 call	 _ImmIsIME@4
  00026	85 c0		 test	 eax, eax
  00028	74 1a		 je	 SHORT $LN8@CheckToggl
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0002f	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  00034	3d 00 00 00 e0	 cmp	 eax, -536870912		; e0000000H
  00039	75 09		 jne	 SHORT $LN8@CheckToggl
  0003b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  00042	eb 04		 jmp	 SHORT $LN9@CheckToggl
$LN8@CheckToggl:
  00044	83 65 f4 00	 and	 DWORD PTR tv71[ebp], 0
$LN9@CheckToggl:
  00048	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  0004b	88 45 ff	 mov	 BYTE PTR _bIme$[ebp], al

; 1531 : 		&& ( ( 0xF0000000 & (DWORD)ms_hklCurrent ) == 0xE0000000 ); // Hack to detect IME correctly. When IME is running as TIP, ImmIsIME() returns true for CHT US keyboard.
; 1532 : 	ms_bChineseIME = ( GETPRIMLANG() == LANG_CHINESE ) && bIme;

  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00053	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00058	0f b7 c0	 movzx	 eax, ax
  0005b	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00060	0f b7 c0	 movzx	 eax, ax
  00063	83 f8 04	 cmp	 eax, 4
  00066	75 11		 jne	 SHORT $LN10@CheckToggl
  00068	0f b6 45 ff	 movzx	 eax, BYTE PTR _bIme$[ebp]
  0006c	85 c0		 test	 eax, eax
  0006e	74 09		 je	 SHORT $LN10@CheckToggl
  00070	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  00077	eb 04		 jmp	 SHORT $LN11@CheckToggl
$LN10@CheckToggl:
  00079	83 65 f0 00	 and	 DWORD PTR tv82[ebp], 0
$LN11@CheckToggl:
  0007d	8a 45 f0	 mov	 al, BYTE PTR tv82[ebp]
  00080	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, al ; CIME::ms_bChineseIME

; 1533 : 
; 1534 : 	HIMC himc;
; 1535 : 	if (NULL != (himc = ImmGetContext(ms_hWnd))) {

  00085	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0008b	e8 00 00 00 00	 call	 _ImmGetContext@4
  00090	89 45 f8	 mov	 DWORD PTR _himc$[ebp], eax
  00093	83 7d f8 00	 cmp	 DWORD PTR _himc$[ebp], 0
  00097	74 76		 je	 SHORT $LN3@CheckToggl

; 1536 : 		if (ms_bChineseIME) {

  00099	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bChineseIME@CIME@@2_NA ; CIME::ms_bChineseIME
  000a0	85 c0		 test	 eax, eax
  000a2	74 32		 je	 SHORT $LN5@CheckToggl

; 1537 : 			DWORD dwConvMode, dwSentMode;
; 1538 : 			ImmGetConversionStatus(himc, &dwConvMode, &dwSentMode);

  000a4	8d 45 e0	 lea	 eax, DWORD PTR _dwSentMode$1[ebp]
  000a7	50		 push	 eax
  000a8	8d 45 e4	 lea	 eax, DWORD PTR _dwConvMode$2[ebp]
  000ab	50		 push	 eax
  000ac	ff 75 f8	 push	 DWORD PTR _himc$[ebp]
  000af	e8 00 00 00 00	 call	 _ImmGetConversionStatus@12

; 1539 : 			ms_dwImeState = ( dwConvMode & IME_CMODE_NATIVE ) ? IMEUI_STATE_ON : IMEUI_STATE_ENGLISH;

  000b4	8b 45 e4	 mov	 eax, DWORD PTR _dwConvMode$2[ebp]
  000b7	83 e0 01	 and	 eax, 1
  000ba	74 09		 je	 SHORT $LN12@CheckToggl
  000bc	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv94[ebp], 1
  000c3	eb 07		 jmp	 SHORT $LN13@CheckToggl
$LN12@CheckToggl:
  000c5	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR tv94[ebp], 2
$LN13@CheckToggl:
  000cc	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  000cf	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwImeState@CIME@@2KA, eax ; CIME::ms_dwImeState

; 1540 : 		}

  000d4	eb 29		 jmp	 SHORT $LN6@CheckToggl
$LN5@CheckToggl:

; 1541 : 		else
; 1542 : 		{
; 1543 : 			ms_dwImeState = ( bIme && ImmGetOpenStatus( himc ) != 0 ) ? IMEUI_STATE_ON : IMEUI_STATE_OFF;

  000d6	0f b6 45 ff	 movzx	 eax, BYTE PTR _bIme$[ebp]
  000da	85 c0		 test	 eax, eax
  000dc	74 15		 je	 SHORT $LN14@CheckToggl
  000de	ff 75 f8	 push	 DWORD PTR _himc$[ebp]
  000e1	e8 00 00 00 00	 call	 _ImmGetOpenStatus@4
  000e6	85 c0		 test	 eax, eax
  000e8	74 09		 je	 SHORT $LN14@CheckToggl
  000ea	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv132[ebp], 1
  000f1	eb 04		 jmp	 SHORT $LN15@CheckToggl
$LN14@CheckToggl:
  000f3	83 65 e8 00	 and	 DWORD PTR tv132[ebp], 0
$LN15@CheckToggl:
  000f7	8b 45 e8	 mov	 eax, DWORD PTR tv132[ebp]
  000fa	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwImeState@CIME@@2KA, eax ; CIME::ms_dwImeState
$LN6@CheckToggl:

; 1544 : 		}
; 1545 : 		ImmReleaseContext(ms_hWnd, himc);

  000ff	ff 75 f8	 push	 DWORD PTR _himc$[ebp]
  00102	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00108	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 1546 : 	}

  0010d	eb 07		 jmp	 SHORT $LN1@CheckToggl
$LN3@CheckToggl:

; 1547 : 	else
; 1548 : 		ms_dwImeState = IMEUI_STATE_OFF;

  0010f	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_dwImeState@CIME@@2KA, 0 ; CIME::ms_dwImeState
$LN1@CheckToggl:

; 1549 : }

  00116	c9		 leave
  00117	c3		 ret	 0
?CheckToggleState@CIME@@KAXXZ ENDP			; CIME::CheckToggleState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CheckInputLocale@CIME@@KAXXZ
_TEXT	SEGMENT
_iRc$ = -36						; size = 4
tv87 = -32						; size = 4
tv128 = -28						; size = 4
_szCodePage$ = -24					; size = 8
_szLang$1 = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
?CheckInputLocale@CIME@@KAXXZ PROC			; CIME::CheckInputLocale, COMDAT

; 1439 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1440 : 	static UINT s_uPrevCodePage = 0xFFFF;
; 1441 : 	static HKL	s_hklPrev = NULL;
; 1442 : 
; 1443 : 	ms_hklCurrent = GetKeyboardLayout( 0 );

  00010	6a 00		 push	 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyboardLayout@4
  00018	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, eax ; CIME::ms_hklCurrent

; 1444 : 	if ( s_hklPrev == ms_hklCurrent )

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_hklPrev@?1??CheckInputLocale@CIME@@KAXXZ@4PAUHKL__@@A
  00022	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00028	75 05		 jne	 SHORT $LN6@CheckInput

; 1445 : 		return;

  0002a	e9 e1 01 00 00	 jmp	 $LN1@CheckInput
$LN6@CheckInput:

; 1446 : 	s_hklPrev = ms_hklCurrent;

  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00034	a3 00 00 00 00	 mov	 DWORD PTR ?s_hklPrev@?1??CheckInputLocale@CIME@@KAXXZ@4PAUHKL__@@A, eax

; 1447 : 
; 1448 : 	char szCodePage[8];
; 1449 : 	int iRc = GetLocaleInfoA( MAKELCID( GETLANG(), SORT_DEFAULT ), LOCALE_IDEFAULTANSICODEPAGE, szCodePage, COUNTOF( szCodePage ) ); iRc;

  00039	6a 08		 push	 8
  0003b	8d 45 e8	 lea	 eax, DWORD PTR _szCodePage$[ebp]
  0003e	50		 push	 eax
  0003f	68 04 10 00 00	 push	 4100			; 00001004H
  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00049	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004e	0f b7 c0	 movzx	 eax, ax
  00051	50		 push	 eax
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  00058	89 45 dc	 mov	 DWORD PTR _iRc$[ebp], eax

; 1450 : 	ms_uInputCodePage = _strtoul( szCodePage, NULL, 0 );

  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	8d 45 e8	 lea	 eax, DWORD PTR _szCodePage$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?_strtoul@@YAKPBDPAPADH@Z ; _strtoul
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA, eax ; CIME::ms_uInputCodePage

; 1451 : 	if ( s_uPrevCodePage == ms_uInputCodePage )

  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_uPrevCodePage@?1??CheckInputLocale@CIME@@KAXXZ@4IA
  00075	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  0007b	75 05		 jne	 SHORT $LN7@CheckInput

; 1452 : 		return;

  0007d	e9 8e 01 00 00	 jmp	 $LN1@CheckInput
$LN7@CheckInput:

; 1453 : 	s_uPrevCodePage = ms_uInputCodePage;

  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  00087	a3 00 00 00 00	 mov	 DWORD PTR ?s_uPrevCodePage@?1??CheckInputLocale@CIME@@KAXXZ@4IA, eax

; 1454 : 
; 1455 : 	GetKeyboardLayoutName(ms_szKeyboardLayout);

  0008c	68 00 00 00 00	 push	 OFFSET ?ms_szKeyboardLayout@CIME@@2PADA ; CIME::ms_szKeyboardLayout
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyboardLayoutNameA@4

; 1456 : 
; 1457 :     switch (GETPRIMLANG()) 

  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0009c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000a1	0f b7 c0	 movzx	 eax, ax
  000a4	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  000a9	0f b7 c0	 movzx	 eax, ax
  000ac	89 45 e0	 mov	 DWORD PTR tv87[ebp], eax
  000af	83 7d e0 04	 cmp	 DWORD PTR tv87[ebp], 4
  000b3	74 49		 je	 SHORT $LN10@CheckInput
  000b5	83 7d e0 11	 cmp	 DWORD PTR tv87[ebp], 17	; 00000011H
  000b9	74 27		 je	 SHORT $LN9@CheckInput
  000bb	83 7d e0 12	 cmp	 DWORD PTR tv87[ebp], 18	; 00000012H
  000bf	74 05		 je	 SHORT $LN8@CheckInput
  000c1	e9 ae 00 00 00	 jmp	 $LN14@CheckInput
$LN8@CheckInput:

; 1458 : 	{
; 1459 : 		case LANG_KOREAN:
; 1460 : 			ms_bVerticalCandidate = false;

  000c6	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bVerticalCandidate@CIME@@2_NA, 0 ; CIME::ms_bVerticalCandidate

; 1461 : 			ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_KOREAN];

  000cd	6a 06		 push	 6
  000cf	58		 pop	 eax
  000d0	6b c0 03	 imul	 eax, eax, 3
  000d3	05 00 00 00 00	 add	 eax, OFFSET ?s_aszIndicator@@3PAY02_WA ; s_aszIndicator
  000d8	a3 00 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, eax ; CIME::ms_wszCurrentIndicator

; 1462 : 			break;

  000dd	e9 a2 00 00 00	 jmp	 $LN2@CheckInput
$LN9@CheckInput:

; 1463 : 
; 1464 : 		case LANG_JAPANESE:
; 1465 : 			ms_bVerticalCandidate = true;

  000e2	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bVerticalCandidate@CIME@@2_NA, 1 ; CIME::ms_bVerticalCandidate

; 1466 : 			ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_JAPANESE];

  000e9	6a 06		 push	 6
  000eb	58		 pop	 eax
  000ec	c1 e0 02	 shl	 eax, 2
  000ef	05 00 00 00 00	 add	 eax, OFFSET ?s_aszIndicator@@3PAY02_WA ; s_aszIndicator
  000f4	a3 00 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, eax ; CIME::ms_wszCurrentIndicator

; 1467 : 			break;

  000f9	e9 86 00 00 00	 jmp	 $LN2@CheckInput
$LN10@CheckInput:

; 1468 : 
; 1469 : 		case LANG_CHINESE:
; 1470 : 			ms_bVerticalCandidate = true;

  000fe	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bVerticalCandidate@CIME@@2_NA, 1 ; CIME::ms_bVerticalCandidate

; 1471 : 
; 1472 : 			switch(GETSUBLANG()) 

  00105	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0010a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0010f	0f b7 c0	 movzx	 eax, ax
  00112	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00115	89 45 e4	 mov	 DWORD PTR tv128[ebp], eax
  00118	83 7d e4 01	 cmp	 DWORD PTR tv128[ebp], 1
  0011c	74 33		 je	 SHORT $LN12@CheckInput
  0011e	83 7d e4 02	 cmp	 DWORD PTR tv128[ebp], 2
  00122	74 14		 je	 SHORT $LN11@CheckInput
  00124	83 7d e4 03	 cmp	 DWORD PTR tv128[ebp], 3
  00128	74 27		 je	 SHORT $LN12@CheckInput
  0012a	83 7d e4 04	 cmp	 DWORD PTR tv128[ebp], 4
  0012e	74 08		 je	 SHORT $LN11@CheckInput
  00130	83 7d e4 05	 cmp	 DWORD PTR tv128[ebp], 5
  00134	74 1b		 je	 SHORT $LN12@CheckInput
  00136	eb 2a		 jmp	 SHORT $LN13@CheckInput
$LN11@CheckInput:

; 1473 : 			{
; 1474 : 				case SUBLANG_CHINESE_SIMPLIFIED:
; 1475 : 				case SUBLANG_CHINESE_SINGAPORE:
; 1476 : 					//ms_bVerticalCandidate = (GetImeId() == 0);
; 1477 : 					ms_bVerticalCandidate = false;

  00138	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bVerticalCandidate@CIME@@2_NA, 0 ; CIME::ms_bVerticalCandidate

; 1478 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_CHS];

  0013f	6a 06		 push	 6
  00141	58		 pop	 eax
  00142	c1 e0 00	 shl	 eax, 0
  00145	05 00 00 00 00	 add	 eax, OFFSET ?s_aszIndicator@@3PAY02_WA ; s_aszIndicator
  0014a	a3 00 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, eax ; CIME::ms_wszCurrentIndicator

; 1479 : 					break;

  0014f	eb 21		 jmp	 SHORT $LN4@CheckInput
$LN12@CheckInput:

; 1480 : 
; 1481 : 				case SUBLANG_CHINESE_TRADITIONAL:
; 1482 : 				case SUBLANG_CHINESE_HONGKONG:
; 1483 : 				case SUBLANG_CHINESE_MACAU:
; 1484 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_CHT];

  00151	6a 06		 push	 6
  00153	58		 pop	 eax
  00154	d1 e0		 shl	 eax, 1
  00156	05 00 00 00 00	 add	 eax, OFFSET ?s_aszIndicator@@3PAY02_WA ; s_aszIndicator
  0015b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, eax ; CIME::ms_wszCurrentIndicator

; 1485 : 					break;

  00160	eb 10		 jmp	 SHORT $LN4@CheckInput
$LN13@CheckInput:

; 1486 : 
; 1487 : 				default:	// unsupported sub-language
; 1488 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_NON_IME];

  00162	6a 06		 push	 6
  00164	58		 pop	 eax
  00165	6b c0 00	 imul	 eax, eax, 0
  00168	05 00 00 00 00	 add	 eax, OFFSET ?s_aszIndicator@@3PAY02_WA ; s_aszIndicator
  0016d	a3 00 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, eax ; CIME::ms_wszCurrentIndicator
$LN4@CheckInput:

; 1489 : 					break;
; 1490 : 			}
; 1491 : 			break;

  00172	eb 10		 jmp	 SHORT $LN2@CheckInput
$LN14@CheckInput:

; 1492 : 
; 1493 : 		default:
; 1494 : 			ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_NON_IME];

  00174	6a 06		 push	 6
  00176	58		 pop	 eax
  00177	6b c0 00	 imul	 eax, eax, 0
  0017a	05 00 00 00 00	 add	 eax, OFFSET ?s_aszIndicator@@3PAY02_WA ; s_aszIndicator
  0017f	a3 00 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, eax ; CIME::ms_wszCurrentIndicator
$LN2@CheckInput:

; 1495 : 			break;
; 1496 :     }
; 1497 : 
; 1498 :     if (ms_wszCurrentIndicator == s_aszIndicator[INDICATOR_NON_IME])

  00184	6a 06		 push	 6
  00186	58		 pop	 eax
  00187	6b c0 00	 imul	 eax, eax, 0
  0018a	05 00 00 00 00	 add	 eax, OFFSET ?s_aszIndicator@@3PAY02_WA ; s_aszIndicator
  0018f	39 05 00 00 00
	00		 cmp	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, eax ; CIME::ms_wszCurrentIndicator
  00195	75 5e		 jne	 SHORT $LN15@CheckInput

; 1499 :     {
; 1500 :         char szLang[10];
; 1501 :         GetLocaleInfoA(MAKELCID(GETLANG(), SORT_DEFAULT), LOCALE_SABBREVLANGNAME, szLang, sizeof(szLang));

  00197	6a 0a		 push	 10			; 0000000aH
  00199	8d 45 f0	 lea	 eax, DWORD PTR _szLang$1[ebp]
  0019c	50		 push	 eax
  0019d	6a 03		 push	 3
  0019f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  001a4	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001a9	0f b7 c0	 movzx	 eax, ax
  001ac	50		 push	 eax
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16

; 1502 :         ms_wszCurrentIndicator[0] = szLang[0];

  001b3	33 c0		 xor	 eax, eax
  001b5	40		 inc	 eax
  001b6	6b c0 00	 imul	 eax, eax, 0
  001b9	66 0f be 44 05
	f0		 movsx	 ax, BYTE PTR _szLang$1[ebp+eax]
  001bf	6a 02		 push	 2
  001c1	59		 pop	 ecx
  001c2	6b c9 00	 imul	 ecx, ecx, 0
  001c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA ; CIME::ms_wszCurrentIndicator
  001cb	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax

; 1503 :         ms_wszCurrentIndicator[1] = towlower(szLang[1]);

  001cf	33 c0		 xor	 eax, eax
  001d1	40		 inc	 eax
  001d2	c1 e0 00	 shl	 eax, 0
  001d5	66 0f be 44 05
	f0		 movsx	 ax, BYTE PTR _szLang$1[ebp+eax]
  001db	0f b7 c0	 movzx	 eax, ax
  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 _towlower
  001e4	59		 pop	 ecx
  001e5	6a 02		 push	 2
  001e7	59		 pop	 ecx
  001e8	c1 e1 00	 shl	 ecx, 0
  001eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA ; CIME::ms_wszCurrentIndicator
  001f1	66 89 04 0a	 mov	 WORD PTR [edx+ecx], ax
$LN15@CheckInput:

; 1504 :     }
; 1505 : 
; 1506 : 	//       
; 1507 : 	//   .
; 1508 : 	if(ms_uOutputCodePage != 1256) {

  001f5	81 3d 00 00 00
	00 e8 04 00 00	 cmp	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA, 1256 ; CIME::ms_uOutputCodePage, 000004e8H
  001ff	74 0f		 je	 SHORT $LN1@CheckInput

; 1509 : 		ms_uOutputCodePage = ms_uInputCodePage;

  00201	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  00206	a3 00 00 00 00	 mov	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA, eax ; CIME::ms_uOutputCodePage

; 1510 : 		Clear();

  0020b	e8 00 00 00 00	 call	 ?Clear@CIME@@SAXXZ	; CIME::Clear
$LN1@CheckInput:

; 1511 : 	}
; 1512 : 
; 1513 : 	//for ( int i = 0; i < 256; i++ )
; 1514 : 	//{
; 1515 : 	//	LeadByteTable[i] = (BYTE)IsDBCSLeadByteEx( g_uCodePage, (BYTE)i );
; 1516 : 	//}
; 1517 : }

  00210	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00213	33 cd		 xor	 ecx, ebp
  00215	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021a	c9		 leave
  0021b	c3		 ret	 0
?CheckInputLocale@CIME@@KAXXZ ENDP			; CIME::CheckInputLocale
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?DelCurPos@CIME@@IAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv82 = -8						; size = 4
_eraseCount$1 = -4					; size = 4
?DelCurPos@CIME@@IAEXXZ PROC				; CIME::DelCurPos, COMDAT
; _this$ = ecx

; 829  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 830  : 	if (ms_curpos < ms_lastpos)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0000e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00014	7d 7f		 jge	 SHORT $LN1@DelCurPos

; 831  : 	{
; 832  : 		int eraseCount = FindColorTagEndPosition(m_wText + ms_curpos, ms_lastpos - ms_curpos) + 1;

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0001b	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00021	50		 push	 eax
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00027	8d 04 45 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax*2]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?FindColorTagEndPosition@@YAHPB_WH@Z ; FindColorTagEndPosition
  00034	59		 pop	 ecx
  00035	59		 pop	 ecx
  00036	40		 inc	 eax
  00037	89 45 fc	 mov	 DWORD PTR _eraseCount$1[ebp], eax

; 833  : 		wcscpy(m_wText + ms_curpos, m_wText + ms_curpos + eraseCount);

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _eraseCount$1[ebp]
  0003d	d1 e0		 shl	 eax, 1
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00045	8d 84 48 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax+ecx*2]
  0004c	50		 push	 eax
  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00052	8d 04 45 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax*2]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _wcscpy
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx

; 834  : 		ms_lastpos -= eraseCount;

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00066	2b 45 fc	 sub	 eax, DWORD PTR _eraseCount$1[ebp]
  00069	a3 00 00 00 00	 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, eax ; CIME::ms_lastpos

; 835  : 		ms_curpos = min(ms_lastpos, ms_curpos);

  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00073	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00079	7d 0a		 jge	 SHORT $LN4@DelCurPos
  0007b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00080	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
  00083	eb 08		 jmp	 SHORT $LN5@DelCurPos
$LN4@DelCurPos:
  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0008a	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
$LN5@DelCurPos:
  0008d	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00090	a3 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, eax ; CIME::ms_curpos
$LN1@DelCurPos:

; 836  : 	}
; 837  : }

  00095	c9		 leave
  00096	c3		 ret	 0
?DelCurPos@CIME@@IAEXXZ ENDP				; CIME::DelCurPos
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetCurPos@CIME@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv75 = -4						; size = 4
_offset$ = 8						; size = 4
?SetCurPos@CIME@@IAEXH@Z PROC				; CIME::SetCurPos, COMDAT
; _this$ = ecx

; 814  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 815  : 	if (offset < 0 || offset > ms_lastpos)

  00008	83 7d 08 00	 cmp	 DWORD PTR _offset$[ebp], 0
  0000c	7c 0b		 jl	 SHORT $LN4@SetCurPos
  0000e	8b 45 08	 mov	 eax, DWORD PTR _offset$[ebp]
  00011	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00017	7e 0e		 jle	 SHORT $LN2@SetCurPos
$LN4@SetCurPos:

; 816  : 	{
; 817  : 		ms_curpos = ms_lastpos;

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0001e	a3 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, eax ; CIME::ms_curpos

; 818  : 		return;

  00023	eb 4b		 jmp	 SHORT $LN1@SetCurPos

; 819  : 	}

  00025	eb 49		 jmp	 SHORT $LN1@SetCurPos
$LN2@SetCurPos:

; 820  : 	else
; 821  : 	{
; 822  : 		// offset    .   .
; 823  : 		//ms_curpos = min(ms_lastpos, offset);
; 824  : 		ms_curpos = min(ms_lastpos, GetTextTagInternalPosFromRenderPos(m_wText, ms_lastpos, offset));

  00027	ff 75 08	 push	 DWORD PTR _offset$[ebp]
  0002a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00030	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  00035	e8 00 00 00 00	 call	 ?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z ; GetTextTagInternalPosFromRenderPos
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	39 05 00 00 00
	00		 cmp	 DWORD PTR ?ms_lastpos@CIME@@2HA, eax ; CIME::ms_lastpos
  00043	7d 0a		 jge	 SHORT $LN6@SetCurPos
  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0004a	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
  0004d	eb 19		 jmp	 SHORT $LN7@SetCurPos
$LN6@SetCurPos:
  0004f	ff 75 08	 push	 DWORD PTR _offset$[ebp]
  00052	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00058	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  0005d	e8 00 00 00 00	 call	 ?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z ; GetTextTagInternalPosFromRenderPos
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
$LN7@SetCurPos:
  00068	8b 45 fc	 mov	 eax, DWORD PTR tv75[ebp]
  0006b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, eax ; CIME::ms_curpos
$LN1@SetCurPos:

; 825  : 	}
; 826  : }

  00070	c9		 leave
  00071	c2 04 00	 ret	 4
?SetCurPos@CIME@@IAEXH@Z ENDP				; CIME::SetCurPos
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?DecCurPos@CIME@@IAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv85 = -16						; size = 4
tv84 = -12						; size = 4
tv77 = -8						; size = 4
_pos$1 = -4						; size = 4
?DecCurPos@CIME@@IAEXXZ PROC				; CIME::DecCurPos, COMDAT
; _this$ = ecx

; 793  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 794  : 	if (ms_curpos > 0)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_curpos@CIME@@2HA, 0 ; CIME::ms_curpos
  00010	0f 8e 98 00 00
	00		 jle	 $LN1@DecCurPos

; 795  : 	{
; 796  : 		int pos = FindColorTagStartPosition(m_wText + ms_curpos - 1, ms_curpos);

  00016	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00021	8d 04 45 fe ff
	ff ff		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax*2-2]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?FindColorTagStartPosition@@YAHPB_WH@Z ; FindColorTagStartPosition
  0002e	59		 pop	 ecx
  0002f	59		 pop	 ecx
  00030	89 45 fc	 mov	 DWORD PTR _pos$1[ebp], eax

; 797  : 		
; 798  : 		if (pos > 0)

  00033	83 7d fc 00	 cmp	 DWORD PTR _pos$1[ebp], 0
  00037	7e 6a		 jle	 SHORT $LN3@DecCurPos

; 799  : 			ms_curpos = min(ms_lastpos, max(0, ms_curpos - (pos + 1)));

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pos$1[ebp]
  0003c	40		 inc	 eax
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00043	2b c8		 sub	 ecx, eax
  00045	79 06		 jns	 SHORT $LN6@DecCurPos
  00047	83 65 f8 00	 and	 DWORD PTR tv77[ebp], 0
  0004b	eb 0f		 jmp	 SHORT $LN7@DecCurPos
$LN6@DecCurPos:
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _pos$1[ebp]
  00050	40		 inc	 eax
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00057	2b c8		 sub	 ecx, eax
  00059	89 4d f8	 mov	 DWORD PTR tv77[ebp], ecx
$LN7@DecCurPos:
  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00061	3b 45 f8	 cmp	 eax, DWORD PTR tv77[ebp]
  00064	7d 0a		 jge	 SHORT $LN10@DecCurPos
  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0006b	89 45 f0	 mov	 DWORD PTR tv85[ebp], eax
  0006e	eb 29		 jmp	 SHORT $LN11@DecCurPos
$LN10@DecCurPos:
  00070	8b 45 fc	 mov	 eax, DWORD PTR _pos$1[ebp]
  00073	40		 inc	 eax
  00074	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0007a	2b c8		 sub	 ecx, eax
  0007c	79 06		 jns	 SHORT $LN8@DecCurPos
  0007e	83 65 f4 00	 and	 DWORD PTR tv84[ebp], 0
  00082	eb 0f		 jmp	 SHORT $LN9@DecCurPos
$LN8@DecCurPos:
  00084	8b 45 fc	 mov	 eax, DWORD PTR _pos$1[ebp]
  00087	40		 inc	 eax
  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0008e	2b c8		 sub	 ecx, eax
  00090	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
$LN9@DecCurPos:
  00093	8b 45 f4	 mov	 eax, DWORD PTR tv84[ebp]
  00096	89 45 f0	 mov	 DWORD PTR tv85[ebp], eax
$LN11@DecCurPos:
  00099	8b 45 f0	 mov	 eax, DWORD PTR tv85[ebp]
  0009c	a3 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, eax ; CIME::ms_curpos
  000a1	eb 0b		 jmp	 SHORT $LN1@DecCurPos
$LN3@DecCurPos:

; 800  : 		else
; 801  : 			--ms_curpos;

  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  000a8	48		 dec	 eax
  000a9	a3 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, eax ; CIME::ms_curpos
$LN1@DecCurPos:

; 802  : 		//--ms_curpos;
; 803  : 	}
; 804  : }

  000ae	c9		 leave
  000af	c3		 ret	 0
?DecCurPos@CIME@@IAEXXZ ENDP				; CIME::DecCurPos
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?IncCurPos@CIME@@IAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv85 = -16						; size = 4
tv84 = -12						; size = 4
tv77 = -8						; size = 4
_pos$1 = -4						; size = 4
?IncCurPos@CIME@@IAEXXZ PROC				; CIME::IncCurPos, COMDAT
; _this$ = ecx

; 779  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 780  : 	if (ms_curpos < ms_lastpos)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0000e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00014	0f 8d a6 00 00
	00		 jge	 $LN1@IncCurPos

; 781  : 	{
; 782  : 		int pos = FindColorTagEndPosition(m_wText + ms_curpos, ms_lastpos - ms_curpos);

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0001f	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00025	50		 push	 eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0002b	8d 04 45 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax*2]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?FindColorTagEndPosition@@YAHPB_WH@Z ; FindColorTagEndPosition
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
  0003a	89 45 fc	 mov	 DWORD PTR _pos$1[ebp], eax

; 783  : 
; 784  : 		if (pos > 0)

  0003d	83 7d fc 00	 cmp	 DWORD PTR _pos$1[ebp], 0
  00041	7e 72		 jle	 SHORT $LN3@IncCurPos

; 785  : 			ms_curpos = min(ms_lastpos, max(0, ms_curpos + (pos + 1)));

  00043	8b 45 fc	 mov	 eax, DWORD PTR _pos$1[ebp]
  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0004c	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00050	85 c0		 test	 eax, eax
  00052	7d 06		 jge	 SHORT $LN6@IncCurPos
  00054	83 65 f8 00	 and	 DWORD PTR tv77[ebp], 0
  00058	eb 10		 jmp	 SHORT $LN7@IncCurPos
$LN6@IncCurPos:
  0005a	8b 45 fc	 mov	 eax, DWORD PTR _pos$1[ebp]
  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00063	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00067	89 45 f8	 mov	 DWORD PTR tv77[ebp], eax
$LN7@IncCurPos:
  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0006f	3b 45 f8	 cmp	 eax, DWORD PTR tv77[ebp]
  00072	7d 0a		 jge	 SHORT $LN10@IncCurPos
  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00079	89 45 f0	 mov	 DWORD PTR tv85[ebp], eax
  0007c	eb 2d		 jmp	 SHORT $LN11@IncCurPos
$LN10@IncCurPos:
  0007e	8b 45 fc	 mov	 eax, DWORD PTR _pos$1[ebp]
  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00087	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  0008b	85 c0		 test	 eax, eax
  0008d	7d 06		 jge	 SHORT $LN8@IncCurPos
  0008f	83 65 f4 00	 and	 DWORD PTR tv84[ebp], 0
  00093	eb 10		 jmp	 SHORT $LN9@IncCurPos
$LN8@IncCurPos:
  00095	8b 45 fc	 mov	 eax, DWORD PTR _pos$1[ebp]
  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0009e	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  000a2	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
$LN9@IncCurPos:
  000a5	8b 45 f4	 mov	 eax, DWORD PTR tv84[ebp]
  000a8	89 45 f0	 mov	 DWORD PTR tv85[ebp], eax
$LN11@IncCurPos:
  000ab	8b 45 f0	 mov	 eax, DWORD PTR tv85[ebp]
  000ae	a3 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, eax ; CIME::ms_curpos
  000b3	eb 0b		 jmp	 SHORT $LN1@IncCurPos
$LN3@IncCurPos:

; 786  : 		else
; 787  : 			++ms_curpos;

  000b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  000ba	40		 inc	 eax
  000bb	a3 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, eax ; CIME::ms_curpos
$LN1@IncCurPos:

; 788  : 		//++ms_curpos;
; 789  : 	}
; 790  : }

  000c0	c9		 leave
  000c1	c3		 ret	 0
?IncCurPos@CIME@@IAEXXZ ENDP				; CIME::IncCurPos
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?WMChar@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
tv67 = -36						; size = 4
_this$ = -32						; size = 4
_c$ = -25						; size = 1
_w$1 = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WMChar@CIME@@QAEJPAUHWND__@@IIJ@Z PROC			; CIME::WMChar, COMDAT
; _this$ = ecx

; 2264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 2265 : 	unsigned char c = unsigned char(wParam & 0xff);

  00013	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00016	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0001b	88 45 e7	 mov	 BYTE PTR _c$[ebp], al

; 2266 : 
; 2267 : 	switch (c) 

  0001e	8a 45 e7	 mov	 al, BYTE PTR _c$[ebp]
  00021	88 45 dc	 mov	 BYTE PTR tv67[ebp], al
  00024	80 7d dc 08	 cmp	 BYTE PTR tv67[ebp], 8
  00028	74 02		 je	 SHORT $LN4@WMChar
  0002a	eb 50		 jmp	 SHORT $LN8@WMChar
$LN4@WMChar:

; 2268 : 	{
; 2269 : 	case 8:
; 2270 : 		if(ms_bCaptureInput == false)

  0002c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bCaptureInput@CIME@@2_NA ; CIME::ms_bCaptureInput
  00033	85 c0		 test	 eax, eax
  00035	75 07		 jne	 SHORT $LN5@WMChar

; 2271 : 			return 0;

  00037	33 c0		 xor	 eax, eax
  00039	e9 e1 00 00 00	 jmp	 $LN1@WMChar
$LN5@WMChar:

; 2272 : 		if (ms_curpos > 0)

  0003e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_curpos@CIME@@2HA, 0 ; CIME::ms_curpos
  00045	7e 10		 jle	 SHORT $LN6@WMChar

; 2273 : 		{
; 2274 : 			DecCurPos();

  00047	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?DecCurPos@CIME@@IAEXXZ	; CIME::DecCurPos

; 2275 : 			DelCurPos();

  0004f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?DelCurPos@CIME@@IAEXXZ	; CIME::DelCurPos
$LN6@WMChar:

; 2276 : 		}
; 2277 : 		if(ms_pEvent)

  00057	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  0005e	74 10		 je	 SHORT $LN7@WMChar

; 2278 : 			ms_pEvent->OnUpdate();

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0006d	ff 50 04	 call	 DWORD PTR [eax+4]
$LN7@WMChar:

; 2279 : 		return 0;

  00070	33 c0		 xor	 eax, eax
  00072	e9 a8 00 00 00	 jmp	 $LN1@WMChar

; 2280 : 		break;

  00077	e9 a1 00 00 00	 jmp	 $LN2@WMChar
$LN8@WMChar:

; 2281 : 
; 2282 : 	default:
; 2283 : 		if(ms_pEvent) {

  0007c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  00083	74 1e		 je	 SHORT $LN9@WMChar

; 2284 : 			if (ms_pEvent->OnWM_CHAR(wParam, lParam))

  00085	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00088	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00090	8b 00		 mov	 eax, DWORD PTR [eax]
  00092	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00098	ff 10		 call	 DWORD PTR [eax]
  0009a	0f b6 c0	 movzx	 eax, al
  0009d	85 c0		 test	 eax, eax
  0009f	74 02		 je	 SHORT $LN9@WMChar

; 2285 : 				break;

  000a1	eb 7a		 jmp	 SHORT $LN2@WMChar
$LN9@WMChar:

; 2286 : 		}
; 2287 : 		if(ms_bCaptureInput == false)

  000a3	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bCaptureInput@CIME@@2_NA ; CIME::ms_bCaptureInput
  000aa	85 c0		 test	 eax, eax
  000ac	75 04		 jne	 SHORT $LN11@WMChar

; 2288 : 			return 0;

  000ae	33 c0		 xor	 eax, eax
  000b0	eb 6d		 jmp	 SHORT $LN1@WMChar
$LN11@WMChar:

; 2289 : 		wchar_t w[10];
; 2290 : 		MultiByteToWideChar(ms_uInputCodePage, 0, (char*)&c, 1, w, 1);

  000b2	6a 01		 push	 1
  000b4	8d 45 e8	 lea	 eax, DWORD PTR _w$1[ebp]
  000b7	50		 push	 eax
  000b8	6a 01		 push	 1
  000ba	8d 45 e7	 lea	 eax, DWORD PTR _c$[ebp]
  000bd	50		 push	 eax
  000be	6a 00		 push	 0
  000c0	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 2291 : 
; 2292 : 		OnChar(w[0]);

  000cc	6a 02		 push	 2
  000ce	58		 pop	 eax
  000cf	6b c0 00	 imul	 eax, eax, 0
  000d2	0f b7 44 05 e8	 movzx	 eax, WORD PTR _w$1[ebp+eax]
  000d7	50		 push	 eax
  000d8	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	e8 00 00 00 00	 call	 ?OnChar@CIME@@IAEX_W@Z	; CIME::OnChar

; 2293 : 		if (w[0] == L'|')

  000e0	6a 02		 push	 2
  000e2	58		 pop	 eax
  000e3	6b c0 00	 imul	 eax, eax, 0
  000e6	0f b7 44 05 e8	 movzx	 eax, WORD PTR _w$1[ebp+eax]
  000eb	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  000ee	75 14		 jne	 SHORT $LN12@WMChar

; 2294 : 			OnChar(w[0]);

  000f0	6a 02		 push	 2
  000f2	58		 pop	 eax
  000f3	6b c0 00	 imul	 eax, eax, 0
  000f6	0f b7 44 05 e8	 movzx	 eax, WORD PTR _w$1[ebp+eax]
  000fb	50		 push	 eax
  000fc	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	e8 00 00 00 00	 call	 ?OnChar@CIME@@IAEX_W@Z	; CIME::OnChar
$LN12@WMChar:

; 2295 : 		if(ms_pEvent)

  00104	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  0010b	74 10		 je	 SHORT $LN2@WMChar

; 2296 : 			ms_pEvent->OnUpdate();

  0010d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00112	8b 00		 mov	 eax, DWORD PTR [eax]
  00114	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0011a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN2@WMChar:

; 2297 : 		break;
; 2298 : 	}
; 2299 : 
; 2300 : 	return 0;

  0011d	33 c0		 xor	 eax, eax
$LN1@WMChar:

; 2301 : }

  0011f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00122	33 cd		 xor	 ecx, ebp
  00124	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00129	c9		 leave
  0012a	c2 10 00	 ret	 16			; 00000010H
?WMChar@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP			; CIME::WMChar
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?WMNotify@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_result$ = -24						; size = 4
_hImc$1 = -20						; size = 4
_hImc$2 = -16						; size = 4
_this$ = -12						; size = 4
tv66 = -8						; size = 4
tv145 = -4						; size = 4
_hWnd$ = 8						; size = 4
_uiMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WMNotify@CIME@@QAEJPAUHWND__@@IIJ@Z PROC		; CIME::WMNotify, COMDAT
; _this$ = ecx

; 2184 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2185 : 	LRESULT		result = 0;

  00009	83 65 e8 00	 and	 DWORD PTR _result$[ebp], 0

; 2186 : 
; 2187 : 	if(ms_bCaptureInput == false)

  0000d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bCaptureInput@CIME@@2_NA ; CIME::ms_bCaptureInput
  00014	85 c0		 test	 eax, eax
  00016	75 07		 jne	 SHORT $LN6@WMNotify

; 2188 : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	e9 2b 02 00 00	 jmp	 $LN1@WMNotify
$LN6@WMNotify:

; 2189 : 	switch (wParam) {

  0001f	8b 45 10	 mov	 eax, DWORD PTR _wParam$[ebp]
  00022	89 45 f8	 mov	 DWORD PTR tv66[ebp], eax
  00025	83 7d f8 03	 cmp	 DWORD PTR tv66[ebp], 3
  00029	74 33		 je	 SHORT $LN7@WMNotify
  0002b	83 7d f8 04	 cmp	 DWORD PTR tv66[ebp], 4
  0002f	0f 84 b0 00 00
	00		 je	 $LN13@WMNotify
  00035	83 7d f8 05	 cmp	 DWORD PTR tv66[ebp], 5
  00039	74 23		 je	 SHORT $LN7@WMNotify
  0003b	83 7d f8 06	 cmp	 DWORD PTR tv66[ebp], 6
  0003f	0f 84 e7 00 00
	00		 je	 $LN17@WMNotify
  00045	83 7d f8 08	 cmp	 DWORD PTR tv66[ebp], 8
  00049	0f 84 dd 00 00
	00		 je	 $LN17@WMNotify
  0004f	83 7d f8 0e	 cmp	 DWORD PTR tv66[ebp], 14	; 0000000eH
  00053	0f 84 ed 00 00
	00		 je	 $LN19@WMNotify
  00059	e9 d0 01 00 00	 jmp	 $LN2@WMNotify
$LN7@WMNotify:

; 2190 : 
; 2191 : 	case IMN_OPENCANDIDATE:
; 2192 : 	case IMN_CHANGECANDIDATE: {
; 2193 : 		if (ms_bUILessMode && !ms_bUseIMMCandidate)

  0005e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode
  00065	85 c0		 test	 eax, eax
  00067	74 10		 je	 SHORT $LN8@WMNotify
  00069	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUseIMMCandidate@CIME@@2_NA ; CIME::ms_bUseIMMCandidate
  00070	85 c0		 test	 eax, eax
  00072	75 05		 jne	 SHORT $LN8@WMNotify

; 2194 : 			break;

  00074	e9 b5 01 00 00	 jmp	 $LN2@WMNotify
$LN8@WMNotify:

; 2195 : 		HIMC hImc = ImmGetContext(hWnd);

  00079	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  0007c	e8 00 00 00 00	 call	 _ImmGetContext@4
  00081	89 45 f0	 mov	 DWORD PTR _hImc$2[ebp], eax

; 2196 : 		if (hImc == NULL)

  00084	83 7d f0 00	 cmp	 DWORD PTR _hImc$2[ebp], 0
  00088	75 05		 jne	 SHORT $LN9@WMNotify

; 2197 : 			break;

  0008a	e9 9f 01 00 00	 jmp	 $LN2@WMNotify
$LN9@WMNotify:

; 2198 : 		CandidateProcess(hImc);

  0008f	ff 75 f0	 push	 DWORD PTR _hImc$2[ebp]
  00092	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CandidateProcess

; 2199 : 		if (!m_bUseDefaultIME) {

  0009a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	0f b6 40 21	 movzx	 eax, BYTE PTR [eax+33]
  000a1	85 c0		 test	 eax, eax
  000a3	75 1b		 jne	 SHORT $LN10@WMNotify

; 2200 : 			if(ms_pEvent)

  000a5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  000ac	74 10		 je	 SHORT $LN12@WMNotify

; 2201 : 				ms_pEvent->OnOpenCandidateList();

  000ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  000b3	8b 00		 mov	 eax, DWORD PTR [eax]
  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  000bb	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN12@WMNotify:

; 2202 : 		} else

  000be	eb 15		 jmp	 SHORT $LN11@WMNotify
$LN10@WMNotify:

; 2203 : 			result = ::DefWindowProc(hWnd, uiMsg, wParam, lParam);

  000c0	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  000c3	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  000c6	ff 75 0c	 push	 DWORD PTR _uiMsg$[ebp]
  000c9	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  000d2	89 45 e8	 mov	 DWORD PTR _result$[ebp], eax
$LN11@WMNotify:

; 2204 : 		ImmReleaseContext(hWnd, hImc);

  000d5	ff 75 f0	 push	 DWORD PTR _hImc$2[ebp]
  000d8	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  000db	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 2205 : 		break;

  000e0	e9 49 01 00 00	 jmp	 $LN2@WMNotify
$LN13@WMNotify:

; 2206 : 		}
; 2207 : 	case IMN_CLOSECANDIDATE:
; 2208 : 		if (ms_bUILessMode && !ms_bUseIMMCandidate)

  000e5	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode
  000ec	85 c0		 test	 eax, eax
  000ee	74 10		 je	 SHORT $LN14@WMNotify
  000f0	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUseIMMCandidate@CIME@@2_NA ; CIME::ms_bUseIMMCandidate
  000f7	85 c0		 test	 eax, eax
  000f9	75 05		 jne	 SHORT $LN14@WMNotify

; 2209 : 			break;

  000fb	e9 2e 01 00 00	 jmp	 $LN2@WMNotify
$LN14@WMNotify:

; 2210 : 		if (!m_bUseDefaultIME)

  00100	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00103	0f b6 40 21	 movzx	 eax, BYTE PTR [eax+33]
  00107	85 c0		 test	 eax, eax
  00109	75 07		 jne	 SHORT $LN15@WMNotify

; 2211 : 			CloseCandidateList();

  0010b	e8 00 00 00 00	 call	 ?CloseCandidateList@CIME@@SAXXZ ; CIME::CloseCandidateList
  00110	eb 15		 jmp	 SHORT $LN16@WMNotify
$LN15@WMNotify:

; 2212 : 		else
; 2213 : 			result = DefWindowProc(hWnd, uiMsg, wParam, lParam);

  00112	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00115	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00118	ff 75 0c	 push	 DWORD PTR _uiMsg$[ebp]
  0011b	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  00124	89 45 e8	 mov	 DWORD PTR _result$[ebp], eax
$LN16@WMNotify:

; 2214 : 		break;

  00127	e9 02 01 00 00	 jmp	 $LN2@WMNotify
$LN17@WMNotify:

; 2215 : 
; 2216 : 	case IMN_SETCONVERSIONMODE:
; 2217 : 	case IMN_SETOPENSTATUS:
; 2218 : 		if (ms_bUILessMode)

  0012c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode
  00133	85 c0		 test	 eax, eax
  00135	74 05		 je	 SHORT $LN18@WMNotify

; 2219 : 			break;

  00137	e9 f2 00 00 00	 jmp	 $LN2@WMNotify
$LN18@WMNotify:

; 2220 : 		CheckToggleState();

  0013c	e8 00 00 00 00	 call	 ?CheckToggleState@CIME@@KAXXZ ; CIME::CheckToggleState

; 2221 : 		break;

  00141	e9 e8 00 00 00	 jmp	 $LN2@WMNotify
$LN19@WMNotify:

; 2222 : 
; 2223 : 	case IMN_PRIVATE: {
; 2224 : 		if (ms_bUILessMode)

  00146	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode
  0014d	85 c0		 test	 eax, eax
  0014f	74 05		 je	 SHORT $LN20@WMNotify

; 2225 : 			break;

  00151	e9 d8 00 00 00	 jmp	 $LN2@WMNotify
$LN20@WMNotify:

; 2226 : 		HIMC hImc = ImmGetContext(hWnd);

  00156	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  00159	e8 00 00 00 00	 call	 _ImmGetContext@4
  0015e	89 45 ec	 mov	 DWORD PTR _hImc$1[ebp], eax

; 2227 : 		if (hImc == NULL)

  00161	83 7d ec 00	 cmp	 DWORD PTR _hImc$1[ebp], 0
  00165	75 05		 jne	 SHORT $LN21@WMNotify

; 2228 : 			break;

  00167	e9 c2 00 00 00	 jmp	 $LN2@WMNotify
$LN21@WMNotify:

; 2229 :         ReadingProcess(hImc);

  0016c	ff 75 ec	 push	 DWORD PTR _hImc$1[ebp]
  0016f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00172	e8 00 00 00 00	 call	 ?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::ReadingProcess

; 2230 : 
; 2231 : 		// Trap some messages to hide reading window
; 2232 :         switch(ms_adwId[0])

  00177	6a 04		 push	 4
  00179	58		 pop	 eax
  0017a	6b c0 00	 imul	 eax, eax, 0
  0017d	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR ?ms_adwId@CIME@@2PAKA[eax]
  00183	89 45 fc	 mov	 DWORD PTR tv145[ebp], eax
  00186	81 7d fc 04 04
	00 05		 cmp	 DWORD PTR tv145[ebp], 83887108 ; 05000404H
  0018d	77 38		 ja	 SHORT $LN30@WMNotify
  0018f	81 7d fc 04 04
	00 05		 cmp	 DWORD PTR tv145[ebp], 83887108 ; 05000404H
  00196	74 68		 je	 SHORT $LN25@WMNotify
  00198	81 7d fc 04 08
	01 04		 cmp	 DWORD PTR tv145[ebp], 67176452 ; 04010804H
  0019f	74 4c		 je	 SHORT $LN22@WMNotify
  001a1	81 7d fc 04 04
	02 04		 cmp	 DWORD PTR tv145[ebp], 67240964 ; 04020404H
  001a8	74 43		 je	 SHORT $LN22@WMNotify
  001aa	81 7d fc 04 08
	02 04		 cmp	 DWORD PTR tv145[ebp], 67241988 ; 04020804H
  001b1	74 3a		 je	 SHORT $LN22@WMNotify
  001b3	81 7d fc 04 04
	03 04		 cmp	 DWORD PTR tv145[ebp], 67306500 ; 04030404H
  001ba	74 31		 je	 SHORT $LN22@WMNotify
  001bc	81 7d fc 04 04
	04 04		 cmp	 DWORD PTR tv145[ebp], 67372036 ; 04040404H
  001c3	74 28		 je	 SHORT $LN22@WMNotify
  001c5	eb 5c		 jmp	 SHORT $LN4@WMNotify
$LN30@WMNotify:
  001c7	81 7d fc 04 04
	01 05		 cmp	 DWORD PTR tv145[ebp], 83952644 ; 05010404H
  001ce	74 30		 je	 SHORT $LN25@WMNotify
  001d0	81 7d fc 04 04
	02 05		 cmp	 DWORD PTR tv145[ebp], 84018180 ; 05020404H
  001d7	74 27		 je	 SHORT $LN25@WMNotify
  001d9	81 7d fc 04 08
	03 05		 cmp	 DWORD PTR tv145[ebp], 84084740 ; 05030804H
  001e0	74 1e		 je	 SHORT $LN25@WMNotify
  001e2	81 7d fc 04 04
	00 06		 cmp	 DWORD PTR tv145[ebp], 100664324 ; 06000404H
  001e9	74 15		 je	 SHORT $LN25@WMNotify
  001eb	eb 36		 jmp	 SHORT $LN4@WMNotify
$LN22@WMNotify:

; 2233 :         {
; 2234 :             case IMEID_CHT_VER42:
; 2235 :             case IMEID_CHT_VER43:
; 2236 :             case IMEID_CHT_VER44:
; 2237 :             case IMEID_CHS_VER41:
; 2238 :             case IMEID_CHS_VER42:
; 2239 : 				if ((lParam == 1)||(lParam == 2))

  001ed	83 7d 14 01	 cmp	 DWORD PTR _lParam$[ebp], 1
  001f1	74 06		 je	 SHORT $LN24@WMNotify
  001f3	83 7d 14 02	 cmp	 DWORD PTR _lParam$[ebp], 2
  001f7	75 05		 jne	 SHORT $LN23@WMNotify
$LN24@WMNotify:

; 2240 : 					return true;

  001f9	33 c0		 xor	 eax, eax
  001fb	40		 inc	 eax
  001fc	eb 4c		 jmp	 SHORT $LN1@WMNotify
$LN23@WMNotify:

; 2241 :                 break;

  001fe	eb 23		 jmp	 SHORT $LN4@WMNotify
$LN25@WMNotify:

; 2242 : 
; 2243 :             case IMEID_CHT_VER50:
; 2244 :             case IMEID_CHT_VER51:
; 2245 :             case IMEID_CHT_VER52:
; 2246 :             case IMEID_CHT_VER60:
; 2247 :             case IMEID_CHS_VER53:
; 2248 :                 if ((lParam == 16)||(lParam == 17)||(lParam == 26)||(lParam == 27)||(lParam == 28))

  00200	83 7d 14 10	 cmp	 DWORD PTR _lParam$[ebp], 16 ; 00000010H
  00204	74 18		 je	 SHORT $LN27@WMNotify
  00206	83 7d 14 11	 cmp	 DWORD PTR _lParam$[ebp], 17 ; 00000011H
  0020a	74 12		 je	 SHORT $LN27@WMNotify
  0020c	83 7d 14 1a	 cmp	 DWORD PTR _lParam$[ebp], 26 ; 0000001aH
  00210	74 0c		 je	 SHORT $LN27@WMNotify
  00212	83 7d 14 1b	 cmp	 DWORD PTR _lParam$[ebp], 27 ; 0000001bH
  00216	74 06		 je	 SHORT $LN27@WMNotify
  00218	83 7d 14 1c	 cmp	 DWORD PTR _lParam$[ebp], 28 ; 0000001cH
  0021c	75 05		 jne	 SHORT $LN4@WMNotify
$LN27@WMNotify:

; 2249 : 					return true;

  0021e	33 c0		 xor	 eax, eax
  00220	40		 inc	 eax
  00221	eb 27		 jmp	 SHORT $LN1@WMNotify
$LN4@WMNotify:

; 2250 :                 break;
; 2251 :         }
; 2252 : 		ImmReleaseContext(hWnd, hImc);

  00223	ff 75 ec	 push	 DWORD PTR _hImc$1[ebp]
  00226	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  00229	e8 00 00 00 00	 call	 _ImmReleaseContext@8
$LN2@WMNotify:

; 2253 : 		break;
; 2254 : 		}
; 2255 : 	}
; 2256 : 
; 2257 : 	if(ms_pEvent)

  0022e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  00235	74 10		 je	 SHORT $LN28@WMNotify

; 2258 : 		ms_pEvent->OnUpdate();

  00237	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0023c	8b 00		 mov	 eax, DWORD PTR [eax]
  0023e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00244	ff 50 04	 call	 DWORD PTR [eax+4]
$LN28@WMNotify:

; 2259 : 
; 2260 : 	return result;

  00247	8b 45 e8	 mov	 eax, DWORD PTR _result$[ebp]
$LN1@WMNotify:

; 2261 : }

  0024a	c9		 leave
  0024b	c2 10 00	 ret	 16			; 00000010H
?WMNotify@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP		; CIME::WMNotify
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?WMEndComposition@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?WMEndComposition@CIME@@QAEJPAUHWND__@@IIJ@Z PROC	; CIME::WMEndComposition, COMDAT
; _this$ = ecx

; 2172 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2173 : 	ms_compLen = 0;

  00007	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen

; 2174 : 	ms_ulbegin = 0;

  0000e	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_ulbegin@CIME@@2HA, 0 ; CIME::ms_ulbegin

; 2175 : 	ms_ulend = 0;

  00015	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_ulend@CIME@@2HA, 0 ; CIME::ms_ulend

; 2176 : 
; 2177 : 	if(ms_pEvent)

  0001c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  00023	74 10		 je	 SHORT $LN2@WMEndCompo

; 2178 : 		ms_pEvent->OnUpdate();

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00032	ff 50 04	 call	 DWORD PTR [eax+4]
$LN2@WMEndCompo:

; 2179 : 
; 2180 : 	return 0L;

  00035	33 c0		 xor	 eax, eax

; 2181 : }

  00037	c9		 leave
  00038	c2 10 00	 ret	 16			; 00000010H
?WMEndComposition@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP	; CIME::WMEndComposition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?WMComposition@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_result$ = -12						; size = 4
_this$ = -8						; size = 4
_hImc$ = -4						; size = 4
_hWnd$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WMComposition@CIME@@QAEJPAUHWND__@@IIJ@Z PROC		; CIME::WMComposition, COMDAT
; _this$ = ecx

; 2133 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2134 : 	LRESULT		result = 0;

  00009	83 65 f4 00	 and	 DWORD PTR _result$[ebp], 0

; 2135 : 
; 2136 : 	if(ms_bCaptureInput == false)

  0000d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bCaptureInput@CIME@@2_NA ; CIME::ms_bCaptureInput
  00014	85 c0		 test	 eax, eax
  00016	75 07		 jne	 SHORT $LN2@WMComposit

; 2137 : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	e9 a8 00 00 00	 jmp	 $LN1@WMComposit
$LN2@WMComposit:

; 2138 : 
; 2139 : 	HIMC hImc = ImmGetContext(hWnd);

  0001f	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  00022	e8 00 00 00 00	 call	 _ImmGetContext@4
  00027	89 45 fc	 mov	 DWORD PTR _hImc$[ebp], eax

; 2140 : 
; 2141 : 	if(hImc == NULL)

  0002a	83 7d fc 00	 cmp	 DWORD PTR _hImc$[ebp], 0
  0002e	75 07		 jne	 SHORT $LN3@WMComposit

; 2142 : 		return 0;

  00030	33 c0		 xor	 eax, eax
  00032	e9 90 00 00 00	 jmp	 $LN1@WMComposit
$LN3@WMComposit:

; 2143 : 
; 2144 : 	if(lParam&GCS_RESULTSTR) 

  00037	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0003a	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0003f	74 0b		 je	 SHORT $LN4@WMComposit

; 2145 : 		ResultProcess(hImc);

  00041	ff 75 fc	 push	 DWORD PTR _hImc$[ebp]
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::ResultProcess
$LN4@WMComposit:

; 2146 : 	if(lParam&GCS_COMPATTR) 

  0004c	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0004f	83 e0 10	 and	 eax, 16			; 00000010H
  00052	74 0b		 je	 SHORT $LN5@WMComposit

; 2147 : 		AttributeProcess(hImc);

  00054	ff 75 fc	 push	 DWORD PTR _hImc$[ebp]
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::AttributeProcess
$LN5@WMComposit:

; 2148 : 	if(lParam&GCS_COMPSTR)

  0005f	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00062	83 e0 08	 and	 eax, 8
  00065	74 39		 je	 SHORT $LN6@WMComposit

; 2149 : 	{
; 2150 : 		if (ms_uOutputCodePage == 950) //    

  00067	81 3d 00 00 00
	00 b6 03 00 00	 cmp	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA, 950 ; CIME::ms_uOutputCodePage, 000003b6H
  00071	75 22		 jne	 SHORT $LN7@WMComposit

; 2151 : 		{
; 2152 : 			if (lParam&GCS_COMPATTR) 

  00073	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00076	83 e0 10	 and	 eax, 16			; 00000010H
  00079	74 0d		 je	 SHORT $LN9@WMComposit

; 2153 : 				CompositionProcessBuilding(hImc);

  0007b	ff 75 fc	 push	 DWORD PTR _hImc$[ebp]
  0007e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	e8 00 00 00 00	 call	 ?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CompositionProcessBuilding
  00086	eb 0b		 jmp	 SHORT $LN10@WMComposit
$LN9@WMComposit:

; 2154 : 			else
; 2155 : 				CompositionProcess(hImc);

  00088	ff 75 fc	 push	 DWORD PTR _hImc$[ebp]
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CompositionProcess
$LN10@WMComposit:

; 2156 : 		}

  00093	eb 0b		 jmp	 SHORT $LN6@WMComposit
$LN7@WMComposit:

; 2157 : 		else
; 2158 : 		{
; 2159 : 			CompositionProcess(hImc);

  00095	ff 75 fc	 push	 DWORD PTR _hImc$[ebp]
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CompositionProcess
$LN6@WMComposit:

; 2160 : 		}
; 2161 : 	}
; 2162 : 
; 2163 : 	ImmReleaseContext(hWnd, hImc);

  000a0	ff 75 fc	 push	 DWORD PTR _hImc$[ebp]
  000a3	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  000a6	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 2164 : 
; 2165 : 	if(ms_pEvent)

  000ab	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  000b2	74 10		 je	 SHORT $LN11@WMComposit

; 2166 : 		ms_pEvent->OnUpdate();

  000b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  000b9	8b 00		 mov	 eax, DWORD PTR [eax]
  000bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  000c1	ff 50 04	 call	 DWORD PTR [eax+4]
$LN11@WMComposit:

; 2167 : 
; 2168 : 	return (result);

  000c4	8b 45 f4	 mov	 eax, DWORD PTR _result$[ebp]
$LN1@WMComposit:

; 2169 : }

  000c7	c9		 leave
  000c8	c2 10 00	 ret	 16			; 00000010H
?WMComposition@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP		; CIME::WMComposition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?WMStartComposition@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?WMStartComposition@CIME@@QAEJPAUHWND__@@IIJ@Z PROC	; CIME::WMStartComposition, COMDAT
; _this$ = ecx

; 2128 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2129 : 	return 1L;

  00007	33 c0		 xor	 eax, eax
  00009	40		 inc	 eax

; 2130 : }

  0000a	c9		 leave
  0000b	c2 10 00	 ret	 16			; 00000010H
?WMStartComposition@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP	; CIME::WMStartComposition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?WMInputLanguage@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hWnd$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WMInputLanguage@CIME@@QAEJPAUHWND__@@IIJ@Z PROC	; CIME::WMInputLanguage, COMDAT
; _this$ = ecx

; 2122 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2123 : 	ChangeInputLanguage();

  00007	e8 00 00 00 00	 call	 ?ChangeInputLanguage@CIME@@SAXXZ ; CIME::ChangeInputLanguage

; 2124 : 	return 0;

  0000c	33 c0		 xor	 eax, eax

; 2125 : }

  0000e	c9		 leave
  0000f	c2 10 00	 ret	 16			; 00000010H
?WMInputLanguage@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP	; CIME::WMInputLanguage
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?ChangeInputLanguageWorker@CIME@@SAXXZ
_TEXT	SEGMENT
tv67 = -4						; size = 4
?ChangeInputLanguageWorker@CIME@@SAXXZ PROC		; CIME::ChangeInputLanguageWorker, COMDAT

; 757  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 758  : 	if ( !ms_bUILessMode )

  00004	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode
  0000b	85 c0		 test	 eax, eax
  0000d	75 21		 jne	 SHORT $LN2@ChangeInpu

; 759  : 		ms_iCandListIndexBase = ( ms_hklCurrent == _CHT_HKL_DAYI ) ? 0 : 1;

  0000f	81 3d 00 00 00
	00 04 04 06 e0	 cmp	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, -536476668 ; CIME::ms_hklCurrent, e0060404H
  00019	75 06		 jne	 SHORT $LN4@ChangeInpu
  0001b	83 65 fc 00	 and	 DWORD PTR tv67[ebp], 0
  0001f	eb 07		 jmp	 SHORT $LN5@ChangeInpu
$LN4@ChangeInpu:
  00021	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
$LN5@ChangeInpu:
  00028	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]
  0002b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_iCandListIndexBase@CIME@@2HA, eax ; CIME::ms_iCandListIndexBase
$LN2@ChangeInpu:

; 760  : 	SetupImeApi();

  00030	e8 00 00 00 00	 call	 ?SetupImeApi@CIME@@KAXXZ ; CIME::SetupImeApi

; 761  : }

  00035	c9		 leave
  00036	c3		 ret	 0
?ChangeInputLanguageWorker@CIME@@SAXXZ ENDP		; CIME::ChangeInputLanguageWorker
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?ChangeInputLanguage@CIME@@SAXXZ
_TEXT	SEGMENT
_uLanguage$ = -8					; size = 4
tv78 = -4						; size = 4
?ChangeInputLanguage@CIME@@SAXXZ PROC			; CIME::ChangeInputLanguage, COMDAT

; 733  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 734  : 	UINT uLanguage = (UINT) GETLANG();

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	0f b7 c0	 movzx	 eax, ax
  00012	89 45 f8	 mov	 DWORD PTR _uLanguage$[ebp], eax

; 735  : 	CheckToggleState();

  00015	e8 00 00 00 00	 call	 ?CheckToggleState@CIME@@KAXXZ ; CIME::CheckToggleState

; 736  : 	ChangeInputLanguageWorker();

  0001a	e8 00 00 00 00	 call	 ?ChangeInputLanguageWorker@CIME@@SAXXZ ; CIME::ChangeInputLanguageWorker

; 737  : 	if (uLanguage != GETLANG())

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00024	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00029	0f b7 c0	 movzx	 eax, ax
  0002c	39 45 f8	 cmp	 DWORD PTR _uLanguage$[ebp], eax
  0002f	74 34		 je	 SHORT $LN2@ChangeInpu

; 738  : 	{
; 739  : 		// Korean IME always uses level 3 support.
; 740  : 		// Other languages use the level that is specified by ImeUi_SetSupportLevel()
; 741  : 		SetSupportLevel( ( GETPRIMLANG() == LANG_KOREAN ) ? 3 : ms_dwIMELevelSaved );

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00036	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003b	0f b7 c0	 movzx	 eax, ax
  0003e	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00043	0f b7 c0	 movzx	 eax, ax
  00046	83 f8 12	 cmp	 eax, 18			; 00000012H
  00049	75 09		 jne	 SHORT $LN5@ChangeInpu
  0004b	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR tv78[ebp], 3
  00052	eb 08		 jmp	 SHORT $LN6@ChangeInpu
$LN5@ChangeInpu:
  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwIMELevelSaved@CIME@@2KA ; CIME::ms_dwIMELevelSaved
  00059	89 45 fc	 mov	 DWORD PTR tv78[ebp], eax
$LN6@ChangeInpu:
  0005c	ff 75 fc	 push	 DWORD PTR tv78[ebp]
  0005f	e8 00 00 00 00	 call	 ?SetSupportLevel@CIME@@KAXK@Z ; CIME::SetSupportLevel
  00064	59		 pop	 ecx
$LN2@ChangeInpu:

; 742  : 	}
; 743  : 
; 744  : 	if(ms_pEvent)

  00065	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  0006c	74 10		 je	 SHORT $LN1@ChangeInpu

; 745  : 		ms_pEvent->OnChangeCodePage();

  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0007b	ff 50 08	 call	 DWORD PTR [eax+8]
$LN1@ChangeInpu:

; 746  : 
; 747  : 	//HWND hwndImeDef = ImmGetDefaultIMEWnd(ms_hWnd);
; 748  : 	//if ( hwndImeDef )
; 749  : 	//{
; 750  : 	//	// Fix for Zooty #3995: prevent CHT IME toobar from showing up
; 751  : 	//	SendMessageA(hwndImeDef, WM_IME_CONTROL, IMC_OPENSTATUSWINDOW, 0);
; 752  : 	//	SendMessageA(hwndImeDef, WM_IME_CONTROL, IMC_CLOSESTATUSWINDOW, 0);
; 753  : 	//}
; 754  : }

  0007e	c9		 leave
  0007f	c3		 ret	 0
?ChangeInputLanguage@CIME@@SAXXZ ENDP			; CIME::ChangeInputLanguage
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CloseReadingInformation@CIME@@SAXXZ
_TEXT	SEGMENT
?CloseReadingInformation@CIME@@SAXXZ PROC		; CIME::CloseReadingInformation, COMDAT

; 726  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 727  : 	CIME::ms_bReadingInformation = false;

  00003	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bReadingInformation@CIME@@2_NA, 0 ; CIME::ms_bReadingInformation

; 728  : 	if(CIME::ms_pEvent)

  0000a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  00011	74 10		 je	 SHORT $LN1@CloseReadi

; 729  : 		CIME::ms_pEvent->OnCloseReadingWnd();

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00020	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1@CloseReadi:

; 730  : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?CloseReadingInformation@CIME@@SAXXZ ENDP		; CIME::CloseReadingInformation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CloseCandidateList@CIME@@SAXXZ
_TEXT	SEGMENT
?CloseCandidateList@CIME@@SAXXZ PROC			; CIME::CloseCandidateList, COMDAT

; 717  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 718  : 	ms_bCandidateList = false;

  00003	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bCandidateList@CIME@@2_NA, 0 ; CIME::ms_bCandidateList

; 719  : 	ms_dwCandidateCount = 0;

  0000a	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_dwCandidateCount@CIME@@2KA, 0 ; CIME::ms_dwCandidateCount

; 720  : 	memset(&ms_wszCandidate, 0, sizeof(ms_wszCandidate));

  00011	68 00 14 00 00	 push	 5120			; 00001400H
  00016	6a 00		 push	 0
  00018	68 00 00 00 00	 push	 OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  0001d	e8 00 00 00 00	 call	 _memset
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 721  : 	if(ms_pEvent)

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  0002c	74 10		 je	 SHORT $LN1@CloseCandi

; 722  : 		ms_pEvent->OnCloseCandidateList();

  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0003b	ff 50 10	 call	 DWORD PTR [eax+16]
$LN1@CloseCandi:

; 723  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?CloseCandidateList@CIME@@SAXXZ ENDP			; CIME::CloseCandidateList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetULEnd@CIME@@SAHXZ
_TEXT	SEGMENT
?GetULEnd@CIME@@SAHXZ PROC				; CIME::GetULEnd, COMDAT

; 712  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 713  : 	return ms_ulend;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_ulend@CIME@@2HA ; CIME::ms_ulend

; 714  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?GetULEnd@CIME@@SAHXZ ENDP				; CIME::GetULEnd
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetULBegin@CIME@@SAHXZ
_TEXT	SEGMENT
?GetULBegin@CIME@@SAHXZ PROC				; CIME::GetULBegin, COMDAT

; 707  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 708  : 	return ms_ulbegin;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_ulbegin@CIME@@2HA ; CIME::ms_ulbegin

; 709  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?GetULBegin@CIME@@SAHXZ ENDP				; CIME::GetULBegin
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCompLen@CIME@@SAHXZ
_TEXT	SEGMENT
?GetCompLen@CIME@@SAHXZ PROC				; CIME::GetCompLen, COMDAT

; 702  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 703  : 	return ms_compLen;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_compLen@CIME@@2HA ; CIME::ms_compLen

; 704  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?GetCompLen@CIME@@SAHXZ ENDP				; CIME::GetCompLen
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCurPos@CIME@@SAHXZ
_TEXT	SEGMENT
_pos$ = -4						; size = 4
?GetCurPos@CIME@@SAHXZ PROC				; CIME::GetCurPos, COMDAT

; 807  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 808  : 	int pos = GetTextTagOutputLen(m_wText, ms_curpos);

  00004	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0000a	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  0000f	e8 00 00 00 00	 call	 ?GetTextTagOutputLen@@YAHPB_WH@Z ; GetTextTagOutputLen
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx
  00016	89 45 fc	 mov	 DWORD PTR _pos$[ebp], eax

; 809  : 	return pos;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _pos$[ebp]

; 810  : 	//return ms_curpos;
; 811  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?GetCurPos@CIME@@SAHXZ ENDP				; CIME::GetCurPos
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?UseDefaultIME@CIME@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UseDefaultIME@CIME@@QAEXXZ PROC			; CIME::UseDefaultIME, COMDAT
; _this$ = ecx

; 376  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 377  : 	m_bUseDefaultIME = true;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 21 01	 mov	 BYTE PTR [eax+33], 1

; 378  : }

  0000e	c9		 leave
  0000f	c3		 ret	 0
?UseDefaultIME@CIME@@QAEXXZ ENDP			; CIME::UseDefaultIME
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?FinalizeString@CIME@@SAX_N@Z
_TEXT	SEGMENT
_himc$ = -4						; size = 4
_bSend$ = 8						; size = 1
?FinalizeString@CIME@@SAX_N@Z PROC			; CIME::FinalizeString, COMDAT

; 663  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 664  : 	HIMC himc;
; 665  : 	static bool s_bProcessing = false; // to avoid infinite recursion
; 666  : 	if ( !ms_bInitialized || s_bProcessing || NULL == ( himc = ImmGetContext( ms_hWnd ) ) )

  00004	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bInitialized@CIME@@2_NA ; CIME::ms_bInitialized
  0000b	85 c0		 test	 eax, eax
  0000d	74 1f		 je	 SHORT $LN3@FinalizeSt
  0000f	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA
  00016	85 c0		 test	 eax, eax
  00018	75 14		 jne	 SHORT $LN3@FinalizeSt
  0001a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00020	e8 00 00 00 00	 call	 _ImmGetContext@4
  00025	89 45 fc	 mov	 DWORD PTR _himc$[ebp], eax
  00028	83 7d fc 00	 cmp	 DWORD PTR _himc$[ebp], 0
  0002c	75 02		 jne	 SHORT $LN2@FinalizeSt
$LN3@FinalizeSt:

; 667  : 		return;

  0002e	eb 60		 jmp	 SHORT $LN1@FinalizeSt
$LN2@FinalizeSt:

; 668  : 	s_bProcessing = true;

  00030	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA, 1

; 669  : 
; 670  : 	if (ms_dwIMELevel == 2 && bSend)
; 671  : 	{
; 672  : 		//// Send composition string to app.
; 673  : 		//LONG lRet = lstrlenW( m_wszComposition );
; 674  : 		////assert( lRet >= 2);
; 675  : 		//// In case of CHT IME, don't send the trailing double byte space, if it exists.
; 676  : 		//if ( GETLANG() == LANG_CHT && (lRet >= 1)
; 677  : 		//	&& m_wszComposition[lRet - 1] == 0x3000 )
; 678  : 		//{
; 679  : 		//	lRet--;
; 680  : 		//}
; 681  : 		//SendCompString();
; 682  : 	}
; 683  : 
; 684  : 	//InitCompStringData();
; 685  : 	// clear composition string in IME
; 686  : 	ImmNotifyIME(himc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);

  00037	6a 00		 push	 0
  00039	6a 04		 push	 4
  0003b	6a 15		 push	 21			; 00000015H
  0003d	ff 75 fc	 push	 DWORD PTR _himc$[ebp]
  00040	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 687  : 	if (ms_bUILessMode)

  00045	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode
  0004c	85 c0		 test	 eax, eax
  0004e	74 18		 je	 SHORT $LN5@FinalizeSt

; 688  : 	{
; 689  : 		// For some reason ImmNotifyIME doesn't work on DaYi and Array CHT IMEs. Cancel composition string by setting zero-length string.
; 690  : 		ImmSetCompositionStringW(himc, SCS_SETSTR, L"", sizeof(wchar_t), L"", sizeof(wchar_t));

  00050	6a 02		 push	 2
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00057	6a 02		 push	 2
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  0005e	6a 09		 push	 9
  00060	ff 75 fc	 push	 DWORD PTR _himc$[ebp]
  00063	e8 00 00 00 00	 call	 _ImmSetCompositionStringW@24
$LN5@FinalizeSt:

; 691  : 	}
; 692  : 	// the following line is necessary as Korean IME doesn't close cand list when comp string is cancelled.
; 693  : 	ImmNotifyIME( himc, NI_CLOSECANDIDATE, 0, 0 );	

  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	6a 11		 push	 17			; 00000011H
  0006e	ff 75 fc	 push	 DWORD PTR _himc$[ebp]
  00071	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 694  : 	ImmReleaseContext(ms_hWnd, himc);

  00076	ff 75 fc	 push	 DWORD PTR _himc$[ebp]
  00079	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0007f	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 695  : 	// Zooty2 RAID #4759: Sometimes application doesn't receive IMN_CLOSECANDIDATE on Alt+Tab
; 696  : 	// So the same code for IMN_CLOSECANDIDATE is replicated here.
; 697  : 	CloseCandidateList();

  00084	e8 00 00 00 00	 call	 ?CloseCandidateList@CIME@@SAXXZ ; CIME::CloseCandidateList

; 698  : 	s_bProcessing = false;

  00089	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA, 0
$LN1@FinalizeSt:

; 699  : }

  00090	c9		 leave
  00091	c3		 ret	 0
?FinalizeString@CIME@@SAX_N@Z ENDP			; CIME::FinalizeString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?PasteString@CIME@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -128						; size = 4
_wstrLen$ = -124					; size = 4
_end$ = -120						; size = 4
_begin$ = -116						; size = 4
_m_wText$ = -112					; size = 2048
__$ArrayPad$ = 1936					; size = 4
_str$ = 1948						; size = 4
?PasteString@CIME@@QAEXPBD@Z PROC			; CIME::PasteString, COMDAT
; _this$ = ecx

; 840  : {

  00000	55		 push	 ebp
  00001	8d ac 24 6c f8
	ff ff		 lea	 ebp, DWORD PTR [esp-1940]
  00008	81 ec 14 08 00
	00		 sub	 esp, 2068		; 00000814H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 90 07 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 80	 mov	 DWORD PTR _this$[ebp], ecx

; 841  : 	const char * begin = str;

  0001e	8b 85 9c 07 00
	00		 mov	 eax, DWORD PTR _str$[ebp]
  00024	89 45 8c	 mov	 DWORD PTR _begin$[ebp], eax

; 842  : 	const char * end = str + strlen(str);

  00027	ff b5 9c 07 00
	00		 push	 DWORD PTR _str$[ebp]
  0002d	e8 00 00 00 00	 call	 _strlen
  00032	59		 pop	 ecx
  00033	03 85 9c 07 00
	00		 add	 eax, DWORD PTR _str$[ebp]
  00039	89 45 88	 mov	 DWORD PTR _end$[ebp], eax

; 843  : 	wchar_t m_wText[IMESTR_MAXLEN];
; 844  : 	int wstrLen = MultiByteToWideChar(ms_uInputCodePage, 0, begin, end - begin, m_wText, IMESTR_MAXLEN);

  0003c	68 00 04 00 00	 push	 1024			; 00000400H
  00041	8d 45 90	 lea	 eax, DWORD PTR _m_wText$[ebp]
  00044	50		 push	 eax
  00045	8b 45 88	 mov	 eax, DWORD PTR _end$[ebp]
  00048	2b 45 8c	 sub	 eax, DWORD PTR _begin$[ebp]
  0004b	50		 push	 eax
  0004c	ff 75 8c	 push	 DWORD PTR _begin$[ebp]
  0004f	6a 00		 push	 0
  00051	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  0005d	89 45 84	 mov	 DWORD PTR _wstrLen$[ebp], eax

; 845  : 	InsertString(m_wText, wstrLen);

  00060	ff 75 84	 push	 DWORD PTR _wstrLen$[ebp]
  00063	8d 45 90	 lea	 eax, DWORD PTR _m_wText$[ebp]
  00066	50		 push	 eax
  00067	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?InsertString@CIME@@IAEXPA_WH@Z ; CIME::InsertString

; 846  : 	if(ms_pEvent)

  0006f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  00076	74 10		 je	 SHORT $LN1@PasteStrin

; 847  : 		ms_pEvent->OnUpdate();

  00078	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00085	ff 50 04	 call	 DWORD PTR [eax+4]
$LN1@PasteStrin:

; 848  : }

  00088	8b 8d 90 07 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	81 c5 94 07 00
	00		 add	 ebp, 1940		; 00000794H
  0009b	c9		 leave
  0009c	c2 04 00	 ret	 4
?PasteString@CIME@@QAEXPBD@Z ENDP			; CIME::PasteString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?EnablePaste@CIME@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bFlag$ = 8						; size = 1
?EnablePaste@CIME@@QAEX_N@Z PROC			; CIME::EnablePaste, COMDAT
; _this$ = ecx

; 631  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 632  : 	m_bEnablePaste = bFlag;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 4d 08	 mov	 cl, BYTE PTR _bFlag$[ebp]
  0000d	88 48 20	 mov	 BYTE PTR [eax+32], cl

; 633  : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?EnablePaste@CIME@@QAEX_N@Z ENDP			; CIME::EnablePaste
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?PasteTextFromClipBoard@CIME@@QAEXXZ
_TEXT	SEGMENT
_wstrLen$ = -52						; size = 4
_end$ = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
_buffer$ = -36						; size = 4
_this$ = -32						; size = 4
tv152 = -28						; size = 4
_handle$ = -24						; size = 4
_begin$ = -20						; size = 4
$T4 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_strClipboard$ = 0					; size = 24
_m_wText$ = 24						; size = 2048
__$ArrayPad$ = 2072					; size = 4
?PasteTextFromClipBoard@CIME@@QAEXXZ PROC		; CIME::PasteTextFromClipBoard, COMDAT
; _this$ = ecx

; 636  : {

  00000	55		 push	 ebp
  00001	8d ac 24 e4 f7
	ff ff		 lea	 ebp, DWORD PTR [esp-2076]
  00008	81 ec 1c 08 00
	00		 sub	 esp, 2076		; 0000081cH
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?PasteTextFromClipBoard@CIME@@QAEXXZ
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 28	 sub	 esp, 40			; 00000028H
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 18 08 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 637  : 	if (!m_bEnablePaste)

  00039	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	0f b6 40 20	 movzx	 eax, BYTE PTR [eax+32]
  00040	85 c0		 test	 eax, eax
  00042	75 05		 jne	 SHORT $LN2@PasteTextF

; 638  : 		return;

  00044	e9 ed 00 00 00	 jmp	 $LN1@PasteTextF
$LN2@PasteTextF:

; 639  : 
; 640  : 	if (!OpenClipboard(NULL))

  00049	6a 00		 push	 0
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenClipboard@4
  00051	85 c0		 test	 eax, eax
  00053	75 05		 jne	 SHORT $LN3@PasteTextF

; 641  : 		return;

  00055	e9 dc 00 00 00	 jmp	 $LN1@PasteTextF
$LN3@PasteTextF:

; 642  : 
; 643  : 	HANDLE handle = GetClipboardData(CF_TEXT);

  0005a	6a 01		 push	 1
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardData@4
  00062	89 45 e8	 mov	 DWORD PTR _handle$[ebp], eax

; 644  : 	char * buffer = (char*)GlobalLock(handle);

  00065	ff 75 e8	 push	 DWORD PTR _handle$[ebp]
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  0006e	89 45 dc	 mov	 DWORD PTR _buffer$[ebp], eax

; 645  : 	std::string strClipboard = buffer;

  00071	ff 75 dc	 push	 DWORD PTR _buffer$[ebp]
  00074	8d 4d 00	 lea	 ecx, DWORD PTR _strClipboard$[ebp]
  00077	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0007c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 646  : 	GlobalUnlock(handle);

  00080	ff 75 e8	 push	 DWORD PTR _handle$[ebp]
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 647  : 	CloseClipboard();

  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseClipboard@0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  0008f	8b 45 10	 mov	 eax, DWORD PTR _strClipboard$[ebp+16]
  00092	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax

; 3848 :         return size() == 0;

  00095	83 7d d8 00	 cmp	 DWORD PTR $T3[ebp], 0
  00099	75 09		 jne	 SHORT $LN39@PasteTextF
  0009b	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv152[ebp], 1
  000a2	eb 04		 jmp	 SHORT $LN40@PasteTextF
$LN39@PasteTextF:
  000a4	83 65 e4 00	 and	 DWORD PTR tv152[ebp], 0
$LN40@PasteTextF:
  000a8	8a 45 e4	 mov	 al, BYTE PTR tv152[ebp]
  000ab	88 45 f3	 mov	 BYTE PTR $T4[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 649  : 	if (strClipboard.empty())

  000ae	0f b6 45 f3	 movzx	 eax, BYTE PTR $T4[ebp]
  000b2	85 c0		 test	 eax, eax
  000b4	74 0e		 je	 SHORT $LN4@PasteTextF

; 650  : 		return;

  000b6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000ba	8d 4d 00	 lea	 ecx, DWORD PTR _strClipboard$[ebp]
  000bd	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 650  : 		return;

  000c2	eb 72		 jmp	 SHORT $LN1@PasteTextF
$LN4@PasteTextF:

; 651  : 
; 652  : 	const char* begin = strClipboard.c_str();

  000c4	8d 4d 00	 lea	 ecx, DWORD PTR _strClipboard$[ebp]
  000c7	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000cc	89 45 ec	 mov	 DWORD PTR _begin$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  000cf	8b 45 10	 mov	 eax, DWORD PTR _strClipboard$[ebp+16]
  000d2	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 653  : 	const char* end = begin + strClipboard.length();

  000d5	8b 45 ec	 mov	 eax, DWORD PTR _begin$[ebp]
  000d8	03 45 d4	 add	 eax, DWORD PTR $T2[ebp]
  000db	89 45 d0	 mov	 DWORD PTR _end$[ebp], eax

; 654  : 	wchar_t m_wText[IMESTR_MAXLEN];
; 655  : 	int wstrLen = MultiByteToWideChar(ms_uInputCodePage, 0, begin, end-begin, m_wText, IMESTR_MAXLEN);

  000de	68 00 04 00 00	 push	 1024			; 00000400H
  000e3	8d 45 18	 lea	 eax, DWORD PTR _m_wText$[ebp]
  000e6	50		 push	 eax
  000e7	8b 45 d0	 mov	 eax, DWORD PTR _end$[ebp]
  000ea	2b 45 ec	 sub	 eax, DWORD PTR _begin$[ebp]
  000ed	50		 push	 eax
  000ee	ff 75 ec	 push	 DWORD PTR _begin$[ebp]
  000f1	6a 00		 push	 0
  000f3	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  000ff	89 45 cc	 mov	 DWORD PTR _wstrLen$[ebp], eax

; 656  : 
; 657  : 	InsertString(m_wText, wstrLen);

  00102	ff 75 cc	 push	 DWORD PTR _wstrLen$[ebp]
  00105	8d 45 18	 lea	 eax, DWORD PTR _m_wText$[ebp]
  00108	50		 push	 eax
  00109	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	e8 00 00 00 00	 call	 ?InsertString@CIME@@IAEXPA_WH@Z ; CIME::InsertString

; 658  : 	if(ms_pEvent)

  00111	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A, 0 ; CIME::ms_pEvent
  00118	74 10		 je	 SHORT $LN5@PasteTextF

; 659  : 		ms_pEvent->OnUpdate();

  0011a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0011f	8b 00		 mov	 eax, DWORD PTR [eax]
  00121	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00127	ff 50 04	 call	 DWORD PTR [eax+4]
$LN5@PasteTextF:

; 660  : }

  0012a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0012e	8d 4d 00	 lea	 ecx, DWORD PTR _strClipboard$[ebp]
  00131	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1@PasteTextF:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 660  : }

  00136	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00139	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00140	59		 pop	 ecx
  00141	8b 8d 18 08 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00147	33 cd		 xor	 ecx, ebp
  00149	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014e	81 c5 1c 08 00
	00		 add	 ebp, 2076		; 0000081cH
  00154	c9		 leave
  00155	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PasteTextFromClipBoard@CIME@@QAEXXZ$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _strClipboard$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?PasteTextFromClipBoard@CIME@@QAEXXZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 8a 24 08 00
	00		 mov	 ecx, DWORD PTR [edx+2084]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PasteTextFromClipBoard@CIME@@QAEXXZ
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PasteTextFromClipBoard@CIME@@QAEXXZ ENDP		; CIME::PasteTextFromClipBoard
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?ClearExceptKey@CIME@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearExceptKey@CIME@@QAEXXZ PROC			; CIME::ClearExceptKey, COMDAT
; _this$ = ecx

; 618  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 619  : 	m_exceptKey.clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 14	 add	 ecx, 20			; 00000014H
  0000d	e8 00 00 00 00	 call	 ?clear@?$vector@_WV?$allocator@_W@std@@@std@@QAEXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::clear

; 620  : }

  00012	c9		 leave
  00013	c3		 ret	 0
?ClearExceptKey@CIME@@QAEXXZ ENDP			; CIME::ClearExceptKey
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?AddExceptKey@CIME@@QAEX_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 2
?AddExceptKey@CIME@@QAEX_W@Z PROC			; CIME::AddExceptKey, COMDAT
; _this$ = ecx

; 613  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00007	8d 45 08	 lea	 eax, DWORD PTR _key$[ebp]
  0000a	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 614  : 	m_exceptKey.push_back(key);

  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 14	 add	 ecx, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00011	e8 00 00 00 00	 call	 ??$emplace_back@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::emplace_back<wchar_t const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 615  : }

  00016	c9		 leave
  00017	c2 04 00	 ret	 4
?AddExceptKey@CIME@@QAEX_W@Z ENDP			; CIME::AddExceptKey
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?__IsWritable@CIME@@QAE_N_W@Z
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
__Right$ = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
___param0$ = -44					; size = 4
$T9 = -40						; size = 4
___param0$ = -36					; size = 4
$T10 = -32						; size = 4
___param0$ = -28					; size = 4
tv203 = -24						; size = 4
__My_data$11 = -20					; size = 4
__My_data$12 = -16					; size = 4
__My_data$13 = -12					; size = 4
_this$ = -8						; size = 4
$T14 = -1						; size = 1
_key$ = 8						; size = 2
?__IsWritable@CIME@@QAE_N_W@Z PROC			; CIME::__IsWritable, COMDAT
; _this$ = ecx

; 623  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 14	 add	 eax, 20			; 00000014H
  0000f	89 45 f4	 mov	 DWORD PTR __My_data$13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f4	 mov	 eax, DWORD PTR __My_data$13[ebp]
  00015	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f4	 mov	 eax, DWORD PTR __My_data$13[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 e4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 e4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 e0	 mov	 DWORD PTR $T10[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 e0	 lea	 eax, DWORD PTR $T10[ebp]
  0002a	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 14	 add	 eax, 20			; 00000014H
  00033	89 45 f0	 mov	 DWORD PTR __My_data$12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f0	 mov	 eax, DWORD PTR __My_data$12[ebp]
  00039	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f0	 mov	 eax, DWORD PTR __My_data$12[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 d8	 mov	 DWORD PTR $T9[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 d8	 lea	 eax, DWORD PTR $T9[ebp]
  0004d	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	83 c0 14	 add	 eax, 20			; 00000014H
  00056	89 45 ec	 mov	 DWORD PTR __My_data$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00059	8b 45 ec	 mov	 eax, DWORD PTR __My_data$11[ebp]
  0005c	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0005f	8b 45 ec	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00062	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00065	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00068	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  0006b	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0006e	8d 45 d0	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 c4	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 624  : 	if ( m_exceptKey.end() == std::find(m_exceptKey.begin(),m_exceptKey.end(),key) )

  00074	8d 45 08	 lea	 eax, DWORD PTR _key$[ebp]
  00077	50		 push	 eax
  00078	8b 45 cc	 mov	 eax, DWORD PTR $T7[ebp]
  0007b	ff 30		 push	 DWORD PTR [eax]
  0007d	8b 45 c8	 mov	 eax, DWORD PTR $T6[ebp]
  00080	ff 30		 push	 DWORD PTR [eax]
  00082	8d 45 b0	 lea	 eax, DWORD PTR $T1[ebp]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@_W@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@V10@V10@AB_W@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,wchar_t>
  0008b	83 c4 10	 add	 esp, 16			; 00000010H
  0008e	89 45 c0	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 149  :         return _Ptr == _Right._Ptr;

  00091	8b 45 c4	 mov	 eax, DWORD PTR $T5[ebp]
  00094	8b 4d c0	 mov	 ecx, DWORD PTR __Right$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0009b	75 09		 jne	 SHORT $LN85@IsWritable
  0009d	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv203[ebp], 1
  000a4	eb 04		 jmp	 SHORT $LN86@IsWritable
$LN85@IsWritable:
  000a6	83 65 e8 00	 and	 DWORD PTR tv203[ebp], 0
$LN86@IsWritable:
  000aa	8a 45 e8	 mov	 al, BYTE PTR tv203[ebp]
  000ad	88 45 ff	 mov	 BYTE PTR $T14[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 624  : 	if ( m_exceptKey.end() == std::find(m_exceptKey.begin(),m_exceptKey.end(),key) )

  000b0	0f b6 45 ff	 movzx	 eax, BYTE PTR $T14[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	74 06		 je	 SHORT $LN2@IsWritable

; 625  : 		return true;

  000b8	b0 01		 mov	 al, 1
  000ba	eb 04		 jmp	 SHORT $LN1@IsWritable
  000bc	eb 02		 jmp	 SHORT $LN1@IsWritable
$LN2@IsWritable:

; 626  : 	else
; 627  : 		return false;

  000be	32 c0		 xor	 al, al
$LN1@IsWritable:

; 628  : }

  000c0	c9		 leave
  000c1	c2 04 00	 ret	 4
?__IsWritable@CIME@@QAE_N_W@Z ENDP			; CIME::__IsWritable
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetStringMode@CIME@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetStringMode@CIME@@QAEXXZ PROC			; CIME::SetStringMode, COMDAT
; _this$ = ecx

; 608  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 609  : 	m_bOnlyNumberMode = FALSE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 610  : }

  0000e	c9		 leave
  0000f	c3		 ret	 0
?SetStringMode@CIME@@QAEXXZ ENDP			; CIME::SetStringMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetNumberMode@CIME@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetNumberMode@CIME@@QAEXXZ PROC			; CIME::SetNumberMode, COMDAT
; _this$ = ecx

; 603  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 604  : 	m_bOnlyNumberMode = TRUE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 605  : }

  00011	c9		 leave
  00012	c3		 ret	 0
?SetNumberMode@CIME@@QAEXXZ ENDP			; CIME::SetNumberMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?IsCaptureEnabled@CIME@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCaptureEnabled@CIME@@QAE_NXZ PROC			; CIME::IsCaptureEnabled, COMDAT
; _this$ = ecx

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 415  : 	return ms_bCaptureInput;

  00007	a0 00 00 00 00	 mov	 al, BYTE PTR ?ms_bCaptureInput@CIME@@2_NA ; CIME::ms_bCaptureInput

; 416  : }

  0000c	c9		 leave
  0000d	c3		 ret	 0
?IsCaptureEnabled@CIME@@QAE_NXZ ENDP			; CIME::IsCaptureEnabled
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?DisableCaptureInput@CIME@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DisableCaptureInput@CIME@@QAEXXZ PROC			; CIME::DisableCaptureInput, COMDAT
; _this$ = ecx

; 409  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 410  : 	ms_bCaptureInput = false;

  00007	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, 0 ; CIME::ms_bCaptureInput

; 411  : }

  0000e	c9		 leave
  0000f	c3		 ret	 0
?DisableCaptureInput@CIME@@QAEXXZ ENDP			; CIME::DisableCaptureInput
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?EnableCaptureInput@CIME@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EnableCaptureInput@CIME@@QAEXXZ PROC			; CIME::EnableCaptureInput, COMDAT
; _this$ = ecx

; 404  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 405  : 	ms_bCaptureInput = true;

  00007	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, 1 ; CIME::ms_bCaptureInput

; 406  : }

  0000e	c9		 leave
  0000f	c3		 ret	 0
?EnableCaptureInput@CIME@@QAEXXZ ENDP			; CIME::EnableCaptureInput
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?DisableIME@CIME@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DisableIME@CIME@@QAEXXZ PROC				; CIME::DisableIME, COMDAT
; _this$ = ecx

; 399  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 400  : 	EnableIME(false);

  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?EnableIME@CIME@@QAEX_N@Z ; CIME::EnableIME

; 401  : }

  00011	c9		 leave
  00012	c3		 ret	 0
?DisableIME@CIME@@QAEXXZ ENDP				; CIME::DisableIME
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?EnableIME@CIME@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv73 = -4						; size = 4
_bEnable$ = 8						; size = 1
?EnableIME@CIME@@QAEX_N@Z PROC				; CIME::EnableIME, COMDAT
; _this$ = ecx

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 387  : 	if (!ms_bInitialized || !ms_hWnd)

  00008	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bInitialized@CIME@@2_NA ; CIME::ms_bInitialized
  0000f	85 c0		 test	 eax, eax
  00011	74 09		 je	 SHORT $LN3@EnableIME
  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A, 0 ; CIME::ms_hWnd
  0001a	75 02		 jne	 SHORT $LN2@EnableIME
$LN3@EnableIME:

; 388  : 		return;

  0001c	eb 52		 jmp	 SHORT $LN1@EnableIME
$LN2@EnableIME:

; 389  : 	if (ms_bDisableIMECompletely)

  0001e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bDisableIMECompletely@CIME@@2_NA ; CIME::ms_bDisableIMECompletely
  00025	85 c0		 test	 eax, eax
  00027	74 04		 je	 SHORT $LN4@EnableIME

; 390  : 		bEnable = false;

  00029	c6 45 08 00	 mov	 BYTE PTR _bEnable$[ebp], 0
$LN4@EnableIME:

; 391  : 	ImmAssociateContext(ms_hWnd, bEnable ? m_hOrgIMC : NULL);

  0002d	0f b6 45 08	 movzx	 eax, BYTE PTR _bEnable$[ebp]
  00031	85 c0		 test	 eax, eax
  00033	74 0b		 je	 SHORT $LN7@EnableIME
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003b	89 45 fc	 mov	 DWORD PTR tv73[ebp], eax
  0003e	eb 04		 jmp	 SHORT $LN8@EnableIME
$LN7@EnableIME:
  00040	83 65 fc 00	 and	 DWORD PTR tv73[ebp], 0
$LN8@EnableIME:
  00044	ff 75 fc	 push	 DWORD PTR tv73[ebp]
  00047	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0004d	e8 00 00 00 00	 call	 _ImmAssociateContext@8

; 392  : 	ms_bImeEnabled = bEnable;

  00052	8a 45 08	 mov	 al, BYTE PTR _bEnable$[ebp]
  00055	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bImeEnabled@CIME@@2_NA, al ; CIME::ms_bImeEnabled

; 393  : 	if (bEnable)

  0005a	0f b6 45 08	 movzx	 eax, BYTE PTR _bEnable$[ebp]
  0005e	85 c0		 test	 eax, eax
  00060	74 05		 je	 SHORT $LN5@EnableIME

; 394  : 		CheckToggleState();

  00062	e8 00 00 00 00	 call	 ?CheckToggleState@CIME@@KAXXZ ; CIME::CheckToggleState
$LN5@EnableIME:

; 395  : 	CTsfUiLessMode::EnableUiUpdates(bEnable);

  00067	ff 75 08	 push	 DWORD PTR _bEnable$[ebp]
  0006a	e8 00 00 00 00	 call	 ?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z ; CTsfUiLessMode::EnableUiUpdates
  0006f	59		 pop	 ecx
$LN1@EnableIME:

; 396  : }

  00070	c9		 leave
  00071	c2 04 00	 ret	 4
?EnableIME@CIME@@QAEX_N@Z ENDP				; CIME::EnableIME
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?IsIMEEnabled@CIME@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsIMEEnabled@CIME@@QAE_NXZ PROC			; CIME::IsIMEEnabled, COMDAT
; _this$ = ecx

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 382  : 	return ms_bImeEnabled;

  00007	a0 00 00 00 00	 mov	 al, BYTE PTR ?ms_bImeEnabled@CIME@@2_NA ; CIME::ms_bImeEnabled

; 383  : }

  0000c	c9		 leave
  0000d	c3		 ret	 0
?IsIMEEnabled@CIME@@QAE_NXZ ENDP			; CIME::IsIMEEnabled
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetInputMode@CIME@@QAEKXZ
_TEXT	SEGMENT
_dwSMode$ = -16						; size = 4
_this$ = -12						; size = 4
_dwCMode$ = -8						; size = 4
_hImc$ = -4						; size = 4
?GetInputMode@CIME@@QAEKXZ PROC				; CIME::GetInputMode, COMDAT
; _this$ = ecx

; 590  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 591  : 	DWORD dwCMode, dwSMode;
; 592  : 
; 593  : 	HIMC hImc = ImmGetContext(ms_hWnd);

  00009	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0000f	e8 00 00 00 00	 call	 _ImmGetContext@4
  00014	89 45 fc	 mov	 DWORD PTR _hImc$[ebp], eax

; 594  : 
; 595  : 	ImmGetConversionStatus(hImc, &dwCMode, &dwSMode);

  00017	8d 45 f0	 lea	 eax, DWORD PTR _dwSMode$[ebp]
  0001a	50		 push	 eax
  0001b	8d 45 f8	 lea	 eax, DWORD PTR _dwCMode$[ebp]
  0001e	50		 push	 eax
  0001f	ff 75 fc	 push	 DWORD PTR _hImc$[ebp]
  00022	e8 00 00 00 00	 call	 _ImmGetConversionStatus@12

; 596  : 
; 597  : 	ImmReleaseContext(ms_hWnd, hImc);

  00027	ff 75 fc	 push	 DWORD PTR _hImc$[ebp]
  0002a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00030	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 598  : 
; 599  : 	return dwCMode;

  00035	8b 45 f8	 mov	 eax, DWORD PTR _dwCMode$[ebp]

; 600  : }

  00038	c9		 leave
  00039	c3		 ret	 0
?GetInputMode@CIME@@QAEKXZ ENDP				; CIME::GetInputMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetInputMode@CIME@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hImc$ = -4						; size = 4
_dwMode$ = 8						; size = 4
?SetInputMode@CIME@@QAEXK@Z PROC			; CIME::SetInputMode, COMDAT
; _this$ = ecx

; 581  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 582  : 	HIMC hImc = ImmGetContext(ms_hWnd);

  00008	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0000e	e8 00 00 00 00	 call	 _ImmGetContext@4
  00013	89 45 fc	 mov	 DWORD PTR _hImc$[ebp], eax

; 583  : 
; 584  : 	ImmSetConversionStatus(hImc, dwMode, IME_SMODE_AUTOMATIC);

  00016	6a 04		 push	 4
  00018	ff 75 08	 push	 DWORD PTR _dwMode$[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR _hImc$[ebp]
  0001e	e8 00 00 00 00	 call	 _ImmSetConversionStatus@12

; 585  : 
; 586  : 	ImmReleaseContext(ms_hWnd, hImc);

  00023	ff 75 fc	 push	 DWORD PTR _hImc$[ebp]
  00026	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0002c	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 587  : }

  00031	c9		 leave
  00032	c2 04 00	 ret	 4
?SetInputMode@CIME@@QAEXK@Z ENDP			; CIME::SetInputMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetReadingError@CIME@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetReadingError@CIME@@QAEHXZ PROC			; CIME::GetReadingError, COMDAT
; _this$ = ecx

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 444  : 	return ms_iReadingError;

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_iReadingError@CIME@@2HA ; CIME::ms_iReadingError

; 445  : }

  0000c	c9		 leave
  0000d	c3		 ret	 0
?GetReadingError@CIME@@QAEHXZ ENDP			; CIME::GetReadingError
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetReading@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = -84						; size = 4
$T2 = -80						; size = 4
__ULast$3 = -76						; size = 4
__Last$ = -72						; size = 4
__First$ = -68						; size = 4
_readingLen$ = -64					; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
_this$ = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
__My_data$8 = -40					; size = 4
$T9 = -36						; size = 4
__UFirst$10 = -32					; size = 4
__Ptr$ = -28						; size = 4
__My_data$11 = -24					; size = 4
__My_data$12 = -20					; size = 4
_reading$ = -16						; size = 128
__$ArrayPad$ = 112					; size = 4
_rstrText$ = 124					; size = 4
?GetReading@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CIME::GetReading, COMDAT
; _this$ = ecx

; 429  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 70	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00018	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __My_data$12[ebp], OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0001f	8b 45 ec	 mov	 eax, DWORD PTR __My_data$12[ebp]
  00022	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$12[ebp]
  00025	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00028	2b 01		 sub	 eax, DWORD PTR [ecx]
  0002a	d1 f8		 sar	 eax, 1
  0002c	89 45 dc	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 432  : 	if(ms_wstrReading.size() == 0)

  0002f	75 07		 jne	 SHORT $LN2@GetReading

; 433  : 		return 0;

  00031	33 c0		 xor	 eax, eax
  00033	e9 b8 00 00 00	 jmp	 $LN1@GetReading
$LN2@GetReading:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00038	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __My_data$11[ebp], OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0003f	8b 45 e8	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00042	8b 4d e8	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00045	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00048	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004a	d1 f8		 sar	 eax, 1
  0004c	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0004f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __My_data$8[ebp], OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00056	33 c0		 xor	 eax, eax
  00058	d1 e0		 shl	 eax, 1
  0005a	8b 4d d8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  0005d	03 01		 add	 eax, DWORD PTR [ecx]
  0005f	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 434  : 	int readingLen = WideCharToMultiByte(ms_uOutputCodePage, 0, &ms_wstrReading[0], ms_wstrReading.size(), reading, sizeof(reading), NULL, NULL);

  00062	6a 00		 push	 0
  00064	6a 00		 push	 0
  00066	68 80 00 00 00	 push	 128			; 00000080H
  0006b	8d 45 f0	 lea	 eax, DWORD PTR _reading$[ebp]
  0006e	50		 push	 eax
  0006f	ff 75 d4	 push	 DWORD PTR $T7[ebp]
  00072	ff 75 d0	 push	 DWORD PTR $T6[ebp]
  00075	6a 00		 push	 0
  00077	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00083	89 45 c0	 mov	 DWORD PTR _readingLen$[ebp], eax

; 435  : 
; 436  : 	rstrText.append(GetCodePageText());

  00086	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?GetCodePageText@CIME@@QAEPBDXZ ; CIME::GetCodePageText
  0008e	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00091	ff 75 e4	 push	 DWORD PTR __Ptr$[ebp]
  00094	e8 00 00 00 00	 call	 _strlen
  00099	59		 pop	 ecx
  0009a	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0009d	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  000a0	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000a3	ff 75 c4	 push	 DWORD PTR $T4[ebp]
  000a6	ff 75 e4	 push	 DWORD PTR __Ptr$[ebp]
  000a9	8b 4d 7c	 mov	 ecx, DWORD PTR _rstrText$[ebp]
  000ac	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 437  : 	rstrText.append(reading, reading + readingLen);

  000b1	8b 45 c0	 mov	 eax, DWORD PTR _readingLen$[ebp]
  000b4	8d 44 05 f0	 lea	 eax, DWORD PTR _reading$[ebp+eax]
  000b8	89 45 b8	 mov	 DWORD PTR __Last$[ebp], eax
  000bb	8d 45 f0	 lea	 eax, DWORD PTR _reading$[ebp]
  000be	89 45 bc	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2986 :         const auto _UFirst = _Get_unwrapped(_First);

  000c1	8b 45 bc	 mov	 eax, DWORD PTR __First$[ebp]
  000c4	89 45 e0	 mov	 DWORD PTR __UFirst$10[ebp], eax

; 2987 :         const auto _ULast  = _Get_unwrapped(_Last);

  000c7	8b 45 b8	 mov	 eax, DWORD PTR __Last$[ebp]
  000ca	89 45 b4	 mov	 DWORD PTR __ULast$3[ebp], eax

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  000cd	8b 45 b4	 mov	 eax, DWORD PTR __ULast$3[ebp]
  000d0	2b 45 e0	 sub	 eax, DWORD PTR __UFirst$10[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000d3	89 45 b0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  000d6	ff 75 b0	 push	 DWORD PTR $T2[ebp]
  000d9	ff 75 e0	 push	 DWORD PTR __UFirst$10[ebp]
  000dc	8b 4d 7c	 mov	 ecx, DWORD PTR _rstrText$[ebp]
  000df	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3770 :         return _Mypair._Myval2._Mysize;

  000e4	8b 45 7c	 mov	 eax, DWORD PTR _rstrText$[ebp]
  000e7	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000ea	89 45 ac	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 439  : 	return rstrText.size();

  000ed	8b 45 ac	 mov	 eax, DWORD PTR $T1[ebp]
$LN1@GetReading:

; 440  : }

  000f0	8b 4d 70	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f3	33 cd		 xor	 ecx, ebp
  000f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fa	83 c5 74	 add	 ebp, 116		; 00000074H
  000fd	c9		 leave
  000fe	c2 04 00	 ret	 4
?GetReading@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CIME::GetReading
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCandidateSelection@CIME@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCandidateSelection@CIME@@QAEHXZ PROC		; CIME::GetCandidateSelection, COMDAT
; _this$ = ecx

; 576  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 577  : 	return ms_dwCandidateSelection;

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection

; 578  : }

  0000c	c9		 leave
  0000d	c3		 ret	 0
?GetCandidateSelection@CIME@@QAEHXZ ENDP		; CIME::GetCandidateSelection
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCandidate@CIME@@QAEHKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -128						; size = 4
$T1 = -124						; size = 4
__ULast$2 = -120					; size = 4
__Last$ = -116						; size = 4
__First$ = -112						; size = 4
_len$ = -108						; size = 4
$T3 = -104						; size = 4
$T4 = -100						; size = 4
__UFirst$5 = -96					; size = 4
_wTextLen$ = -92					; size = 4
_wszText$ = -88						; size = 4
_text$ = -84						; size = 1024
__$ArrayPad$ = 940					; size = 4
_index$ = 952						; size = 4
_rstrText$ = 956					; size = 4
?GetCandidate@CIME@@QAEHKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CIME::GetCandidate, COMDAT
; _this$ = ecx

; 554  : {

  00000	55		 push	 ebp
  00001	8d ac 24 50 fc
	ff ff		 lea	 ebp, DWORD PTR [esp-944]
  00008	81 ec 30 04 00
	00		 sub	 esp, 1072		; 00000430H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 ac 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 80	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 	if(index >= MAX_CANDLIST)

  0001e	83 bd b8 03 00
	00 0a		 cmp	 DWORD PTR _index$[ebp], 10 ; 0000000aH
  00025	72 07		 jb	 SHORT $LN2@GetCandida

; 556  : 		return 0;

  00027	33 c0		 xor	 eax, eax
  00029	e9 b6 00 00 00	 jmp	 $LN1@GetCandida
$LN2@GetCandida:

; 557  : 
; 558  : 	LPCWSTR wszText = ms_wszCandidate[index];

  0002e	8b 85 b8 03 00
	00		 mov	 eax, DWORD PTR _index$[ebp]
  00034	c1 e0 09	 shl	 eax, 9
  00037	05 00 00 00 00	 add	 eax, OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  0003c	89 45 a8	 mov	 DWORD PTR _wszText$[ebp], eax

; 559  : 	if(wszText == NULL)

  0003f	75 07		 jne	 SHORT $LN3@GetCandida

; 560  : 		return 0;

  00041	33 c0		 xor	 eax, eax
  00043	e9 9c 00 00 00	 jmp	 $LN1@GetCandida
$LN3@GetCandida:

; 561  : 
; 562  : 	int wTextLen = wcslen(wszText);

  00048	ff 75 a8	 push	 DWORD PTR _wszText$[ebp]
  0004b	e8 00 00 00 00	 call	 _wcslen
  00050	59		 pop	 ecx
  00051	89 45 a4	 mov	 DWORD PTR _wTextLen$[ebp], eax

; 563  : 	if(wTextLen == 0)

  00054	83 7d a4 00	 cmp	 DWORD PTR _wTextLen$[ebp], 0
  00058	75 07		 jne	 SHORT $LN4@GetCandida

; 564  : 		return 0;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 83 00 00 00	 jmp	 $LN1@GetCandida
$LN4@GetCandida:

; 565  : 
; 566  : 	char text[IMESTR_MAXLEN];
; 567  : 	int len = ::WideCharToMultiByte(CP_UTF8, 0, wszText, wTextLen, text, sizeof(text), 0, 0);

  00061	6a 00		 push	 0
  00063	6a 00		 push	 0
  00065	68 00 04 00 00	 push	 1024			; 00000400H
  0006a	8d 45 ac	 lea	 eax, DWORD PTR _text$[ebp]
  0006d	50		 push	 eax
  0006e	ff 75 a4	 push	 DWORD PTR _wTextLen$[ebp]
  00071	ff 75 a8	 push	 DWORD PTR _wszText$[ebp]
  00074	6a 00		 push	 0
  00076	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00081	89 45 94	 mov	 DWORD PTR _len$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00084	68 00 00 00 00	 push	 OFFSET ??_C@_05EFEJGKEJ@?$EA9999@
  00089	e8 00 00 00 00	 call	 _strlen
  0008e	59		 pop	 ecx
  0008f	89 45 9c	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00092	8b 45 9c	 mov	 eax, DWORD PTR $T4[ebp]
  00095	89 45 98	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00098	ff 75 98	 push	 DWORD PTR $T3[ebp]
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_05EFEJGKEJ@?$EA9999@
  000a0	8b 8d bc 03 00
	00		 mov	 ecx, DWORD PTR _rstrText$[ebp]
  000a6	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 570  : 	rstrText.append(text, text+len);

  000ab	8b 45 94	 mov	 eax, DWORD PTR _len$[ebp]
  000ae	8d 44 05 ac	 lea	 eax, DWORD PTR _text$[ebp+eax]
  000b2	89 45 8c	 mov	 DWORD PTR __Last$[ebp], eax
  000b5	8d 45 ac	 lea	 eax, DWORD PTR _text$[ebp]
  000b8	89 45 90	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2986 :         const auto _UFirst = _Get_unwrapped(_First);

  000bb	8b 45 90	 mov	 eax, DWORD PTR __First$[ebp]
  000be	89 45 a0	 mov	 DWORD PTR __UFirst$5[ebp], eax

; 2987 :         const auto _ULast  = _Get_unwrapped(_Last);

  000c1	8b 45 8c	 mov	 eax, DWORD PTR __Last$[ebp]
  000c4	89 45 88	 mov	 DWORD PTR __ULast$2[ebp], eax

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  000c7	8b 45 88	 mov	 eax, DWORD PTR __ULast$2[ebp]
  000ca	2b 45 a0	 sub	 eax, DWORD PTR __UFirst$5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000cd	89 45 84	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  000d0	ff 75 84	 push	 DWORD PTR $T1[ebp]
  000d3	ff 75 a0	 push	 DWORD PTR __UFirst$5[ebp]
  000d6	8b 8d bc 03 00
	00		 mov	 ecx, DWORD PTR _rstrText$[ebp]
  000dc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 572  : 	return wTextLen;

  000e1	8b 45 a4	 mov	 eax, DWORD PTR _wTextLen$[ebp]
$LN1@GetCandida:

; 573  : }

  000e4	8b 8d ac 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	81 c5 b0 03 00
	00		 add	 ebp, 944		; 000003b0H
  000f7	c9		 leave
  000f8	c2 08 00	 ret	 8
?GetCandidate@CIME@@QAEHKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CIME::GetCandidate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCandidatePageCount@CIME@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCandidatePageCount@CIME@@QAEHXZ PROC		; CIME::GetCandidatePageCount, COMDAT
; _this$ = ecx

; 544  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 545  : 	return ms_dwCandidatePageSize;

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA ; CIME::ms_dwCandidatePageSize

; 546  : }

  0000c	c9		 leave
  0000d	c3		 ret	 0
?GetCandidatePageCount@CIME@@QAEHXZ ENDP		; CIME::GetCandidatePageCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCandidateCount@CIME@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCandidateCount@CIME@@QAEHXZ PROC			; CIME::GetCandidateCount, COMDAT
; _this$ = ecx

; 549  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 550  : 	return ms_dwCandidateCount;

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidateCount@CIME@@2KA ; CIME::ms_dwCandidateCount

; 551  : }

  0000c	c9		 leave
  0000d	c3		 ret	 0
?GetCandidateCount@CIME@@QAEHXZ ENDP			; CIME::GetCandidateCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCodePage@CIME@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCodePage@CIME@@QAEHXZ PROC				; CIME::GetCodePage, COMDAT
; _this$ = ecx

; 539  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 540  : 	return ms_uOutputCodePage;

  00007	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage

; 541  : }

  0000c	c9		 leave
  0000d	c3		 ret	 0
?GetCodePage@CIME@@QAEHXZ ENDP				; CIME::GetCodePage
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCodePageText@CIME@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_defCodePage$ = -12					; size = 4
$T1 = -8						; size = 4
_outCodePage$ = -4					; size = 4
?GetCodePageText@CIME@@QAEPBDXZ PROC			; CIME::GetCodePageText, COMDAT
; _this$ = ecx

; 520  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 	static char szCodePage[16];
; 522  : 
; 523  : 	const int defCodePage = GetDefaultCodePage();

  00009	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  0000e	89 45 f4	 mov	 DWORD PTR _defCodePage$[ebp], eax

; 524  : 	const int outCodePage = ms_uOutputCodePage;

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  00016	89 45 fc	 mov	 DWORD PTR _outCodePage$[ebp], eax

; 525  : 
; 526  : 	if (outCodePage != defCodePage)

  00019	8b 45 fc	 mov	 eax, DWORD PTR _outCodePage$[ebp]
  0001c	3b 45 f4	 cmp	 eax, DWORD PTR _defCodePage$[ebp]
  0001f	74 17		 je	 SHORT $LN2@GetCodePag

; 527  : 	{
; 528  : 		sprintf(szCodePage, "@%04d", outCodePage);

  00021	ff 75 fc	 push	 DWORD PTR _outCodePage$[ebp]
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_05JKJMOPAK@?$EA?$CF04d@
  00029	68 00 00 00 00	 push	 OFFSET ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA
  0002e	e8 00 00 00 00	 call	 _sprintf
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 529  : 	}

  00036	eb 20		 jmp	 SHORT $LN3@GetCodePag
$LN2@GetCodePag:

; 530  : 	else
; 531  : 	{
; 532  : 		szCodePage[0] = 0;

  00038	33 c0		 xor	 eax, eax
  0003a	40		 inc	 eax
  0003b	6b c0 00	 imul	 eax, eax, 0
  0003e	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00041	83 7d f8 10	 cmp	 DWORD PTR $T1[ebp], 16	; 00000010H
  00045	73 02		 jae	 SHORT $LN5@GetCodePag
  00047	eb 05		 jmp	 SHORT $LN6@GetCodePag
$LN5@GetCodePag:
  00049	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN6@GetCodePag:
  0004e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00051	c6 80 00 00 00
	00 00		 mov	 BYTE PTR ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA[eax], 0
$LN3@GetCodePag:

; 533  : 	}
; 534  : 
; 535  : 	return szCodePage;

  00058	b8 00 00 00 00	 mov	 eax, OFFSET ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA
$LN4@GetCodePag:

; 536  : }

  0005d	c9		 leave
  0005e	c3		 ret	 0
?GetCodePageText@CIME@@QAEPBDXZ ENDP			; CIME::GetCodePageText
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetText@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
$T1 = -128						; size = 4
$T2 = -124						; size = 4
__ULast$3 = -120					; size = 4
__Last$ = -116						; size = 4
__First$ = -112						; size = 4
$T4 = -108						; size = 4
__ULast$5 = -104					; size = 4
__Last$ = -100						; size = 4
__First$ = -96						; size = 4
$T6 = -92						; size = 4
__ULast$7 = -88						; size = 4
__Last$ = -84						; size = 4
__First$ = -80						; size = 4
_this$ = -76						; size = 4
tv64 = -72						; size = 4
__UFirst$8 = -68					; size = 4
__UFirst$9 = -64					; size = 4
__UFirst$10 = -60					; size = 4
_outCodePage$ = -56					; size = 4
_dataCodePage$ = -52					; size = 4
_i$ = -48						; size = 4
_len$ = -44						; size = 4
_text$ = -40						; size = 1024
__$ArrayPad$ = 984					; size = 4
_rstrText$ = 996					; size = 4
_addCodePage$ = 1000					; size = 1
?GetText@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; CIME::GetText, COMDAT
; _this$ = ecx

; 478  : {

  00000	55		 push	 ebp
  00001	8d ac 24 24 fc
	ff ff		 lea	 ebp, DWORD PTR [esp-988]
  00008	81 ec 5c 04 00
	00		 sub	 esp, 1116		; 0000045cH
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 d8 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 479  : 	int outCodePage = ms_uOutputCodePage;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  00023	89 45 c8	 mov	 DWORD PTR _outCodePage$[ebp], eax

; 480  : 	int dataCodePage;
; 481  : 	switch (outCodePage)

  00026	8b 45 c8	 mov	 eax, DWORD PTR _outCodePage$[ebp]
  00029	89 45 b8	 mov	 DWORD PTR tv64[ebp], eax
  0002c	81 7d b8 f4 04
	00 00		 cmp	 DWORD PTR tv64[ebp], 1268 ; 000004f4H
  00033	74 02		 je	 SHORT $LN7@GetText
  00035	eb 09		 jmp	 SHORT $LN8@GetText
$LN7@GetText:

; 482  : 	{
; 483  : 		//case 1256: // ARABIC
; 484  : 		case 1268: // VIETNAM
; 485  : 			dataCodePage = CP_UTF8;

  00037	c7 45 cc e9 fd
	00 00		 mov	 DWORD PTR _dataCodePage$[ebp], 65001 ; 0000fde9H

; 486  : 			break;

  0003e	eb 06		 jmp	 SHORT $LN2@GetText
$LN8@GetText:

; 487  : 		default:
; 488  : 			dataCodePage = outCodePage;

  00040	8b 45 c8	 mov	 eax, DWORD PTR _outCodePage$[ebp]
  00043	89 45 cc	 mov	 DWORD PTR _dataCodePage$[ebp], eax
$LN2@GetText:

; 489  : 	}
; 490  : 
; 491  : 	int len = 0;

  00046	83 65 d4 00	 and	 DWORD PTR _len$[ebp], 0

; 492  : 	char text[IMESTR_MAXLEN];
; 493  : 
; 494  : 	len += WideCharToMultiByte(dataCodePage, 0, m_wText, ms_curpos, text, sizeof(text)-len, NULL, NULL);

  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  00053	2b 45 d4	 sub	 eax, DWORD PTR _len$[ebp]
  00056	50		 push	 eax
  00057	8d 45 d8	 lea	 eax, DWORD PTR _text$[ebp]
  0005a	50		 push	 eax
  0005b	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00061	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  00066	6a 00		 push	 0
  00068	ff 75 cc	 push	 DWORD PTR _dataCodePage$[ebp]
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00071	03 45 d4	 add	 eax, DWORD PTR _len$[ebp]
  00074	89 45 d4	 mov	 DWORD PTR _len$[ebp], eax

; 495  : 	len += WideCharToMultiByte(dataCodePage, 0, m_wszComposition, ms_compLen, text+len, sizeof(text)-len, NULL, NULL);

  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  00080	2b 45 d4	 sub	 eax, DWORD PTR _len$[ebp]
  00083	50		 push	 eax
  00084	8b 45 d4	 mov	 eax, DWORD PTR _len$[ebp]
  00087	8d 44 05 d8	 lea	 eax, DWORD PTR _text$[ebp+eax]
  0008b	50		 push	 eax
  0008c	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_compLen@CIME@@2HA ; CIME::ms_compLen
  00092	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00095	83 c0 22	 add	 eax, 34			; 00000022H
  00098	50		 push	 eax
  00099	6a 00		 push	 0
  0009b	ff 75 cc	 push	 DWORD PTR _dataCodePage$[ebp]
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  000a4	03 45 d4	 add	 eax, DWORD PTR _len$[ebp]
  000a7	89 45 d4	 mov	 DWORD PTR _len$[ebp], eax

; 496  : 	len += WideCharToMultiByte(dataCodePage, 0, m_wText+ms_curpos, ms_lastpos-ms_curpos, text+len, sizeof(text)-len, NULL, NULL);

  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  000b3	2b 45 d4	 sub	 eax, DWORD PTR _len$[ebp]
  000b6	50		 push	 eax
  000b7	8b 45 d4	 mov	 eax, DWORD PTR _len$[ebp]
  000ba	8d 44 05 d8	 lea	 eax, DWORD PTR _text$[ebp+eax]
  000be	50		 push	 eax
  000bf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  000c4	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  000ca	50		 push	 eax
  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  000d0	8d 04 45 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax*2]
  000d7	50		 push	 eax
  000d8	6a 00		 push	 0
  000da	ff 75 cc	 push	 DWORD PTR _dataCodePage$[ebp]
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  000e3	03 45 d4	 add	 eax, DWORD PTR _len$[ebp]
  000e6	89 45 d4	 mov	 DWORD PTR _len$[ebp], eax

; 497  : 
; 498  : 	int i;
; 499  : 	for(i=0; i<len; ++i)

  000e9	83 65 d0 00	 and	 DWORD PTR _i$[ebp], 0
  000ed	eb 07		 jmp	 SHORT $LN6@GetText
$LN4@GetText:
  000ef	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  000f2	40		 inc	 eax
  000f3	89 45 d0	 mov	 DWORD PTR _i$[ebp], eax
$LN6@GetText:
  000f6	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  000f9	3b 45 d4	 cmp	 eax, DWORD PTR _len$[ebp]
  000fc	7d 11		 jge	 SHORT $LN5@GetText

; 500  : 		if((BYTE)text[i] > 0x7F) break;

  000fe	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  00101	0f b6 44 05 d8	 movzx	 eax, BYTE PTR _text$[ebp+eax]
  00106	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00109	7e 02		 jle	 SHORT $LN9@GetText
  0010b	eb 02		 jmp	 SHORT $LN5@GetText
$LN9@GetText:
  0010d	eb e0		 jmp	 SHORT $LN4@GetText
$LN5@GetText:

; 501  : 
; 502  : 	if(i == len)

  0010f	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  00112	3b 45 d4	 cmp	 eax, DWORD PTR _len$[ebp]
  00115	75 38		 jne	 SHORT $LN10@GetText

; 503  : 	{
; 504  : 		rstrText.append(text, text+len);

  00117	8b 45 d4	 mov	 eax, DWORD PTR _len$[ebp]
  0011a	8d 44 05 d8	 lea	 eax, DWORD PTR _text$[ebp+eax]
  0011e	89 45 ac	 mov	 DWORD PTR __Last$[ebp], eax
  00121	8d 45 d8	 lea	 eax, DWORD PTR _text$[ebp]
  00124	89 45 b0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2986 :         const auto _UFirst = _Get_unwrapped(_First);

  00127	8b 45 b0	 mov	 eax, DWORD PTR __First$[ebp]
  0012a	89 45 c4	 mov	 DWORD PTR __UFirst$10[ebp], eax

; 2987 :         const auto _ULast  = _Get_unwrapped(_Last);

  0012d	8b 45 ac	 mov	 eax, DWORD PTR __Last$[ebp]
  00130	89 45 a8	 mov	 DWORD PTR __ULast$7[ebp], eax

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  00133	8b 45 a8	 mov	 eax, DWORD PTR __ULast$7[ebp]
  00136	2b 45 c4	 sub	 eax, DWORD PTR __UFirst$10[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00139	89 45 a4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  0013c	ff 75 a4	 push	 DWORD PTR $T6[ebp]
  0013f	ff 75 c4	 push	 DWORD PTR __UFirst$10[ebp]
  00142	8b 8d e4 03 00
	00		 mov	 ecx, DWORD PTR _rstrText$[ebp]
  00148	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 505  : 	}

  0014d	eb 70		 jmp	 SHORT $LN11@GetText
$LN10@GetText:

; 506  : 	else
; 507  : 	{
; 508  : 		rstrText.append(text, text+i);

  0014f	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  00152	8d 44 05 d8	 lea	 eax, DWORD PTR _text$[ebp+eax]
  00156	89 45 9c	 mov	 DWORD PTR __Last$[ebp], eax
  00159	8d 45 d8	 lea	 eax, DWORD PTR _text$[ebp]
  0015c	89 45 a0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2986 :         const auto _UFirst = _Get_unwrapped(_First);

  0015f	8b 45 a0	 mov	 eax, DWORD PTR __First$[ebp]
  00162	89 45 c0	 mov	 DWORD PTR __UFirst$9[ebp], eax

; 2987 :         const auto _ULast  = _Get_unwrapped(_Last);

  00165	8b 45 9c	 mov	 eax, DWORD PTR __Last$[ebp]
  00168	89 45 98	 mov	 DWORD PTR __ULast$5[ebp], eax

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  0016b	8b 45 98	 mov	 eax, DWORD PTR __ULast$5[ebp]
  0016e	2b 45 c0	 sub	 eax, DWORD PTR __UFirst$9[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00171	89 45 94	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  00174	ff 75 94	 push	 DWORD PTR $T4[ebp]
  00177	ff 75 c0	 push	 DWORD PTR __UFirst$9[ebp]
  0017a	8b 8d e4 03 00
	00		 mov	 ecx, DWORD PTR _rstrText$[ebp]
  00180	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 513  : 		rstrText.append(text+i, text+len);

  00185	8b 45 d4	 mov	 eax, DWORD PTR _len$[ebp]
  00188	8d 44 05 d8	 lea	 eax, DWORD PTR _text$[ebp+eax]
  0018c	89 45 8c	 mov	 DWORD PTR __Last$[ebp], eax
  0018f	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp]
  00192	8d 44 05 d8	 lea	 eax, DWORD PTR _text$[ebp+eax]
  00196	89 45 90	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2986 :         const auto _UFirst = _Get_unwrapped(_First);

  00199	8b 45 90	 mov	 eax, DWORD PTR __First$[ebp]
  0019c	89 45 bc	 mov	 DWORD PTR __UFirst$8[ebp], eax

; 2987 :         const auto _ULast  = _Get_unwrapped(_Last);

  0019f	8b 45 8c	 mov	 eax, DWORD PTR __Last$[ebp]
  001a2	89 45 88	 mov	 DWORD PTR __ULast$3[ebp], eax

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  001a5	8b 45 88	 mov	 eax, DWORD PTR __ULast$3[ebp]
  001a8	2b 45 bc	 sub	 eax, DWORD PTR __UFirst$8[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  001ab	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  001ae	ff 75 84	 push	 DWORD PTR $T2[ebp]
  001b1	ff 75 bc	 push	 DWORD PTR __UFirst$8[ebp]
  001b4	8b 8d e4 03 00
	00		 mov	 ecx, DWORD PTR _rstrText$[ebp]
  001ba	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN11@GetText:

; 3770 :         return _Mypair._Myval2._Mysize;

  001bf	8b 85 e4 03 00
	00		 mov	 eax, DWORD PTR _rstrText$[ebp]
  001c5	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  001c8	89 45 80	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 516  : 	return rstrText.size();

  001cb	8b 45 80	 mov	 eax, DWORD PTR $T1[ebp]

; 517  : }

  001ce	8b 8d d8 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d4	33 cd		 xor	 ecx, ebp
  001d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001db	81 c5 dc 03 00
	00		 add	 ebp, 988		; 000003dcH
  001e1	c9		 leave
  001e2	c2 08 00	 ret	 8
?GetText@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; CIME::GetText
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetText@CIME@@QAEXPBDH@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv94 = -20						; size = 4
_m_wTextLen$ = -16					; size = 4
_end$ = -12						; size = 4
_begin$ = -8						; size = 4
_iter$ = -4						; size = 4
_szText$ = 8						; size = 4
_len$ = 12						; size = 4
?SetText@CIME@@QAEXPBDH@Z PROC				; CIME::SetText, COMDAT
; _this$ = ecx

; 458  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  : 	ms_compLen = 0;

  00009	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen

; 460  : 	ms_ulbegin = 0;

  00010	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_ulbegin@CIME@@2HA, 0 ; CIME::ms_ulbegin

; 461  : 	ms_ulend = 0;

  00017	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_ulend@CIME@@2HA, 0 ; CIME::ms_ulend

; 462  : 
; 463  : 	const char* begin = szText;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _szText$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _begin$[ebp], eax

; 464  : 	const char* end = begin + len;

  00024	8b 45 f8	 mov	 eax, DWORD PTR _begin$[ebp]
  00027	03 45 0c	 add	 eax, DWORD PTR _len$[ebp]
  0002a	89 45 f4	 mov	 DWORD PTR _end$[ebp], eax

; 465  : 	const char* iter = FindToken(begin, end);

  0002d	ff 75 f4	 push	 DWORD PTR _end$[ebp]
  00030	ff 75 f8	 push	 DWORD PTR _begin$[ebp]
  00033	e8 00 00 00 00	 call	 ?FindToken@@YAPBDPBD0@Z	; FindToken
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
  0003a	89 45 fc	 mov	 DWORD PTR _iter$[ebp], eax

; 466  : 
; 467  : 	int m_wTextLen = sizeof(m_wText)/sizeof(wchar_t);

  0003d	c7 45 f0 00 04
	00 00		 mov	 DWORD PTR _m_wTextLen$[ebp], 1024 ; 00000400H

; 468  : 
; 469  : 	ms_lastpos = MultiByteToWideChar(ms_uInputCodePage, 0, begin, iter-begin, m_wText, m_wTextLen);

  00044	ff 75 f0	 push	 DWORD PTR _m_wTextLen$[ebp]
  00047	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _iter$[ebp]
  0004f	2b 45 f8	 sub	 eax, DWORD PTR _begin$[ebp]
  00052	50		 push	 eax
  00053	ff 75 f8	 push	 DWORD PTR _begin$[ebp]
  00056	6a 00		 push	 0
  00058	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00064	a3 00 00 00 00	 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, eax ; CIME::ms_lastpos

; 470  : 
; 471  : 	if (iter < end)

  00069	8b 45 fc	 mov	 eax, DWORD PTR _iter$[ebp]
  0006c	3b 45 f4	 cmp	 eax, DWORD PTR _end$[ebp]
  0006f	73 47		 jae	 SHORT $LN2@SetText

; 472  : 		ms_lastpos += MultiByteToWideChar(ReadToken(iter), 0, (iter+5), end-(iter+5), m_wText+ms_lastpos, m_wTextLen-ms_lastpos);

  00071	8b 45 f0	 mov	 eax, DWORD PTR _m_wTextLen$[ebp]
  00074	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0007a	50		 push	 eax
  0007b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00080	8d 04 45 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax*2]
  00087	50		 push	 eax
  00088	8b 45 fc	 mov	 eax, DWORD PTR _iter$[ebp]
  0008b	83 c0 05	 add	 eax, 5
  0008e	8b 4d f4	 mov	 ecx, DWORD PTR _end$[ebp]
  00091	2b c8		 sub	 ecx, eax
  00093	51		 push	 ecx
  00094	8b 45 fc	 mov	 eax, DWORD PTR _iter$[ebp]
  00097	83 c0 05	 add	 eax, 5
  0009a	50		 push	 eax
  0009b	6a 00		 push	 0
  0009d	ff 75 fc	 push	 DWORD PTR _iter$[ebp]
  000a0	e8 00 00 00 00	 call	 ?ReadToken@@YAHPBD@Z	; ReadToken
  000a5	59		 pop	 ecx
  000a6	50		 push	 eax
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  000ad	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  000b3	a3 00 00 00 00	 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, eax ; CIME::ms_lastpos
$LN2@SetText:

; 473  : 
; 474  : 	ms_curpos = min(ms_curpos, ms_lastpos);

  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  000bd	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  000c3	7d 0a		 jge	 SHORT $LN4@SetText
  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  000ca	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  000cd	eb 08		 jmp	 SHORT $LN5@SetText
$LN4@SetText:
  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  000d4	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
$LN5@SetText:
  000d7	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  000da	a3 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, eax ; CIME::ms_curpos

; 475  : }

  000df	c9		 leave
  000e0	c2 08 00	 ret	 8
?SetText@CIME@@QAEXPBDH@Z ENDP				; CIME::SetText
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetUserMax@CIME@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iMax$ = 8						; size = 4
?SetUserMax@CIME@@QAEXH@Z PROC				; CIME::SetUserMax, COMDAT
; _this$ = ecx

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 454  : 	m_userMax = iMax;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _iMax$[ebp]
  0000d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 455  : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?SetUserMax@CIME@@QAEXH@Z ENDP				; CIME::SetUserMax
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetMax@CIME@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iMax$ = 8						; size = 4
?SetMax@CIME@@QAEXH@Z PROC				; CIME::SetMax, COMDAT
; _this$ = ecx

; 448  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 449  : 	m_max = iMax;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _iMax$[ebp]
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 450  : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?SetMax@CIME@@QAEXH@Z ENDP				; CIME::SetMax
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?Clear@CIME@@SAXXZ
_TEXT	SEGMENT
?Clear@CIME@@SAXXZ PROC					; CIME::Clear, COMDAT

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 420  : 	ms_lastpos = 0;

  00003	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_lastpos@CIME@@2HA, 0 ; CIME::ms_lastpos

; 421  : 	ms_curpos = 0;

  0000a	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_curpos@CIME@@2HA, 0 ; CIME::ms_curpos

; 422  : 
; 423  : 	ms_compLen = 0;

  00011	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen

; 424  : 	ms_ulbegin = 0;

  00018	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_ulbegin@CIME@@2HA, 0 ; CIME::ms_ulbegin

; 425  : 	ms_ulend = 0;

  0001f	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_ulend@CIME@@2HA, 0 ; CIME::ms_ulend

; 426  : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?Clear@CIME@@SAXXZ ENDP					; CIME::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?Uninitialize@CIME@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Uninitialize@CIME@@QAEXXZ PROC				; CIME::Uninitialize, COMDAT
; _this$ = ecx

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 362  : 	if ( !ms_bInitialized )

  00007	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bInitialized@CIME@@2_NA ; CIME::ms_bInitialized
  0000e	85 c0		 test	 eax, eax
  00010	75 02		 jne	 SHORT $LN2@Uninitiali

; 363  : 		return;

  00012	eb 76		 jmp	 SHORT $LN1@Uninitiali
$LN2@Uninitiali:

; 364  : 	CTsfUiLessMode::ReleaseSinks();

  00014	e8 00 00 00 00	 call	 ?ReleaseSinks@CTsfUiLessMode@@SAXXZ ; CTsfUiLessMode::ReleaseSinks

; 365  : 	if ( ms_hWnd )

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A, 0 ; CIME::ms_hWnd
  00020	74 11		 je	 SHORT $LN3@Uninitiali

; 366  : 		ImmAssociateContext(ms_hWnd, m_hOrgIMC);

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	ff 70 04	 push	 DWORD PTR [eax+4]
  00028	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0002e	e8 00 00 00 00	 call	 _ImmAssociateContext@8
$LN3@Uninitiali:

; 367  : 	ms_hWnd = NULL;

  00033	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A, 0 ; CIME::ms_hWnd

; 368  : 	m_hOrgIMC = NULL;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 369  : 	SAFE_FREE_LIBRARY(ms_hCurrentImeDll);

  00041	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
  00048	74 13		 je	 SHORT $LN4@Uninitiali
  0004a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00056	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
$LN4@Uninitiali:

; 370  : 	SAFE_FREE_LIBRARY(ms_hImm32Dll);

  0005d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hImm32Dll
  00064	74 13		 je	 SHORT $LN5@Uninitiali
  00066	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00072	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hImm32Dll
$LN5@Uninitiali:

; 371  : 	g_disableCicero.Uninitialize();

  00079	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_disableCicero@@3VCDisableCicero@@A
  0007e	e8 00 00 00 00	 call	 ?Uninitialize@CDisableCicero@@QAEXXZ ; CDisableCicero::Uninitialize

; 372  : 	ms_bInitialized = false;

  00083	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 0 ; CIME::ms_bInitialized
$LN1@Uninitiali:

; 373  : }

  0008a	c9		 leave
  0008b	c3		 ret	 0
?Uninitialize@CIME@@QAEXXZ ENDP				; CIME::Uninitialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?Initialize@CIME@@QAE_NPAUHWND__@@@Z
_TEXT	SEGMENT
tv152 = -128						; size = 4
tv139 = -124						; size = 4
_this$ = -120						; size = 4
__ImmDisableTextFrameService$1 = -116			; size = 4
_bUnicodeImm$ = -109					; size = 1
_szPath$ = -108						; size = 261
__$ArrayPad$ = 156					; size = 4
_hWnd$ = 168						; size = 4
?Initialize@CIME@@QAE_NPAUHWND__@@@Z PROC		; CIME::Initialize, COMDAT
; _this$ = ecx

; 301  : {

  00000	55		 push	 ebp
  00001	8d ac 24 60 ff
	ff ff		 lea	 ebp, DWORD PTR [esp-160]
  00008	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 9c 00 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 88	 mov	 DWORD PTR _this$[ebp], ecx

; 302  : 	if(ms_bInitialized)

  0001e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bInitialized@CIME@@2_NA ; CIME::ms_bInitialized
  00025	85 c0		 test	 eax, eax
  00027	74 07		 je	 SHORT $LN2@Initialize

; 303  : 		return true;

  00029	b0 01		 mov	 al, 1
  0002b	e9 c7 01 00 00	 jmp	 $LN1@Initialize
$LN2@Initialize:

; 304  : 	ms_hWnd = hWnd;

  00030	8b 85 a8 00 00
	00		 mov	 eax, DWORD PTR _hWnd$[ebp]
  00036	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A, eax ; CIME::ms_hWnd

; 305  : 
; 306  : 	g_disableCicero.Initialize();

  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_disableCicero@@3VCDisableCicero@@A
  00040	e8 00 00 00 00	 call	 ?Initialize@CDisableCicero@@QAEXXZ ; CDisableCicero::Initialize

; 307  : 
; 308  : 	ms_stOSVI.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

  00045	c7 05 00 00 00
	00 94 00 00 00	 mov	 DWORD PTR ?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A, 148 ; 00000094H

; 309  : 	GetVersionExA(&ms_stOSVI);

  0004f	68 00 00 00 00	 push	 OFFSET ?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A ; CIME::ms_stOSVI
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 310  : 
; 311  : 	bool bUnicodeImm = false;

  0005a	c6 45 93 00	 mov	 BYTE PTR _bUnicodeImm$[ebp], 0

; 312  : 	// IMM in NT or Win98 supports Unicode
; 313  : 	if ( ms_stOSVI.dwPlatformId == VER_PLATFORM_WIN32_NT ||
; 314  : 		( ms_stOSVI.dwMajorVersion > 4 ) ||

  0005e	83 3d 10 00 00
	00 02		 cmp	 DWORD PTR ?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A+16, 2
  00065	74 1b		 je	 SHORT $LN4@Initialize
  00067	83 3d 04 00 00
	00 04		 cmp	 DWORD PTR ?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A+4, 4
  0006e	77 12		 ja	 SHORT $LN4@Initialize
  00070	83 3d 04 00 00
	00 04		 cmp	 DWORD PTR ?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A+4, 4
  00077	75 0d		 jne	 SHORT $LN3@Initialize
  00079	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR ?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A+8, 0
  00080	76 04		 jbe	 SHORT $LN3@Initialize
$LN4@Initialize:

; 315  : 		( ms_stOSVI.dwMajorVersion == 4 ) && ( ms_stOSVI.dwMinorVersion > 0 ) ) {
; 316  : 		bUnicodeImm = true;

  00082	c6 45 93 01	 mov	 BYTE PTR _bUnicodeImm$[ebp], 1
$LN3@Initialize:

; 317  : 	}
; 318  : 
; 319  : 	// Load ImmLock/ImmUnlock Function Proc
; 320  :     CHAR szPath[MAX_PATH+1];
; 321  : 	ms_bDisableIMECompletely = false;

  00086	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bDisableIMECompletely@CIME@@2_NA, 0 ; CIME::ms_bDisableIMECompletely

; 322  :     
; 323  : 	if(GetSystemDirectoryA(szPath, MAX_PATH+1)) {

  0008d	68 05 01 00 00	 push	 261			; 00000105H
  00092	8d 45 94	 lea	 eax, DWORD PTR _szPath$[ebp]
  00095	50		 push	 eax
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemDirectoryA@8
  0009c	85 c0		 test	 eax, eax
  0009e	0f 84 a8 00 00
	00		 je	 $LN5@Initialize

; 324  : 		strcat(szPath, "\\imm32.dll");

  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0L@LPOFADGE@?2imm32?4dll@
  000a9	8d 45 94	 lea	 eax, DWORD PTR _szPath$[ebp]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _strcat
  000b2	59		 pop	 ecx
  000b3	59		 pop	 ecx

; 325  : 		ms_hImm32Dll = LoadLibraryA(szPath);

  000b4	8d 45 94	 lea	 eax, DWORD PTR _szPath$[ebp]
  000b7	50		 push	 eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  000be	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A, eax ; CIME::ms_hImm32Dll

; 326  : 		if(ms_hImm32Dll)

  000c3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hImm32Dll
  000ca	74 79		 je	 SHORT $LN6@Initialize

; 327  : 		{
; 328  : 			_ImmLockIMC		= (INPUTCONTEXT*(WINAPI *)(HIMC))	GetProcAddress(ms_hImm32Dll, "ImmLockIMC");

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JGAMEFKO@ImmLockIMC@
  000d1	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  000dd	a3 00 00 00 00	 mov	 DWORD PTR ?_ImmLockIMC@CIME@@1P6GPAU__MIDL___MIDL_itf_dimm_0000_0012@@PAUHIMC__@@@ZA, eax ; CIME::_ImmLockIMC

; 329  : 			_ImmUnlockIMC	= (BOOL(WINAPI *)(HIMC))			GetProcAddress(ms_hImm32Dll, "ImmUnlockIMC");

  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PDIACEGP@ImmUnlockIMC@
  000e7	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  000f3	a3 00 00 00 00	 mov	 DWORD PTR ?_ImmUnlockIMC@CIME@@1P6GHPAUHIMC__@@@ZA, eax ; CIME::_ImmUnlockIMC

; 330  : 			_ImmLockIMCC	= (LPVOID(WINAPI *)(HIMCC))			GetProcAddress(ms_hImm32Dll, "ImmLockIMCC");

  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OKKMJOGM@ImmLockIMCC@
  000fd	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00109	a3 00 00 00 00	 mov	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA, eax ; CIME::_ImmLockIMCC

; 331  : 			_ImmUnlockIMCC	= (BOOL(WINAPI *)(HIMCC))			GetProcAddress(ms_hImm32Dll, "ImmUnlockIMCC");

  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GKKOACL@ImmUnlockIMCC@
  00113	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0011f	a3 00 00 00 00	 mov	 DWORD PTR ?_ImmUnlockIMCC@CIME@@1P6GHPAUHIMCC__@@@ZA, eax ; CIME::_ImmUnlockIMCC

; 332  : 			BOOL (WINAPI* _ImmDisableTextFrameService)(DWORD) = (BOOL (WINAPI*)(DWORD))GetProcAddress(ms_hImm32Dll, "ImmDisableTextFrameService");

  00124	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MBEANDFB@ImmDisableTextFrameService@
  00129	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00135	89 45 8c	 mov	 DWORD PTR __ImmDisableTextFrameService$1[ebp], eax

; 333  : 			if ( _ImmDisableTextFrameService )

  00138	83 7d 8c 00	 cmp	 DWORD PTR __ImmDisableTextFrameService$1[ebp], 0
  0013c	74 05		 je	 SHORT $LN8@Initialize

; 334  : 				_ImmDisableTextFrameService( (DWORD)-1 );

  0013e	6a ff		 push	 -1
  00140	ff 55 8c	 call	 DWORD PTR __ImmDisableTextFrameService$1[ebp]
$LN8@Initialize:

; 335  : 		} else {

  00143	eb 07		 jmp	 SHORT $LN5@Initialize
$LN6@Initialize:

; 336  : 			ms_bDisableIMECompletely = true;

  00145	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bDisableIMECompletely@CIME@@2_NA, 1 ; CIME::ms_bDisableIMECompletely
$LN5@Initialize:

; 337  : 		}
; 338  : 	}
; 339  : 
; 340  : 	ms_bInitialized = true;

  0014c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 1 ; CIME::ms_bInitialized

; 341  : 
; 342  : 	m_hOrgIMC = ImmGetContext( ms_hWnd );

  00153	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00159	e8 00 00 00 00	 call	 _ImmGetContext@4
  0015e	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 343  : 	ImmReleaseContext( ms_hWnd, m_hOrgIMC );

  00164	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00167	ff 70 04	 push	 DWORD PTR [eax+4]
  0016a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00170	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 344  : 
; 345  : 	CheckInputLocale();

  00175	e8 00 00 00 00	 call	 ?CheckInputLocale@CIME@@KAXXZ ; CIME::CheckInputLocale

; 346  : 	ChangeInputLanguageWorker();

  0017a	e8 00 00 00 00	 call	 ?ChangeInputLanguageWorker@CIME@@SAXXZ ; CIME::ChangeInputLanguageWorker

; 347  : 	SetSupportLevel(2);

  0017f	6a 02		 push	 2
  00181	e8 00 00 00 00	 call	 ?SetSupportLevel@CIME@@KAXK@Z ; CIME::SetSupportLevel
  00186	59		 pop	 ecx

; 348  : 
; 349  : 	ms_bUILessMode = CTsfUiLessMode::SetupSinks() != FALSE;

  00187	e8 00 00 00 00	 call	 ?SetupSinks@CTsfUiLessMode@@SAHXZ ; CTsfUiLessMode::SetupSinks
  0018c	85 c0		 test	 eax, eax
  0018e	74 09		 je	 SHORT $LN11@Initialize
  00190	c7 45 84 01 00
	00 00		 mov	 DWORD PTR tv139[ebp], 1
  00197	eb 04		 jmp	 SHORT $LN12@Initialize
$LN11@Initialize:
  00199	83 65 84 00	 and	 DWORD PTR tv139[ebp], 0
$LN12@Initialize:
  0019d	8a 45 84	 mov	 al, BYTE PTR tv139[ebp]
  001a0	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, al ; CIME::ms_bUILessMode

; 350  : 	CheckToggleState();

  001a5	e8 00 00 00 00	 call	 ?CheckToggleState@CIME@@KAXXZ ; CIME::CheckToggleState

; 351  : 	if ( ms_bUILessMode )

  001aa	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode
  001b1	85 c0		 test	 eax, eax
  001b3	74 40		 je	 SHORT $LN9@Initialize

; 352  : 	{
; 353  : 		ms_bChineseIME = ( GETPRIMLANG() == LANG_CHINESE ) && CTsfUiLessMode::CurrentInputLocaleIsIme();

  001b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  001ba	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001bf	0f b7 c0	 movzx	 eax, ax
  001c2	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  001c7	0f b7 c0	 movzx	 eax, ax
  001ca	83 f8 04	 cmp	 eax, 4
  001cd	75 12		 jne	 SHORT $LN13@Initialize
  001cf	e8 00 00 00 00	 call	 ?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ ; CTsfUiLessMode::CurrentInputLocaleIsIme
  001d4	85 c0		 test	 eax, eax
  001d6	74 09		 je	 SHORT $LN13@Initialize
  001d8	c7 45 80 01 00
	00 00		 mov	 DWORD PTR tv152[ebp], 1
  001df	eb 04		 jmp	 SHORT $LN14@Initialize
$LN13@Initialize:
  001e1	83 65 80 00	 and	 DWORD PTR tv152[ebp], 0
$LN14@Initialize:
  001e5	8a 45 80	 mov	 al, BYTE PTR tv152[ebp]
  001e8	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, al ; CIME::ms_bChineseIME

; 354  : 		CTsfUiLessMode::UpdateImeState();

  001ed	6a 00		 push	 0
  001ef	e8 00 00 00 00	 call	 ?UpdateImeState@CTsfUiLessMode@@SAXH@Z ; CTsfUiLessMode::UpdateImeState
  001f4	59		 pop	 ecx
$LN9@Initialize:

; 355  : 	}
; 356  : 
; 357  : 	return true;

  001f5	b0 01		 mov	 al, 1
$LN1@Initialize:

; 358  : }

  001f7	8b 8d 9c 00 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fd	33 cd		 xor	 ecx, ebp
  001ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00204	81 c5 a0 00 00
	00		 add	 ebp, 160		; 000000a0H
  0020a	c9		 leave
  0020b	c2 04 00	 ret	 4
?Initialize@CIME@@QAE_NPAUHWND__@@@Z ENDP		; CIME::Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??1CIME@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CIME@@UAE@XZ PROC					; CIME::~CIME, COMDAT
; _this$ = ecx

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CIME@@6B@

; 296  : 	SAFE_FREE_LIBRARY(ms_hCurrentImeDll);

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
  00017	74 13		 je	 SHORT $LN2@CIME
  00019	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00025	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
$LN2@CIME:

; 297  : 	SAFE_FREE_LIBRARY(ms_hImm32Dll);

  0002c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hImm32Dll
  00033	74 13		 je	 SHORT $LN1@CIME
  00035	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00041	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hImm32Dll
$LN1@CIME:

; 298  : }

  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	83 c1 14	 add	 ecx, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0004e	e8 00 00 00 00	 call	 ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AAEXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 298  : }

  00053	c9		 leave
  00054	c3		 ret	 0
??1CIME@@UAE@XZ ENDP					; CIME::~CIME
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??0CIME@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CIME@@QAE@XZ PROC					; CIME::CIME, COMDAT
; _this$ = ecx

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CIME@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CIME@@6B@
  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 c0 14	 add	 eax, 20			; 00000014H
  00037	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0003a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00040	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 ec	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00046	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  00049	83 20 00	 and	 DWORD PTR [eax], 0
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  0004f	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00053	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  00056	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 276  : {

  0005a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 277  : 	ms_hWnd = NULL;

  0005e	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A, 0 ; CIME::ms_hWnd

; 278  : 
; 279  : 	ms_bCandidateList = false;

  00065	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bCandidateList@CIME@@2_NA, 0 ; CIME::ms_bCandidateList

; 280  : 	ms_bReadingInformation = false;

  0006c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bReadingInformation@CIME@@2_NA, 0 ; CIME::ms_bReadingInformation

; 281  : 
; 282  : 	Clear();

  00073	e8 00 00 00 00	 call	 ?Clear@CIME@@SAXXZ	; CIME::Clear

; 283  : 
; 284  : 	m_max = 0;

  00078	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 285  : 	m_userMax = 0;

  0007f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00082	83 60 0c 00	 and	 DWORD PTR [eax+12], 0

; 286  : 
; 287  : 	m_bOnlyNumberMode = FALSE;

  00086	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 288  : 	m_hOrgIMC = NULL;

  0008d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00090	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 289  : 
; 290  : 	m_bEnablePaste = false;

  00094	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00097	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0

; 291  : 	m_bUseDefaultIME = false;

  0009b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	c6 40 21 00	 mov	 BYTE PTR [eax+33], 0

; 292  : }

  000a2	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000a6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ac	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b3	59		 pop	 ecx
  000b4	c9		 leave
  000b5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CIME@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 14	 add	 ecx, 20			; 00000014H
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0CIME@@QAE@XZ:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CIME@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CIME@@QAE@XZ ENDP					; CIME::CIME
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z PROC		; std::_Destroy_in_place<wchar_t *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ENDP		; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -4						; size = 2
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 37		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ; std::_Destroy_in_place<wchar_t *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	8b 45 ec	 mov	 eax, DWORD PTR __Count$[ebp]
  00057	d1 e0		 shl	 eax, 1
  00059	50		 push	 eax
  0005a	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00062	59		 pop	 ecx
  00063	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00075	33 c0		 xor	 eax, eax
  00077	66 89 45 fc	 mov	 WORD PTR $T4[ebp], ax
  0007b	6a 02		 push	 2
  0007d	58		 pop	 eax
  0007e	6b c0 00	 imul	 eax, eax, 0

; 281  :         _Left = _Right;

  00081	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	66 8b 55 fc	 mov	 dx, WORD PTR $T4[ebp]
  00088	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx

; 4396 :     }

  0008c	c9		 leave
  0008d	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	d1 e0		 shl	 eax, 1
  0000c	50		 push	 eax
  0000d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00015	59		 pop	 ecx
  00016	59		 pop	 ecx

; 811  :     }

  00017	c9		 leave
  00018	c2 08 00	 ret	 8
?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv75 = -12						; size = 4
$T3 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4284 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 0f	 or	 eax, 15			; 0000000fH
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  00012	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4287 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 46		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0001f	d1 e8		 shr	 eax, 1
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4291 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 32		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003e	3b 45 f8	 cmp	 eax, DWORD PTR $T3[ebp]
  00041	73 08		 jae	 SHORT $LN7@Calculate_
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00046	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00049	eb 06		 jmp	 SHORT $LN8@Calculate_
$LN7@Calculate_:
  0004b	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  0004e	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
$LN8@Calculate_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00057	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4295 :     }

  00062	c9		 leave
  00063	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -24						; size = 1
__First1$ = -20						; size = 4
__Old_ptr$2 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2935 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2936 :         // append [_Ptr, _Ptr + _Count)
; 2937 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 2938 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 49		 ja	 SHORT $LN2@append

; 2939 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00023	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2940 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 2941 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8b 45 f0	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  0003a	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR __First1$[ebp], eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00046	ff 75 ec	 push	 DWORD PTR __First1$[ebp]
  00049	e8 00 00 00 00	 call	 _memmove
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2942 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00051	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00055	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00058	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]

; 428  :         _Left = _Right;

  0005b	8b 4d f0	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  0005e	8a 55 ff	 mov	 dl, BYTE PTR $T3[ebp]
  00061	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2943 :             return *this;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	eb 19		 jmp	 SHORT $LN1@append
$LN2@append:

; 2944 :         }
; 2945 : 
; 2946 :         return _Reallocate_grow_by(

  00069	33 c0		 xor	 eax, eax
  0006b	88 45 e8	 mov	 BYTE PTR $T1[ebp], al
  0006e	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00071	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00074	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00077	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 2947 :             _Count,
; 2948 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2949 :                 const size_type _Count) {
; 2950 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2953 :             },
; 2954 :             _Ptr, _Count);
; 2955 :     }

  00082	c9		 leave
  00083	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S6$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0003b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00046	8d 45 f3	 lea	 eax, DWORD PTR _$S6$[ebp]
  00049	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00054	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	59		 pop	 ecx
  0005d	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00063	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00066	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00069	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }

  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	6a ff		 push	 -1
  0001c	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  0001f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	83 c9 01	 or	 ecx, 1
  00029	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00033	83 c4 1c	 add	 esp, 28			; 0000001cH
  00036	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00039	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003d	7d 06		 jge	 SHORT $LN7@sprintf
  0003f	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00043	eb 06		 jmp	 SHORT $LN3@sprintf
$LN7@sprintf:
  00045	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00048	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@sprintf:

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00051	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00058	c9		 leave
  00059	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
