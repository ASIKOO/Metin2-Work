; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0SPlaneData@@QAE@XZ				; SPlaneData::SPlaneData
PUBLIC	?DestroyCollisionInstanceSystem@@YAXXZ		; DestroyCollisionInstanceSystem
PUBLIC	?Destroy@CBaseCollisionInstance@@QAEXXZ		; CBaseCollisionInstance::Destroy
PUBLIC	?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z ; CBaseCollisionInstance::BuildCollisionInstance
PUBLIC	?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ ; CSphereCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ ; CSphereCollisionInstance::GetAttribute
PUBLIC	?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; CSphereCollisionInstance::Render
PUBLIC	?OnDestroy@CSphereCollisionInstance@@MAEXXZ	; CSphereCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CSphereCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CSphereCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CSphereCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ ; CPlaneCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@CPlaneCollisionInstance@@QBEABUSPlaneData@@XZ ; CPlaneCollisionInstance::GetAttribute
PUBLIC	?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; CPlaneCollisionInstance::Render
PUBLIC	?OnDestroy@CPlaneCollisionInstance@@MAEXXZ	; CPlaneCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CPlaneCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CPlaneCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CPlaneCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ ; CAABBCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@CAABBCollisionInstance@@QBEABUSAABBData@@XZ ; CAABBCollisionInstance::GetAttribute
PUBLIC	?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; CAABBCollisionInstance::Render
PUBLIC	?OnDestroy@CAABBCollisionInstance@@MAEXXZ	; CAABBCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CAABBCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CAABBCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CAABBCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ ; COBBCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@COBBCollisionInstance@@QBEABUSOBBData@@XZ ; COBBCollisionInstance::GetAttribute
PUBLIC	?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; COBBCollisionInstance::Render
PUBLIC	?OnDestroy@COBBCollisionInstance@@MAEXXZ	; COBBCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; COBBCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; COBBCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; COBBCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ ; CCylinderCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@CCylinderCollisionInstance@@QBEABUSCylinderData@@XZ ; CCylinderCollisionInstance::GetAttribute
PUBLIC	?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; CCylinderCollisionInstance::Render
PUBLIC	?OnDestroy@CCylinderCollisionInstance@@MAEXXZ	; CCylinderCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere
PUBLIC	?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z ; square_distance_between_linesegment_and_point
PUBLIC	??0?$CDynamicPool@VCSphereCollisionInstance@@@@QAE@XZ ; CDynamicPool<CSphereCollisionInstance>::CDynamicPool<CSphereCollisionInstance>
PUBLIC	??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXXZ ; CDynamicPool<CSphereCollisionInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEPAVCSphereCollisionInstance@@XZ ; CDynamicPool<CSphereCollisionInstance>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCSphereCollisionInstance@@@@KAXPAVCSphereCollisionInstance@@@Z ; CDynamicPool<CSphereCollisionInstance>::Delete
PUBLIC	?deallocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXQAPAVCSphereCollisionInstance@@I@Z ; std::allocator<CSphereCollisionInstance *>::deallocate
PUBLIC	?clear@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXPAPAVCSphereCollisionInstance@@0@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@ABEII@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXQAPAVCSphereCollisionInstance@@II@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Xlength
PUBLIC	??_G?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<CSphereCollisionInstance>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCCylinderCollisionInstance@@@@QAE@XZ ; CDynamicPool<CCylinderCollisionInstance>::CDynamicPool<CCylinderCollisionInstance>
PUBLIC	??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXXZ ; CDynamicPool<CCylinderCollisionInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEPAVCCylinderCollisionInstance@@XZ ; CDynamicPool<CCylinderCollisionInstance>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCCylinderCollisionInstance@@@@KAXPAVCCylinderCollisionInstance@@@Z ; CDynamicPool<CCylinderCollisionInstance>::Delete
PUBLIC	?deallocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXQAPAVCCylinderCollisionInstance@@I@Z ; std::allocator<CCylinderCollisionInstance *>::deallocate
PUBLIC	?clear@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXPAPAVCCylinderCollisionInstance@@0@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@ABEII@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXQAPAVCCylinderCollisionInstance@@II@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Xlength
PUBLIC	??_G?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<CCylinderCollisionInstance>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCPlaneCollisionInstance@@@@QAE@XZ ; CDynamicPool<CPlaneCollisionInstance>::CDynamicPool<CPlaneCollisionInstance>
PUBLIC	??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXXZ ; CDynamicPool<CPlaneCollisionInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ ; CDynamicPool<CPlaneCollisionInstance>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCPlaneCollisionInstance@@@@KAXPAVCPlaneCollisionInstance@@@Z ; CDynamicPool<CPlaneCollisionInstance>::Delete
PUBLIC	?deallocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXQAPAVCPlaneCollisionInstance@@I@Z ; std::allocator<CPlaneCollisionInstance *>::deallocate
PUBLIC	?clear@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXPAPAVCPlaneCollisionInstance@@0@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@ABEII@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXQAPAVCPlaneCollisionInstance@@II@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Xlength
PUBLIC	??_G?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<CPlaneCollisionInstance>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCAABBCollisionInstance@@@@QAE@XZ ; CDynamicPool<CAABBCollisionInstance>::CDynamicPool<CAABBCollisionInstance>
PUBLIC	??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXXZ ; CDynamicPool<CAABBCollisionInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ ; CDynamicPool<CAABBCollisionInstance>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCAABBCollisionInstance@@@@KAXPAVCAABBCollisionInstance@@@Z ; CDynamicPool<CAABBCollisionInstance>::Delete
PUBLIC	?deallocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXQAPAVCAABBCollisionInstance@@I@Z ; std::allocator<CAABBCollisionInstance *>::deallocate
PUBLIC	?clear@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXPAPAVCAABBCollisionInstance@@0@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@ABEII@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXQAPAVCAABBCollisionInstance@@II@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Xlength
PUBLIC	??_G?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<CAABBCollisionInstance>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCOBBCollisionInstance@@@@QAE@XZ ; CDynamicPool<COBBCollisionInstance>::CDynamicPool<COBBCollisionInstance>
PUBLIC	??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ ; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXXZ ; CDynamicPool<COBBCollisionInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEPAVCOBBCollisionInstance@@XZ ; CDynamicPool<COBBCollisionInstance>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCOBBCollisionInstance@@@@KAXPAVCOBBCollisionInstance@@@Z ; CDynamicPool<COBBCollisionInstance>::Delete
PUBLIC	?deallocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXQAPAVCOBBCollisionInstance@@I@Z ; std::allocator<COBBCollisionInstance *>::deallocate
PUBLIC	?clear@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXPAPAVCOBBCollisionInstance@@0@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@ABEII@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXQAPAVCOBBCollisionInstance@@II@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Xlength
PUBLIC	??_G?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<COBBCollisionInstance>::`scalar deleting destructor'
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCOBBCollisionInstance@@@Z@std@@YAP6AXPAVCOBBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >,void (__cdecl*)(COBBCollisionInstance *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCAABBCollisionInstance@@@Z@std@@YAP6AXPAVCAABBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >,void (__cdecl*)(CAABBCollisionInstance *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@P6AXPAVCPlaneCollisionInstance@@@Z@std@@YAP6AXPAVCPlaneCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >,void (__cdecl*)(CPlaneCollisionInstance *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@P6AXPAVCCylinderCollisionInstance@@@Z@std@@YAP6AXPAVCCylinderCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >,void (__cdecl*)(CCylinderCollisionInstance *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@P6AXPAVCSphereCollisionInstance@@@Z@std@@YAP6AXPAVCSphereCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >,void (__cdecl*)(CSphereCollisionInstance *)>
PUBLIC	??$emplace_back@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::emplace_back<COBBCollisionInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXABQAVCOBBCollisionInstance@@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_back_with_unused_capacity<COBBCollisionInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_reallocate<COBBCollisionInstance * const &>
PUBLIC	??$emplace_back@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::emplace_back<CAABBCollisionInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXABQAVCAABBCollisionInstance@@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_back_with_unused_capacity<CAABBCollisionInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_reallocate<CAABBCollisionInstance * const &>
PUBLIC	??$emplace_back@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::emplace_back<CPlaneCollisionInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXABQAVCPlaneCollisionInstance@@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_back_with_unused_capacity<CPlaneCollisionInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_reallocate<CPlaneCollisionInstance * const &>
PUBLIC	??$emplace_back@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::emplace_back<CCylinderCollisionInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXABQAVCCylinderCollisionInstance@@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_back_with_unused_capacity<CCylinderCollisionInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_reallocate<CCylinderCollisionInstance * const &>
PUBLIC	??$emplace_back@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::emplace_back<CSphereCollisionInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXABQAVCSphereCollisionInstance@@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_back_with_unused_capacity<CSphereCollisionInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_reallocate<CSphereCollisionInstance * const &>
PUBLIC	??$_Destroy_range@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<COBBCollisionInstance *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAABBCollisionInstance *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@QAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CPlaneCollisionInstance *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@QAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CCylinderCollisionInstance *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@QAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CSphereCollisionInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z ; std::_Uninitialized_move<COBBCollisionInstance * *,std::allocator<COBBCollisionInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CAABBCollisionInstance * *,std::allocator<CAABBCollisionInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CPlaneCollisionInstance * *,std::allocator<CPlaneCollisionInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CCylinderCollisionInstance * *,std::allocator<CCylinderCollisionInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CSphereCollisionInstance * *,std::allocator<CSphereCollisionInstance *> >
PUBLIC	??$_Copy_memmove@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<COBBCollisionInstance * *,COBBCollisionInstance * *>
PUBLIC	??$_Copy_memmove@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAABBCollisionInstance * *,CAABBCollisionInstance * *>
PUBLIC	??$_Copy_memmove@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *>
PUBLIC	??$_Copy_memmove@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *>
PUBLIC	??$_Copy_memmove@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CSphereCollisionInstance * *,CSphereCollisionInstance * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7CBaseCollisionInstance@@6B@			; CBaseCollisionInstance::`vftable'
PUBLIC	??_7CSphereCollisionInstance@@6B@		; CSphereCollisionInstance::`vftable'
PUBLIC	??_7CPlaneCollisionInstance@@6B@		; CPlaneCollisionInstance::`vftable'
PUBLIC	??_7CAABBCollisionInstance@@6B@			; CAABBCollisionInstance::`vftable'
PUBLIC	??_7COBBCollisionInstance@@6B@			; COBBCollisionInstance::`vftable'
PUBLIC	??_7CCylinderCollisionInstance@@6B@		; CCylinderCollisionInstance::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ ; CDynamicPool<CSphereCollisionInstance>::`vftable'
PUBLIC	?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A ; gs_sci
PUBLIC	??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ ; CDynamicPool<CCylinderCollisionInstance>::`vftable'
PUBLIC	?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A ; gs_cci
PUBLIC	??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ ; CDynamicPool<CPlaneCollisionInstance>::`vftable'
PUBLIC	?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A ; gs_pci
PUBLIC	??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ ; CDynamicPool<CAABBCollisionInstance>::`vftable'
PUBLIC	?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A ; gs_aci
PUBLIC	??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ ; CDynamicPool<COBBCollisionInstance>::`vftable'
PUBLIC	?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A ; gs_oci
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CBaseCollisionInstance@@6B@		; CBaseCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBaseCollisionInstance@@@8		; CBaseCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CBaseCollisionInstance@@8			; CBaseCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBaseCollisionInstance@@8			; CBaseCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBaseCollisionInstance@@8		; CBaseCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CSphereCollisionInstance@@6B@		; CSphereCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCSphereCollisionInstance@@@8		; CSphereCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CSphereCollisionInstance@@8		; CSphereCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CSphereCollisionInstance@@8		; CSphereCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CSphereCollisionInstance@@8	; CSphereCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CPlaneCollisionInstance@@6B@		; CPlaneCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPlaneCollisionInstance@@@8		; CPlaneCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CPlaneCollisionInstance@@8			; CPlaneCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPlaneCollisionInstance@@8			; CPlaneCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CPlaneCollisionInstance@@8	; CPlaneCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CAABBCollisionInstance@@6B@		; CAABBCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCAABBCollisionInstance@@@8		; CAABBCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CAABBCollisionInstance@@8			; CAABBCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CAABBCollisionInstance@@8			; CAABBCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CAABBCollisionInstance@@8		; CAABBCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4COBBCollisionInstance@@6B@			; COBBCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCOBBCollisionInstance@@@8		; COBBCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3COBBCollisionInstance@@8			; COBBCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2COBBCollisionInstance@@8			; COBBCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@COBBCollisionInstance@@8		; COBBCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CCylinderCollisionInstance@@6B@		; CCylinderCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCylinderCollisionInstance@@@8		; CCylinderCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CCylinderCollisionInstance@@8		; CCylinderCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCylinderCollisionInstance@@8		; CCylinderCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCylinderCollisionInstance@@8	; CCylinderCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ ; CDynamicPool<CSphereCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8 ; CDynamicPool<CSphereCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCSphereCollisionInstance@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCSphereCollisionInstance@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8 ; CDynamicPool<CCylinderCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCCylinderCollisionInstance@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCCylinderCollisionInstance@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8 ; CDynamicPool<CPlaneCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCPlaneCollisionInstance@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCPlaneCollisionInstance@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ ; CDynamicPool<CAABBCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8 ; CDynamicPool<CAABBCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCAABBCollisionInstance@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCAABBCollisionInstance@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ ; CDynamicPool<COBBCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8 ; CDynamicPool<COBBCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8	; CDynamicPool<COBBCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCOBBCollisionInstance@@@@8	; CDynamicPool<COBBCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCOBBCollisionInstance@@@@8 ; CDynamicPool<COBBCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@38d1b717
PUBLIC	__real@3f000000
PUBLIC	__real@3f1a36e2eb1c432d
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40800000
PUBLIC	__real@bf1a36e2eb1c432d
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	_D3DXVec3TransformCoord@12:PROC
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixTranslation@16:PROC
EXTRN	_D3DXMatrixRotationQuaternion@8:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??0CScreen@@QAE@XZ:PROC				; CScreen::CScreen
EXTRN	??1CScreen@@UAE@XZ:PROC				; CScreen::~CScreen
EXTRN	?RenderBar3d@CScreen@@QAEXPBUD3DXVECTOR3@@@Z:PROC ; CScreen::RenderBar3d
EXTRN	?RenderCube@CScreen@@QAEXMMMMMM@Z:PROC		; CScreen::RenderCube
EXTRN	?RenderCube@CScreen@@QAEXMMMMMMUD3DXMATRIX@@@Z:PROC ; CScreen::RenderCube
EXTRN	?RenderSphere@CScreen@@QAEXPBUD3DXMATRIX@@MMMMW4_D3DFILLMODE@@@Z:PROC ; CScreen::RenderSphere
EXTRN	?RenderCylinder@CScreen@@QAEXPBUD3DXMATRIX@@MMMMMW4_D3DFILLMODE@@@Z:PROC ; CScreen::RenderCylinder
EXTRN	?IntersectLineSegments@@YAXABUD3DXVECTOR3@@000AAU1@1@Z:PROC ; IntersectLineSegments
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	??_E?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CSphereCollisionInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CCylinderCollisionInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CPlaneCollisionInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CAABBCollisionInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<COBBCollisionInstance>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A DB 024H DUP (?) ; gs_sci
?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A DB 024H DUP (?) ; gs_cci
?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A DB 024H DUP (?) ; gs_pci
?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A DB 024H DUP (?) ; gs_aci
?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A DB 024H DUP (?) ; gs_oci
_BSS	ENDS
;	COMDAT ?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `CSphereCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA DD 01H DUP (?) ; `CSphereCollisionInstance::Render'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `CPlaneCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA DD 01H DUP (?) ; `CPlaneCollisionInstance::Render'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `CCylinderCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA DD 01H DUP (?) ; `CCylinderCollisionInstance::Render'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `CAABBCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA DD 01H DUP (?) ; `CAABBCollisionInstance::Render'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `COBBCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA DD 01H DUP (?) ; `COBBCollisionInstance::Render'::`2'::$TSS0
_BSS	ENDS
CRT$XCU	SEGMENT
?gs_sci$initializer$@@3P6AXXZA DD FLAT:??__Egs_sci@@YAXXZ ; gs_sci$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf1a36e2eb1c432d
CONST	SEGMENT
__real@bf1a36e2eb1c432d DQ 0bf1a36e2eb1c432dr	; -0.0001
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f1a36e2eb1c432d
CONST	SEGMENT
__real@3f1a36e2eb1c432d DQ 03f1a36e2eb1c432dr	; 0.0001
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCOBBCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8 ; CDynamicPool<COBBCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCOBBCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCOBBCollisionInstance@@@@8 ; CDynamicPool<COBBCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8 DD 00H	; CDynamicPool<COBBCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<COBBCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCOBBCollisionInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCOBBCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<COBBCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCAABBCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCAABBCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCAABBCollisionInstance@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8 DD 00H	; CDynamicPool<CAABBCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CAABBCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCAABBCollisionInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCAABBCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<CAABBCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCPlaneCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCPlaneCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCPlaneCollisionInstance@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8 DD 00H ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CPlaneCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCCylinderCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCCylinderCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCCylinderCollisionInstance@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8 DD 00H ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CCylinderCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCSphereCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCSphereCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCSphereCollisionInstance@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8 DD 00H ; CDynamicPool<CSphereCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CSphereCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCSphereCollisionInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCSphereCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<CSphereCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CCylinderCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CCylinderCollisionInstance@@8 DD FLAT:??_R0?AVCCylinderCollisionInstance@@@8 ; CCylinderCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCylinderCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CCylinderCollisionInstance@@8
rdata$r	SEGMENT
??_R2CCylinderCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CCylinderCollisionInstance@@8 ; CCylinderCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CCylinderCollisionInstance@@8
rdata$r	SEGMENT
??_R3CCylinderCollisionInstance@@8 DD 00H		; CCylinderCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CCylinderCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCylinderCollisionInstance@@@8
data$rs	SEGMENT
??_R0?AVCCylinderCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CCylinderCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCylinderCollisionInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CCylinderCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CCylinderCollisionInstance@@6B@ DD 00H		; CCylinderCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCylinderCollisionInstance@@@8
	DD	FLAT:??_R3CCylinderCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@COBBCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@COBBCollisionInstance@@8 DD FLAT:??_R0?AVCOBBCollisionInstance@@@8 ; COBBCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3COBBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2COBBCollisionInstance@@8
rdata$r	SEGMENT
??_R2COBBCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@COBBCollisionInstance@@8 ; COBBCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3COBBCollisionInstance@@8
rdata$r	SEGMENT
??_R3COBBCollisionInstance@@8 DD 00H			; COBBCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2COBBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCOBBCollisionInstance@@@8
data$rs	SEGMENT
??_R0?AVCOBBCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; COBBCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCOBBCollisionInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4COBBCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4COBBCollisionInstance@@6B@ DD 00H			; COBBCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCOBBCollisionInstance@@@8
	DD	FLAT:??_R3COBBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CAABBCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CAABBCollisionInstance@@8 DD FLAT:??_R0?AVCAABBCollisionInstance@@@8 ; CAABBCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CAABBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CAABBCollisionInstance@@8
rdata$r	SEGMENT
??_R2CAABBCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CAABBCollisionInstance@@8 ; CAABBCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CAABBCollisionInstance@@8
rdata$r	SEGMENT
??_R3CAABBCollisionInstance@@8 DD 00H			; CAABBCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CAABBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCAABBCollisionInstance@@@8
data$rs	SEGMENT
??_R0?AVCAABBCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CAABBCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAABBCollisionInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CAABBCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CAABBCollisionInstance@@6B@ DD 00H			; CAABBCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCAABBCollisionInstance@@@8
	DD	FLAT:??_R3CAABBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPlaneCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPlaneCollisionInstance@@8 DD FLAT:??_R0?AVCPlaneCollisionInstance@@@8 ; CPlaneCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPlaneCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CPlaneCollisionInstance@@8
rdata$r	SEGMENT
??_R2CPlaneCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CPlaneCollisionInstance@@8 ; CPlaneCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CPlaneCollisionInstance@@8
rdata$r	SEGMENT
??_R3CPlaneCollisionInstance@@8 DD 00H			; CPlaneCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CPlaneCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPlaneCollisionInstance@@@8
data$rs	SEGMENT
??_R0?AVCPlaneCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CPlaneCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPlaneCollisionInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CPlaneCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CPlaneCollisionInstance@@6B@ DD 00H		; CPlaneCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPlaneCollisionInstance@@@8
	DD	FLAT:??_R3CPlaneCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CSphereCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSphereCollisionInstance@@8 DD FLAT:??_R0?AVCSphereCollisionInstance@@@8 ; CSphereCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CSphereCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CSphereCollisionInstance@@8
rdata$r	SEGMENT
??_R2CSphereCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CSphereCollisionInstance@@8 ; CSphereCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CSphereCollisionInstance@@8
rdata$r	SEGMENT
??_R3CSphereCollisionInstance@@8 DD 00H			; CSphereCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CSphereCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSphereCollisionInstance@@@8
data$rs	SEGMENT
??_R0?AVCSphereCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CSphereCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSphereCollisionInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CSphereCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CSphereCollisionInstance@@6B@ DD 00H		; CSphereCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCSphereCollisionInstance@@@8
	DD	FLAT:??_R3CSphereCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CBaseCollisionInstance@@8 DD FLAT:??_R0?AVCBaseCollisionInstance@@@8 ; CBaseCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CBaseCollisionInstance@@8
rdata$r	SEGMENT
??_R2CBaseCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8 ; CBaseCollisionInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CBaseCollisionInstance@@8
rdata$r	SEGMENT
??_R3CBaseCollisionInstance@@8 DD 00H			; CBaseCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBaseCollisionInstance@@@8
data$rs	SEGMENT
??_R0?AVCBaseCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CBaseCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBaseCollisionInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CBaseCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CBaseCollisionInstance@@6B@ DD 00H			; CBaseCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBaseCollisionInstance@@@8
	DD	FLAT:??_R3CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ ; CDynamicPool<COBBCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ ; CDynamicPool<CAABBCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ ; CDynamicPool<CPlaneCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ ; CDynamicPool<CCylinderCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ ; CDynamicPool<CSphereCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CCylinderCollisionInstance@@6B@
CONST	SEGMENT
??_7CCylinderCollisionInstance@@6B@ DD FLAT:??_R4CCylinderCollisionInstance@@6B@ ; CCylinderCollisionInstance::`vftable'
	DD	FLAT:?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@CCylinderCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7COBBCollisionInstance@@6B@
CONST	SEGMENT
??_7COBBCollisionInstance@@6B@ DD FLAT:??_R4COBBCollisionInstance@@6B@ ; COBBCollisionInstance::`vftable'
	DD	FLAT:?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@COBBCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CAABBCollisionInstance@@6B@
CONST	SEGMENT
??_7CAABBCollisionInstance@@6B@ DD FLAT:??_R4CAABBCollisionInstance@@6B@ ; CAABBCollisionInstance::`vftable'
	DD	FLAT:?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@CAABBCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CPlaneCollisionInstance@@6B@
CONST	SEGMENT
??_7CPlaneCollisionInstance@@6B@ DD FLAT:??_R4CPlaneCollisionInstance@@6B@ ; CPlaneCollisionInstance::`vftable'
	DD	FLAT:?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@CPlaneCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CSphereCollisionInstance@@6B@
CONST	SEGMENT
??_7CSphereCollisionInstance@@6B@ DD FLAT:??_R4CSphereCollisionInstance@@6B@ ; CSphereCollisionInstance::`vftable'
	DD	FLAT:?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@CSphereCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CBaseCollisionInstance@@6B@
CONST	SEGMENT
??_7CBaseCollisionInstance@@6B@ DD FLAT:??_R4CBaseCollisionInstance@@6B@ ; CBaseCollisionInstance::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?gs_cci$initializer$@@3P6AXXZA DD FLAT:??__Egs_cci@@YAXXZ ; gs_cci$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gs_pci$initializer$@@3P6AXXZA DD FLAT:??__Egs_pci@@YAXXZ ; gs_pci$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gs_aci$initializer$@@3P6AXXZA DD FLAT:??__Egs_aci@@YAXXZ ; gs_aci$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gs_oci$initializer$@@3P6AXXZA DD FLAT:??__Egs_oci@@YAXXZ ; gs_oci$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CSphereCollisionInstance * *,CSphereCollisionInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CSphereCollisionInstance * *,CSphereCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CAABBCollisionInstance * *,CAABBCollisionInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CAABBCollisionInstance * *,CAABBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<COBBCollisionInstance * *,COBBCollisionInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<COBBCollisionInstance * *,COBBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z PROC ; std::_Uninitialized_move<CSphereCollisionInstance * *,std::allocator<CSphereCollisionInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CSphereCollisionInstance * *,CSphereCollisionInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CSphereCollisionInstance * *,std::allocator<CSphereCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z PROC ; std::_Uninitialized_move<CCylinderCollisionInstance * *,std::allocator<CCylinderCollisionInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CCylinderCollisionInstance * *,std::allocator<CCylinderCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z PROC ; std::_Uninitialized_move<CPlaneCollisionInstance * *,std::allocator<CPlaneCollisionInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CPlaneCollisionInstance * *,std::allocator<CPlaneCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z PROC ; std::_Uninitialized_move<CAABBCollisionInstance * *,std::allocator<CAABBCollisionInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAABBCollisionInstance * *,CAABBCollisionInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CAABBCollisionInstance * *,std::allocator<CAABBCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z PROC ; std::_Uninitialized_move<COBBCollisionInstance * *,std::allocator<COBBCollisionInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<COBBCollisionInstance * *,COBBCollisionInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z ENDP ; std::_Uninitialized_move<COBBCollisionInstance * *,std::allocator<COBBCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@QAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@QAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CSphereCollisionInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@QAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CSphereCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@QAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@QAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CCylinderCollisionInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@QAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CCylinderCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@QAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@QAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CPlaneCollisionInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@QAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CPlaneCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CAABBCollisionInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CAABBCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<COBBCollisionInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<COBBCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_reallocate<CSphereCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@ABEII@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CSphereCollisionInstance * *,std::allocator<CSphereCollisionInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CSphereCollisionInstance * *,std::allocator<CSphereCollisionInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAPAPAVCSphereCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CSphereCollisionInstance * *,std::allocator<CSphereCollisionInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXPAPAVCSphereCollisionInstance@@0@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXQAPAVCSphereCollisionInstance@@I@Z ; std::allocator<CSphereCollisionInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXQAPAVCSphereCollisionInstance@@II@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_reallocate<CSphereCollisionInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXABQAVCSphereCollisionInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXABQAVCSphereCollisionInstance@@@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_back_with_unused_capacity<CSphereCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXABQAVCSphereCollisionInstance@@@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_back_with_unused_capacity<CSphereCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::emplace_back<CSphereCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXABQAVCSphereCollisionInstance@@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_back_with_unused_capacity<CSphereCollisionInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_reallocate<CSphereCollisionInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::emplace_back<CSphereCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_reallocate<CCylinderCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@ABEII@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CCylinderCollisionInstance * *,std::allocator<CCylinderCollisionInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CCylinderCollisionInstance * *,std::allocator<CCylinderCollisionInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAPAPAVCCylinderCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CCylinderCollisionInstance * *,std::allocator<CCylinderCollisionInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXPAPAVCCylinderCollisionInstance@@0@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXQAPAVCCylinderCollisionInstance@@I@Z ; std::allocator<CCylinderCollisionInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXQAPAVCCylinderCollisionInstance@@II@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_reallocate<CCylinderCollisionInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXABQAVCCylinderCollisionInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXABQAVCCylinderCollisionInstance@@@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_back_with_unused_capacity<CCylinderCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXABQAVCCylinderCollisionInstance@@@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_back_with_unused_capacity<CCylinderCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::emplace_back<CCylinderCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXABQAVCCylinderCollisionInstance@@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_back_with_unused_capacity<CCylinderCollisionInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_reallocate<CCylinderCollisionInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::emplace_back<CCylinderCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_reallocate<CPlaneCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@ABEII@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CPlaneCollisionInstance * *,std::allocator<CPlaneCollisionInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CPlaneCollisionInstance * *,std::allocator<CPlaneCollisionInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAPAPAVCPlaneCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CPlaneCollisionInstance * *,std::allocator<CPlaneCollisionInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXPAPAVCPlaneCollisionInstance@@0@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXQAPAVCPlaneCollisionInstance@@I@Z ; std::allocator<CPlaneCollisionInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXQAPAVCPlaneCollisionInstance@@II@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_reallocate<CPlaneCollisionInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXABQAVCPlaneCollisionInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXABQAVCPlaneCollisionInstance@@@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_back_with_unused_capacity<CPlaneCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXABQAVCPlaneCollisionInstance@@@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_back_with_unused_capacity<CPlaneCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::emplace_back<CPlaneCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXABQAVCPlaneCollisionInstance@@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_back_with_unused_capacity<CPlaneCollisionInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_reallocate<CPlaneCollisionInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::emplace_back<CPlaneCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_reallocate<CAABBCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@ABEII@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CAABBCollisionInstance * *,std::allocator<CAABBCollisionInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CAABBCollisionInstance * *,std::allocator<CAABBCollisionInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAPAPAVCAABBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CAABBCollisionInstance * *,std::allocator<CAABBCollisionInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXPAPAVCAABBCollisionInstance@@0@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXQAPAVCAABBCollisionInstance@@I@Z ; std::allocator<CAABBCollisionInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXQAPAVCAABBCollisionInstance@@II@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_reallocate<CAABBCollisionInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXABQAVCAABBCollisionInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXABQAVCAABBCollisionInstance@@@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_back_with_unused_capacity<CAABBCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXABQAVCAABBCollisionInstance@@@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_back_with_unused_capacity<CAABBCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::emplace_back<CAABBCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXABQAVCAABBCollisionInstance@@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_back_with_unused_capacity<CAABBCollisionInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_reallocate<CAABBCollisionInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::emplace_back<CAABBCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_reallocate<COBBCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@ABEII@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z ; std::_Uninitialized_move<COBBCollisionInstance * *,std::allocator<COBBCollisionInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z ; std::_Uninitialized_move<COBBCollisionInstance * *,std::allocator<COBBCollisionInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAPAPAVCOBBCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z ; std::_Uninitialized_move<COBBCollisionInstance * *,std::allocator<COBBCollisionInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXPAPAVCOBBCollisionInstance@@0@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXQAPAVCOBBCollisionInstance@@I@Z ; std::allocator<COBBCollisionInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXQAPAVCOBBCollisionInstance@@II@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_reallocate<COBBCollisionInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXABQAVCOBBCollisionInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXABQAVCOBBCollisionInstance@@@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_back_with_unused_capacity<COBBCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXABQAVCOBBCollisionInstance@@@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_back_with_unused_capacity<COBBCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::emplace_back<COBBCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXABQAVCOBBCollisionInstance@@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_back_with_unused_capacity<COBBCollisionInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_reallocate<COBBCollisionInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::emplace_back<COBBCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@P6AXPAVCSphereCollisionInstance@@@Z@std@@YAP6AXPAVCSphereCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@P6AXPAVCSphereCollisionInstance@@@Z@std@@YAP6AXPAVCSphereCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >,void (__cdecl*)(CSphereCollisionInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@P6AXPAVCSphereCollisionInstance@@@Z@std@@YAP6AXPAVCSphereCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >,void (__cdecl*)(CSphereCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@P6AXPAVCCylinderCollisionInstance@@@Z@std@@YAP6AXPAVCCylinderCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@P6AXPAVCCylinderCollisionInstance@@@Z@std@@YAP6AXPAVCCylinderCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >,void (__cdecl*)(CCylinderCollisionInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@P6AXPAVCCylinderCollisionInstance@@@Z@std@@YAP6AXPAVCCylinderCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >,void (__cdecl*)(CCylinderCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@P6AXPAVCPlaneCollisionInstance@@@Z@std@@YAP6AXPAVCPlaneCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@P6AXPAVCPlaneCollisionInstance@@@Z@std@@YAP6AXPAVCPlaneCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >,void (__cdecl*)(CPlaneCollisionInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@P6AXPAVCPlaneCollisionInstance@@@Z@std@@YAP6AXPAVCPlaneCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >,void (__cdecl*)(CPlaneCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCAABBCollisionInstance@@@Z@std@@YAP6AXPAVCAABBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCAABBCollisionInstance@@@Z@std@@YAP6AXPAVCAABBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >,void (__cdecl*)(CAABBCollisionInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCAABBCollisionInstance@@@Z@std@@YAP6AXPAVCAABBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >,void (__cdecl*)(CAABBCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCOBBCollisionInstance@@@Z@std@@YAP6AXPAVCOBBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCOBBCollisionInstance@@@Z@std@@YAP6AXPAVCOBBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >,void (__cdecl*)(COBBCollisionInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCOBBCollisionInstance@@@Z@std@@YAP6AXPAVCOBBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >,void (__cdecl*)(COBBCollisionInstance *)>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fs@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `COBBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00008	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fs@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `COBBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fs@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `CAABBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00008	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fs@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `CAABBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fs@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `CCylinderCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00008	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fs@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `CCylinderCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fs@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `CPlaneCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00008	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fs@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `CPlaneCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fs@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `CSphereCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00008	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fs@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `CSphereCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fgs_oci@@YAXXZ
text$yd	SEGMENT
??__Fgs_oci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_oci'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A ; gs_oci
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ ; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fgs_oci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_oci''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ??__Egs_oci@@YAXXZ
text$di	SEGMENT
??__Egs_oci@@YAXXZ PROC					; `dynamic initializer for 'gs_oci'', COMDAT

; 22   : CDynamicPool<COBBCollisionInstance> gs_oci;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A ; gs_oci
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCOBBCollisionInstance@@@@QAE@XZ ; CDynamicPool<COBBCollisionInstance>::CDynamicPool<COBBCollisionInstance>
  0000d	68 00 00 00 00	 push	 OFFSET ??__Fgs_oci@@YAXXZ ; `dynamic atexit destructor for 'gs_oci''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Egs_oci@@YAXXZ ENDP					; `dynamic initializer for 'gs_oci''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<COBBCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ ; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<COBBCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@CAXXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<COBBCollisionInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXQAPAVCOBBCollisionInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXQAPAVCOBBCollisionInstance@@II@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<COBBCollisionInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXQAPAVCOBBCollisionInstance@@II@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXPAPAVCOBBCollisionInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXPAPAVCOBBCollisionInstance@@0@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<COBBCollisionInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXPAPAVCOBBCollisionInstance@@0@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@YAXPAPAVCOBBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCOBBCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<COBBCollisionInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXQAPAVCOBBCollisionInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXQAPAVCOBBCollisionInstance@@I@Z PROC ; std::allocator<COBBCollisionInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCOBBCollisionInstance@@@std@@QAEXQAPAVCOBBCollisionInstance@@I@Z ENDP ; std::allocator<COBBCollisionInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCOBBCollisionInstance@@@@KAXPAVCOBBCollisionInstance@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCOBBCollisionInstance@@@@KAXPAVCOBBCollisionInstance@@@Z PROC ; CDynamicPool<COBBCollisionInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 110  : 			delete pkData;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000a	6a 5c		 push	 92			; 0000005cH
  0000c	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 111  : 		}

  00016	c9		 leave
  00017	c3		 ret	 0
?Delete@?$CDynamicPool@VCOBBCollisionInstance@@@@KAXPAVCOBBCollisionInstance@@@Z ENDP ; CDynamicPool<COBBCollisionInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEPAVCOBBCollisionInstance@@XZ
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
_pkFreeData$ = -64					; size = 4
$T3 = -60						; size = 4
__Ptr$ = -56						; size = 4
__My_data$4 = -52					; size = 4
$T5 = -48						; size = 4
__My_data$6 = -44					; size = 4
$T7 = -40						; size = 4
_this$ = -36						; size = 4
_pkNewData$8 = -32					; size = 4
tv80 = -28						; size = 4
tv130 = -24						; size = 4
__My_data$9 = -20					; size = 4
__Mylast$10 = -16					; size = 4
$T11 = -12						; size = 4
_this$ = -8						; size = 4
$T12 = -1						; size = 1
?Alloc@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEPAVCOBBCollisionInstance@@XZ PROC ; CDynamicPool<COBBCollisionInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 10	 add	 eax, 16			; 00000010H
  0000f	89 45 ec	 mov	 DWORD PTR __My_data$9[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00012	8b 45 ec	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00015	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$9[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0001d	75 09		 jne	 SHORT $LN9@Alloc
  0001f	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00026	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00028	83 65 e8 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0002c	8a 45 e8	 mov	 al, BYTE PTR tv130[ebp]
  0002f	88 45 ff	 mov	 BYTE PTR $T12[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00032	0f b6 45 ff	 movzx	 eax, BYTE PTR $T12[ebp]
  00036	85 c0		 test	 eax, eax
  00038	74 5c		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0003a	6a 5c		 push	 92			; 0000005cH
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	59		 pop	 ecx
  00042	89 45 f4	 mov	 DWORD PTR $T11[ebp], eax
  00045	83 7d f4 00	 cmp	 DWORD PTR $T11[ebp], 0
  00049	74 1a		 je	 SHORT $LN4@Alloc
  0004b	8b 45 f4	 mov	 eax, DWORD PTR $T11[ebp]
  0004e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CBaseCollisionInstance@@6B@
  00054	8b 45 f4	 mov	 eax, DWORD PTR $T11[ebp]
  00057	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7COBBCollisionInstance@@6B@
  0005d	8b 45 f4	 mov	 eax, DWORD PTR $T11[ebp]
  00060	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax
  00063	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00065	83 65 e4 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  00069	8b 45 e4	 mov	 eax, DWORD PTR tv80[ebp]
  0006c	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax
  0006f	8b 45 d8	 mov	 eax, DWORD PTR $T7[ebp]
  00072	89 45 e0	 mov	 DWORD PTR _pkNewData$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00075	8d 45 e0	 lea	 eax, DWORD PTR _pkNewData$8[ebp]
  00078	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00079	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0007f	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::emplace_back<COBBCollisionInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  00084	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00087	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0008a	40		 inc	 eax
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  00091	8b 45 e0	 mov	 eax, DWORD PTR _pkNewData$8[ebp]
  00094	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  00096	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 10	 add	 eax, 16			; 00000010H
  0009c	89 45 d4	 mov	 DWORD PTR __My_data$6[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  0009f	6a 04		 push	 4
  000a1	58		 pop	 eax
  000a2	6b c0 ff	 imul	 eax, eax, -1
  000a5	8b 4d d4	 mov	 ecx, DWORD PTR __My_data$6[ebp]
  000a8	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000ab	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000ae	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  000b1	8b 00		 mov	 eax, DWORD PTR [eax]
  000b3	89 45 c0	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	83 c0 10	 add	 eax, 16			; 00000010H
  000bc	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000bf	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	89 45 cc	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000c5	8b 45 cc	 mov	 eax, DWORD PTR __My_data$4[ebp]
  000c8	83 c0 04	 add	 eax, 4
  000cb	89 45 f0	 mov	 DWORD PTR __Mylast$10[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000ce	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$10[ebp]
  000d1	8b 00		 mov	 eax, DWORD PTR [eax]
  000d3	83 e8 04	 sub	 eax, 4
  000d6	89 45 c8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000d9	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000dc	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000df	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000e2	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000e5	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000e8	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax

; 1338 :         --_Mylast;

  000eb	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$10[ebp]
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	83 e8 04	 sub	 eax, 4
  000f3	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$10[ebp]
  000f6	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 73   : 			return pkFreeData;

  000f8	8b 45 c0	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  000fb	c9		 leave
  000fc	c3		 ret	 0
?Alloc@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEPAVCOBBCollisionInstance@@XZ ENDP ; CDynamicPool<COBBCollisionInstance>::Alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXXZ PROC ; CDynamicPool<COBBCollisionInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCOBBCollisionInstance@@@@KAXPAVCOBBCollisionInstance@@@Z ; CDynamicPool<COBBCollisionInstance>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCOBBCollisionInstance@@@Z@std@@YAP6AXPAVCOBBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCOBBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<COBBCollisionInstance *> > >,void (__cdecl*)(COBBCollisionInstance *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXXZ ENDP ; CDynamicPool<COBBCollisionInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ PROC	; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ ENDP	; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCOBBCollisionInstance@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCOBBCollisionInstance@@@@QAE@XZ PROC	; CDynamicPool<COBBCollisionInstance>::CDynamicPool<COBBCollisionInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCOBBCollisionInstance@@@@QAE@XZ ENDP	; CDynamicPool<COBBCollisionInstance>::CDynamicPool<COBBCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fgs_aci@@YAXXZ
text$yd	SEGMENT
??__Fgs_aci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_aci'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A ; gs_aci
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fgs_aci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_aci''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ??__Egs_aci@@YAXXZ
text$di	SEGMENT
??__Egs_aci@@YAXXZ PROC					; `dynamic initializer for 'gs_aci'', COMDAT

; 21   : CDynamicPool<CAABBCollisionInstance> gs_aci;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A ; gs_aci
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCAABBCollisionInstance@@@@QAE@XZ ; CDynamicPool<CAABBCollisionInstance>::CDynamicPool<CAABBCollisionInstance>
  0000d	68 00 00 00 00	 push	 OFFSET ??__Fgs_aci@@YAXXZ ; `dynamic atexit destructor for 'gs_aci''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Egs_aci@@YAXXZ ENDP					; `dynamic initializer for 'gs_aci''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CAABBCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CAABBCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAABBCollisionInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXQAPAVCAABBCollisionInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXQAPAVCAABBCollisionInstance@@II@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAABBCollisionInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXQAPAVCAABBCollisionInstance@@II@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXPAPAVCAABBCollisionInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXPAPAVCAABBCollisionInstance@@0@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAABBCollisionInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXPAPAVCAABBCollisionInstance@@0@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@YAXPAPAVCAABBCollisionInstance@@QAPAV1@AAV?$allocator@PAVCAABBCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAABBCollisionInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXQAPAVCAABBCollisionInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXQAPAVCAABBCollisionInstance@@I@Z PROC ; std::allocator<CAABBCollisionInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCAABBCollisionInstance@@@std@@QAEXQAPAVCAABBCollisionInstance@@I@Z ENDP ; std::allocator<CAABBCollisionInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCAABBCollisionInstance@@@@KAXPAVCAABBCollisionInstance@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCAABBCollisionInstance@@@@KAXPAVCAABBCollisionInstance@@@Z PROC ; CDynamicPool<CAABBCollisionInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 110  : 			delete pkData;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000a	6a 1c		 push	 28			; 0000001cH
  0000c	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 111  : 		}

  00016	c9		 leave
  00017	c3		 ret	 0
?Delete@?$CDynamicPool@VCAABBCollisionInstance@@@@KAXPAVCAABBCollisionInstance@@@Z ENDP ; CDynamicPool<CAABBCollisionInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
_pkFreeData$ = -64					; size = 4
$T3 = -60						; size = 4
__Ptr$ = -56						; size = 4
__My_data$4 = -52					; size = 4
$T5 = -48						; size = 4
__My_data$6 = -44					; size = 4
$T7 = -40						; size = 4
_this$ = -36						; size = 4
_pkNewData$8 = -32					; size = 4
tv80 = -28						; size = 4
tv130 = -24						; size = 4
__My_data$9 = -20					; size = 4
__Mylast$10 = -16					; size = 4
$T11 = -12						; size = 4
_this$ = -8						; size = 4
$T12 = -1						; size = 1
?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ PROC ; CDynamicPool<CAABBCollisionInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 10	 add	 eax, 16			; 00000010H
  0000f	89 45 ec	 mov	 DWORD PTR __My_data$9[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00012	8b 45 ec	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00015	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$9[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0001d	75 09		 jne	 SHORT $LN9@Alloc
  0001f	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00026	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00028	83 65 e8 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0002c	8a 45 e8	 mov	 al, BYTE PTR tv130[ebp]
  0002f	88 45 ff	 mov	 BYTE PTR $T12[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00032	0f b6 45 ff	 movzx	 eax, BYTE PTR $T12[ebp]
  00036	85 c0		 test	 eax, eax
  00038	74 5c		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0003a	6a 1c		 push	 28			; 0000001cH
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	59		 pop	 ecx
  00042	89 45 f4	 mov	 DWORD PTR $T11[ebp], eax
  00045	83 7d f4 00	 cmp	 DWORD PTR $T11[ebp], 0
  00049	74 1a		 je	 SHORT $LN4@Alloc
  0004b	8b 45 f4	 mov	 eax, DWORD PTR $T11[ebp]
  0004e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CBaseCollisionInstance@@6B@
  00054	8b 45 f4	 mov	 eax, DWORD PTR $T11[ebp]
  00057	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CAABBCollisionInstance@@6B@
  0005d	8b 45 f4	 mov	 eax, DWORD PTR $T11[ebp]
  00060	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax
  00063	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00065	83 65 e4 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  00069	8b 45 e4	 mov	 eax, DWORD PTR tv80[ebp]
  0006c	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax
  0006f	8b 45 d8	 mov	 eax, DWORD PTR $T7[ebp]
  00072	89 45 e0	 mov	 DWORD PTR _pkNewData$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00075	8d 45 e0	 lea	 eax, DWORD PTR _pkNewData$8[ebp]
  00078	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00079	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0007f	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::emplace_back<CAABBCollisionInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  00084	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00087	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0008a	40		 inc	 eax
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  00091	8b 45 e0	 mov	 eax, DWORD PTR _pkNewData$8[ebp]
  00094	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  00096	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 10	 add	 eax, 16			; 00000010H
  0009c	89 45 d4	 mov	 DWORD PTR __My_data$6[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  0009f	6a 04		 push	 4
  000a1	58		 pop	 eax
  000a2	6b c0 ff	 imul	 eax, eax, -1
  000a5	8b 4d d4	 mov	 ecx, DWORD PTR __My_data$6[ebp]
  000a8	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000ab	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000ae	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  000b1	8b 00		 mov	 eax, DWORD PTR [eax]
  000b3	89 45 c0	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	83 c0 10	 add	 eax, 16			; 00000010H
  000bc	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000bf	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	89 45 cc	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000c5	8b 45 cc	 mov	 eax, DWORD PTR __My_data$4[ebp]
  000c8	83 c0 04	 add	 eax, 4
  000cb	89 45 f0	 mov	 DWORD PTR __Mylast$10[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000ce	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$10[ebp]
  000d1	8b 00		 mov	 eax, DWORD PTR [eax]
  000d3	83 e8 04	 sub	 eax, 4
  000d6	89 45 c8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000d9	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000dc	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000df	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000e2	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000e5	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000e8	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax

; 1338 :         --_Mylast;

  000eb	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$10[ebp]
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	83 e8 04	 sub	 eax, 4
  000f3	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$10[ebp]
  000f6	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 73   : 			return pkFreeData;

  000f8	8b 45 c0	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  000fb	c9		 leave
  000fc	c3		 ret	 0
?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ ENDP ; CDynamicPool<CAABBCollisionInstance>::Alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXXZ PROC ; CDynamicPool<CAABBCollisionInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCAABBCollisionInstance@@@@KAXPAVCAABBCollisionInstance@@@Z ; CDynamicPool<CAABBCollisionInstance>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@std@@P6AXPAVCAABBCollisionInstance@@@Z@std@@YAP6AXPAVCAABBCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAABBCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAABBCollisionInstance *> > >,void (__cdecl*)(CAABBCollisionInstance *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXXZ ENDP ; CDynamicPool<CAABBCollisionInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ PROC ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ ENDP ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCAABBCollisionInstance@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCAABBCollisionInstance@@@@QAE@XZ PROC ; CDynamicPool<CAABBCollisionInstance>::CDynamicPool<CAABBCollisionInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCAABBCollisionInstance@@@@QAE@XZ ENDP ; CDynamicPool<CAABBCollisionInstance>::CDynamicPool<CAABBCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fgs_pci@@YAXXZ
text$yd	SEGMENT
??__Fgs_pci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_pci'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A ; gs_pci
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fgs_pci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_pci''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ??__Egs_pci@@YAXXZ
text$di	SEGMENT
??__Egs_pci@@YAXXZ PROC					; `dynamic initializer for 'gs_pci'', COMDAT

; 20   : CDynamicPool<CPlaneCollisionInstance> gs_pci;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A ; gs_pci
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCPlaneCollisionInstance@@@@QAE@XZ ; CDynamicPool<CPlaneCollisionInstance>::CDynamicPool<CPlaneCollisionInstance>
  0000d	68 00 00 00 00	 push	 OFFSET ??__Fgs_pci@@YAXXZ ; `dynamic atexit destructor for 'gs_pci''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Egs_pci@@YAXXZ ENDP					; `dynamic initializer for 'gs_pci''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CPlaneCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CPlaneCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@QAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CPlaneCollisionInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXQAPAVCPlaneCollisionInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXQAPAVCPlaneCollisionInstance@@II@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@QAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CPlaneCollisionInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXQAPAVCPlaneCollisionInstance@@II@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXPAPAVCPlaneCollisionInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXPAPAVCPlaneCollisionInstance@@0@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@QAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CPlaneCollisionInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXPAPAVCPlaneCollisionInstance@@0@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@YAXPAPAVCPlaneCollisionInstance@@QAPAV1@AAV?$allocator@PAVCPlaneCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CPlaneCollisionInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXQAPAVCPlaneCollisionInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXQAPAVCPlaneCollisionInstance@@I@Z PROC ; std::allocator<CPlaneCollisionInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCPlaneCollisionInstance@@@std@@QAEXQAPAVCPlaneCollisionInstance@@I@Z ENDP ; std::allocator<CPlaneCollisionInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCPlaneCollisionInstance@@@@KAXPAVCPlaneCollisionInstance@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCPlaneCollisionInstance@@@@KAXPAVCPlaneCollisionInstance@@@Z PROC ; CDynamicPool<CPlaneCollisionInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 110  : 			delete pkData;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000a	6a 7c		 push	 124			; 0000007cH
  0000c	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 111  : 		}

  00016	c9		 leave
  00017	c3		 ret	 0
?Delete@?$CDynamicPool@VCPlaneCollisionInstance@@@@KAXPAVCPlaneCollisionInstance@@@Z ENDP ; CDynamicPool<CPlaneCollisionInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
tv130 = -36						; size = 4
__My_data$10 = -32					; size = 4
__Mylast$11 = -28					; size = 4
$T12 = -24						; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ PROC ; CDynamicPool<CPlaneCollisionInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e0	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e0	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00034	8b 4d e0	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 dc 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 dc	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 6f		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	6a 7c		 push	 124			; 0000007cH
  0005b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00060	59		 pop	 ecx
  00061	89 45 e8	 mov	 DWORD PTR $T12[ebp], eax
  00064	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	83 7d e8 00	 cmp	 DWORD PTR $T12[ebp], 0
  0006c	74 25		 je	 SHORT $LN4@Alloc
  0006e	8b 45 e8	 mov	 eax, DWORD PTR $T12[ebp]
  00071	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CBaseCollisionInstance@@6B@
  00077	8b 45 e8	 mov	 eax, DWORD PTR $T12[ebp]
  0007a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CPlaneCollisionInstance@@6B@
  00080	8b 4d e8	 mov	 ecx, DWORD PTR $T12[ebp]
  00083	83 c1 04	 add	 ecx, 4
  00086	e8 00 00 00 00	 call	 ??0SPlaneData@@QAE@XZ
  0008b	8b 45 e8	 mov	 eax, DWORD PTR $T12[ebp]
  0008e	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  00091	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00093	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  00097	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  0009a	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  0009d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000a1	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  000a4	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  000a7	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  000aa	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  000ab	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  000b1	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::emplace_back<CPlaneCollisionInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  000b6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000bc	40		 inc	 eax
  000bd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000c3	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000c6	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000c8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cb	83 c0 10	 add	 eax, 16			; 00000010H
  000ce	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000d1	6a 04		 push	 4
  000d3	58		 pop	 eax
  000d4	6b c0 ff	 imul	 eax, eax, -1
  000d7	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000da	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000dd	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000e0	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000e3	8b 00		 mov	 eax, DWORD PTR [eax]
  000e5	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000e8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	83 c0 10	 add	 eax, 16			; 00000010H
  000ee	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000f1	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000f4	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000f7	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000fa	83 c0 04	 add	 eax, 4
  000fd	89 45 e4	 mov	 DWORD PTR __Mylast$11[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  00100	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00103	8b 00		 mov	 eax, DWORD PTR [eax]
  00105	83 e8 04	 sub	 eax, 4
  00108	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0010b	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0010e	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00111	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00114	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00117	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  0011a	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00120	8b 00		 mov	 eax, DWORD PTR [eax]
  00122	83 e8 04	 sub	 eax, 4
  00125	8b 4d e4	 mov	 ecx, DWORD PTR __Mylast$11[ebp]
  00128	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 73   : 			return pkFreeData;

  0012a	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  0012d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00130	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00137	59		 pop	 ecx
  00138	c9		 leave
  00139	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ$0:
  00000	6a 7c		 push	 124			; 0000007cH
  00002	ff 75 e8	 push	 DWORD PTR $T12[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ ENDP ; CDynamicPool<CPlaneCollisionInstance>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXXZ PROC ; CDynamicPool<CPlaneCollisionInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCPlaneCollisionInstance@@@@KAXPAVCPlaneCollisionInstance@@@Z ; CDynamicPool<CPlaneCollisionInstance>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@std@@P6AXPAVCPlaneCollisionInstance@@@Z@std@@YAP6AXPAVCPlaneCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCPlaneCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CPlaneCollisionInstance *> > >,void (__cdecl*)(CPlaneCollisionInstance *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXXZ ENDP ; CDynamicPool<CPlaneCollisionInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ PROC ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ ENDP ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCPlaneCollisionInstance@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCPlaneCollisionInstance@@@@QAE@XZ PROC ; CDynamicPool<CPlaneCollisionInstance>::CDynamicPool<CPlaneCollisionInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCPlaneCollisionInstance@@@@QAE@XZ ENDP ; CDynamicPool<CPlaneCollisionInstance>::CDynamicPool<CPlaneCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fgs_cci@@YAXXZ
text$yd	SEGMENT
??__Fgs_cci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_cci'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A ; gs_cci
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fgs_cci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_cci''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ??__Egs_cci@@YAXXZ
text$di	SEGMENT
??__Egs_cci@@YAXXZ PROC					; `dynamic initializer for 'gs_cci'', COMDAT

; 19   : CDynamicPool<CCylinderCollisionInstance> gs_cci;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A ; gs_cci
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCCylinderCollisionInstance@@@@QAE@XZ ; CDynamicPool<CCylinderCollisionInstance>::CDynamicPool<CCylinderCollisionInstance>
  0000d	68 00 00 00 00	 push	 OFFSET ??__Fgs_cci@@YAXXZ ; `dynamic atexit destructor for 'gs_cci''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Egs_cci@@YAXXZ ENDP					; `dynamic initializer for 'gs_cci''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CCylinderCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CCylinderCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@QAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CCylinderCollisionInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXQAPAVCCylinderCollisionInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXQAPAVCCylinderCollisionInstance@@II@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@QAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CCylinderCollisionInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXQAPAVCCylinderCollisionInstance@@II@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXPAPAVCCylinderCollisionInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXPAPAVCCylinderCollisionInstance@@0@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@QAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CCylinderCollisionInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXPAPAVCCylinderCollisionInstance@@0@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@YAXPAPAVCCylinderCollisionInstance@@QAPAV1@AAV?$allocator@PAVCCylinderCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CCylinderCollisionInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXQAPAVCCylinderCollisionInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXQAPAVCCylinderCollisionInstance@@I@Z PROC ; std::allocator<CCylinderCollisionInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCCylinderCollisionInstance@@@std@@QAEXQAPAVCCylinderCollisionInstance@@I@Z ENDP ; std::allocator<CCylinderCollisionInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCCylinderCollisionInstance@@@@KAXPAVCCylinderCollisionInstance@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCCylinderCollisionInstance@@@@KAXPAVCCylinderCollisionInstance@@@Z PROC ; CDynamicPool<CCylinderCollisionInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 110  : 			delete pkData;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000a	6a 18		 push	 24			; 00000018H
  0000c	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 111  : 		}

  00016	c9		 leave
  00017	c3		 ret	 0
?Delete@?$CDynamicPool@VCCylinderCollisionInstance@@@@KAXPAVCCylinderCollisionInstance@@@Z ENDP ; CDynamicPool<CCylinderCollisionInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEPAVCCylinderCollisionInstance@@XZ
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
_pkFreeData$ = -64					; size = 4
$T3 = -60						; size = 4
__Ptr$ = -56						; size = 4
__My_data$4 = -52					; size = 4
$T5 = -48						; size = 4
__My_data$6 = -44					; size = 4
$T7 = -40						; size = 4
_this$ = -36						; size = 4
_pkNewData$8 = -32					; size = 4
tv80 = -28						; size = 4
tv130 = -24						; size = 4
__My_data$9 = -20					; size = 4
__Mylast$10 = -16					; size = 4
$T11 = -12						; size = 4
_this$ = -8						; size = 4
$T12 = -1						; size = 1
?Alloc@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEPAVCCylinderCollisionInstance@@XZ PROC ; CDynamicPool<CCylinderCollisionInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 10	 add	 eax, 16			; 00000010H
  0000f	89 45 ec	 mov	 DWORD PTR __My_data$9[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00012	8b 45 ec	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00015	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$9[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0001d	75 09		 jne	 SHORT $LN9@Alloc
  0001f	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00026	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00028	83 65 e8 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0002c	8a 45 e8	 mov	 al, BYTE PTR tv130[ebp]
  0002f	88 45 ff	 mov	 BYTE PTR $T12[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00032	0f b6 45 ff	 movzx	 eax, BYTE PTR $T12[ebp]
  00036	85 c0		 test	 eax, eax
  00038	74 5c		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0003a	6a 18		 push	 24			; 00000018H
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	59		 pop	 ecx
  00042	89 45 f4	 mov	 DWORD PTR $T11[ebp], eax
  00045	83 7d f4 00	 cmp	 DWORD PTR $T11[ebp], 0
  00049	74 1a		 je	 SHORT $LN4@Alloc
  0004b	8b 45 f4	 mov	 eax, DWORD PTR $T11[ebp]
  0004e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CBaseCollisionInstance@@6B@
  00054	8b 45 f4	 mov	 eax, DWORD PTR $T11[ebp]
  00057	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCylinderCollisionInstance@@6B@
  0005d	8b 45 f4	 mov	 eax, DWORD PTR $T11[ebp]
  00060	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax
  00063	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00065	83 65 e4 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  00069	8b 45 e4	 mov	 eax, DWORD PTR tv80[ebp]
  0006c	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax
  0006f	8b 45 d8	 mov	 eax, DWORD PTR $T7[ebp]
  00072	89 45 e0	 mov	 DWORD PTR _pkNewData$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00075	8d 45 e0	 lea	 eax, DWORD PTR _pkNewData$8[ebp]
  00078	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00079	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0007f	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::emplace_back<CCylinderCollisionInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  00084	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00087	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0008a	40		 inc	 eax
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  00091	8b 45 e0	 mov	 eax, DWORD PTR _pkNewData$8[ebp]
  00094	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  00096	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 10	 add	 eax, 16			; 00000010H
  0009c	89 45 d4	 mov	 DWORD PTR __My_data$6[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  0009f	6a 04		 push	 4
  000a1	58		 pop	 eax
  000a2	6b c0 ff	 imul	 eax, eax, -1
  000a5	8b 4d d4	 mov	 ecx, DWORD PTR __My_data$6[ebp]
  000a8	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000ab	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000ae	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  000b1	8b 00		 mov	 eax, DWORD PTR [eax]
  000b3	89 45 c0	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	83 c0 10	 add	 eax, 16			; 00000010H
  000bc	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000bf	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	89 45 cc	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000c5	8b 45 cc	 mov	 eax, DWORD PTR __My_data$4[ebp]
  000c8	83 c0 04	 add	 eax, 4
  000cb	89 45 f0	 mov	 DWORD PTR __Mylast$10[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000ce	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$10[ebp]
  000d1	8b 00		 mov	 eax, DWORD PTR [eax]
  000d3	83 e8 04	 sub	 eax, 4
  000d6	89 45 c8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000d9	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000dc	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000df	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000e2	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000e5	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000e8	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax

; 1338 :         --_Mylast;

  000eb	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$10[ebp]
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	83 e8 04	 sub	 eax, 4
  000f3	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$10[ebp]
  000f6	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 73   : 			return pkFreeData;

  000f8	8b 45 c0	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  000fb	c9		 leave
  000fc	c3		 ret	 0
?Alloc@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEPAVCCylinderCollisionInstance@@XZ ENDP ; CDynamicPool<CCylinderCollisionInstance>::Alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXXZ PROC ; CDynamicPool<CCylinderCollisionInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCCylinderCollisionInstance@@@@KAXPAVCCylinderCollisionInstance@@@Z ; CDynamicPool<CCylinderCollisionInstance>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@std@@P6AXPAVCCylinderCollisionInstance@@@Z@std@@YAP6AXPAVCCylinderCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCCylinderCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CCylinderCollisionInstance *> > >,void (__cdecl*)(CCylinderCollisionInstance *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXXZ ENDP ; CDynamicPool<CCylinderCollisionInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ PROC ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ ENDP ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCCylinderCollisionInstance@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCCylinderCollisionInstance@@@@QAE@XZ PROC ; CDynamicPool<CCylinderCollisionInstance>::CDynamicPool<CCylinderCollisionInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCCylinderCollisionInstance@@@@QAE@XZ ENDP ; CDynamicPool<CCylinderCollisionInstance>::CDynamicPool<CCylinderCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fgs_sci@@YAXXZ
text$yd	SEGMENT
??__Fgs_sci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_sci'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A ; gs_sci
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fgs_sci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_sci''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ??__Egs_sci@@YAXXZ
text$di	SEGMENT
??__Egs_sci@@YAXXZ PROC					; `dynamic initializer for 'gs_sci'', COMDAT

; 18   : CDynamicPool<CSphereCollisionInstance> gs_sci;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A ; gs_sci
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCSphereCollisionInstance@@@@QAE@XZ ; CDynamicPool<CSphereCollisionInstance>::CDynamicPool<CSphereCollisionInstance>
  0000d	68 00 00 00 00	 push	 OFFSET ??__Fgs_sci@@YAXXZ ; `dynamic atexit destructor for 'gs_sci''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Egs_sci@@YAXXZ ENDP					; `dynamic initializer for 'gs_sci''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CSphereCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CSphereCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@QAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CSphereCollisionInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXQAPAVCSphereCollisionInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXQAPAVCSphereCollisionInstance@@II@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@QAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CSphereCollisionInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXQAPAVCSphereCollisionInstance@@II@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXPAPAVCSphereCollisionInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXPAPAVCSphereCollisionInstance@@0@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@QAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CSphereCollisionInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXPAPAVCSphereCollisionInstance@@0@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@YAXPAPAVCSphereCollisionInstance@@QAPAV1@AAV?$allocator@PAVCSphereCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CSphereCollisionInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXQAPAVCSphereCollisionInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXQAPAVCSphereCollisionInstance@@I@Z PROC ; std::allocator<CSphereCollisionInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCSphereCollisionInstance@@@std@@QAEXQAPAVCSphereCollisionInstance@@I@Z ENDP ; std::allocator<CSphereCollisionInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCSphereCollisionInstance@@@@KAXPAVCSphereCollisionInstance@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCSphereCollisionInstance@@@@KAXPAVCSphereCollisionInstance@@@Z PROC ; CDynamicPool<CSphereCollisionInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 110  : 			delete pkData;

  00004	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000a	6a 14		 push	 20			; 00000014H
  0000c	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 111  : 		}

  00016	c9		 leave
  00017	c3		 ret	 0
?Delete@?$CDynamicPool@VCSphereCollisionInstance@@@@KAXPAVCSphereCollisionInstance@@@Z ENDP ; CDynamicPool<CSphereCollisionInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEPAVCSphereCollisionInstance@@XZ
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
_pkFreeData$ = -64					; size = 4
$T3 = -60						; size = 4
__Ptr$ = -56						; size = 4
__My_data$4 = -52					; size = 4
$T5 = -48						; size = 4
__My_data$6 = -44					; size = 4
$T7 = -40						; size = 4
_this$ = -36						; size = 4
_pkNewData$8 = -32					; size = 4
tv80 = -28						; size = 4
tv130 = -24						; size = 4
__My_data$9 = -20					; size = 4
__Mylast$10 = -16					; size = 4
$T11 = -12						; size = 4
_this$ = -8						; size = 4
$T12 = -1						; size = 1
?Alloc@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEPAVCSphereCollisionInstance@@XZ PROC ; CDynamicPool<CSphereCollisionInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 10	 add	 eax, 16			; 00000010H
  0000f	89 45 ec	 mov	 DWORD PTR __My_data$9[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00012	8b 45 ec	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00015	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$9[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0001d	75 09		 jne	 SHORT $LN9@Alloc
  0001f	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00026	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00028	83 65 e8 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0002c	8a 45 e8	 mov	 al, BYTE PTR tv130[ebp]
  0002f	88 45 ff	 mov	 BYTE PTR $T12[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00032	0f b6 45 ff	 movzx	 eax, BYTE PTR $T12[ebp]
  00036	85 c0		 test	 eax, eax
  00038	74 5c		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  0003a	6a 14		 push	 20			; 00000014H
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	59		 pop	 ecx
  00042	89 45 f4	 mov	 DWORD PTR $T11[ebp], eax
  00045	83 7d f4 00	 cmp	 DWORD PTR $T11[ebp], 0
  00049	74 1a		 je	 SHORT $LN4@Alloc
  0004b	8b 45 f4	 mov	 eax, DWORD PTR $T11[ebp]
  0004e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CBaseCollisionInstance@@6B@
  00054	8b 45 f4	 mov	 eax, DWORD PTR $T11[ebp]
  00057	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CSphereCollisionInstance@@6B@
  0005d	8b 45 f4	 mov	 eax, DWORD PTR $T11[ebp]
  00060	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax
  00063	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00065	83 65 e4 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  00069	8b 45 e4	 mov	 eax, DWORD PTR tv80[ebp]
  0006c	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax
  0006f	8b 45 d8	 mov	 eax, DWORD PTR $T7[ebp]
  00072	89 45 e0	 mov	 DWORD PTR _pkNewData$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00075	8d 45 e0	 lea	 eax, DWORD PTR _pkNewData$8[ebp]
  00078	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00079	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0007f	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::emplace_back<CSphereCollisionInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  00084	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00087	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0008a	40		 inc	 eax
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  00091	8b 45 e0	 mov	 eax, DWORD PTR _pkNewData$8[ebp]
  00094	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  00096	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 10	 add	 eax, 16			; 00000010H
  0009c	89 45 d4	 mov	 DWORD PTR __My_data$6[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  0009f	6a 04		 push	 4
  000a1	58		 pop	 eax
  000a2	6b c0 ff	 imul	 eax, eax, -1
  000a5	8b 4d d4	 mov	 ecx, DWORD PTR __My_data$6[ebp]
  000a8	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000ab	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000ae	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  000b1	8b 00		 mov	 eax, DWORD PTR [eax]
  000b3	89 45 c0	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	83 c0 10	 add	 eax, 16			; 00000010H
  000bc	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000bf	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	89 45 cc	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000c5	8b 45 cc	 mov	 eax, DWORD PTR __My_data$4[ebp]
  000c8	83 c0 04	 add	 eax, 4
  000cb	89 45 f0	 mov	 DWORD PTR __Mylast$10[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000ce	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$10[ebp]
  000d1	8b 00		 mov	 eax, DWORD PTR [eax]
  000d3	83 e8 04	 sub	 eax, 4
  000d6	89 45 c8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000d9	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000dc	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000df	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000e2	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000e5	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000e8	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax

; 1338 :         --_Mylast;

  000eb	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$10[ebp]
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	83 e8 04	 sub	 eax, 4
  000f3	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$10[ebp]
  000f6	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 73   : 			return pkFreeData;

  000f8	8b 45 c0	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  000fb	c9		 leave
  000fc	c3		 ret	 0
?Alloc@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEPAVCSphereCollisionInstance@@XZ ENDP ; CDynamicPool<CSphereCollisionInstance>::Alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXXZ PROC ; CDynamicPool<CSphereCollisionInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCSphereCollisionInstance@@@@KAXPAVCSphereCollisionInstance@@@Z ; CDynamicPool<CSphereCollisionInstance>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@std@@P6AXPAVCSphereCollisionInstance@@@Z@std@@YAP6AXPAVCSphereCollisionInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSphereCollisionInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CSphereCollisionInstance *> > >,void (__cdecl*)(CSphereCollisionInstance *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXXZ ENDP ; CDynamicPool<CSphereCollisionInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ PROC ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ ENDP ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCSphereCollisionInstance@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCSphereCollisionInstance@@@@QAE@XZ PROC ; CDynamicPool<CSphereCollisionInstance>::CDynamicPool<CSphereCollisionInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCSphereCollisionInstance@@@@QAE@XZ ENDP ; CDynamicPool<CSphereCollisionInstance>::CDynamicPool<CSphereCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
;	COMDAT ?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z
_TEXT	SEGMENT
_fz$ = -108						; size = 4
_fy$ = -104						; size = 4
_fz$ = -100						; size = 4
_fx$ = -96						; size = 4
_fy$ = -92						; size = 4
_fz$ = -88						; size = 4
tv900 = -84						; size = 4
_fx$ = -80						; size = 4
_fy$ = -76						; size = 4
tv962 = -72						; size = 4
_fz$ = -68						; size = 4
_fy$ = -64						; size = 4
_fx$ = -60						; size = 4
_fz$ = -56						; size = 4
_fy$ = -52						; size = 4
_fx$ = -48						; size = 4
tv919 = -44						; size = 4
_fx$ = -40						; size = 4
_fz$ = -36						; size = 4
_fy$ = -32						; size = 4
_fx$ = -28						; size = 4
_fz$ = -24						; size = 4
_fy$ = -20						; size = 4
_fx$ = -16						; size = 4
_d$ = -12						; size = 4
_l$ = -8						; size = 4
_v$1 = -4						; size = 12
$T2 = 8							; size = 12
$T3 = 20						; size = 12
_c$4 = 32						; size = 12
$T5 = 44						; size = 12
$T6 = 56						; size = 12
$T7 = 68						; size = 12
$T8 = 80						; size = 12
$T9 = 92						; size = 12
__$ArrayPad$ = 104					; size = 4
_p1$ = 116						; size = 4
_p2$ = 120						; size = 4
_x$ = 124						; size = 4
?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z PROC ; square_distance_between_linesegment_and_point, COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 94	 lea	 ebp, DWORD PTR [esp-108]
  00005	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 68	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00017	8b 45 78	 mov	 eax, DWORD PTR _p2$[ebp]
  0001a	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  0001d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00021	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00025	f3 0f 11 45 f0	 movss	 DWORD PTR _fx$[ebp], xmm0
  0002a	8b 45 78	 mov	 eax, DWORD PTR _p2$[ebp]
  0002d	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  00030	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00035	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0003a	f3 0f 11 45 ec	 movss	 DWORD PTR _fy$[ebp], xmm0
  0003f	8b 45 78	 mov	 eax, DWORD PTR _p2$[ebp]
  00042	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  00045	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0004a	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0004f	f3 0f 11 45 e8	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00054	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00059	f3 0f 11 45 2c	 movss	 DWORD PTR $T5[ebp], xmm0

; 181  :     y = fy;

  0005e	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00063	f3 0f 11 45 30	 movss	 DWORD PTR $T5[ebp+4], xmm0

; 182  :     z = fz;

  00068	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0006d	f3 0f 11 45 34	 movss	 DWORD PTR $T5[ebp+8], xmm0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00072	f3 0f 10 45 34	 movss	 xmm0, DWORD PTR $T5[ebp+8]
  00077	f3 0f 59 45 34	 mulss	 xmm0, DWORD PTR $T5[ebp+8]
  0007c	f3 0f 10 4d 30	 movss	 xmm1, DWORD PTR $T5[ebp+4]
  00081	f3 0f 59 4d 30	 mulss	 xmm1, DWORD PTR $T5[ebp+4]
  00086	f3 0f 10 55 2c	 movss	 xmm2, DWORD PTR $T5[ebp]
  0008b	f3 0f 59 55 2c	 mulss	 xmm2, DWORD PTR $T5[ebp]
  00090	f3 0f 58 d1	 addss	 xmm2, xmm1
  00094	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 82   : 	float l = D3DXVec3LengthSq(&(p2-p1));

  00098	f3 0f 11 55 f8	 movss	 DWORD PTR _l$[ebp], xmm2
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0009d	8b 45 78	 mov	 eax, DWORD PTR _p2$[ebp]
  000a0	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  000a3	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000a7	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  000ab	f3 0f 11 45 e4	 movss	 DWORD PTR _fx$[ebp], xmm0
  000b0	8b 45 78	 mov	 eax, DWORD PTR _p2$[ebp]
  000b3	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  000b6	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000bb	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  000c0	f3 0f 11 45 e0	 movss	 DWORD PTR _fy$[ebp], xmm0
  000c5	8b 45 78	 mov	 eax, DWORD PTR _p2$[ebp]
  000c8	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  000cb	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000d0	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  000d5	f3 0f 11 45 dc	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  000da	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000df	f3 0f 11 45 14	 movss	 DWORD PTR $T3[ebp], xmm0

; 181  :     y = fy;

  000e4	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  000e9	f3 0f 11 45 18	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 182  :     z = fz;

  000ee	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  000f3	f3 0f 11 45 1c	 movss	 DWORD PTR $T3[ebp+8], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000f8	8b 45 7c	 mov	 eax, DWORD PTR _x$[ebp]
  000fb	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  000fe	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00102	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00106	f3 0f 11 45 d8	 movss	 DWORD PTR _fx$[ebp], xmm0
  0010b	8b 45 7c	 mov	 eax, DWORD PTR _x$[ebp]
  0010e	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  00111	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00116	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0011b	f3 0f 11 45 98	 movss	 DWORD PTR _fy$[ebp], xmm0
  00120	8b 45 7c	 mov	 eax, DWORD PTR _x$[ebp]
  00123	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  00126	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0012b	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00130	f3 0f 11 45 9c	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00135	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0013a	f3 0f 11 45 08	 movss	 DWORD PTR $T2[ebp], xmm0

; 181  :     y = fy;

  0013f	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00144	f3 0f 11 45 0c	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 182  :     z = fz;

  00149	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0014e	f3 0f 11 45 10	 movss	 DWORD PTR $T2[ebp+8], xmm0

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00153	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR $T2[ebp+8]
  00158	f3 0f 59 45 1c	 mulss	 xmm0, DWORD PTR $T3[ebp+8]
  0015d	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR $T2[ebp+4]
  00162	f3 0f 59 4d 18	 mulss	 xmm1, DWORD PTR $T3[ebp+4]
  00167	f3 0f 10 55 08	 movss	 xmm2, DWORD PTR $T2[ebp]
  0016c	f3 0f 59 55 14	 mulss	 xmm2, DWORD PTR $T3[ebp]
  00171	f3 0f 58 d1	 addss	 xmm2, xmm1
  00175	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 83   : 	float d = D3DXVec3Dot(&(x-p1),&(p2-p1));

  00179	f3 0f 11 55 f4	 movss	 DWORD PTR _d$[ebp], xmm2

; 84   : 	if (d<=0.0f)

  0017e	0f 57 c0	 xorps	 xmm0, xmm0
  00181	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _d$[ebp]
  00185	0f 82 93 00 00
	00		 jb	 $LN2@square_dis
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0018b	8b 45 7c	 mov	 eax, DWORD PTR _x$[ebp]
  0018e	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  00191	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00195	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00199	f3 0f 11 45 a0	 movss	 DWORD PTR _fx$[ebp], xmm0
  0019e	8b 45 7c	 mov	 eax, DWORD PTR _x$[ebp]
  001a1	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  001a4	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001a9	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  001ae	f3 0f 11 45 a4	 movss	 DWORD PTR _fy$[ebp], xmm0
  001b3	8b 45 7c	 mov	 eax, DWORD PTR _x$[ebp]
  001b6	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  001b9	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001be	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  001c3	f3 0f 11 45 a8	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  001c8	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _fx$[ebp]
  001cd	f3 0f 11 45 38	 movss	 DWORD PTR $T6[ebp], xmm0

; 181  :     y = fy;

  001d2	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  001d7	f3 0f 11 45 3c	 movss	 DWORD PTR $T6[ebp+4], xmm0

; 182  :     z = fz;

  001dc	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _fz$[ebp]
  001e1	f3 0f 11 45 40	 movss	 DWORD PTR $T6[ebp+8], xmm0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  001e6	f3 0f 10 45 40	 movss	 xmm0, DWORD PTR $T6[ebp+8]
  001eb	f3 0f 59 45 40	 mulss	 xmm0, DWORD PTR $T6[ebp+8]
  001f0	f3 0f 10 4d 3c	 movss	 xmm1, DWORD PTR $T6[ebp+4]
  001f5	f3 0f 59 4d 3c	 mulss	 xmm1, DWORD PTR $T6[ebp+4]
  001fa	f3 0f 10 55 38	 movss	 xmm2, DWORD PTR $T6[ebp]
  001ff	f3 0f 59 55 38	 mulss	 xmm2, DWORD PTR $T6[ebp]
  00204	f3 0f 58 d1	 addss	 xmm2, xmm1
  00208	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 86   : 		return D3DXVec3LengthSq(&(x-p1));

  0020c	f3 0f 11 55 ac	 movss	 DWORD PTR tv900[ebp], xmm2
  00211	d9 45 ac	 fld	 DWORD PTR tv900[ebp]
  00214	e9 f0 01 00 00	 jmp	 $LN5@square_dis

; 87   : 	}

  00219	e9 eb 01 00 00	 jmp	 $LN5@square_dis
$LN2@square_dis:

; 88   : 	else if (d>=l)

  0021e	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _d$[ebp]
  00223	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _l$[ebp]
  00227	0f 82 93 00 00
	00		 jb	 $LN4@square_dis
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0022d	8b 45 7c	 mov	 eax, DWORD PTR _x$[ebp]
  00230	8b 4d 78	 mov	 ecx, DWORD PTR _p2$[ebp]
  00233	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00237	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0023b	f3 0f 11 45 b0	 movss	 DWORD PTR _fx$[ebp], xmm0
  00240	8b 45 7c	 mov	 eax, DWORD PTR _x$[ebp]
  00243	8b 4d 78	 mov	 ecx, DWORD PTR _p2$[ebp]
  00246	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0024b	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00250	f3 0f 11 45 b4	 movss	 DWORD PTR _fy$[ebp], xmm0
  00255	8b 45 7c	 mov	 eax, DWORD PTR _x$[ebp]
  00258	8b 4d 78	 mov	 ecx, DWORD PTR _p2$[ebp]
  0025b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00260	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00265	f3 0f 11 45 94	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0026a	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0026f	f3 0f 11 45 44	 movss	 DWORD PTR $T7[ebp], xmm0

; 181  :     y = fy;

  00274	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00279	f3 0f 11 45 48	 movss	 DWORD PTR $T7[ebp+4], xmm0

; 182  :     z = fz;

  0027e	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00283	f3 0f 11 45 4c	 movss	 DWORD PTR $T7[ebp+8], xmm0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00288	f3 0f 10 45 4c	 movss	 xmm0, DWORD PTR $T7[ebp+8]
  0028d	f3 0f 59 45 4c	 mulss	 xmm0, DWORD PTR $T7[ebp+8]
  00292	f3 0f 10 4d 48	 movss	 xmm1, DWORD PTR $T7[ebp+4]
  00297	f3 0f 59 4d 48	 mulss	 xmm1, DWORD PTR $T7[ebp+4]
  0029c	f3 0f 10 55 44	 movss	 xmm2, DWORD PTR $T7[ebp]
  002a1	f3 0f 59 55 44	 mulss	 xmm2, DWORD PTR $T7[ebp]
  002a6	f3 0f 58 d1	 addss	 xmm2, xmm1
  002aa	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 90   : 		return D3DXVec3LengthSq(&(x-p2));

  002ae	f3 0f 11 55 d4	 movss	 DWORD PTR tv919[ebp], xmm2
  002b3	d9 45 d4	 fld	 DWORD PTR tv919[ebp]
  002b6	e9 4e 01 00 00	 jmp	 $LN5@square_dis

; 91   : 	}

  002bb	e9 49 01 00 00	 jmp	 $LN5@square_dis
$LN4@square_dis:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  002c0	8b 45 78	 mov	 eax, DWORD PTR _p2$[ebp]
  002c3	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  002c6	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002ca	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  002ce	f3 0f 11 45 d0	 movss	 DWORD PTR _fx$[ebp], xmm0
  002d3	8b 45 78	 mov	 eax, DWORD PTR _p2$[ebp]
  002d6	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  002d9	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  002de	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  002e3	f3 0f 11 45 cc	 movss	 DWORD PTR _fy$[ebp], xmm0
  002e8	8b 45 78	 mov	 eax, DWORD PTR _p2$[ebp]
  002eb	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  002ee	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002f3	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  002f8	f3 0f 11 45 c8	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  002fd	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00302	f3 0f 11 45 5c	 movss	 DWORD PTR $T9[ebp], xmm0

; 181  :     y = fy;

  00307	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0030c	f3 0f 11 45 60	 movss	 DWORD PTR $T9[ebp+4], xmm0

; 182  :     z = fz;

  00311	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00316	f3 0f 11 45 64	 movss	 DWORD PTR $T9[ebp+8], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0031b	8b 45 7c	 mov	 eax, DWORD PTR _x$[ebp]
  0031e	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  00321	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00325	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00329	f3 0f 11 45 c4	 movss	 DWORD PTR _fx$[ebp], xmm0
  0032e	8b 45 7c	 mov	 eax, DWORD PTR _x$[ebp]
  00331	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  00334	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00339	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0033e	f3 0f 11 45 c0	 movss	 DWORD PTR _fy$[ebp], xmm0
  00343	8b 45 7c	 mov	 eax, DWORD PTR _x$[ebp]
  00346	8b 4d 74	 mov	 ecx, DWORD PTR _p1$[ebp]
  00349	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0034e	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00353	f3 0f 11 45 bc	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00358	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0035d	f3 0f 11 45 50	 movss	 DWORD PTR $T8[ebp], xmm0

; 181  :     y = fy;

  00362	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00367	f3 0f 11 45 54	 movss	 DWORD PTR $T8[ebp+4], xmm0

; 182  :     z = fz;

  0036c	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00371	f3 0f 11 45 58	 movss	 DWORD PTR $T8[ebp+8], xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00376	f3 0f 10 45 54	 movss	 xmm0, DWORD PTR $T8[ebp+4]
  0037b	f3 0f 59 45 64	 mulss	 xmm0, DWORD PTR $T9[ebp+8]
  00380	f3 0f 10 4d 58	 movss	 xmm1, DWORD PTR $T8[ebp+8]
  00385	f3 0f 59 4d 60	 mulss	 xmm1, DWORD PTR $T9[ebp+4]
  0038a	f3 0f 5c c1	 subss	 xmm0, xmm1
  0038e	f3 0f 11 45 fc	 movss	 DWORD PTR _v$1[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00393	f3 0f 10 45 58	 movss	 xmm0, DWORD PTR $T8[ebp+8]
  00398	f3 0f 59 45 5c	 mulss	 xmm0, DWORD PTR $T9[ebp]
  0039d	f3 0f 10 4d 50	 movss	 xmm1, DWORD PTR $T8[ebp]
  003a2	f3 0f 59 4d 64	 mulss	 xmm1, DWORD PTR $T9[ebp+8]
  003a7	f3 0f 5c c1	 subss	 xmm0, xmm1
  003ab	f3 0f 11 45 00	 movss	 DWORD PTR _v$1[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  003b0	f3 0f 10 45 50	 movss	 xmm0, DWORD PTR $T8[ebp]
  003b5	f3 0f 59 45 60	 mulss	 xmm0, DWORD PTR $T9[ebp+4]
  003ba	f3 0f 10 4d 54	 movss	 xmm1, DWORD PTR $T8[ebp+4]
  003bf	f3 0f 59 4d 5c	 mulss	 xmm1, DWORD PTR $T9[ebp]
  003c4	f3 0f 5c c1	 subss	 xmm0, xmm1
  003c8	f3 0f 11 45 04	 movss	 DWORD PTR _v$1[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  003cd	8d 75 fc	 lea	 esi, DWORD PTR _v$1[ebp]
  003d0	8d 7d 20	 lea	 edi, DWORD PTR _c$4[ebp]
  003d3	a5		 movsd
  003d4	a5		 movsd
  003d5	a5		 movsd

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  003d6	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _c$4[ebp+8]
  003db	f3 0f 59 45 28	 mulss	 xmm0, DWORD PTR _c$4[ebp+8]
  003e0	f3 0f 10 4d 24	 movss	 xmm1, DWORD PTR _c$4[ebp+4]
  003e5	f3 0f 59 4d 24	 mulss	 xmm1, DWORD PTR _c$4[ebp+4]
  003ea	f3 0f 10 55 20	 movss	 xmm2, DWORD PTR _c$4[ebp]
  003ef	f3 0f 59 55 20	 mulss	 xmm2, DWORD PTR _c$4[ebp]
  003f4	f3 0f 58 d1	 addss	 xmm2, xmm1
  003f8	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 95   : 		return D3DXVec3LengthSq(D3DXVec3Cross(&c,&(x-p1),&(p2-p1)))/l;

  003fc	f3 0f 5e 55 f8	 divss	 xmm2, DWORD PTR _l$[ebp]
  00401	f3 0f 11 55 b8	 movss	 DWORD PTR tv962[ebp], xmm2
  00406	d9 45 b8	 fld	 DWORD PTR tv962[ebp]
$LN5@square_dis:

; 96   : 	}
; 97   : }

  00409	5f		 pop	 edi
  0040a	5e		 pop	 esi
  0040b	8b 4d 68	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0040e	33 cd		 xor	 ecx, ebp
  00410	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00415	83 c5 6c	 add	 ebp, 108		; 0000006cH
  00418	c9		 leave
  00419	c3		 ret	 0
?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z ENDP ; square_distance_between_linesegment_and_point
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
_fz$ = -80						; size = 4
_fy$ = -76						; size = 4
_fx$ = -72						; size = 4
_fz$ = -68						; size = 4
_fy$ = -64						; size = 4
_fx$ = -60						; size = 4
tv178 = -56						; size = 4
_ob$ = -52						; size = 12
_oa$ = -40						; size = 12
$T1 = -28						; size = 12
$T2 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_c_rattribute$ = 8					; size = 4
_s$ = 12						; size = 4
?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z PROC ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere, COMDAT
; _this$ = ecx

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx

; 453  : 	if (s.v3Position.z + s.fRadius < c_rattribute.v3Position.z)

  00013	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00019	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0001e	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  00023	8b 45 08	 mov	 eax, DWORD PTR _c_rattribute$[ebp]
  00026	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  0002b	0f 2f c8	 comiss	 xmm1, xmm0
  0002e	76 07		 jbe	 SHORT $LN2@CollideCyl

; 454  : 		return false;

  00030	32 c0		 xor	 al, al
  00032	e9 43 01 00 00	 jmp	 $LN1@CollideCyl
$LN2@CollideCyl:

; 455  : 
; 456  : 	if (s.v3Position.z - s.fRadius > c_rattribute.v3Position.z + c_rattribute.fHeight)

  00037	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  0003d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00042	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [ecx+24]
  00047	8b 45 08	 mov	 eax, DWORD PTR _c_rattribute$[ebp]
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _c_rattribute$[ebp]
  0004d	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00052	f3 0f 58 49 10	 addss	 xmm1, DWORD PTR [ecx+16]
  00057	0f 2f c1	 comiss	 xmm0, xmm1
  0005a	76 07		 jbe	 SHORT $LN3@CollideCyl

; 457  : 		return false;

  0005c	32 c0		 xor	 al, al
  0005e	e9 17 01 00 00	 jmp	 $LN1@CollideCyl
$LN3@CollideCyl:

; 466  : 	IntersectLineSegments(c_rattribute.v3Position, D3DXVECTOR3(c_rattribute.v3Position.x,c_rattribute.v3Position.y,c_rattribute.v3Position.z+c_rattribute.fHeight), s.v3LastPosition, s.v3Position, oa, ob);

  00063	8b 45 08	 mov	 eax, DWORD PTR _c_rattribute$[ebp]
  00066	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0006a	f3 0f 11 45 c4	 movss	 DWORD PTR _fx$[ebp], xmm0
  0006f	8b 45 08	 mov	 eax, DWORD PTR _c_rattribute$[ebp]
  00072	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00077	f3 0f 11 45 c0	 movss	 DWORD PTR _fy$[ebp], xmm0
  0007c	8b 45 08	 mov	 eax, DWORD PTR _c_rattribute$[ebp]
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _c_rattribute$[ebp]
  00082	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00087	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  0008c	f3 0f 11 45 bc	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  00091	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00096	f3 0f 11 45 e4	 movss	 DWORD PTR $T1[ebp], xmm0

; 181  :     y = fy;

  0009b	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  000a0	f3 0f 11 45 e8	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 182  :     z = fz;

  000a5	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  000aa	f3 0f 11 45 ec	 movss	 DWORD PTR $T1[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 466  : 	IntersectLineSegments(c_rattribute.v3Position, D3DXVECTOR3(c_rattribute.v3Position.x,c_rattribute.v3Position.y,c_rattribute.v3Position.z+c_rattribute.fHeight), s.v3LastPosition, s.v3Position, oa, ob);

  000af	8d 45 cc	 lea	 eax, DWORD PTR _ob$[ebp]
  000b2	50		 push	 eax
  000b3	8d 45 d8	 lea	 eax, DWORD PTR _oa$[ebp]
  000b6	50		 push	 eax
  000b7	ff 75 0c	 push	 DWORD PTR _s$[ebp]
  000ba	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  000bd	83 c0 0c	 add	 eax, 12			; 0000000cH
  000c0	50		 push	 eax
  000c1	8d 45 e4	 lea	 eax, DWORD PTR $T1[ebp]
  000c4	50		 push	 eax
  000c5	ff 75 08	 push	 DWORD PTR _c_rattribute$[ebp]
  000c8	e8 00 00 00 00	 call	 ?IntersectLineSegments@@YAXABUD3DXVECTOR3@@000AAU1@1@Z ; IntersectLineSegments
  000cd	83 c4 18	 add	 esp, 24			; 00000018H
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000d0	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _oa$[ebp]
  000d5	f3 0f 5c 45 cc	 subss	 xmm0, DWORD PTR _ob$[ebp]
  000da	f3 0f 11 45 b8	 movss	 DWORD PTR _fx$[ebp], xmm0
  000df	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _oa$[ebp+4]
  000e4	f3 0f 5c 45 d0	 subss	 xmm0, DWORD PTR _ob$[ebp+4]
  000e9	f3 0f 11 45 b4	 movss	 DWORD PTR _fy$[ebp], xmm0
  000ee	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _oa$[ebp+8]
  000f3	f3 0f 5c 45 d4	 subss	 xmm0, DWORD PTR _ob$[ebp+8]
  000f8	f3 0f 11 45 b0	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  000fd	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00102	f3 0f 11 45 f0	 movss	 DWORD PTR $T2[ebp], xmm0

; 181  :     y = fy;

  00107	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0010c	f3 0f 11 45 f4	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 182  :     z = fz;

  00111	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00116	f3 0f 11 45 f8	 movss	 DWORD PTR $T2[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 467  : 	return (D3DXVec3LengthSq(&(oa-ob))<=(c_rattribute.fRadius+s.fRadius)*(c_rattribute.fRadius+s.fRadius));

  0011b	8b 45 08	 mov	 eax, DWORD PTR _c_rattribute$[ebp]
  0011e	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00121	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00126	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  0012b	8b 45 08	 mov	 eax, DWORD PTR _c_rattribute$[ebp]
  0012e	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00131	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  00136	f3 0f 58 49 18	 addss	 xmm1, DWORD PTR [ecx+24]
  0013b	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0013f	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR $T2[ebp+8]
  00144	f3 0f 59 4d f8	 mulss	 xmm1, DWORD PTR $T2[ebp+8]
  00149	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR $T2[ebp+4]
  0014e	f3 0f 59 55 f4	 mulss	 xmm2, DWORD PTR $T2[ebp+4]
  00153	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR $T2[ebp]
  00158	f3 0f 59 5d f0	 mulss	 xmm3, DWORD PTR $T2[ebp]
  0015d	f3 0f 58 da	 addss	 xmm3, xmm2
  00161	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 467  : 	return (D3DXVec3LengthSq(&(oa-ob))<=(c_rattribute.fRadius+s.fRadius)*(c_rattribute.fRadius+s.fRadius));

  00165	0f 2f c3	 comiss	 xmm0, xmm3
  00168	72 09		 jb	 SHORT $LN5@CollideCyl
  0016a	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR tv178[ebp], 1
  00171	eb 04		 jmp	 SHORT $LN6@CollideCyl
$LN5@CollideCyl:
  00173	83 65 c8 00	 and	 DWORD PTR tv178[ebp], 0
$LN6@CollideCyl:
  00177	8a 45 c8	 mov	 al, BYTE PTR tv178[ebp]
$LN1@CollideCyl:

; 468  : }

  0017a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017d	33 cd		 xor	 ecx, ebp
  0017f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00184	c9		 leave
  00185	c2 08 00	 ret	 8
?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ENDP ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
tv928 = -248						; size = 8
tv958 = -240						; size = 8
tv933 = -232						; size = 8
_fy$ = -224						; size = 4
_fz$ = -220						; size = 4
_fx$ = -216						; size = 4
_fy$ = -212						; size = 4
_fz$ = -208						; size = 4
_fz$ = -204						; size = 4
_fx$ = -200						; size = 4
_fy$ = -196						; size = 4
_fz$ = -192						; size = 4
_fy$ = -188						; size = 4
_fx$ = -184						; size = 4
_fz$ = -180						; size = 4
_fy$ = -176						; size = 4
_fx$ = -172						; size = 4
_fz$ = -168						; size = 4
_fy$ = -164						; size = 4
_fx$ = -160						; size = 4
_fx$ = -156						; size = 4
_sq$ = -152						; size = 4
_mul$ = -148						; size = 4
_this$ = -144						; size = 4
_f$ = -140						; size = 4
_f$ = -136						; size = 4
_this$ = -132						; size = 4
_this$ = -128						; size = 4
_v$ = -124						; size = 4
_this$ = -120						; size = 4
_t2$ = -116						; size = 4
_t1$ = -112						; size = 4
_this$ = -108						; size = 4
_sum$ = -104						; size = 4
_v$1 = -100						; size = 12
$T2 = -88						; size = 12
$T3 = -76						; size = 12
$T4 = -64						; size = 12
$T5 = -52						; size = 12
_advance$ = -40						; size = 12
_c$ = -28						; size = 12
_v3Position$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CCylinderCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 515  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 	D3DXVECTOR3 v3Position = m_attribute.v3Position;

  00018	8b 75 94	 mov	 esi, DWORD PTR _this$[ebp]
  0001b	83 c6 04	 add	 esi, 4
  0001e	8d 7d f0	 lea	 edi, DWORD PTR _v3Position$[ebp]
  00021	a5		 movsd
  00022	a5		 movsd
  00023	a5		 movsd

; 517  : 	v3Position.z = s.v3Position.z;

  00024	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00027	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0002c	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Position$[ebp+8], xmm0

; 518  : 	if (D3DXVec3LengthSq(&(s.v3Position-v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  00031	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00034	89 45 88	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00037	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0003e	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _v3Position$[ebp]
  00043	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0004b	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00053	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR _v3Position$[ebp+4]
  00058	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00060	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00063	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00068	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _v3Position$[ebp+8]
  0006d	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00075	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0007d	f3 0f 11 45 b4	 movss	 DWORD PTR $T3[ebp], xmm0

; 181  :     y = fy;

  00082	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0008a	f3 0f 11 45 b8	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 182  :     z = fz;

  0008f	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00097	f3 0f 11 45 bc	 movss	 DWORD PTR $T3[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 518  : 	if (D3DXVec3LengthSq(&(s.v3Position-v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  0009c	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0009f	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  000a7	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  000ac	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  000af	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  000b2	f3 0f 10 48 10	 movss	 xmm1, DWORD PTR [eax+16]
  000b7	f3 0f 58 49 18	 addss	 xmm1, DWORD PTR [ecx+24]
  000bc	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000c0	f3 0f 10 4d bc	 movss	 xmm1, DWORD PTR $T3[ebp+8]
  000c5	f3 0f 59 4d bc	 mulss	 xmm1, DWORD PTR $T3[ebp+8]
  000ca	f3 0f 10 55 b8	 movss	 xmm2, DWORD PTR $T3[ebp+4]
  000cf	f3 0f 59 55 b8	 mulss	 xmm2, DWORD PTR $T3[ebp+4]
  000d4	f3 0f 10 5d b4	 movss	 xmm3, DWORD PTR $T3[ebp]
  000d9	f3 0f 59 5d b4	 mulss	 xmm3, DWORD PTR $T3[ebp]
  000de	f3 0f 58 da	 addss	 xmm3, xmm2
  000e2	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 518  : 	if (D3DXVec3LengthSq(&(s.v3Position-v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  000e6	0f 2f d8	 comiss	 xmm3, xmm0
  000e9	72 28		 jb	 SHORT $LN2@OnGetColli
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  000eb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ee	0f 57 c0	 xorps	 xmm0, xmm0
  000f1	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  000f5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000f8	0f 57 c0	 xorps	 xmm0, xmm0
  000fb	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  00100	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00103	0f 57 c0	 xorps	 xmm0, xmm0
  00106	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 519  : 		return D3DXVECTOR3(0.0f,0.0f,0.0f);

  0010b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0010e	e9 c3 04 00 00	 jmp	 $LN5@OnGetColli
$LN2@OnGetColli:

; 520  : 	D3DXVECTOR3 c;
; 521  : 	D3DXVECTOR3 advance = s.v3Position - s.v3LastPosition;

  00113	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00116	83 c0 0c	 add	 eax, 12			; 0000000cH
  00119	89 45 84	 mov	 DWORD PTR _v$[ebp], eax
  0011c	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0011f	89 85 70 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00125	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0012b	8b 4d 84	 mov	 ecx, DWORD PTR _v$[ebp]
  0012e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00132	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00136	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0013e	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00144	8b 4d 84	 mov	 ecx, DWORD PTR _v$[ebp]
  00147	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0014c	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00151	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00159	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0015f	8b 4d 84	 mov	 ecx, DWORD PTR _v$[ebp]
  00162	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00167	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0016c	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00174	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0017c	f3 0f 11 45 d8	 movss	 DWORD PTR _advance$[ebp], xmm0

; 181  :     y = fy;

  00181	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00189	f3 0f 11 45 dc	 movss	 DWORD PTR _advance$[ebp+4], xmm0

; 182  :     z = fz;

  0018e	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00196	f3 0f 11 45 e0	 movss	 DWORD PTR _advance$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 522  : 	advance.z = 0;

  0019b	0f 57 c0	 xorps	 xmm0, xmm0
  0019e	f3 0f 11 45 e0	 movss	 DWORD PTR _advance$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  001a3	0f 57 c0	 xorps	 xmm0, xmm0
  001a6	f3 0f 11 45 c0	 movss	 DWORD PTR $T4[ebp], xmm0

; 181  :     y = fy;

  001ab	0f 57 c0	 xorps	 xmm0, xmm0
  001ae	f3 0f 11 45 c4	 movss	 DWORD PTR $T4[ebp+4], xmm0

; 182  :     z = fz;

  001b3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001bb	f3 0f 11 45 c8	 movss	 DWORD PTR $T4[ebp+8], xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  001c0	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _advance$[ebp+4]
  001c5	f3 0f 59 45 c8	 mulss	 xmm0, DWORD PTR $T4[ebp+8]
  001ca	f3 0f 10 4d e0	 movss	 xmm1, DWORD PTR _advance$[ebp+8]
  001cf	f3 0f 59 4d c4	 mulss	 xmm1, DWORD PTR $T4[ebp+4]
  001d4	f3 0f 5c c1	 subss	 xmm0, xmm1
  001d8	f3 0f 11 45 9c	 movss	 DWORD PTR _v$1[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  001dd	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _advance$[ebp+8]
  001e2	f3 0f 59 45 c0	 mulss	 xmm0, DWORD PTR $T4[ebp]
  001e7	f3 0f 10 4d d8	 movss	 xmm1, DWORD PTR _advance$[ebp]
  001ec	f3 0f 59 4d c8	 mulss	 xmm1, DWORD PTR $T4[ebp+8]
  001f1	f3 0f 5c c1	 subss	 xmm0, xmm1
  001f5	f3 0f 11 45 a0	 movss	 DWORD PTR _v$1[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  001fa	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _advance$[ebp]
  001ff	f3 0f 59 45 c4	 mulss	 xmm0, DWORD PTR $T4[ebp+4]
  00204	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR _advance$[ebp+4]
  00209	f3 0f 59 4d c0	 mulss	 xmm1, DWORD PTR $T4[ebp]
  0020e	f3 0f 5c c1	 subss	 xmm0, xmm1
  00212	f3 0f 11 45 a4	 movss	 DWORD PTR _v$1[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  00217	8d 75 9c	 lea	 esi, DWORD PTR _v$1[ebp]
  0021a	8d 7d e4	 lea	 edi, DWORD PTR _c$[ebp]
  0021d	a5		 movsd
  0021e	a5		 movsd
  0021f	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 525  : 	float sum = - D3DXVec3Dot(&c,&(s.v3Position-v3Position));

  00220	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00223	89 45 80	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00226	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  00229	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0022d	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _v3Position$[ebp]
  00232	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0023a	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  0023d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00242	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR _v3Position$[ebp+4]
  00247	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0024f	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  00252	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00257	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _v3Position$[ebp+8]
  0025c	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00264	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0026c	f3 0f 11 45 a8	 movss	 DWORD PTR $T2[ebp], xmm0

; 181  :     y = fy;

  00271	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00279	f3 0f 11 45 ac	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 182  :     z = fz;

  0027e	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00286	f3 0f 11 45 b0	 movss	 DWORD PTR $T2[ebp+8], xmm0

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0028b	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _c$[ebp+8]
  00290	f3 0f 59 45 b0	 mulss	 xmm0, DWORD PTR $T2[ebp+8]
  00295	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _c$[ebp+4]
  0029a	f3 0f 59 4d ac	 mulss	 xmm1, DWORD PTR $T2[ebp+4]
  0029f	f3 0f 10 55 e4	 movss	 xmm2, DWORD PTR _c$[ebp]
  002a4	f3 0f 59 55 a8	 mulss	 xmm2, DWORD PTR $T2[ebp]
  002a9	f3 0f 58 d1	 addss	 xmm2, xmm1
  002ad	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 525  : 	float sum = - D3DXVec3Dot(&c,&(s.v3Position-v3Position));

  002b1	0f 57 15 00 00
	00 00		 xorps	 xmm2, DWORD PTR __xmm@80000000800000008000000080000000
  002b8	f3 0f 11 55 98	 movss	 DWORD PTR _sum$[ebp], xmm2

; 526  : 	float mul = (s.fRadius+m_attribute.fRadius)*(s.fRadius+m_attribute.fRadius)-D3DXVec3LengthSq(&(s.v3Position-v3Position));

  002bd	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  002c0	89 85 7c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  002c6	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002cc	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002d0	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _v3Position$[ebp]
  002d5	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  002dd	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002e3	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  002e8	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR _v3Position$[ebp+4]
  002ed	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  002f5	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002fb	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00300	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _v3Position$[ebp+8]
  00305	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0030d	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00315	f3 0f 11 45 cc	 movss	 DWORD PTR $T5[ebp], xmm0

; 181  :     y = fy;

  0031a	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00322	f3 0f 11 45 d0	 movss	 DWORD PTR $T5[ebp+4], xmm0

; 182  :     z = fz;

  00327	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0032f	f3 0f 11 45 d4	 movss	 DWORD PTR $T5[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 526  : 	float mul = (s.fRadius+m_attribute.fRadius)*(s.fRadius+m_attribute.fRadius)-D3DXVec3LengthSq(&(s.v3Position-v3Position));

  00334	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00337	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0033a	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0033f	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  00344	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00347	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0034a	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [eax+24]
  0034f	f3 0f 58 49 10	 addss	 xmm1, DWORD PTR [ecx+16]
  00354	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00358	f3 0f 10 4d d4	 movss	 xmm1, DWORD PTR $T5[ebp+8]
  0035d	f3 0f 59 4d d4	 mulss	 xmm1, DWORD PTR $T5[ebp+8]
  00362	f3 0f 10 55 d0	 movss	 xmm2, DWORD PTR $T5[ebp+4]
  00367	f3 0f 59 55 d0	 mulss	 xmm2, DWORD PTR $T5[ebp+4]
  0036c	f3 0f 10 5d cc	 movss	 xmm3, DWORD PTR $T5[ebp]
  00371	f3 0f 59 5d cc	 mulss	 xmm3, DWORD PTR $T5[ebp]
  00376	f3 0f 58 da	 addss	 xmm3, xmm2
  0037a	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 526  : 	float mul = (s.fRadius+m_attribute.fRadius)*(s.fRadius+m_attribute.fRadius)-D3DXVec3LengthSq(&(s.v3Position-v3Position));

  0037e	f3 0f 5c c3	 subss	 xmm0, xmm3
  00382	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _mul$[ebp], xmm0

; 527  : 
; 528  : 	if (sum*sum-4*mul<=0)

  0038a	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _sum$[ebp]
  0038f	f3 0f 59 45 98	 mulss	 xmm0, DWORD PTR _sum$[ebp]
  00394	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40800000
  0039c	f3 0f 59 8d 6c
	ff ff ff	 mulss	 xmm1, DWORD PTR _mul$[ebp]
  003a4	f3 0f 5c c1	 subss	 xmm0, xmm1
  003a8	0f 57 c9	 xorps	 xmm1, xmm1
  003ab	0f 2f c8	 comiss	 xmm1, xmm0
  003ae	72 28		 jb	 SHORT $LN3@OnGetColli
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  003b0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  003b3	0f 57 c0	 xorps	 xmm0, xmm0
  003b6	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  003ba	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  003bd	0f 57 c0	 xorps	 xmm0, xmm0
  003c0	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  003c5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  003c8	0f 57 c0	 xorps	 xmm0, xmm0
  003cb	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 529  : 		return D3DXVECTOR3(0.0f,0.0f,0.0f);

  003d0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  003d3	e9 fe 01 00 00	 jmp	 $LN5@OnGetColli
$LN3@OnGetColli:

; 530  : 	float sq = sqrt(sum*sum-4*mul);

  003d8	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _sum$[ebp]
  003dd	f3 0f 59 45 98	 mulss	 xmm0, DWORD PTR _sum$[ebp]
  003e2	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40800000
  003ea	f3 0f 59 8d 6c
	ff ff ff	 mulss	 xmm1, DWORD PTR _mul$[ebp]
  003f2	f3 0f 5c c1	 subss	 xmm0, xmm1
  003f6	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  003fa	51		 push	 ecx
  003fb	51		 push	 ecx
  003fc	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00401	e8 00 00 00 00	 call	 _sqrt
  00406	59		 pop	 ecx
  00407	59		 pop	 ecx
  00408	d9 9d 68 ff ff
	ff		 fstp	 DWORD PTR _sq$[ebp]

; 531  : 	float t1=-sum-sq, t2=-sum+sq;

  0040e	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _sum$[ebp]
  00413	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0041a	f3 0f 5c 85 68
	ff ff ff	 subss	 xmm0, DWORD PTR _sq$[ebp]
  00422	f3 0f 11 45 90	 movss	 DWORD PTR _t1$[ebp], xmm0
  00427	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _sum$[ebp]
  0042c	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00433	f3 0f 58 85 68
	ff ff ff	 addss	 xmm0, DWORD PTR _sq$[ebp]
  0043b	f3 0f 11 45 8c	 movss	 DWORD PTR _t2$[ebp], xmm0

; 532  : 	t1*=0.5f;

  00440	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _t1$[ebp]
  00445	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0044d	f3 0f 11 45 90	 movss	 DWORD PTR _t1$[ebp], xmm0

; 533  : 	t2*=0.5f;

  00452	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _t2$[ebp]
  00457	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0045f	f3 0f 11 45 8c	 movss	 DWORD PTR _t2$[ebp], xmm0

; 534  : 	
; 535  : 
; 536  : 	if (fabs(t1)<=fabs(t2))

  00464	f3 0f 5a 45 90	 cvtss2sd xmm0, DWORD PTR _t1$[ebp]
  00469	51		 push	 ecx
  0046a	51		 push	 ecx
  0046b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00470	e8 00 00 00 00	 call	 _fabs
  00475	59		 pop	 ecx
  00476	59		 pop	 ecx
  00477	dd 9d 08 ff ff
	ff		 fstp	 QWORD PTR tv928[ebp]
  0047d	f2 0f 10 85 08
	ff ff ff	 movsd	 xmm0, QWORD PTR tv928[ebp]
  00485	f3 0f 5a 4d 8c	 cvtss2sd xmm1, DWORD PTR _t2$[ebp]
  0048a	51		 push	 ecx
  0048b	51		 push	 ecx
  0048c	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00491	f2 0f 11 85 10
	ff ff ff	 movsd	 QWORD PTR tv958[ebp], xmm0
  00499	e8 00 00 00 00	 call	 _fabs
  0049e	59		 pop	 ecx
  0049f	59		 pop	 ecx
  004a0	dd 9d 18 ff ff
	ff		 fstp	 QWORD PTR tv933[ebp]
  004a6	f2 0f 10 85 18
	ff ff ff	 movsd	 xmm0, QWORD PTR tv933[ebp]
  004ae	f2 0f 10 8d 10
	ff ff ff	 movsd	 xmm1, QWORD PTR tv958[ebp]
  004b6	66 0f 2f c1	 comisd	 xmm0, xmm1
  004ba	0f 82 90 00 00
	00		 jb	 $LN4@OnGetColli

; 538  : 		return (gc_fReduceMove*t1)*c;

  004c0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  004c8	f3 0f 59 45 90	 mulss	 xmm0, DWORD PTR _t1$[ebp]
  004cd	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  004d5	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  004dd	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _c$[ebp]
  004e2	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  004ea	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  004f2	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _c$[ebp+4]
  004f7	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  004ff	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00507	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _c$[ebp+8]
  0050c	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00514	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00517	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0051f	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  00523	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00526	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0052e	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  00533	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00536	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0053e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 538  : 		return (gc_fReduceMove*t1)*c;

  00543	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00546	e9 8b 00 00 00	 jmp	 $LN5@OnGetColli

; 539  : 	}

  0054b	e9 86 00 00 00	 jmp	 $LN5@OnGetColli
$LN4@OnGetColli:

; 541  : 		return (gc_fReduceMove*t2)*c;

  00550	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00558	f3 0f 59 45 8c	 mulss	 xmm0, DWORD PTR _t2$[ebp]
  0055d	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00565	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  0056d	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _c$[ebp]
  00572	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0057a	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00582	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _c$[ebp+4]
  00587	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0058f	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00597	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _c$[ebp+8]
  0059c	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  005a4	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  005a7	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  005af	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  005b3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  005b6	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  005be	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  005c3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  005c6	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  005ce	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 541  : 		return (gc_fReduceMove*t2)*c;

  005d3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@OnGetColli:

; 542  : 
; 543  : 	/*D3DXVECTOR3 p1 = s.v3Position+t1*c;
; 544  : 	D3DXVECTOR3 p2 = s.v3Position+t2*c;
; 545  : 	
; 546  : 	if (D3DXVec3LengthSq(&(p2-s.v3Position))>D3DXVec3LengthSq(&(p1-s.v3Position)))
; 547  : 	{
; 548  : 		return p1-s.v3Position;
; 549  : 	}
; 550  : 	else
; 551  : 	{
; 552  : 		return p2-s.v3Position;
; 553  : 	}*/
; 554  : }

  005d6	5f		 pop	 edi
  005d7	5e		 pop	 esi
  005d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005db	33 cd		 xor	 ecx, ebp
  005dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005e2	c9		 leave
  005e3	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CCylinderCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CCylinderCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 508  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 509  : 	//Tracef("OnCollisionDynamicSphere\n");
; 510  : 	
; 511  : 	return (CollideCylinderVSDynamicSphere(m_attribute, s));

  00007	ff 75 08	 push	 DWORD PTR _s$[ebp]
  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	83 c0 04	 add	 eax, 4
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere

; 512  : }

  00019	c9		 leave
  0001a	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CCylinderCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_fz$ = -124						; size = 4
_fy$ = -120						; size = 4
_fx$ = -116						; size = 4
__X$ = -112						; size = 4
_fz$ = -108						; size = 4
_fy$ = -104						; size = 4
_fx$ = -100						; size = 4
$T1 = -96						; size = 4
_iStep$2 = -92						; size = 4
_fDistance$ = -88					; size = 4
_i$3 = -84						; size = 4
_fInv$4 = -80						; size = 4
_v$ = -76						; size = 4
_this$ = -72						; size = 4
_c_rv3Target$ = -68					; size = 4
_c_rv3Source$ = -64					; size = 4
_c_rv3Target$ = -60					; size = 4
_c_rv3Source$ = -56					; size = 4
_this$ = -52						; size = 4
_cylinder$5 = -48					; size = 20
_v3Step$6 = -28						; size = 12
_v3Distance$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CCylinderCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 471  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 472  : 	if (CollideCylinderVSDynamicSphere(m_attribute, s))

  00015	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00018	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c0 04	 add	 eax, 4
  0001e	50		 push	 eax
  0001f	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 c3 00 00
	00		 je	 $LN6@OnMovement

; 475  : 		if (GetVector3Distance(s.v3Position, m_attribute.v3Position) <

  00032	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 c0 04	 add	 eax, 4
  00038	89 45 c4	 mov	 DWORD PTR _c_rv3Target$[ebp], eax
  0003b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0003e	89 45 c8	 mov	 DWORD PTR _c_rv3Source$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00041	8b 45 c8	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  00044	8b 4d c4	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  00047	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0004b	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0004f	8b 45 c8	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  00052	8b 4d c4	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  00055	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00059	f3 0f 5c 09	 subss	 xmm1, DWORD PTR [ecx]
  0005d	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00061	8b 45 c8	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  00064	8b 4d c4	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  00067	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0006c	f3 0f 5c 49 04	 subss	 xmm1, DWORD PTR [ecx+4]
  00071	8b 45 c8	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  00074	8b 4d c4	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  00077	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [eax+4]
  0007c	f3 0f 5c 51 04	 subss	 xmm2, DWORD PTR [ecx+4]
  00081	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00085	f3 0f 58 c1	 addss	 xmm0, xmm1
  00089	f3 0f 11 45 a0	 movss	 DWORD PTR $T1[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 475  : 		if (GetVector3Distance(s.v3Position, m_attribute.v3Position) <

  0008e	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00091	83 c0 04	 add	 eax, 4
  00094	89 45 bc	 mov	 DWORD PTR _c_rv3Target$[ebp], eax
  00097	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0009a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0009d	89 45 c0	 mov	 DWORD PTR _c_rv3Source$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  000a0	8b 45 c0	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  000a3	8b 4d bc	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  000a6	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000ab	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  000b0	8b 45 c0	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  000b3	8b 4d bc	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  000b6	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  000bb	f3 0f 5c 49 04	 subss	 xmm1, DWORD PTR [ecx+4]
  000c0	f3 0f 59 c8	 mulss	 xmm1, xmm0
  000c4	8b 45 c0	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  000c7	8b 4d bc	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  000ca	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000ce	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  000d2	8b 45 c0	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  000d5	8b 4d bc	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  000d8	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  000dc	f3 0f 5c 11	 subss	 xmm2, DWORD PTR [ecx]
  000e0	f3 0f 59 d0	 mulss	 xmm2, xmm0
  000e4	f3 0f 58 d1	 addss	 xmm2, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 475  : 		if (GetVector3Distance(s.v3Position, m_attribute.v3Position) <

  000e8	0f 2f 55 a0	 comiss	 xmm2, DWORD PTR $T1[ebp]
  000ec	76 07		 jbe	 SHORT $LN6@OnMovement

; 476  : 			GetVector3Distance(s.v3LastPosition, m_attribute.v3Position))
; 477  : 			return true;

  000ee	b0 01		 mov	 al, 1
  000f0	e9 d8 01 00 00	 jmp	 $LN1@OnMovement
$LN6@OnMovement:

; 478  : 	}
; 479  : 
; 480  : 	
; 481  : 	// NOTE :      (  )      - [levites]
; 482  : 	D3DXVECTOR3 v3Distance = s.v3Position - s.v3LastPosition;

  000f5	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000f8	83 c0 0c	 add	 eax, 12			; 0000000cH
  000fb	89 45 b4	 mov	 DWORD PTR _v$[ebp], eax
  000fe	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00101	89 45 b8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00104	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00107	8b 4d b4	 mov	 ecx, DWORD PTR _v$[ebp]
  0010a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0010e	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00112	f3 0f 11 45 9c	 movss	 DWORD PTR _fx$[ebp], xmm0
  00117	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	8b 4d b4	 mov	 ecx, DWORD PTR _v$[ebp]
  0011d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00122	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00127	f3 0f 11 45 98	 movss	 DWORD PTR _fy$[ebp], xmm0
  0012c	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	8b 4d b4	 mov	 ecx, DWORD PTR _v$[ebp]
  00132	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00137	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0013c	f3 0f 11 45 94	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00141	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00146	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Distance$[ebp], xmm0

; 181  :     y = fy;

  0014b	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00150	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Distance$[ebp+4], xmm0

; 182  :     z = fz;

  00155	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0015a	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Distance$[ebp+8], xmm0

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  0015f	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3Distance$[ebp+8]
  00164	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _v3Distance$[ebp+8]
  00169	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _v3Distance$[ebp+4]
  0016e	f3 0f 59 4d f4	 mulss	 xmm1, DWORD PTR _v3Distance$[ebp+4]
  00173	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _v3Distance$[ebp]
  00178	f3 0f 59 55 f0	 mulss	 xmm2, DWORD PTR _v3Distance$[ebp]
  0017d	f3 0f 58 d1	 addss	 xmm2, xmm1
  00181	f3 0f 58 d0	 addss	 xmm2, xmm0
  00185	f3 0f 11 55 90	 movss	 DWORD PTR __X$[ebp], xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  0018a	f3 0f 5a 45 90	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0018f	51		 push	 ecx
  00190	51		 push	 ecx
  00191	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00196	e8 00 00 00 00	 call	 _sqrt
  0019b	59		 pop	 ecx
  0019c	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 483  : 	float fDistance = D3DXVec3Length(&v3Distance);

  0019d	d9 5d a8	 fstp	 DWORD PTR _fDistance$[ebp]

; 484  : 	if (s.fRadius<=0.0001f)

  001a0	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001a3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@38d1b717
  001ab	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  001af	72 07		 jb	 SHORT $LN7@OnMovement

; 485  : 		return false;

  001b1	32 c0		 xor	 al, al
  001b3	e9 15 01 00 00	 jmp	 $LN1@OnMovement
$LN7@OnMovement:

; 486  : 	if (fDistance >= s.fRadius*2.0f)

  001b8	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001bb	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  001c0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  001c8	f3 0f 10 4d a8	 movss	 xmm1, DWORD PTR _fDistance$[ebp]
  001cd	0f 2f c8	 comiss	 xmm1, xmm0
  001d0	0f 82 f5 00 00
	00		 jb	 $LN3@OnMovement

; 487  : 	{
; 488  : 		TCylinderData cylinder;
; 489  : 		cylinder = m_attribute;

  001d6	8b 75 cc	 mov	 esi, DWORD PTR _this$[ebp]
  001d9	83 c6 04	 add	 esi, 4
  001dc	6a 05		 push	 5
  001de	59		 pop	 ecx
  001df	8d 7d d0	 lea	 edi, DWORD PTR _cylinder$5[ebp]
  001e2	f3 a5		 rep movsd

; 490  : 		cylinder.v3Position = s.v3LastPosition;

  001e4	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  001e7	83 c6 0c	 add	 esi, 12			; 0000000cH
  001ea	8d 7d d0	 lea	 edi, DWORD PTR _cylinder$5[ebp]
  001ed	a5		 movsd
  001ee	a5		 movsd
  001ef	a5		 movsd

; 491  : 		
; 492  : 		int iStep = fDistance / s.fRadius*2.0f;

  001f0	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001f3	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _fDistance$[ebp]
  001f8	f3 0f 5e 40 18	 divss	 xmm0, DWORD PTR [eax+24]
  001fd	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00205	f3 0f 2c c0	 cvttss2si eax, xmm0
  00209	89 45 a4	 mov	 DWORD PTR _iStep$2[ebp], eax

; 493  : 		D3DXVECTOR3 v3Step = v3Distance / float(iStep);

  0020c	f3 0f 2a 45 a4	 cvtsi2ss xmm0, DWORD PTR _iStep$2[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 275  :     FLOAT fInv = 1.0f / f;

  00211	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00219	f3 0f 5e c8	 divss	 xmm1, xmm0
  0021d	f3 0f 11 4d b0	 movss	 DWORD PTR _fInv$4[ebp], xmm1

; 276  :     return D3DXVECTOR3(x * fInv, y * fInv, z * fInv);

  00222	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v3Distance$[ebp]
  00227	f3 0f 59 45 b0	 mulss	 xmm0, DWORD PTR _fInv$4[ebp]
  0022c	f3 0f 11 45 8c	 movss	 DWORD PTR _fx$[ebp], xmm0
  00231	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v3Distance$[ebp+4]
  00236	f3 0f 59 45 b0	 mulss	 xmm0, DWORD PTR _fInv$4[ebp]
  0023b	f3 0f 11 45 88	 movss	 DWORD PTR _fy$[ebp], xmm0
  00240	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3Distance$[ebp+8]
  00245	f3 0f 59 45 b0	 mulss	 xmm0, DWORD PTR _fInv$4[ebp]
  0024a	f3 0f 11 45 84	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0024f	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00254	f3 0f 11 45 e4	 movss	 DWORD PTR _v3Step$6[ebp], xmm0

; 181  :     y = fy;

  00259	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0025e	f3 0f 11 45 e8	 movss	 DWORD PTR _v3Step$6[ebp+4], xmm0

; 182  :     z = fz;

  00263	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00268	f3 0f 11 45 ec	 movss	 DWORD PTR _v3Step$6[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 495  : 		for (int i = 0; i < iStep; ++i)

  0026d	83 65 ac 00	 and	 DWORD PTR _i$3[ebp], 0
  00271	eb 07		 jmp	 SHORT $LN4@OnMovement
$LN2@OnMovement:
  00273	8b 45 ac	 mov	 eax, DWORD PTR _i$3[ebp]
  00276	40		 inc	 eax
  00277	89 45 ac	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@OnMovement:
  0027a	8b 45 ac	 mov	 eax, DWORD PTR _i$3[ebp]
  0027d	3b 45 a4	 cmp	 eax, DWORD PTR _iStep$2[ebp]
  00280	7d 49		 jge	 SHORT $LN3@OnMovement
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 204  :     x += v.x;

  00282	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _cylinder$5[ebp]
  00287	f3 0f 58 45 e4	 addss	 xmm0, DWORD PTR _v3Step$6[ebp]
  0028c	f3 0f 11 45 d0	 movss	 DWORD PTR _cylinder$5[ebp], xmm0

; 205  :     y += v.y;

  00291	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _cylinder$5[ebp+4]
  00296	f3 0f 58 45 e8	 addss	 xmm0, DWORD PTR _v3Step$6[ebp+4]
  0029b	f3 0f 11 45 d4	 movss	 DWORD PTR _cylinder$5[ebp+4], xmm0

; 206  :     z += v.z;

  002a0	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _cylinder$5[ebp+8]
  002a5	f3 0f 58 45 ec	 addss	 xmm0, DWORD PTR _v3Step$6[ebp+8]
  002aa	f3 0f 11 45 d8	 movss	 DWORD PTR _cylinder$5[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 498  : 			if (CollideCylinderVSDynamicSphere(cylinder, s))

  002af	ff 75 08	 push	 DWORD PTR _s$[ebp]
  002b2	8d 45 d0	 lea	 eax, DWORD PTR _cylinder$5[ebp]
  002b5	50		 push	 eax
  002b6	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b9	e8 00 00 00 00	 call	 ?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere
  002be	0f b6 c0	 movzx	 eax, al
  002c1	85 c0		 test	 eax, eax
  002c3	74 04		 je	 SHORT $LN9@OnMovement

; 499  : 				return true;

  002c5	b0 01		 mov	 al, 1
  002c7	eb 04		 jmp	 SHORT $LN1@OnMovement
$LN9@OnMovement:

; 500  : 				
; 501  : 		}

  002c9	eb a8		 jmp	 SHORT $LN2@OnMovement
$LN3@OnMovement:

; 502  : 	}
; 503  : 	
; 504  : 	return false;

  002cb	32 c0		 xor	 al, al
$LN1@OnMovement:

; 505  : }

  002cd	5f		 pop	 edi
  002ce	5e		 pop	 esi
  002cf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d2	33 cd		 xor	 ecx, ebp
  002d4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d9	c9		 leave
  002da	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CCylinderCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnDestroy@CCylinderCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -8						; size = 4
_this$ = -4						; size = 4
?OnDestroy@CCylinderCollisionInstance@@MAEXXZ PROC	; CCylinderCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 564  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 565  : 	gs_cci.Free(this);

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	89 45 f8	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0000e	8d 45 f8	 lea	 eax, DWORD PTR _pkData$[ebp]
  00011	50		 push	 eax
  00012	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+16
  00017	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@QAEXABQAVCCylinderCollisionInstance@@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::emplace_back<CCylinderCollisionInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 566  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?OnDestroy@CCylinderCollisionInstance@@MAEXXZ ENDP	; CCylinderCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_d3dFillMode$ = 8					; size = 4
?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; CCylinderCollisionInstance::Render, COMDAT
; _this$ = ecx

; 557  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 558  : 	static CScreen s;

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  0002b	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  00032	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  0003b	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  00041	7e 3c		 jle	 SHORT $LN2@Render
  00043	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00048	e8 00 00 00 00	 call	 __Init_thread_header
  0004d	59		 pop	 ecx
  0004e	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA, -1
  00055	75 28		 jne	 SHORT $LN2@Render
  00057	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00060	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00065	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `CCylinderCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  0006a	e8 00 00 00 00	 call	 _atexit
  0006f	59		 pop	 ecx
  00070	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00074	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00079	e8 00 00 00 00	 call	 __Init_thread_footer
  0007e	59		 pop	 ecx
$LN2@Render:

; 559  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  0007f	6a ff		 push	 -1
  00081	6a 3c		 push	 60			; 0000003cH
  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00089	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 560  : 	s.RenderCylinder(NULL, m_attribute.v3Position.x, m_attribute.v3Position.y, m_attribute.v3Position.z+m_attribute.fHeight/2, m_attribute.fRadius, m_attribute.fHeight, d3dFillMode);

  0008e	ff 75 08	 push	 DWORD PTR _d3dFillMode$[ebp]
  00091	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00094	51		 push	 ecx
  00095	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0009a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	51		 push	 ecx
  000a3	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  000a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ad	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  000b5	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000bd	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	f3 0f 58 40 0c	 addss	 xmm0, DWORD PTR [eax+12]
  000c5	51		 push	 ecx
  000c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	51		 push	 ecx
  000cf	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000d4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	51		 push	 ecx
  000dd	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000e2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e7	6a 00		 push	 0
  000e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  000ee	e8 00 00 00 00	 call	 ?RenderCylinder@CScreen@@QAEXPBUD3DXMATRIX@@MMMMMW4_D3DFILLMODE@@@Z ; CScreen::RenderCylinder

; 561  : }

  000f3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fd	59		 pop	 ecx
  000fe	c9		 leave
  000ff	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; CCylinderCollisionInstance::Render
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CCylinderCollisionInstance@@QBEABUSCylinderData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAttribute@CCylinderCollisionInstance@@QBEABUSCylinderData@@XZ PROC ; CCylinderCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 447  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 448  : 	return m_attribute;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 449  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetAttribute@CCylinderCollisionInstance@@QBEABUSCylinderData@@XZ ENDP ; CCylinderCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ PROC ; CCylinderCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 442  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 443  : 	return m_attribute;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 444  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ ENDP ; CCylinderCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; COBBCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 812  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  00011	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00014	0f 57 c0	 xorps	 xmm0, xmm0
  00017	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	0f 57 c0	 xorps	 xmm0, xmm0
  00022	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 814  : 	return D3DXVECTOR3(.0f, .0f, .0f);

  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 815  : 	
; 816  : }

  0002a	c9		 leave
  0002b	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; COBBCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_fz$ = -64						; size = 4
_fy$ = -60						; size = 4
_fx$ = -56						; size = 4
_fz$ = -52						; size = 4
_fy$ = -48						; size = 4
_fx$ = -44						; size = 4
_fz$ = -40						; size = 4
_fy$ = -36						; size = 4
_fx$ = -32						; size = 4
_fz$ = -28						; size = 4
_fy$ = -24						; size = 4
_fx$ = -20						; size = 4
_fz$ = -16						; size = 4
_fy$ = -12						; size = 4
_fx$ = -8						; size = 4
_fz$ = -4						; size = 4
_fy$ = 0						; size = 4
_fx$ = 4						; size = 4
_this$ = 8						; size = 4
_this$ = 12						; size = 4
_v$ = 16						; size = 4
_this$ = 20						; size = 4
_this$ = 24						; size = 4
$T1 = 28						; size = 12
$T2 = 40						; size = 12
$T3 = 52						; size = 12
$T4 = 64						; size = 12
_v3Center$ = 76						; size = 12
_v3Sphere$ = 88						; size = 12
_v3Point$ = 100						; size = 12
__$ArrayPad$ = 112					; size = 4
_s$ = 124						; size = 4
?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; COBBCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 776  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 70	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	89 4d 18	 mov	 DWORD PTR _this$[ebp], ecx

; 777  : 	
; 778  : 	D3DXVECTOR3 v3Center = 0.5f * (m_attribute.v3Min + m_attribute.v3Max);

  0001a	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c0 10	 add	 eax, 16			; 00000010H
  00020	89 45 10	 mov	 DWORD PTR _v$[ebp], eax
  00023	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c0 04	 add	 eax, 4
  00029	89 45 14	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0002c	8b 45 14	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00032	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00036	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  0003a	f3 0f 11 45 04	 movss	 DWORD PTR _fx$[ebp], xmm0
  0003f	8b 45 14	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00045	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0004a	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  0004f	f3 0f 11 45 00	 movss	 DWORD PTR _fy$[ebp], xmm0
  00054	8b 45 14	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  0005a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0005f	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  00064	f3 0f 11 45 fc	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00069	f3 0f 10 45 04	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0006e	f3 0f 11 45 40	 movss	 DWORD PTR $T4[ebp], xmm0

; 181  :     y = fy;

  00073	f3 0f 10 45 00	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00078	f3 0f 11 45 44	 movss	 DWORD PTR $T4[ebp+4], xmm0

; 182  :     z = fz;

  0007d	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00082	f3 0f 11 45 48	 movss	 DWORD PTR $T4[ebp+8], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00087	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0008f	f3 0f 59 45 40	 mulss	 xmm0, DWORD PTR $T4[ebp]
  00094	f3 0f 11 45 f8	 movss	 DWORD PTR _fx$[ebp], xmm0
  00099	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000a1	f3 0f 59 45 44	 mulss	 xmm0, DWORD PTR $T4[ebp+4]
  000a6	f3 0f 11 45 f4	 movss	 DWORD PTR _fy$[ebp], xmm0
  000ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000b3	f3 0f 59 45 48	 mulss	 xmm0, DWORD PTR $T4[ebp+8]
  000b8	f3 0f 11 45 f0	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  000bd	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000c2	f3 0f 11 45 4c	 movss	 DWORD PTR _v3Center$[ebp], xmm0

; 181  :     y = fy;

  000c7	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  000cc	f3 0f 11 45 50	 movss	 DWORD PTR _v3Center$[ebp+4], xmm0

; 182  :     z = fz;

  000d1	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  000d6	f3 0f 11 45 54	 movss	 DWORD PTR _v3Center$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 779  : 	D3DXVECTOR3 v3Sphere = s.v3Position - v3Center;

  000db	8b 45 7c	 mov	 eax, DWORD PTR _s$[ebp]
  000de	89 45 0c	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000e1	8b 45 0c	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000e8	f3 0f 5c 45 4c	 subss	 xmm0, DWORD PTR _v3Center$[ebp]
  000ed	f3 0f 11 45 ec	 movss	 DWORD PTR _fx$[ebp], xmm0
  000f2	8b 45 0c	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000fa	f3 0f 5c 45 50	 subss	 xmm0, DWORD PTR _v3Center$[ebp+4]
  000ff	f3 0f 11 45 e8	 movss	 DWORD PTR _fy$[ebp], xmm0
  00104	8b 45 0c	 mov	 eax, DWORD PTR _this$[ebp]
  00107	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0010c	f3 0f 5c 45 54	 subss	 xmm0, DWORD PTR _v3Center$[ebp+8]
  00111	f3 0f 11 45 e4	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00116	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0011b	f3 0f 11 45 58	 movss	 DWORD PTR _v3Sphere$[ebp], xmm0

; 181  :     y = fy;

  00120	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00125	f3 0f 11 45 5c	 movss	 DWORD PTR _v3Sphere$[ebp+4], xmm0

; 182  :     z = fz;

  0012a	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0012f	f3 0f 11 45 60	 movss	 DWORD PTR _v3Sphere$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00134	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00137	83 c0 1c	 add	 eax, 28			; 0000001cH
  0013a	50		 push	 eax
  0013b	8d 45 58	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  0013e	50		 push	 eax
  0013f	8d 45 58	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00148	f3 0f 10 45 58	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp]
  0014d	f3 0f 58 45 4c	 addss	 xmm0, DWORD PTR _v3Center$[ebp]
  00152	f3 0f 11 45 e0	 movss	 DWORD PTR _fx$[ebp], xmm0
  00157	f3 0f 10 45 5c	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+4]
  0015c	f3 0f 58 45 50	 addss	 xmm0, DWORD PTR _v3Center$[ebp+4]
  00161	f3 0f 11 45 dc	 movss	 DWORD PTR _fy$[ebp], xmm0
  00166	f3 0f 10 45 60	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+8]
  0016b	f3 0f 58 45 54	 addss	 xmm0, DWORD PTR _v3Center$[ebp+8]
  00170	f3 0f 11 45 d8	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00175	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0017a	f3 0f 11 45 34	 movss	 DWORD PTR $T3[ebp], xmm0

; 181  :     y = fy;

  0017f	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00184	f3 0f 11 45 38	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 182  :     z = fz;

  00189	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0018e	f3 0f 11 45 3c	 movss	 DWORD PTR $T3[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 781  : 	v3Sphere = v3Sphere + v3Center;

  00193	8d 75 34	 lea	 esi, DWORD PTR $T3[ebp]
  00196	8d 7d 58	 lea	 edi, DWORD PTR _v3Sphere$[ebp]
  00199	a5		 movsd
  0019a	a5		 movsd
  0019b	a5		 movsd

; 782  : 
; 783  : 	D3DXVECTOR3 v3Point = v3Sphere;

  0019c	8d 75 58	 lea	 esi, DWORD PTR _v3Sphere$[ebp]
  0019f	8d 7d 64	 lea	 edi, DWORD PTR _v3Point$[ebp]
  001a2	a5		 movsd
  001a3	a5		 movsd
  001a4	a5		 movsd

; 784  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  001a5	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001a8	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001ad	0f 2f 45 64	 comiss	 xmm0, DWORD PTR _v3Point$[ebp]
  001b1	76 0d		 jbe	 SHORT $LN2@OnCollisio
  001b3	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001b6	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001bb	f3 0f 11 45 64	 movss	 DWORD PTR _v3Point$[ebp], xmm0
$LN2@OnCollisio:

; 785  : 	if(v3Point.x > m_attribute.v3Max.x) { v3Point.x = m_attribute.v3Max.x; }

  001c0	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001c3	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _v3Point$[ebp]
  001c8	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  001cc	76 0d		 jbe	 SHORT $LN3@OnCollisio
  001ce	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001d1	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  001d6	f3 0f 11 45 64	 movss	 DWORD PTR _v3Point$[ebp], xmm0
$LN3@OnCollisio:

; 786  : 	if(v3Point.y < m_attribute.v3Min.y) { v3Point.y = m_attribute.v3Min.y; }

  001db	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001de	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001e3	0f 2f 45 68	 comiss	 xmm0, DWORD PTR _v3Point$[ebp+4]
  001e7	76 0d		 jbe	 SHORT $LN4@OnCollisio
  001e9	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001ec	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001f1	f3 0f 11 45 68	 movss	 DWORD PTR _v3Point$[ebp+4], xmm0
$LN4@OnCollisio:

; 787  : 	if(v3Point.y > m_attribute.v3Max.y) { v3Point.y = m_attribute.v3Max.y; }

  001f6	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001f9	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _v3Point$[ebp+4]
  001fe	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  00202	76 0d		 jbe	 SHORT $LN5@OnCollisio
  00204	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00207	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0020c	f3 0f 11 45 68	 movss	 DWORD PTR _v3Point$[ebp+4], xmm0
$LN5@OnCollisio:

; 788  : 	if(v3Point.z < m_attribute.v3Min.z) { v3Point.z = m_attribute.v3Min.z; }

  00211	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00214	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00219	0f 2f 45 6c	 comiss	 xmm0, DWORD PTR _v3Point$[ebp+8]
  0021d	76 0d		 jbe	 SHORT $LN6@OnCollisio
  0021f	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00222	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00227	f3 0f 11 45 6c	 movss	 DWORD PTR _v3Point$[ebp+8], xmm0
$LN6@OnCollisio:

; 789  : 	if(v3Point.z > m_attribute.v3Max.z) { v3Point.z = m_attribute.v3Max.z; }

  0022c	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  0022f	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _v3Point$[ebp+8]
  00234	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  00238	76 0d		 jbe	 SHORT $LN7@OnCollisio
  0023a	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  0023d	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00242	f3 0f 11 45 6c	 movss	 DWORD PTR _v3Point$[ebp+8], xmm0
$LN7@OnCollisio:

; 791  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  00247	8b 45 7c	 mov	 eax, DWORD PTR _s$[ebp]
  0024a	8b 4d 7c	 mov	 ecx, DWORD PTR _s$[ebp]
  0024d	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00252	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00257	f3 0f 10 4d 68	 movss	 xmm1, DWORD PTR _v3Point$[ebp+4]
  0025c	f3 0f 5c 4d 5c	 subss	 xmm1, DWORD PTR _v3Sphere$[ebp+4]
  00261	f3 0f 10 55 68	 movss	 xmm2, DWORD PTR _v3Point$[ebp+4]
  00266	f3 0f 5c 55 5c	 subss	 xmm2, DWORD PTR _v3Sphere$[ebp+4]
  0026b	f3 0f 59 d1	 mulss	 xmm2, xmm1
  0026f	f3 0f 10 4d 64	 movss	 xmm1, DWORD PTR _v3Point$[ebp]
  00274	f3 0f 5c 4d 58	 subss	 xmm1, DWORD PTR _v3Sphere$[ebp]
  00279	f3 0f 10 5d 64	 movss	 xmm3, DWORD PTR _v3Point$[ebp]
  0027e	f3 0f 5c 5d 58	 subss	 xmm3, DWORD PTR _v3Sphere$[ebp]
  00283	f3 0f 59 d9	 mulss	 xmm3, xmm1
  00287	f3 0f 58 da	 addss	 xmm3, xmm2
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 791  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0028b	0f 2f c3	 comiss	 xmm0, xmm3
  0028e	72 07		 jb	 SHORT $LN8@OnCollisio
  00290	b0 01		 mov	 al, 1
  00292	e9 c7 01 00 00	 jmp	 $LN1@OnCollisio
$LN8@OnCollisio:

; 793  : 	v3Sphere = s.v3LastPosition - v3Center;

  00297	8b 45 7c	 mov	 eax, DWORD PTR _s$[ebp]
  0029a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0029d	89 45 08	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  002a0	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002a3	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002a7	f3 0f 5c 45 4c	 subss	 xmm0, DWORD PTR _v3Center$[ebp]
  002ac	f3 0f 11 45 d4	 movss	 DWORD PTR _fx$[ebp], xmm0
  002b1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002b4	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  002b9	f3 0f 5c 45 50	 subss	 xmm0, DWORD PTR _v3Center$[ebp+4]
  002be	f3 0f 11 45 d0	 movss	 DWORD PTR _fy$[ebp], xmm0
  002c3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002c6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002cb	f3 0f 5c 45 54	 subss	 xmm0, DWORD PTR _v3Center$[ebp+8]
  002d0	f3 0f 11 45 cc	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  002d5	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002da	f3 0f 11 45 28	 movss	 DWORD PTR $T2[ebp], xmm0

; 181  :     y = fy;

  002df	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002e4	f3 0f 11 45 2c	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 182  :     z = fz;

  002e9	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002ee	f3 0f 11 45 30	 movss	 DWORD PTR $T2[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 793  : 	v3Sphere = s.v3LastPosition - v3Center;

  002f3	8d 75 28	 lea	 esi, DWORD PTR $T2[ebp]
  002f6	8d 7d 58	 lea	 edi, DWORD PTR _v3Sphere$[ebp]
  002f9	a5		 movsd
  002fa	a5		 movsd
  002fb	a5		 movsd

; 794  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  002fc	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  002ff	83 c0 1c	 add	 eax, 28			; 0000001cH
  00302	50		 push	 eax
  00303	8d 45 58	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  00306	50		 push	 eax
  00307	8d 45 58	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  0030a	50		 push	 eax
  0030b	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00310	f3 0f 10 45 58	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp]
  00315	f3 0f 58 45 4c	 addss	 xmm0, DWORD PTR _v3Center$[ebp]
  0031a	f3 0f 11 45 c8	 movss	 DWORD PTR _fx$[ebp], xmm0
  0031f	f3 0f 10 45 5c	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+4]
  00324	f3 0f 58 45 50	 addss	 xmm0, DWORD PTR _v3Center$[ebp+4]
  00329	f3 0f 11 45 c4	 movss	 DWORD PTR _fy$[ebp], xmm0
  0032e	f3 0f 10 45 60	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+8]
  00333	f3 0f 58 45 54	 addss	 xmm0, DWORD PTR _v3Center$[ebp+8]
  00338	f3 0f 11 45 c0	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0033d	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00342	f3 0f 11 45 1c	 movss	 DWORD PTR $T1[ebp], xmm0

; 181  :     y = fy;

  00347	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0034c	f3 0f 11 45 20	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 182  :     z = fz;

  00351	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00356	f3 0f 11 45 24	 movss	 DWORD PTR $T1[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 795  : 	v3Sphere = v3Sphere + v3Center;

  0035b	8d 75 1c	 lea	 esi, DWORD PTR $T1[ebp]
  0035e	8d 7d 58	 lea	 edi, DWORD PTR _v3Sphere$[ebp]
  00361	a5		 movsd
  00362	a5		 movsd
  00363	a5		 movsd

; 796  : 	
; 797  : 	v3Point = v3Sphere;

  00364	8d 75 58	 lea	 esi, DWORD PTR _v3Sphere$[ebp]
  00367	8d 7d 64	 lea	 edi, DWORD PTR _v3Point$[ebp]
  0036a	a5		 movsd
  0036b	a5		 movsd
  0036c	a5		 movsd

; 798  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  0036d	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00370	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00375	0f 2f 45 64	 comiss	 xmm0, DWORD PTR _v3Point$[ebp]
  00379	76 0d		 jbe	 SHORT $LN9@OnCollisio
  0037b	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  0037e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00383	f3 0f 11 45 64	 movss	 DWORD PTR _v3Point$[ebp], xmm0
$LN9@OnCollisio:

; 799  : 	if(v3Point.x > m_attribute.v3Max.x) { v3Point.x = m_attribute.v3Max.x; }

  00388	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  0038b	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _v3Point$[ebp]
  00390	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  00394	76 0d		 jbe	 SHORT $LN10@OnCollisio
  00396	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00399	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0039e	f3 0f 11 45 64	 movss	 DWORD PTR _v3Point$[ebp], xmm0
$LN10@OnCollisio:

; 800  : 	if(v3Point.y < m_attribute.v3Min.y) { v3Point.y = m_attribute.v3Min.y; }

  003a3	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003a6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  003ab	0f 2f 45 68	 comiss	 xmm0, DWORD PTR _v3Point$[ebp+4]
  003af	76 0d		 jbe	 SHORT $LN11@OnCollisio
  003b1	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003b4	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  003b9	f3 0f 11 45 68	 movss	 DWORD PTR _v3Point$[ebp+4], xmm0
$LN11@OnCollisio:

; 801  : 	if(v3Point.y > m_attribute.v3Max.y) { v3Point.y = m_attribute.v3Max.y; }

  003be	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003c1	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _v3Point$[ebp+4]
  003c6	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  003ca	76 0d		 jbe	 SHORT $LN12@OnCollisio
  003cc	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003cf	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  003d4	f3 0f 11 45 68	 movss	 DWORD PTR _v3Point$[ebp+4], xmm0
$LN12@OnCollisio:

; 802  : 	if(v3Point.z < m_attribute.v3Min.z) { v3Point.z = m_attribute.v3Min.z; }

  003d9	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003dc	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  003e1	0f 2f 45 6c	 comiss	 xmm0, DWORD PTR _v3Point$[ebp+8]
  003e5	76 0d		 jbe	 SHORT $LN13@OnCollisio
  003e7	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003ea	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  003ef	f3 0f 11 45 6c	 movss	 DWORD PTR _v3Point$[ebp+8], xmm0
$LN13@OnCollisio:

; 803  : 	if(v3Point.z > m_attribute.v3Max.z) { v3Point.z = m_attribute.v3Max.z; }

  003f4	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003f7	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _v3Point$[ebp+8]
  003fc	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  00400	76 0d		 jbe	 SHORT $LN14@OnCollisio
  00402	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00405	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0040a	f3 0f 11 45 6c	 movss	 DWORD PTR _v3Point$[ebp+8], xmm0
$LN14@OnCollisio:

; 805  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0040f	8b 45 7c	 mov	 eax, DWORD PTR _s$[ebp]
  00412	8b 4d 7c	 mov	 ecx, DWORD PTR _s$[ebp]
  00415	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0041a	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0041f	f3 0f 10 4d 68	 movss	 xmm1, DWORD PTR _v3Point$[ebp+4]
  00424	f3 0f 5c 4d 5c	 subss	 xmm1, DWORD PTR _v3Sphere$[ebp+4]
  00429	f3 0f 10 55 68	 movss	 xmm2, DWORD PTR _v3Point$[ebp+4]
  0042e	f3 0f 5c 55 5c	 subss	 xmm2, DWORD PTR _v3Sphere$[ebp+4]
  00433	f3 0f 59 d1	 mulss	 xmm2, xmm1
  00437	f3 0f 10 4d 64	 movss	 xmm1, DWORD PTR _v3Point$[ebp]
  0043c	f3 0f 5c 4d 58	 subss	 xmm1, DWORD PTR _v3Sphere$[ebp]
  00441	f3 0f 10 5d 64	 movss	 xmm3, DWORD PTR _v3Point$[ebp]
  00446	f3 0f 5c 5d 58	 subss	 xmm3, DWORD PTR _v3Sphere$[ebp]
  0044b	f3 0f 59 d9	 mulss	 xmm3, xmm1
  0044f	f3 0f 58 da	 addss	 xmm3, xmm2
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 805  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  00453	0f 2f c3	 comiss	 xmm0, xmm3
  00456	72 04		 jb	 SHORT $LN15@OnCollisio
  00458	b0 01		 mov	 al, 1
  0045a	eb 02		 jmp	 SHORT $LN1@OnCollisio
$LN15@OnCollisio:

; 806  : 
; 807  : 
; 808  : 	return false;

  0045c	32 c0		 xor	 al, al
$LN1@OnCollisio:

; 809  : }

  0045e	5f		 pop	 edi
  0045f	5e		 pop	 esi
  00460	8b 4d 70	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00463	33 cd		 xor	 ecx, ebp
  00465	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0046a	83 c5 74	 add	 ebp, 116		; 00000074H
  0046d	c9		 leave
  0046e	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; COBBCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_fz$ = -64						; size = 4
_fy$ = -60						; size = 4
_fx$ = -56						; size = 4
_fz$ = -52						; size = 4
_fy$ = -48						; size = 4
_fx$ = -44						; size = 4
_fz$ = -40						; size = 4
_fy$ = -36						; size = 4
_fx$ = -32						; size = 4
_fz$ = -28						; size = 4
_fy$ = -24						; size = 4
_fx$ = -20						; size = 4
_fz$ = -16						; size = 4
_fy$ = -12						; size = 4
_fx$ = -8						; size = 4
_fz$ = -4						; size = 4
_fy$ = 0						; size = 4
_fx$ = 4						; size = 4
_this$ = 8						; size = 4
_this$ = 12						; size = 4
_v$ = 16						; size = 4
_this$ = 20						; size = 4
_this$ = 24						; size = 4
$T1 = 28						; size = 12
$T2 = 40						; size = 12
$T3 = 52						; size = 12
$T4 = 64						; size = 12
_v3Center$ = 76						; size = 12
_v3Sphere$ = 88						; size = 12
_v3Point$ = 100						; size = 12
__$ArrayPad$ = 112					; size = 4
_s$ = 124						; size = 4
?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; COBBCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 742  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 70	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	89 4d 18	 mov	 DWORD PTR _this$[ebp], ecx

; 743  : 	D3DXVECTOR3 v3Center = 0.5f * (m_attribute.v3Min + m_attribute.v3Max);

  0001a	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c0 10	 add	 eax, 16			; 00000010H
  00020	89 45 10	 mov	 DWORD PTR _v$[ebp], eax
  00023	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c0 04	 add	 eax, 4
  00029	89 45 14	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0002c	8b 45 14	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00032	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00036	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  0003a	f3 0f 11 45 04	 movss	 DWORD PTR _fx$[ebp], xmm0
  0003f	8b 45 14	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  00045	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0004a	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  0004f	f3 0f 11 45 00	 movss	 DWORD PTR _fy$[ebp], xmm0
  00054	8b 45 14	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 4d 10	 mov	 ecx, DWORD PTR _v$[ebp]
  0005a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0005f	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  00064	f3 0f 11 45 fc	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00069	f3 0f 10 45 04	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0006e	f3 0f 11 45 40	 movss	 DWORD PTR $T4[ebp], xmm0

; 181  :     y = fy;

  00073	f3 0f 10 45 00	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00078	f3 0f 11 45 44	 movss	 DWORD PTR $T4[ebp+4], xmm0

; 182  :     z = fz;

  0007d	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00082	f3 0f 11 45 48	 movss	 DWORD PTR $T4[ebp+8], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00087	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0008f	f3 0f 59 45 40	 mulss	 xmm0, DWORD PTR $T4[ebp]
  00094	f3 0f 11 45 f8	 movss	 DWORD PTR _fx$[ebp], xmm0
  00099	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000a1	f3 0f 59 45 44	 mulss	 xmm0, DWORD PTR $T4[ebp+4]
  000a6	f3 0f 11 45 f4	 movss	 DWORD PTR _fy$[ebp], xmm0
  000ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000b3	f3 0f 59 45 48	 mulss	 xmm0, DWORD PTR $T4[ebp+8]
  000b8	f3 0f 11 45 f0	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  000bd	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000c2	f3 0f 11 45 4c	 movss	 DWORD PTR _v3Center$[ebp], xmm0

; 181  :     y = fy;

  000c7	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  000cc	f3 0f 11 45 50	 movss	 DWORD PTR _v3Center$[ebp+4], xmm0

; 182  :     z = fz;

  000d1	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  000d6	f3 0f 11 45 54	 movss	 DWORD PTR _v3Center$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 744  : 	D3DXVECTOR3 v3Sphere = s.v3Position - v3Center;

  000db	8b 45 7c	 mov	 eax, DWORD PTR _s$[ebp]
  000de	89 45 0c	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000e1	8b 45 0c	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000e8	f3 0f 5c 45 4c	 subss	 xmm0, DWORD PTR _v3Center$[ebp]
  000ed	f3 0f 11 45 ec	 movss	 DWORD PTR _fx$[ebp], xmm0
  000f2	8b 45 0c	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000fa	f3 0f 5c 45 50	 subss	 xmm0, DWORD PTR _v3Center$[ebp+4]
  000ff	f3 0f 11 45 e8	 movss	 DWORD PTR _fy$[ebp], xmm0
  00104	8b 45 0c	 mov	 eax, DWORD PTR _this$[ebp]
  00107	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0010c	f3 0f 5c 45 54	 subss	 xmm0, DWORD PTR _v3Center$[ebp+8]
  00111	f3 0f 11 45 e4	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00116	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0011b	f3 0f 11 45 58	 movss	 DWORD PTR _v3Sphere$[ebp], xmm0

; 181  :     y = fy;

  00120	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00125	f3 0f 11 45 5c	 movss	 DWORD PTR _v3Sphere$[ebp+4], xmm0

; 182  :     z = fz;

  0012a	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0012f	f3 0f 11 45 60	 movss	 DWORD PTR _v3Sphere$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 745  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00134	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00137	83 c0 1c	 add	 eax, 28			; 0000001cH
  0013a	50		 push	 eax
  0013b	8d 45 58	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  0013e	50		 push	 eax
  0013f	8d 45 58	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00148	f3 0f 10 45 58	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp]
  0014d	f3 0f 58 45 4c	 addss	 xmm0, DWORD PTR _v3Center$[ebp]
  00152	f3 0f 11 45 e0	 movss	 DWORD PTR _fx$[ebp], xmm0
  00157	f3 0f 10 45 5c	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+4]
  0015c	f3 0f 58 45 50	 addss	 xmm0, DWORD PTR _v3Center$[ebp+4]
  00161	f3 0f 11 45 dc	 movss	 DWORD PTR _fy$[ebp], xmm0
  00166	f3 0f 10 45 60	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+8]
  0016b	f3 0f 58 45 54	 addss	 xmm0, DWORD PTR _v3Center$[ebp+8]
  00170	f3 0f 11 45 d8	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00175	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0017a	f3 0f 11 45 34	 movss	 DWORD PTR $T3[ebp], xmm0

; 181  :     y = fy;

  0017f	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00184	f3 0f 11 45 38	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 182  :     z = fz;

  00189	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0018e	f3 0f 11 45 3c	 movss	 DWORD PTR $T3[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 746  : 	v3Sphere = v3Sphere + v3Center;

  00193	8d 75 34	 lea	 esi, DWORD PTR $T3[ebp]
  00196	8d 7d 58	 lea	 edi, DWORD PTR _v3Sphere$[ebp]
  00199	a5		 movsd
  0019a	a5		 movsd
  0019b	a5		 movsd

; 747  : 	
; 748  : 	D3DXVECTOR3 v3Point = v3Sphere;

  0019c	8d 75 58	 lea	 esi, DWORD PTR _v3Sphere$[ebp]
  0019f	8d 7d 64	 lea	 edi, DWORD PTR _v3Point$[ebp]
  001a2	a5		 movsd
  001a3	a5		 movsd
  001a4	a5		 movsd

; 749  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  001a5	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001a8	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001ad	0f 2f 45 64	 comiss	 xmm0, DWORD PTR _v3Point$[ebp]
  001b1	76 0d		 jbe	 SHORT $LN2@OnMovement
  001b3	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001b6	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001bb	f3 0f 11 45 64	 movss	 DWORD PTR _v3Point$[ebp], xmm0
$LN2@OnMovement:

; 750  : 	if(v3Point.x > m_attribute.v3Max.x) { v3Point.x = m_attribute.v3Max.x; }

  001c0	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001c3	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _v3Point$[ebp]
  001c8	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  001cc	76 0d		 jbe	 SHORT $LN3@OnMovement
  001ce	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001d1	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  001d6	f3 0f 11 45 64	 movss	 DWORD PTR _v3Point$[ebp], xmm0
$LN3@OnMovement:

; 751  : 	if(v3Point.y < m_attribute.v3Min.y) { v3Point.y = m_attribute.v3Min.y; }

  001db	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001de	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001e3	0f 2f 45 68	 comiss	 xmm0, DWORD PTR _v3Point$[ebp+4]
  001e7	76 0d		 jbe	 SHORT $LN4@OnMovement
  001e9	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001ec	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001f1	f3 0f 11 45 68	 movss	 DWORD PTR _v3Point$[ebp+4], xmm0
$LN4@OnMovement:

; 752  : 	if(v3Point.y > m_attribute.v3Max.y) { v3Point.y = m_attribute.v3Max.y; }

  001f6	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001f9	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _v3Point$[ebp+4]
  001fe	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  00202	76 0d		 jbe	 SHORT $LN5@OnMovement
  00204	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00207	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0020c	f3 0f 11 45 68	 movss	 DWORD PTR _v3Point$[ebp+4], xmm0
$LN5@OnMovement:

; 753  : 	if(v3Point.z < m_attribute.v3Min.z) { v3Point.z = m_attribute.v3Min.z; }

  00211	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00214	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00219	0f 2f 45 6c	 comiss	 xmm0, DWORD PTR _v3Point$[ebp+8]
  0021d	76 0d		 jbe	 SHORT $LN6@OnMovement
  0021f	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00222	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00227	f3 0f 11 45 6c	 movss	 DWORD PTR _v3Point$[ebp+8], xmm0
$LN6@OnMovement:

; 754  : 	if(v3Point.z > m_attribute.v3Max.z) { v3Point.z = m_attribute.v3Max.z; }

  0022c	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  0022f	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _v3Point$[ebp+8]
  00234	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  00238	76 0d		 jbe	 SHORT $LN7@OnMovement
  0023a	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  0023d	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00242	f3 0f 11 45 6c	 movss	 DWORD PTR _v3Point$[ebp+8], xmm0
$LN7@OnMovement:

; 756  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  00247	8b 45 7c	 mov	 eax, DWORD PTR _s$[ebp]
  0024a	8b 4d 7c	 mov	 ecx, DWORD PTR _s$[ebp]
  0024d	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00252	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00257	f3 0f 10 4d 68	 movss	 xmm1, DWORD PTR _v3Point$[ebp+4]
  0025c	f3 0f 5c 4d 5c	 subss	 xmm1, DWORD PTR _v3Sphere$[ebp+4]
  00261	f3 0f 10 55 68	 movss	 xmm2, DWORD PTR _v3Point$[ebp+4]
  00266	f3 0f 5c 55 5c	 subss	 xmm2, DWORD PTR _v3Sphere$[ebp+4]
  0026b	f3 0f 59 d1	 mulss	 xmm2, xmm1
  0026f	f3 0f 10 4d 64	 movss	 xmm1, DWORD PTR _v3Point$[ebp]
  00274	f3 0f 5c 4d 58	 subss	 xmm1, DWORD PTR _v3Sphere$[ebp]
  00279	f3 0f 10 5d 64	 movss	 xmm3, DWORD PTR _v3Point$[ebp]
  0027e	f3 0f 5c 5d 58	 subss	 xmm3, DWORD PTR _v3Sphere$[ebp]
  00283	f3 0f 59 d9	 mulss	 xmm3, xmm1
  00287	f3 0f 58 da	 addss	 xmm3, xmm2
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 756  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0028b	0f 2f c3	 comiss	 xmm0, xmm3
  0028e	72 07		 jb	 SHORT $LN8@OnMovement
  00290	b0 01		 mov	 al, 1
  00292	e9 c7 01 00 00	 jmp	 $LN1@OnMovement
$LN8@OnMovement:

; 758  : 	v3Sphere = s.v3LastPosition - v3Center;

  00297	8b 45 7c	 mov	 eax, DWORD PTR _s$[ebp]
  0029a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0029d	89 45 08	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  002a0	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002a3	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002a7	f3 0f 5c 45 4c	 subss	 xmm0, DWORD PTR _v3Center$[ebp]
  002ac	f3 0f 11 45 d4	 movss	 DWORD PTR _fx$[ebp], xmm0
  002b1	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002b4	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  002b9	f3 0f 5c 45 50	 subss	 xmm0, DWORD PTR _v3Center$[ebp+4]
  002be	f3 0f 11 45 d0	 movss	 DWORD PTR _fy$[ebp], xmm0
  002c3	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  002c6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002cb	f3 0f 5c 45 54	 subss	 xmm0, DWORD PTR _v3Center$[ebp+8]
  002d0	f3 0f 11 45 cc	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  002d5	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002da	f3 0f 11 45 28	 movss	 DWORD PTR $T2[ebp], xmm0

; 181  :     y = fy;

  002df	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002e4	f3 0f 11 45 2c	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 182  :     z = fz;

  002e9	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002ee	f3 0f 11 45 30	 movss	 DWORD PTR $T2[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 758  : 	v3Sphere = s.v3LastPosition - v3Center;

  002f3	8d 75 28	 lea	 esi, DWORD PTR $T2[ebp]
  002f6	8d 7d 58	 lea	 edi, DWORD PTR _v3Sphere$[ebp]
  002f9	a5		 movsd
  002fa	a5		 movsd
  002fb	a5		 movsd

; 759  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  002fc	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  002ff	83 c0 1c	 add	 eax, 28			; 0000001cH
  00302	50		 push	 eax
  00303	8d 45 58	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  00306	50		 push	 eax
  00307	8d 45 58	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  0030a	50		 push	 eax
  0030b	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00310	f3 0f 10 45 58	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp]
  00315	f3 0f 58 45 4c	 addss	 xmm0, DWORD PTR _v3Center$[ebp]
  0031a	f3 0f 11 45 c8	 movss	 DWORD PTR _fx$[ebp], xmm0
  0031f	f3 0f 10 45 5c	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+4]
  00324	f3 0f 58 45 50	 addss	 xmm0, DWORD PTR _v3Center$[ebp+4]
  00329	f3 0f 11 45 c4	 movss	 DWORD PTR _fy$[ebp], xmm0
  0032e	f3 0f 10 45 60	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+8]
  00333	f3 0f 58 45 54	 addss	 xmm0, DWORD PTR _v3Center$[ebp+8]
  00338	f3 0f 11 45 c0	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0033d	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00342	f3 0f 11 45 1c	 movss	 DWORD PTR $T1[ebp], xmm0

; 181  :     y = fy;

  00347	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0034c	f3 0f 11 45 20	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 182  :     z = fz;

  00351	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00356	f3 0f 11 45 24	 movss	 DWORD PTR $T1[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 760  : 	v3Sphere = v3Sphere + v3Center;

  0035b	8d 75 1c	 lea	 esi, DWORD PTR $T1[ebp]
  0035e	8d 7d 58	 lea	 edi, DWORD PTR _v3Sphere$[ebp]
  00361	a5		 movsd
  00362	a5		 movsd
  00363	a5		 movsd

; 761  : 	
; 762  : 	v3Point = v3Sphere;

  00364	8d 75 58	 lea	 esi, DWORD PTR _v3Sphere$[ebp]
  00367	8d 7d 64	 lea	 edi, DWORD PTR _v3Point$[ebp]
  0036a	a5		 movsd
  0036b	a5		 movsd
  0036c	a5		 movsd

; 763  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  0036d	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00370	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00375	0f 2f 45 64	 comiss	 xmm0, DWORD PTR _v3Point$[ebp]
  00379	76 0d		 jbe	 SHORT $LN9@OnMovement
  0037b	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  0037e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00383	f3 0f 11 45 64	 movss	 DWORD PTR _v3Point$[ebp], xmm0
$LN9@OnMovement:

; 764  : 	if(v3Point.x > m_attribute.v3Max.x) { v3Point.x = m_attribute.v3Max.x; }

  00388	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  0038b	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _v3Point$[ebp]
  00390	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  00394	76 0d		 jbe	 SHORT $LN10@OnMovement
  00396	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00399	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0039e	f3 0f 11 45 64	 movss	 DWORD PTR _v3Point$[ebp], xmm0
$LN10@OnMovement:

; 765  : 	if(v3Point.y < m_attribute.v3Min.y) { v3Point.y = m_attribute.v3Min.y; }

  003a3	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003a6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  003ab	0f 2f 45 68	 comiss	 xmm0, DWORD PTR _v3Point$[ebp+4]
  003af	76 0d		 jbe	 SHORT $LN11@OnMovement
  003b1	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003b4	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  003b9	f3 0f 11 45 68	 movss	 DWORD PTR _v3Point$[ebp+4], xmm0
$LN11@OnMovement:

; 766  : 	if(v3Point.y > m_attribute.v3Max.y) { v3Point.y = m_attribute.v3Max.y; }

  003be	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003c1	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _v3Point$[ebp+4]
  003c6	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  003ca	76 0d		 jbe	 SHORT $LN12@OnMovement
  003cc	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003cf	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  003d4	f3 0f 11 45 68	 movss	 DWORD PTR _v3Point$[ebp+4], xmm0
$LN12@OnMovement:

; 767  : 	if(v3Point.z < m_attribute.v3Min.z) { v3Point.z = m_attribute.v3Min.z; }

  003d9	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003dc	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  003e1	0f 2f 45 6c	 comiss	 xmm0, DWORD PTR _v3Point$[ebp+8]
  003e5	76 0d		 jbe	 SHORT $LN13@OnMovement
  003e7	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003ea	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  003ef	f3 0f 11 45 6c	 movss	 DWORD PTR _v3Point$[ebp+8], xmm0
$LN13@OnMovement:

; 768  : 	if(v3Point.z > m_attribute.v3Max.z) { v3Point.z = m_attribute.v3Max.z; }

  003f4	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  003f7	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _v3Point$[ebp+8]
  003fc	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  00400	76 0d		 jbe	 SHORT $LN14@OnMovement
  00402	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  00405	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0040a	f3 0f 11 45 6c	 movss	 DWORD PTR _v3Point$[ebp+8], xmm0
$LN14@OnMovement:

; 770  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0040f	8b 45 7c	 mov	 eax, DWORD PTR _s$[ebp]
  00412	8b 4d 7c	 mov	 ecx, DWORD PTR _s$[ebp]
  00415	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0041a	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0041f	f3 0f 10 4d 68	 movss	 xmm1, DWORD PTR _v3Point$[ebp+4]
  00424	f3 0f 5c 4d 5c	 subss	 xmm1, DWORD PTR _v3Sphere$[ebp+4]
  00429	f3 0f 10 55 68	 movss	 xmm2, DWORD PTR _v3Point$[ebp+4]
  0042e	f3 0f 5c 55 5c	 subss	 xmm2, DWORD PTR _v3Sphere$[ebp+4]
  00433	f3 0f 59 d1	 mulss	 xmm2, xmm1
  00437	f3 0f 10 4d 64	 movss	 xmm1, DWORD PTR _v3Point$[ebp]
  0043c	f3 0f 5c 4d 58	 subss	 xmm1, DWORD PTR _v3Sphere$[ebp]
  00441	f3 0f 10 5d 64	 movss	 xmm3, DWORD PTR _v3Point$[ebp]
  00446	f3 0f 5c 5d 58	 subss	 xmm3, DWORD PTR _v3Sphere$[ebp]
  0044b	f3 0f 59 d9	 mulss	 xmm3, xmm1
  0044f	f3 0f 58 da	 addss	 xmm3, xmm2
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 770  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  00453	0f 2f c3	 comiss	 xmm0, xmm3
  00456	72 04		 jb	 SHORT $LN15@OnMovement
  00458	b0 01		 mov	 al, 1
  0045a	eb 02		 jmp	 SHORT $LN1@OnMovement
$LN15@OnMovement:

; 771  : 
; 772  : 	return false;

  0045c	32 c0		 xor	 al, al
$LN1@OnMovement:

; 773  : }

  0045e	5f		 pop	 edi
  0045f	5e		 pop	 esi
  00460	8b 4d 70	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00463	33 cd		 xor	 ecx, ebp
  00465	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0046a	83 c5 74	 add	 ebp, 116		; 00000074H
  0046d	c9		 leave
  0046e	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; COBBCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnDestroy@COBBCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -8						; size = 4
_this$ = -4						; size = 4
?OnDestroy@COBBCollisionInstance@@MAEXXZ PROC		; COBBCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 827  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 828  : 	gs_oci.Free(this);

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	89 45 f8	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0000e	8d 45 f8	 lea	 eax, DWORD PTR _pkData$[ebp]
  00011	50		 push	 eax
  00012	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+16
  00017	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@QAEXABQAVCOBBCollisionInstance@@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::emplace_back<COBBCollisionInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 829  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?OnDestroy@COBBCollisionInstance@@MAEXXZ ENDP		; COBBCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_d3dFillMode$ = 8					; size = 4
?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; COBBCollisionInstance::Render, COMDAT
; _this$ = ecx

; 819  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 820  : 	static CScreen s;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  0002d	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  00034	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  0003d	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  00043	7e 3c		 jle	 SHORT $LN2@Render
  00045	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  0004a	e8 00 00 00 00	 call	 __Init_thread_header
  0004f	59		 pop	 ecx
  00050	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA, -1
  00057	75 28		 jne	 SHORT $LN2@Render
  00059	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0005d	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00062	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00067	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `COBBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  0006c	e8 00 00 00 00	 call	 _atexit
  00071	59		 pop	 ecx
  00072	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00076	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  0007b	e8 00 00 00 00	 call	 __Init_thread_footer
  00080	59		 pop	 ecx
$LN2@Render:

; 821  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  00081	6a ff		 push	 -1
  00083	6a 3c		 push	 60			; 0000003cH
  00085	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0008b	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 822  : 	s.RenderCube(m_attribute.v3Min.x, m_attribute.v3Min.y, m_attribute.v3Min.z, m_attribute.v3Max.x, m_attribute.v3Max.y, m_attribute.v3Max.z, m_attribute.matRot);

  00090	8b 75 f0	 mov	 esi, DWORD PTR _this$[ebp]
  00093	83 c6 1c	 add	 esi, 28			; 0000001cH
  00096	83 ec 40	 sub	 esp, 64			; 00000040H
  00099	6a 10		 push	 16			; 00000010H
  0009b	59		 pop	 ecx
  0009c	8b fc		 mov	 edi, esp
  0009e	f3 a5		 rep movsd
  000a0	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	51		 push	 ecx
  000a4	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  000a9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ae	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	51		 push	 ecx
  000b2	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  000b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	51		 push	 ecx
  000c0	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  000c5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ca	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	51		 push	 ecx
  000ce	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000d3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000db	51		 push	 ecx
  000dc	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000e1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	51		 push	 ecx
  000ea	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000ef	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  000f9	e8 00 00 00 00	 call	 ?RenderCube@CScreen@@QAEXMMMMMMUD3DXMATRIX@@@Z ; CScreen::RenderCube

; 823  : 	return;
; 824  : }

  000fe	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00101	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00108	59		 pop	 ecx
  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	c9		 leave
  0010c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; COBBCollisionInstance::Render
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@COBBCollisionInstance@@QBEABUSOBBData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAttribute@COBBCollisionInstance@@QBEABUSOBBData@@XZ PROC ; COBBCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 736  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 737  : 
; 738  : 	return m_attribute;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 739  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetAttribute@COBBCollisionInstance@@QBEABUSOBBData@@XZ ENDP ; COBBCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ PROC ; COBBCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 731  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 732  : 	return m_attribute;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 733  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ ENDP ; COBBCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_fz$ = -48						; size = 4
_fy$ = -44						; size = 4
_fx$ = -40						; size = 4
_v$ = -36						; size = 4
_this$ = -32						; size = 4
$T1 = -28						; size = 12
_v3Temp$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CAABBCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 662  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 663  : 	
; 664  : 	//Tracef("OnGetCollisionMovementAdjust	v3Min.x = %f, v3Max.x = %f\n", m_attribute.v3Min.x, m_attribute.v3Max.x);
; 665  : 	/*
; 666  : 	float fARadius = D3DXVec3Length(&(m_attribute.v3Min - m_attribute.v3Max));
; 667  : 	if (D3DXVec3LengthSq(&(s.v3Position-(m_attribute.v3Max + m_attribute.v3Min)))>=(s.fRadius+fARadius)*(fARadius+s.fRadius))
; 668  : 		return D3DXVECTOR3(0.0f,0.0f,0.0f);
; 669  : 	D3DXVECTOR3 c;
; 670  : 	D3DXVec3Cross(&c, &(s.v3Position-s.v3LastPosition), &D3DXVECTOR3(0.0f,0.0f,1.0f) );
; 671  : 	
; 672  : 	float sum = - D3DXVec3Dot(&c,&(s.v3Position-(m_attribute.v3Max + m_attribute.v3Min)));
; 673  : 	float mul = (s.fRadius+fARadius)*(s.fRadius+fARadius)-D3DXVec3LengthSq(&(s.v3Position-(m_attribute.v3Max + m_attribute.v3Min)));
; 674  : 
; 675  : 	if (sum*sum-4*mul<=0)
; 676  : 		return D3DXVECTOR3(0.0f,0.0f,0.0f);
; 677  : 	float sq = sqrt(sum*sum-4*mul);
; 678  : 	float t1=-sum-sq, t2=-sum+sq;
; 679  : 	t1*=0.5f;
; 680  : 	t2*=0.5f;
; 681  : 
; 682  : 	if (fabs(t1)<=fabs(t2))
; 683  : 	{
; 684  : 		return (gc_fReduceMove*t1)*c;
; 685  : 	}
; 686  : 	else
; 687  : 		return (gc_fReduceMove*t2)*c;
; 688  : 	*/
; 689  : 	
; 690  : 	D3DXVECTOR3 v3Temp;
; 691  : 	if(s.v3Position.x + s.fRadius <= m_attribute.v3Min.x)		{ v3Temp.x = m_attribute.v3Min.x; }

  00013	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00019	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0001d	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  00022	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00025	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0002a	0f 2f c8	 comiss	 xmm1, xmm0
  0002d	72 12		 jb	 SHORT $LN2@OnGetColli
  0002f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00032	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00037	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Temp$[ebp], xmm0
  0003c	e9 85 00 00 00	 jmp	 $LN7@OnGetColli
$LN2@OnGetColli:

; 692  : 	else if(s.v3Position.x - s.fRadius >= m_attribute.v3Max.x)	{ v3Temp.x = m_attribute.v3Max.x; }

  00041	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00044	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00047	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0004b	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [ecx+24]
  00050	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00053	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  00057	72 0f		 jb	 SHORT $LN4@OnGetColli
  00059	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00061	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Temp$[ebp], xmm0
  00066	eb 5e		 jmp	 SHORT $LN7@OnGetColli
$LN4@OnGetColli:

; 693  : 	else if(s.v3Position.x + s.fRadius >= m_attribute.v3Min.x && s.v3Position.x + s.fRadius <= m_attribute.v3Max.x) { v3Temp.x = s.v3Position.x + s.fRadius; }

  00068	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  0006e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00072	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  00077	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  0007e	72 32		 jb	 SHORT $LN6@OnGetColli
  00080	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00083	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00086	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0008a	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  0008f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00092	f3 0f 10 48 10	 movss	 xmm1, DWORD PTR [eax+16]
  00097	0f 2f c8	 comiss	 xmm1, xmm0
  0009a	72 16		 jb	 SHORT $LN6@OnGetColli
  0009c	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0009f	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  000a2	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000a6	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  000ab	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Temp$[ebp], xmm0
  000b0	eb 14		 jmp	 SHORT $LN7@OnGetColli
$LN6@OnGetColli:

; 694  : 	else																											{ v3Temp.x = s.v3Position.x - s.fRadius; }

  000b2	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  000b5	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  000b8	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000bc	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [ecx+24]
  000c1	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Temp$[ebp], xmm0
$LN7@OnGetColli:

; 695  : 
; 696  : 	if(s.v3Position.y + s.fRadius <= m_attribute.v3Min.y)		{ v3Temp.y = m_attribute.v3Min.y; }

  000c6	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  000c9	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  000cc	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000d1	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  000d6	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000d9	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  000de	0f 2f c8	 comiss	 xmm1, xmm0
  000e1	72 12		 jb	 SHORT $LN8@OnGetColli
  000e3	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000eb	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Temp$[ebp+4], xmm0
  000f0	e9 8a 00 00 00	 jmp	 $LN13@OnGetColli
$LN8@OnGetColli:

; 697  : 	else if(s.v3Position.y - s.fRadius >= m_attribute.v3Max.y)	{ v3Temp.y = m_attribute.v3Max.y; }

  000f5	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  000f8	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  000fb	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00100	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [ecx+24]
  00105	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00108	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  0010c	72 0f		 jb	 SHORT $LN10@OnGetColli
  0010e	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00111	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00116	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Temp$[ebp+4], xmm0
  0011b	eb 62		 jmp	 SHORT $LN13@OnGetColli
$LN10@OnGetColli:

; 698  : 	else if(s.v3Position.y + s.fRadius >= m_attribute.v3Min.y && s.v3Position.y + s.fRadius <= m_attribute.v3Max.y) { v3Temp.y = s.v3Position.y + s.fRadius; }

  0011d	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00120	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00123	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00128	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  0012d	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00130	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  00134	72 34		 jb	 SHORT $LN12@OnGetColli
  00136	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00139	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  0013c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00141	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  00146	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00149	f3 0f 10 48 14	 movss	 xmm1, DWORD PTR [eax+20]
  0014e	0f 2f c8	 comiss	 xmm1, xmm0
  00151	72 17		 jb	 SHORT $LN12@OnGetColli
  00153	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00156	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00159	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0015e	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  00163	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Temp$[ebp+4], xmm0
  00168	eb 15		 jmp	 SHORT $LN13@OnGetColli
$LN12@OnGetColli:

; 699  : 	else																											{ v3Temp.y = s.v3Position.y - s.fRadius; }

  0016a	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0016d	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00170	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00175	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [ecx+24]
  0017a	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Temp$[ebp+4], xmm0
$LN13@OnGetColli:

; 700  : 	
; 701  : 	if(s.v3Position.z + s.fRadius <= m_attribute.v3Min.z)		{ v3Temp.z = m_attribute.v3Min.z; }

  0017f	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00182	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00185	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0018a	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  0018f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00192	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  00197	0f 2f c8	 comiss	 xmm1, xmm0
  0019a	72 12		 jb	 SHORT $LN14@OnGetColli
  0019c	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0019f	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  001a4	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Temp$[ebp+8], xmm0
  001a9	e9 8a 00 00 00	 jmp	 $LN19@OnGetColli
$LN14@OnGetColli:

; 702  : 	else if(s.v3Position.z - s.fRadius >= m_attribute.v3Max.z)	{ v3Temp.z = m_attribute.v3Max.z; }

  001ae	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  001b1	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  001b4	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001b9	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [ecx+24]
  001be	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  001c1	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  001c5	72 0f		 jb	 SHORT $LN16@OnGetColli
  001c7	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  001ca	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  001cf	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Temp$[ebp+8], xmm0
  001d4	eb 62		 jmp	 SHORT $LN19@OnGetColli
$LN16@OnGetColli:

; 703  : 	else if(s.v3Position.z + s.fRadius >= m_attribute.v3Min.z && s.v3Position.z + s.fRadius <= m_attribute.v3Max.z) { v3Temp.z = s.v3Position.z + s.fRadius; }

  001d6	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  001d9	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  001dc	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001e1	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  001e6	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  001e9	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  001ed	72 34		 jb	 SHORT $LN18@OnGetColli
  001ef	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  001f2	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  001f5	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001fa	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  001ff	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00202	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [eax+24]
  00207	0f 2f c8	 comiss	 xmm1, xmm0
  0020a	72 17		 jb	 SHORT $LN18@OnGetColli
  0020c	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0020f	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00212	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00217	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  0021c	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Temp$[ebp+8], xmm0
  00221	eb 15		 jmp	 SHORT $LN19@OnGetColli
$LN18@OnGetColli:

; 704  : 	else																											{ v3Temp.z = s.v3Position.z - s.fRadius; }

  00223	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00226	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00229	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0022e	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [ecx+24]
  00233	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Temp$[ebp+8], xmm0
$LN19@OnGetColli:

; 707  : 	if(D3DXVec3LengthSq(&(v3Temp - s.v3Position)) < s.fRadius * s.fRadius)

  00238	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0023b	89 45 dc	 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0023e	8b 45 dc	 mov	 eax, DWORD PTR _v$[ebp]
  00241	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v3Temp$[ebp]
  00246	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  0024a	f3 0f 11 45 d8	 movss	 DWORD PTR _fx$[ebp], xmm0
  0024f	8b 45 dc	 mov	 eax, DWORD PTR _v$[ebp]
  00252	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v3Temp$[ebp+4]
  00257	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  0025c	f3 0f 11 45 d4	 movss	 DWORD PTR _fy$[ebp], xmm0
  00261	8b 45 dc	 mov	 eax, DWORD PTR _v$[ebp]
  00264	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3Temp$[ebp+8]
  00269	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [eax+8]
  0026e	f3 0f 11 45 d0	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00273	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00278	f3 0f 11 45 e4	 movss	 DWORD PTR $T1[ebp], xmm0

; 181  :     y = fy;

  0027d	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00282	f3 0f 11 45 e8	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 182  :     z = fz;

  00287	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0028c	f3 0f 11 45 ec	 movss	 DWORD PTR $T1[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 707  : 	if(D3DXVec3LengthSq(&(v3Temp - s.v3Position)) < s.fRadius * s.fRadius)

  00291	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00294	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00297	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0029c	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  002a1	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR $T1[ebp+8]
  002a6	f3 0f 59 4d ec	 mulss	 xmm1, DWORD PTR $T1[ebp+8]
  002ab	f3 0f 10 55 e8	 movss	 xmm2, DWORD PTR $T1[ebp+4]
  002b0	f3 0f 59 55 e8	 mulss	 xmm2, DWORD PTR $T1[ebp+4]
  002b5	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR $T1[ebp]
  002ba	f3 0f 59 5d e4	 mulss	 xmm3, DWORD PTR $T1[ebp]
  002bf	f3 0f 58 da	 addss	 xmm3, xmm2
  002c3	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 707  : 	if(D3DXVec3LengthSq(&(v3Temp - s.v3Position)) < s.fRadius * s.fRadius)

  002c7	0f 2f c3	 comiss	 xmm0, xmm3
  002ca	76 25		 jbe	 SHORT $LN20@OnGetColli
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  002cc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002cf	0f 57 c0	 xorps	 xmm0, xmm0
  002d2	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  002d6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002d9	0f 57 c0	 xorps	 xmm0, xmm0
  002dc	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  002e1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002e4	0f 57 c0	 xorps	 xmm0, xmm0
  002e7	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 708  : 		return D3DXVECTOR3(.0f, .0f, .0f);

  002ec	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002ef	eb 23		 jmp	 SHORT $LN1@OnGetColli
$LN20@OnGetColli:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  002f1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002f4	0f 57 c0	 xorps	 xmm0, xmm0
  002f7	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  002fb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002fe	0f 57 c0	 xorps	 xmm0, xmm0
  00301	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  00306	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00309	0f 57 c0	 xorps	 xmm0, xmm0
  0030c	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 710  : 	return D3DXVECTOR3(.0f, .0f, .0f);

  00311	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@OnGetColli:

; 711  : 	
; 712  : }

  00314	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00317	33 cd		 xor	 ecx, ebp
  00319	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031e	c9		 leave
  0031f	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CAABBCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_c_rv3Target$ = -28					; size = 4
_c_rv3Target$ = -24					; size = 4
_this$ = -20						; size = 4
_v$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CAABBCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 621  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 	D3DXVECTOR3 v;
; 623  : 	memcpy(&v, &s.v3Position, sizeof(D3DXVECTOR3));

  00013	6a 0c		 push	 12			; 0000000cH
  00015	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00018	8d 45 f0	 lea	 eax, DWORD PTR _v$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memcpy
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 624  : 
; 625  : 	if(v.x < m_attribute.v3Min.x) v.x = m_attribute.v3Min.x;

  00024	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00027	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0002c	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _v$[ebp]
  00030	76 0d		 jbe	 SHORT $LN2@OnCollisio
  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00035	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0003a	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN2@OnCollisio:

; 626  : 	if(v.x > m_attribute.v3Max.x) v.x = m_attribute.v3Max.x;

  0003f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00042	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v$[ebp]
  00047	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  0004b	76 0d		 jbe	 SHORT $LN3@OnCollisio
  0004d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00050	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00055	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN3@OnCollisio:

; 627  : 	if(v.y < m_attribute.v3Min.y) v.x = m_attribute.v3Min.y;

  0005a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00062	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _v$[ebp+4]
  00066	76 0d		 jbe	 SHORT $LN4@OnCollisio
  00068	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00070	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN4@OnCollisio:

; 628  : 	if(v.y > m_attribute.v3Max.y) v.x = m_attribute.v3Max.y;

  00075	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00078	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp+4]
  0007d	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  00081	76 0d		 jbe	 SHORT $LN5@OnCollisio
  00083	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00086	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0008b	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN5@OnCollisio:

; 629  : 	if(v.z < m_attribute.v3Min.z) v.z = m_attribute.v3Min.z;

  00090	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00093	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00098	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _v$[ebp+8]
  0009c	76 0d		 jbe	 SHORT $LN6@OnCollisio
  0009e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000a6	f3 0f 11 45 f8	 movss	 DWORD PTR _v$[ebp+8], xmm0
$LN6@OnCollisio:

; 630  : 	if(v.z > m_attribute.v3Max.z) v.z = m_attribute.v3Max.z;

  000ab	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v$[ebp+8]
  000b3	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  000b7	76 0d		 jbe	 SHORT $LN7@OnCollisio
  000b9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  000c1	f3 0f 11 45 f8	 movss	 DWORD PTR _v$[ebp+8], xmm0
$LN7@OnCollisio:

; 631  : 
; 632  : 	if(v.x > m_attribute.v3Min.x && v.x < m_attribute.v3Max.x &&
; 633  : 		v.y > m_attribute.v3Min.y && v.y < m_attribute.v3Max.y &&
; 634  : 		v.z > m_attribute.v3Min.z && v.z < m_attribute.v3Max.z) { return true; }

  000c6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v$[ebp]
  000ce	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  000d2	76 4d		 jbe	 SHORT $LN8@OnCollisio
  000d4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  000dc	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _v$[ebp]
  000e0	76 3f		 jbe	 SHORT $LN8@OnCollisio
  000e2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp+4]
  000ea	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  000ee	76 31		 jbe	 SHORT $LN8@OnCollisio
  000f0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f3	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  000f8	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _v$[ebp+4]
  000fc	76 23		 jbe	 SHORT $LN8@OnCollisio
  000fe	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00101	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v$[ebp+8]
  00106	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  0010a	76 15		 jbe	 SHORT $LN8@OnCollisio
  0010c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0010f	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00114	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _v$[ebp+8]
  00118	76 07		 jbe	 SHORT $LN8@OnCollisio
  0011a	b0 01		 mov	 al, 1
  0011c	e9 d1 01 00 00	 jmp	 $LN1@OnCollisio
$LN8@OnCollisio:

; 636  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius) { return true; }

  00121	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00124	89 45 e8	 mov	 DWORD PTR _c_rv3Target$[ebp], eax
  00127	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0012d	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00132	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00137	8b 45 e8	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  0013a	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _v$[ebp+4]
  0013f	f3 0f 5c 48 04	 subss	 xmm1, DWORD PTR [eax+4]
  00144	8b 45 e8	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  00147	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _v$[ebp+4]
  0014c	f3 0f 5c 50 04	 subss	 xmm2, DWORD PTR [eax+4]
  00151	f3 0f 59 d1	 mulss	 xmm2, xmm1
  00155	8b 45 e8	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  00158	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _v$[ebp]
  0015d	f3 0f 5c 08	 subss	 xmm1, DWORD PTR [eax]
  00161	8b 45 e8	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  00164	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _v$[ebp]
  00169	f3 0f 5c 18	 subss	 xmm3, DWORD PTR [eax]
  0016d	f3 0f 59 d9	 mulss	 xmm3, xmm1
  00171	f3 0f 58 da	 addss	 xmm3, xmm2
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 636  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius) { return true; }

  00175	0f 2f c3	 comiss	 xmm0, xmm3
  00178	72 07		 jb	 SHORT $LN9@OnCollisio
  0017a	b0 01		 mov	 al, 1
  0017c	e9 71 01 00 00	 jmp	 $LN1@OnCollisio
$LN9@OnCollisio:

; 637  : 
; 638  : 
; 639  : 	memcpy(&v, &s.v3LastPosition, sizeof(D3DXVECTOR3));

  00181	6a 0c		 push	 12			; 0000000cH
  00183	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00186	83 c0 0c	 add	 eax, 12			; 0000000cH
  00189	50		 push	 eax
  0018a	8d 45 f0	 lea	 eax, DWORD PTR _v$[ebp]
  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 _memcpy
  00193	83 c4 0c	 add	 esp, 12			; 0000000cH

; 640  : 
; 641  : 	if(v.x < m_attribute.v3Min.x) v.x = m_attribute.v3Min.x;

  00196	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00199	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0019e	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _v$[ebp]
  001a2	76 0d		 jbe	 SHORT $LN10@OnCollisio
  001a4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001a7	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001ac	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN10@OnCollisio:

; 642  : 	if(v.x > m_attribute.v3Max.x) v.x = m_attribute.v3Max.x;

  001b1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001b4	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v$[ebp]
  001b9	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  001bd	76 0d		 jbe	 SHORT $LN11@OnCollisio
  001bf	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001c2	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  001c7	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN11@OnCollisio:

; 643  : 	if(v.y < m_attribute.v3Min.y) v.x = m_attribute.v3Min.y;

  001cc	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001cf	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001d4	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _v$[ebp+4]
  001d8	76 0d		 jbe	 SHORT $LN12@OnCollisio
  001da	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001dd	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001e2	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN12@OnCollisio:

; 644  : 	if(v.y > m_attribute.v3Max.y) v.x = m_attribute.v3Max.y;

  001e7	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001ea	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp+4]
  001ef	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  001f3	76 0d		 jbe	 SHORT $LN13@OnCollisio
  001f5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001f8	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  001fd	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN13@OnCollisio:

; 645  : 	if(v.z < m_attribute.v3Min.z) v.z = m_attribute.v3Min.z;

  00202	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00205	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0020a	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _v$[ebp+8]
  0020e	76 0d		 jbe	 SHORT $LN14@OnCollisio
  00210	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00213	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00218	f3 0f 11 45 f8	 movss	 DWORD PTR _v$[ebp+8], xmm0
$LN14@OnCollisio:

; 646  : 	if(v.z > m_attribute.v3Max.z) v.z = m_attribute.v3Max.z;

  0021d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00220	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v$[ebp+8]
  00225	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  00229	76 0d		 jbe	 SHORT $LN15@OnCollisio
  0022b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0022e	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00233	f3 0f 11 45 f8	 movss	 DWORD PTR _v$[ebp+8], xmm0
$LN15@OnCollisio:

; 647  : 	
; 648  : 
; 649  : 
; 650  : 	if(v.x > m_attribute.v3Min.x && v.x < m_attribute.v3Max.x &&
; 651  : 		v.y > m_attribute.v3Min.y && v.y < m_attribute.v3Max.y &&
; 652  : 		v.z > m_attribute.v3Min.z && v.z < m_attribute.v3Max.z) { return true; }

  00238	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0023b	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v$[ebp]
  00240	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00244	76 4a		 jbe	 SHORT $LN16@OnCollisio
  00246	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00249	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0024e	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _v$[ebp]
  00252	76 3c		 jbe	 SHORT $LN16@OnCollisio
  00254	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00257	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp+4]
  0025c	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  00260	76 2e		 jbe	 SHORT $LN16@OnCollisio
  00262	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00265	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0026a	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _v$[ebp+4]
  0026e	76 20		 jbe	 SHORT $LN16@OnCollisio
  00270	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00273	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v$[ebp+8]
  00278	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  0027c	76 12		 jbe	 SHORT $LN16@OnCollisio
  0027e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00281	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00286	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _v$[ebp+8]
  0028a	76 04		 jbe	 SHORT $LN16@OnCollisio
  0028c	b0 01		 mov	 al, 1
  0028e	eb 62		 jmp	 SHORT $LN1@OnCollisio
$LN16@OnCollisio:

; 654  : 	if(GetVector3Distance(v, s.v3LastPosition) <= s.fRadius * s.fRadius) { return true; }

  00290	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00293	83 c0 0c	 add	 eax, 12			; 0000000cH
  00296	89 45 e4	 mov	 DWORD PTR _c_rv3Target$[ebp], eax
  00299	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0029c	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0029f	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  002a4	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  002a9	8b 45 e4	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  002ac	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _v$[ebp+4]
  002b1	f3 0f 5c 48 04	 subss	 xmm1, DWORD PTR [eax+4]
  002b6	8b 45 e4	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  002b9	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _v$[ebp+4]
  002be	f3 0f 5c 50 04	 subss	 xmm2, DWORD PTR [eax+4]
  002c3	f3 0f 59 d1	 mulss	 xmm2, xmm1
  002c7	8b 45 e4	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  002ca	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _v$[ebp]
  002cf	f3 0f 5c 08	 subss	 xmm1, DWORD PTR [eax]
  002d3	8b 45 e4	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  002d6	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _v$[ebp]
  002db	f3 0f 5c 18	 subss	 xmm3, DWORD PTR [eax]
  002df	f3 0f 59 d9	 mulss	 xmm3, xmm1
  002e3	f3 0f 58 da	 addss	 xmm3, xmm2
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 654  : 	if(GetVector3Distance(v, s.v3LastPosition) <= s.fRadius * s.fRadius) { return true; }

  002e7	0f 2f c3	 comiss	 xmm0, xmm3
  002ea	72 04		 jb	 SHORT $LN17@OnCollisio
  002ec	b0 01		 mov	 al, 1
  002ee	eb 02		 jmp	 SHORT $LN1@OnCollisio
$LN17@OnCollisio:

; 655  : 
; 656  : 	
; 657  : 
; 658  : 	return false;

  002f0	32 c0		 xor	 al, al
$LN1@OnCollisio:

; 659  : }

  002f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f5	33 cd		 xor	 ecx, ebp
  002f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002fc	c9		 leave
  002fd	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CAABBCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_fz$ = -84						; size = 4
_fy$ = -80						; size = 4
_fx$ = -76						; size = 4
_fz$ = -72						; size = 4
_fy$ = -68						; size = 4
_fx$ = -64						; size = 4
_v$ = -60						; size = 4
_this$ = -56						; size = 4
_c_rv3Target$ = -52					; size = 4
_c_rv3Target$ = -48					; size = 4
_this$ = -44						; size = 4
_v3center$ = -40					; size = 12
$T1 = -28						; size = 12
_v$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CAABBCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 582  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 583  : 	D3DXVECTOR3 v;
; 584  : 	D3DXVECTOR3 v3center = (m_attribute.v3Min + m_attribute.v3Max) * 0.5f;

  00013	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 10	 add	 eax, 16			; 00000010H
  00019	89 45 c4	 mov	 DWORD PTR _v$[ebp], eax
  0001c	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 c0 04	 add	 eax, 4
  00022	89 45 c8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00025	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 4d c4	 mov	 ecx, DWORD PTR _v$[ebp]
  0002b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0002f	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  00033	f3 0f 11 45 c0	 movss	 DWORD PTR _fx$[ebp], xmm0
  00038	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 4d c4	 mov	 ecx, DWORD PTR _v$[ebp]
  0003e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00043	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  00048	f3 0f 11 45 bc	 movss	 DWORD PTR _fy$[ebp], xmm0
  0004d	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d c4	 mov	 ecx, DWORD PTR _v$[ebp]
  00053	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00058	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  0005d	f3 0f 11 45 b8	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00062	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00067	f3 0f 11 45 e4	 movss	 DWORD PTR $T1[ebp], xmm0

; 181  :     y = fy;

  0006c	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00071	f3 0f 11 45 e8	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 182  :     z = fz;

  00076	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0007b	f3 0f 11 45 ec	 movss	 DWORD PTR $T1[ebp+8], xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00080	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR $T1[ebp]
  00085	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0008d	f3 0f 11 45 b4	 movss	 DWORD PTR _fx$[ebp], xmm0
  00092	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR $T1[ebp+4]
  00097	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0009f	f3 0f 11 45 b0	 movss	 DWORD PTR _fy$[ebp], xmm0
  000a4	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR $T1[ebp+8]
  000a9	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  000b1	f3 0f 11 45 ac	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  000b6	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000bb	f3 0f 11 45 d8	 movss	 DWORD PTR _v3center$[ebp], xmm0

; 181  :     y = fy;

  000c0	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  000c5	f3 0f 11 45 dc	 movss	 DWORD PTR _v3center$[ebp+4], xmm0

; 182  :     z = fz;

  000ca	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fz$[ebp]
  000cf	f3 0f 11 45 e0	 movss	 DWORD PTR _v3center$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 586  : 	memcpy(&v, &s.v3Position, sizeof(D3DXVECTOR3));

  000d4	6a 0c		 push	 12			; 0000000cH
  000d6	ff 75 08	 push	 DWORD PTR _s$[ebp]
  000d9	8d 45 f0	 lea	 eax, DWORD PTR _v$[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _memcpy
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 587  : 
; 588  : 	if(v.x < m_attribute.v3Min.x) v.x = m_attribute.v3Min.x;

  000e5	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000e8	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000ed	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _v$[ebp]
  000f1	76 0d		 jbe	 SHORT $LN2@OnMovement
  000f3	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000fb	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN2@OnMovement:

; 589  : 	if(v.x > m_attribute.v3Max.x) v.x = m_attribute.v3Max.x;

  00100	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00103	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v$[ebp]
  00108	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  0010c	76 0d		 jbe	 SHORT $LN3@OnMovement
  0010e	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00111	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00116	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN3@OnMovement:

; 590  : 	if(v.y < m_attribute.v3Min.y) v.x = m_attribute.v3Min.y;

  0011b	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0011e	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00123	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _v$[ebp+4]
  00127	76 0d		 jbe	 SHORT $LN4@OnMovement
  00129	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0012c	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00131	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN4@OnMovement:

; 591  : 	if(v.y > m_attribute.v3Max.y) v.x = m_attribute.v3Max.y;

  00136	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00139	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp+4]
  0013e	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  00142	76 0d		 jbe	 SHORT $LN5@OnMovement
  00144	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00147	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0014c	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN5@OnMovement:

; 592  : 	if(v.z < m_attribute.v3Min.z) v.z = m_attribute.v3Min.z;

  00151	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00154	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00159	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _v$[ebp+8]
  0015d	76 0d		 jbe	 SHORT $LN6@OnMovement
  0015f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00162	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00167	f3 0f 11 45 f8	 movss	 DWORD PTR _v$[ebp+8], xmm0
$LN6@OnMovement:

; 593  : 	if(v.z > m_attribute.v3Max.z) v.z = m_attribute.v3Max.z;

  0016c	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0016f	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v$[ebp+8]
  00174	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  00178	76 0d		 jbe	 SHORT $LN7@OnMovement
  0017a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0017d	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00182	f3 0f 11 45 f8	 movss	 DWORD PTR _v$[ebp+8], xmm0
$LN7@OnMovement:

; 595  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius)

  00187	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0018a	89 45 d0	 mov	 DWORD PTR _c_rv3Target$[ebp], eax
  0018d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00190	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00193	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00198	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0019d	8b 45 d0	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  001a0	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _v$[ebp+4]
  001a5	f3 0f 5c 48 04	 subss	 xmm1, DWORD PTR [eax+4]
  001aa	8b 45 d0	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  001ad	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _v$[ebp+4]
  001b2	f3 0f 5c 50 04	 subss	 xmm2, DWORD PTR [eax+4]
  001b7	f3 0f 59 d1	 mulss	 xmm2, xmm1
  001bb	8b 45 d0	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  001be	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _v$[ebp]
  001c3	f3 0f 5c 08	 subss	 xmm1, DWORD PTR [eax]
  001c7	8b 45 d0	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  001ca	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _v$[ebp]
  001cf	f3 0f 5c 18	 subss	 xmm3, DWORD PTR [eax]
  001d3	f3 0f 59 d9	 mulss	 xmm3, xmm1
  001d7	f3 0f 58 da	 addss	 xmm3, xmm2
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 595  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius)

  001db	0f 2f c3	 comiss	 xmm0, xmm3
  001de	72 07		 jb	 SHORT $LN8@OnMovement

; 596  : 	{
; 597  : 		
; 598  : 		return true;

  001e0	b0 01		 mov	 al, 1
  001e2	e9 19 01 00 00	 jmp	 $LN1@OnMovement
$LN8@OnMovement:

; 599  : 	}
; 600  : 
; 601  : 
; 602  : 	memcpy(&v, &s.v3LastPosition, sizeof(D3DXVECTOR3));

  001e7	6a 0c		 push	 12			; 0000000cH
  001e9	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001ec	83 c0 0c	 add	 eax, 12			; 0000000cH
  001ef	50		 push	 eax
  001f0	8d 45 f0	 lea	 eax, DWORD PTR _v$[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 _memcpy
  001f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 603  : 
; 604  : 	if(v.x < m_attribute.v3Min.x) v.x = m_attribute.v3Min.x;

  001fc	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001ff	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00204	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _v$[ebp]
  00208	76 0d		 jbe	 SHORT $LN9@OnMovement
  0020a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0020d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00212	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN9@OnMovement:

; 605  : 	if(v.x > m_attribute.v3Max.x) v.x = m_attribute.v3Max.x;

  00217	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v$[ebp]
  0021f	0f 2f 40 10	 comiss	 xmm0, DWORD PTR [eax+16]
  00223	76 0d		 jbe	 SHORT $LN10@OnMovement
  00225	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00228	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0022d	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN10@OnMovement:

; 606  : 	if(v.y < m_attribute.v3Min.y) v.x = m_attribute.v3Min.y;

  00232	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00235	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0023a	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _v$[ebp+4]
  0023e	76 0d		 jbe	 SHORT $LN11@OnMovement
  00240	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00243	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00248	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN11@OnMovement:

; 607  : 	if(v.y > m_attribute.v3Max.y) v.x = m_attribute.v3Max.y;

  0024d	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00250	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp+4]
  00255	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  00259	76 0d		 jbe	 SHORT $LN12@OnMovement
  0025b	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0025e	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00263	f3 0f 11 45 f0	 movss	 DWORD PTR _v$[ebp], xmm0
$LN12@OnMovement:

; 608  : 	if(v.z < m_attribute.v3Min.z) v.z = m_attribute.v3Min.z;

  00268	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0026b	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00270	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _v$[ebp+8]
  00274	76 0d		 jbe	 SHORT $LN13@OnMovement
  00276	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00279	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0027e	f3 0f 11 45 f8	 movss	 DWORD PTR _v$[ebp+8], xmm0
$LN13@OnMovement:

; 609  : 	if(v.z > m_attribute.v3Max.z) v.z = m_attribute.v3Max.z;

  00283	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00286	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v$[ebp+8]
  0028b	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  0028f	76 0d		 jbe	 SHORT $LN14@OnMovement
  00291	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00294	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00299	f3 0f 11 45 f8	 movss	 DWORD PTR _v$[ebp+8], xmm0
$LN14@OnMovement:

; 611  : 	if(GetVector3Distance(v, s.v3LastPosition) <= s.fRadius * s.fRadius)

  0029e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  002a1	83 c0 0c	 add	 eax, 12			; 0000000cH
  002a4	89 45 cc	 mov	 DWORD PTR _c_rv3Target$[ebp], eax
  002a7	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  002aa	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  002ad	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  002b2	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  002b7	8b 45 cc	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  002ba	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _v$[ebp+4]
  002bf	f3 0f 5c 48 04	 subss	 xmm1, DWORD PTR [eax+4]
  002c4	8b 45 cc	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  002c7	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _v$[ebp+4]
  002cc	f3 0f 5c 50 04	 subss	 xmm2, DWORD PTR [eax+4]
  002d1	f3 0f 59 d1	 mulss	 xmm2, xmm1
  002d5	8b 45 cc	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  002d8	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _v$[ebp]
  002dd	f3 0f 5c 08	 subss	 xmm1, DWORD PTR [eax]
  002e1	8b 45 cc	 mov	 eax, DWORD PTR _c_rv3Target$[ebp]
  002e4	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _v$[ebp]
  002e9	f3 0f 5c 18	 subss	 xmm3, DWORD PTR [eax]
  002ed	f3 0f 59 d9	 mulss	 xmm3, xmm1
  002f1	f3 0f 58 da	 addss	 xmm3, xmm2
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 611  : 	if(GetVector3Distance(v, s.v3LastPosition) <= s.fRadius * s.fRadius)

  002f5	0f 2f c3	 comiss	 xmm0, xmm3
  002f8	72 04		 jb	 SHORT $LN15@OnMovement

; 612  : 	{
; 613  : 		
; 614  : 		return true;

  002fa	b0 01		 mov	 al, 1
  002fc	eb 02		 jmp	 SHORT $LN1@OnMovement
$LN15@OnMovement:

; 615  : 	}
; 616  : 
; 617  : 	return false;

  002fe	32 c0		 xor	 al, al
$LN1@OnMovement:

; 618  : }

  00300	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00303	33 cd		 xor	 ecx, ebp
  00305	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030a	c9		 leave
  0030b	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CAABBCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnDestroy@CAABBCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -8						; size = 4
_this$ = -4						; size = 4
?OnDestroy@CAABBCollisionInstance@@MAEXXZ PROC		; CAABBCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 723  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 724  : 	gs_aci.Free(this);

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	89 45 f8	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0000e	8d 45 f8	 lea	 eax, DWORD PTR _pkData$[ebp]
  00011	50		 push	 eax
  00012	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+16
  00017	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@QAEXABQAVCAABBCollisionInstance@@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::emplace_back<CAABBCollisionInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 725  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?OnDestroy@CAABBCollisionInstance@@MAEXXZ ENDP		; CAABBCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_d3dFillMode$ = 8					; size = 4
?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; CAABBCollisionInstance::Render, COMDAT
; _this$ = ecx

; 715  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 716  : 	static CScreen s;

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  0002b	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  00032	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  0003b	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  00041	7e 3c		 jle	 SHORT $LN2@Render
  00043	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00048	e8 00 00 00 00	 call	 __Init_thread_header
  0004d	59		 pop	 ecx
  0004e	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA, -1
  00055	75 28		 jne	 SHORT $LN2@Render
  00057	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00060	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00065	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `CAABBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  0006a	e8 00 00 00 00	 call	 _atexit
  0006f	59		 pop	 ecx
  00070	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00074	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00079	e8 00 00 00 00	 call	 __Init_thread_footer
  0007e	59		 pop	 ecx
$LN2@Render:

; 717  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  0007f	6a ff		 push	 -1
  00081	6a 3c		 push	 60			; 0000003cH
  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00089	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 718  : 	s.RenderCube(m_attribute.v3Min.x, m_attribute.v3Min.y, m_attribute.v3Min.z, m_attribute.v3Max.x, m_attribute.v3Max.y, m_attribute.v3Max.z);

  0008e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00091	51		 push	 ecx
  00092	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00097	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	51		 push	 ecx
  000a0	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  000a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000aa	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	51		 push	 ecx
  000ae	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  000b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	51		 push	 ecx
  000bc	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	51		 push	 ecx
  000ca	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000cf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	51		 push	 ecx
  000d8	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  000e7	e8 00 00 00 00	 call	 ?RenderCube@CScreen@@QAEXMMMMMM@Z ; CScreen::RenderCube

; 719  : 	return;
; 720  : }

  000ec	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ef	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f6	59		 pop	 ecx
  000f7	c9		 leave
  000f8	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; CAABBCollisionInstance::Render
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CAABBCollisionInstance@@QBEABUSAABBData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAttribute@CAABBCollisionInstance@@QBEABUSAABBData@@XZ PROC ; CAABBCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 576  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 577  : 
; 578  : 	return m_attribute;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 579  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetAttribute@CAABBCollisionInstance@@QBEABUSAABBData@@XZ ENDP ; CAABBCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ PROC ; CAABBCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 571  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 572  : 	return m_attribute;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 573  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ ENDP ; CAABBCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_fy$ = -228						; size = 4
_fx$ = -224						; size = 4
_fy$ = -220						; size = 4
_fz$ = -216						; size = 4
_fx$ = -212						; size = 4
_fz$ = -208						; size = 4
_fz$ = -204						; size = 4
_fy$ = -200						; size = 4
_fx$ = -196						; size = 4
_fz$ = -192						; size = 4
_fy$ = -188						; size = 4
_fx$ = -184						; size = 4
_fz$ = -180						; size = 4
_fy$ = -176						; size = 4
_fx$ = -172						; size = 4
_fz$ = -168						; size = 4
_fy$ = -164						; size = 4
_fx$ = -160						; size = 4
_fz$ = -156						; size = 4
_fy$ = -152						; size = 4
_fx$ = -148						; size = 4
_fz$ = -144						; size = 4
_fy$ = -140						; size = 4
_fx$ = -136						; size = 4
_this$ = -132						; size = 4
_f$ = -128						; size = 4
_v$ = -124						; size = 4
_f$ = -120						; size = 4
_v$ = -116						; size = 4
_pV1$ = -112						; size = 4
_d$ = -108						; size = 4
_pV1$ = -104						; size = 4
_v$ = -100						; size = 4
_pV1$ = -96						; size = 4
_v$ = -92						; size = 4
_this$ = -88						; size = 4
_t$ = -84						; size = 4
_this$ = -80						; size = 4
$T1 = -76						; size = 12
$T2 = -64						; size = 12
$T3 = -52						; size = 12
$T4 = -40						; size = 12
$T5 = -28						; size = 12
_advance$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CPlaneCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 363  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 364  : 	D3DXVECTOR3 advance = s.v3Position-s.v3LastPosition;

  00016	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00019	83 c0 0c	 add	 eax, 12			; 0000000cH
  0001c	89 45 a4	 mov	 DWORD PTR _v$[ebp], eax
  0001f	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00022	89 45 a8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00025	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 4d a4	 mov	 ecx, DWORD PTR _v$[ebp]
  0002b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0002f	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00033	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0003b	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 4d a4	 mov	 ecx, DWORD PTR _v$[ebp]
  00041	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00046	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0004b	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00053	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d a4	 mov	 ecx, DWORD PTR _v$[ebp]
  00059	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0005e	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00063	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0006b	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00073	f3 0f 11 45 f0	 movss	 DWORD PTR _advance$[ebp], xmm0

; 181  :     y = fy;

  00078	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00080	f3 0f 11 45 f4	 movss	 DWORD PTR _advance$[ebp+4], xmm0

; 182  :     z = fz;

  00085	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0008d	f3 0f 11 45 f8	 movss	 DWORD PTR _advance$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 366  : 	float d = D3DXVec3Dot(&m_attribute.v3Normal, &advance);

  00092	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00095	83 c0 10	 add	 eax, 16			; 00000010H
  00098	89 45 a0	 mov	 DWORD PTR _pV1$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0009b	8b 45 a0	 mov	 eax, DWORD PTR _pV1$[ebp]
  0009e	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000a3	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _advance$[ebp+8]
  000a8	8b 45 a0	 mov	 eax, DWORD PTR _pV1$[ebp]
  000ab	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  000b0	f3 0f 59 4d f4	 mulss	 xmm1, DWORD PTR _advance$[ebp+4]
  000b5	8b 45 a0	 mov	 eax, DWORD PTR _pV1$[ebp]
  000b8	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  000bc	f3 0f 59 55 f0	 mulss	 xmm2, DWORD PTR _advance$[ebp]
  000c1	f3 0f 58 d1	 addss	 xmm2, xmm1
  000c5	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 366  : 	float d = D3DXVec3Dot(&m_attribute.v3Normal, &advance);

  000c9	f3 0f 11 55 94	 movss	 DWORD PTR _d$[ebp], xmm2

; 367  : 	if (d>=-0.0001 && d<=0.0001)

  000ce	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _d$[ebp]
  000d3	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@bf1a36e2eb1c432d
  000db	72 3b		 jb	 SHORT $LN2@OnGetColli
  000dd	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _d$[ebp]
  000e2	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3f1a36e2eb1c432d
  000ea	66 0f 2f c8	 comisd	 xmm1, xmm0
  000ee	72 28		 jb	 SHORT $LN2@OnGetColli
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  000f0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000f3	0f 57 c0	 xorps	 xmm0, xmm0
  000f6	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  000fa	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000fd	0f 57 c0	 xorps	 xmm0, xmm0
  00100	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  00105	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00108	0f 57 c0	 xorps	 xmm0, xmm0
  0010b	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 368  : 		return D3DXVECTOR3(0.0f,0.0f,0.0f);

  00110	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00113	e9 9e 03 00 00	 jmp	 $LN4@OnGetColli
$LN2@OnGetColli:

; 369  : 	float t= - D3DXVec3Dot(&m_attribute.v3Normal, &(s.v3Position-m_attribute.v3Position))/d;

  00118	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0011b	83 c0 04	 add	 eax, 4
  0011e	89 45 9c	 mov	 DWORD PTR _v$[ebp], eax
  00121	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00124	89 85 7c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0012a	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00130	8b 4d 9c	 mov	 ecx, DWORD PTR _v$[ebp]
  00133	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00137	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0013b	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00143	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00149	8b 4d 9c	 mov	 ecx, DWORD PTR _v$[ebp]
  0014c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00151	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00156	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0015e	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00164	8b 4d 9c	 mov	 ecx, DWORD PTR _v$[ebp]
  00167	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0016c	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00171	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00179	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00181	f3 0f 11 45 cc	 movss	 DWORD PTR $T3[ebp], xmm0

; 181  :     y = fy;

  00186	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0018e	f3 0f 11 45 d0	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 182  :     z = fz;

  00193	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0019b	f3 0f 11 45 d4	 movss	 DWORD PTR $T3[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 369  : 	float t= - D3DXVec3Dot(&m_attribute.v3Normal, &(s.v3Position-m_attribute.v3Position))/d;

  001a0	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  001a3	83 c0 10	 add	 eax, 16			; 00000010H
  001a6	89 45 98	 mov	 DWORD PTR _pV1$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  001a9	8b 45 98	 mov	 eax, DWORD PTR _pV1$[ebp]
  001ac	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001b1	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR $T3[ebp+8]
  001b6	8b 45 98	 mov	 eax, DWORD PTR _pV1$[ebp]
  001b9	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  001be	f3 0f 59 4d d0	 mulss	 xmm1, DWORD PTR $T3[ebp+4]
  001c3	8b 45 98	 mov	 eax, DWORD PTR _pV1$[ebp]
  001c6	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  001ca	f3 0f 59 55 cc	 mulss	 xmm2, DWORD PTR $T3[ebp]
  001cf	f3 0f 58 d1	 addss	 xmm2, xmm1
  001d3	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 369  : 	float t= - D3DXVec3Dot(&m_attribute.v3Normal, &(s.v3Position-m_attribute.v3Position))/d;

  001d7	0f 57 15 00 00
	00 00		 xorps	 xmm2, DWORD PTR __xmm@80000000800000008000000080000000
  001de	f3 0f 5e 55 94	 divss	 xmm2, DWORD PTR _d$[ebp]
  001e3	f3 0f 11 55 ac	 movss	 DWORD PTR _t$[ebp], xmm2

; 373  : 	if (D3DXVec3Dot(&m_attribute.v3Normal, &advance)>=0)

  001e8	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  001eb	83 c0 10	 add	 eax, 16			; 00000010H
  001ee	89 45 90	 mov	 DWORD PTR _pV1$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  001f1	8b 45 90	 mov	 eax, DWORD PTR _pV1$[ebp]
  001f4	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001f9	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _advance$[ebp+8]
  001fe	8b 45 90	 mov	 eax, DWORD PTR _pV1$[ebp]
  00201	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00206	f3 0f 59 4d f4	 mulss	 xmm1, DWORD PTR _advance$[ebp+4]
  0020b	8b 45 90	 mov	 eax, DWORD PTR _pV1$[ebp]
  0020e	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00212	f3 0f 59 55 f0	 mulss	 xmm2, DWORD PTR _advance$[ebp]
  00217	f3 0f 58 d1	 addss	 xmm2, xmm1
  0021b	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 373  : 	if (D3DXVec3Dot(&m_attribute.v3Normal, &advance)>=0)

  0021f	0f 2f 15 00 00
	00 00		 comiss	 xmm2, DWORD PTR __real@00000000
  00226	0f 82 4a 01 00
	00		 jb	 $LN3@OnGetColli

; 376  : 		return t*advance -s.fRadius*m_attribute.v3Normal;

  0022c	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0022f	83 c0 10	 add	 eax, 16			; 00000010H
  00232	89 45 8c	 mov	 DWORD PTR _v$[ebp], eax
  00235	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00238	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0023d	f3 0f 11 45 88	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00242	8b 45 8c	 mov	 eax, DWORD PTR _v$[ebp]
  00245	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _f$[ebp]
  0024a	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0024e	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00256	8b 45 8c	 mov	 eax, DWORD PTR _v$[ebp]
  00259	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _f$[ebp]
  0025e	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  00263	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0026b	8b 45 8c	 mov	 eax, DWORD PTR _v$[ebp]
  0026e	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _f$[ebp]
  00273	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00278	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00280	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00288	f3 0f 11 45 e4	 movss	 DWORD PTR $T5[ebp], xmm0

; 181  :     y = fy;

  0028d	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00295	f3 0f 11 45 e8	 movss	 DWORD PTR $T5[ebp+4], xmm0

; 182  :     z = fz;

  0029a	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002a2	f3 0f 11 45 ec	 movss	 DWORD PTR $T5[ebp+8], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  002a7	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _t$[ebp]
  002ac	f3 0f 59 45 f0	 mulss	 xmm0, DWORD PTR _advance$[ebp]
  002b1	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  002b9	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _t$[ebp]
  002be	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _advance$[ebp+4]
  002c3	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  002cb	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _t$[ebp]
  002d0	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _advance$[ebp+8]
  002d5	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  002dd	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002e5	f3 0f 11 45 d8	 movss	 DWORD PTR $T4[ebp], xmm0

; 181  :     y = fy;

  002ea	f3 0f 10 85 68
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002f2	f3 0f 11 45 dc	 movss	 DWORD PTR $T4[ebp+4], xmm0

; 182  :     z = fz;

  002f7	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002ff	f3 0f 11 45 e0	 movss	 DWORD PTR $T4[ebp+8], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00304	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR $T4[ebp]
  00309	f3 0f 5c 45 e4	 subss	 xmm0, DWORD PTR $T5[ebp]
  0030e	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00316	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR $T4[ebp+4]
  0031b	f3 0f 5c 45 e8	 subss	 xmm0, DWORD PTR $T5[ebp+4]
  00320	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00328	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR $T4[ebp+8]
  0032d	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR $T5[ebp+8]
  00332	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0033a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0033d	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00345	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  00349	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0034c	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00354	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  00359	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0035c	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00364	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 376  : 		return t*advance -s.fRadius*m_attribute.v3Normal;

  00369	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0036c	e9 45 01 00 00	 jmp	 $LN4@OnGetColli

; 377  : 	}

  00371	e9 40 01 00 00	 jmp	 $LN4@OnGetColli
$LN3@OnGetColli:

; 381  : 		return t*advance +s.fRadius*m_attribute.v3Normal;

  00376	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00379	83 c0 10	 add	 eax, 16			; 00000010H
  0037c	89 45 84	 mov	 DWORD PTR _v$[ebp], eax
  0037f	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00382	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00387	f3 0f 11 45 80	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0038c	8b 45 84	 mov	 eax, DWORD PTR _v$[ebp]
  0038f	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _f$[ebp]
  00394	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00398	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  003a0	8b 45 84	 mov	 eax, DWORD PTR _v$[ebp]
  003a3	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _f$[ebp]
  003a8	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  003ad	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  003b5	8b 45 84	 mov	 eax, DWORD PTR _v$[ebp]
  003b8	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _f$[ebp]
  003bd	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  003c2	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  003ca	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  003d2	f3 0f 11 45 c0	 movss	 DWORD PTR $T2[ebp], xmm0

; 181  :     y = fy;

  003d7	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  003df	f3 0f 11 45 c4	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 182  :     z = fz;

  003e4	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  003ec	f3 0f 11 45 c8	 movss	 DWORD PTR $T2[ebp+8], xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  003f1	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _t$[ebp]
  003f6	f3 0f 59 45 f0	 mulss	 xmm0, DWORD PTR _advance$[ebp]
  003fb	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00403	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _t$[ebp]
  00408	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _advance$[ebp+4]
  0040d	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00415	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _t$[ebp]
  0041a	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _advance$[ebp+8]
  0041f	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00427	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0042f	f3 0f 11 45 b4	 movss	 DWORD PTR $T1[ebp], xmm0

; 181  :     y = fy;

  00434	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0043c	f3 0f 11 45 b8	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 182  :     z = fz;

  00441	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00449	f3 0f 11 45 bc	 movss	 DWORD PTR $T1[ebp+8], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0044e	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR $T1[ebp]
  00453	f3 0f 58 45 c0	 addss	 xmm0, DWORD PTR $T2[ebp]
  00458	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00460	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR $T1[ebp+4]
  00465	f3 0f 58 45 c4	 addss	 xmm0, DWORD PTR $T2[ebp+4]
  0046a	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00472	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR $T1[ebp+8]
  00477	f3 0f 58 45 c8	 addss	 xmm0, DWORD PTR $T2[ebp+8]
  0047c	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00484	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00487	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0048f	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  00493	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00496	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0049e	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  004a3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  004a6	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  004ae	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 381  : 		return t*advance +s.fRadius*m_attribute.v3Normal;

  004b3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN4@OnGetColli:

; 382  : 	}
; 383  : 
; 384  : 
; 385  : 
; 386  : 	/*if (D3DXVec3Dot(&m_attribute.v3Normal, &advance)>=0)
; 387  : 	{
; 388  : 		Tracef("%f %f\n",s.fRadius,-(D3DXVec3Dot(&m_attribute.v3Normal, &(s.v3Position-m_attribute.v3Position))));
; 389  : 		return m_attribute.v3Normal*((-s.fRadius+D3DXVec3Dot(&m_attribute.v3Normal, &(s.v3Position-m_attribute.v3Position)))*gc_fReduceMove); 
; 390  : 	}
; 391  : 	else
; 392  : 	{
; 393  : 		Tracef("%f %f\n",(s.fRadius),(D3DXVec3Dot(&m_attribute.v3Normal, &(s.v3Position-m_attribute.v3Position))));
; 394  : 		return m_attribute.v3Normal*((s.fRadius+D3DXVec3Dot(&m_attribute.v3Normal, &(s.v3Position-m_attribute.v3Position)))*gc_fReduceMove); 
; 395  : 	}*/
; 396  : 
; 397  : 
; 398  : 	/*
; 399  : 	D3DXVECTOR3 advance = s.v3Position-s.v3LastPosition;
; 400  : 	D3DXVECTOR3 slide(-advance.y,advance.x,advance.z);
; 401  : 	slide = m_attribute.v3Normal;
; 402  : 	
; 403  : 	D3DXVECTOR3 radius_adjust = advance;
; 404  : 	D3DXVec3Normalize(&radius_adjust,&radius_adjust);
; 405  : 	radius_adjust*=s.fRadius;
; 406  : 
; 407  : 	float d = D3DXVec3Dot(&m_attribute.v3Normal, &slide);
; 408  : 	if (d>=-0.0001 && d<=0.0001)
; 409  : 		return D3DXVECTOR3(0.0f,0.0f,0.0f);
; 410  : 	
; 411  : 	float t= - D3DXVec3Dot(&m_attribute.v3Normal, &(s.v3Position+radius_adjust-m_attribute.v3Position))
; 412  : 				/ d;*/
; 413  : 	
; 414  : 	//D3DXVECTOR3 nextposition;
; 415  : 	//nextposition = s.v3Position + t*slide;
; 416  : 	//Tracef("$T %f",t);
; 417  : 	//if (D3DXVec3Dot(&m_attribute.v3Normal, &advance)>=0)
; 418  : 	//	return (t*slide - m_attribute.v3Normal * s.fRadius)/**gc_fReduceMove*/; 
; 419  : 	//else
; 420  : 	//	return (t*slide + m_attribute.v3Normal * s.fRadius)/*gc_fReduceMove*/; 
; 421  : 	//if (D3DXVec3Dot(&m_attribute.v3Normal, &advance)>=0)
; 422  : 	//	return (t*slide + m_attribute.v3Normal * D3DXVec3Dot(&m_attribute.v3Normal,&(s.v3LastPosition-m_attribute.v3Position))/** s.fRadius*/)*gc_fReduceMove; 
; 423  : 	//else
; 424  : 	//	return (t*slide + m_attribute.v3Normal * D3DXVec3Dot(&m_attribute.v3Normal,&(s.v3LastPosition-m_attribute.v3Position))/*s.fRadius*/)*gc_fReduceMove; 
; 425  : 	//
; 426  : }

  004b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004b9	33 cd		 xor	 ecx, ebp
  004bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c0	c9		 leave
  004c1	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CPlaneCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_fz$ = -168						; size = 4
_fy$ = -164						; size = 4
_fx$ = -160						; size = 4
_fz$ = -156						; size = 4
_fy$ = -152						; size = 4
_fx$ = -148						; size = 4
_fz$ = -144						; size = 4
_fy$ = -140						; size = 4
_fx$ = -136						; size = 4
_fz$ = -132						; size = 4
_fy$ = -128						; size = 4
_fx$ = -124						; size = 4
_fPosition2$ = -120					; size = 4
_pV2$ = -116						; size = 4
_pV2$ = -112						; size = 4
_pV2$ = -108						; size = 4
_pV2$ = -104						; size = 4
_v$ = -100						; size = 4
_this$ = -96						; size = 4
_v$ = -92						; size = 4
_this$ = -88						; size = 4
_pV1$ = -84						; size = 4
_pV1$ = -80						; size = 4
_v$ = -76						; size = 4
_this$ = -72						; size = 4
_v$ = -68						; size = 4
_this$ = -64						; size = 4
_fPosition1$ = -60					; size = 4
_this$ = -56						; size = 4
_v3SpherePosition$ = -52				; size = 12
_v3SphereLastPosition$ = -40				; size = 12
_v3QuadPosition1$1 = -28				; size = 12
_v3QuadPosition2$2 = -16				; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CPlaneCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 335  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 336  : 	//Tracef("OnCollisionDynamicSphere\n");
; 337  : 	
; 338  : 	D3DXVECTOR3 v3SpherePosition = s.v3Position - m_attribute.v3Position;

  00016	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c0 04	 add	 eax, 4
  0001c	89 45 bc	 mov	 DWORD PTR _v$[ebp], eax
  0001f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00022	89 45 c0	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00025	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 4d bc	 mov	 ecx, DWORD PTR _v$[ebp]
  0002b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0002f	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00033	f3 0f 11 45 84	 movss	 DWORD PTR _fx$[ebp], xmm0
  00038	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 4d bc	 mov	 ecx, DWORD PTR _v$[ebp]
  0003e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00043	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00048	f3 0f 11 45 80	 movss	 DWORD PTR _fy$[ebp], xmm0
  0004d	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d bc	 mov	 ecx, DWORD PTR _v$[ebp]
  00053	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00058	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0005d	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00065	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0006a	f3 0f 11 45 cc	 movss	 DWORD PTR _v3SpherePosition$[ebp], xmm0

; 181  :     y = fy;

  0006f	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00074	f3 0f 11 45 d0	 movss	 DWORD PTR _v3SpherePosition$[ebp+4], xmm0

; 182  :     z = fz;

  00079	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00081	f3 0f 11 45 d4	 movss	 DWORD PTR _v3SpherePosition$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 339  : 	D3DXVECTOR3 v3SphereLastPosition = s.v3LastPosition - m_attribute.v3Position;

  00086	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00089	83 c0 04	 add	 eax, 4
  0008c	89 45 b4	 mov	 DWORD PTR _v$[ebp], eax
  0008f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00092	83 c0 0c	 add	 eax, 12			; 0000000cH
  00095	89 45 b8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00098	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 4d b4	 mov	 ecx, DWORD PTR _v$[ebp]
  0009e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000a2	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  000a6	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  000ae	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b 4d b4	 mov	 ecx, DWORD PTR _v$[ebp]
  000b4	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000b9	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  000be	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  000c6	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	8b 4d b4	 mov	 ecx, DWORD PTR _v$[ebp]
  000cc	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000d1	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  000d6	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  000de	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000e6	f3 0f 11 45 d8	 movss	 DWORD PTR _v3SphereLastPosition$[ebp], xmm0

; 181  :     y = fy;

  000eb	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  000f3	f3 0f 11 45 dc	 movss	 DWORD PTR _v3SphereLastPosition$[ebp+4], xmm0

; 182  :     z = fz;

  000f8	f3 0f 10 85 70
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00100	f3 0f 11 45 e0	 movss	 DWORD PTR _v3SphereLastPosition$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 341  : 	float fPosition1 = D3DXVec3Dot(&m_attribute.v3Normal, &v3SpherePosition);

  00105	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00108	83 c0 10	 add	 eax, 16			; 00000010H
  0010b	89 45 b0	 mov	 DWORD PTR _pV1$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0010e	8b 45 b0	 mov	 eax, DWORD PTR _pV1$[ebp]
  00111	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00116	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _v3SpherePosition$[ebp+8]
  0011b	8b 45 b0	 mov	 eax, DWORD PTR _pV1$[ebp]
  0011e	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00123	f3 0f 59 4d d0	 mulss	 xmm1, DWORD PTR _v3SpherePosition$[ebp+4]
  00128	8b 45 b0	 mov	 eax, DWORD PTR _pV1$[ebp]
  0012b	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0012f	f3 0f 59 55 cc	 mulss	 xmm2, DWORD PTR _v3SpherePosition$[ebp]
  00134	f3 0f 58 d1	 addss	 xmm2, xmm1
  00138	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 341  : 	float fPosition1 = D3DXVec3Dot(&m_attribute.v3Normal, &v3SpherePosition);

  0013c	f3 0f 11 55 c4	 movss	 DWORD PTR _fPosition1$[ebp], xmm2

; 342  : 	float fPosition2 = D3DXVec3Dot(&m_attribute.v3Normal, &v3SphereLastPosition);

  00141	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00144	83 c0 10	 add	 eax, 16			; 00000010H
  00147	89 45 ac	 mov	 DWORD PTR _pV1$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0014a	8b 45 ac	 mov	 eax, DWORD PTR _pV1$[ebp]
  0014d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00152	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _v3SphereLastPosition$[ebp+8]
  00157	8b 45 ac	 mov	 eax, DWORD PTR _pV1$[ebp]
  0015a	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0015f	f3 0f 59 4d dc	 mulss	 xmm1, DWORD PTR _v3SphereLastPosition$[ebp+4]
  00164	8b 45 ac	 mov	 eax, DWORD PTR _pV1$[ebp]
  00167	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0016b	f3 0f 59 55 d8	 mulss	 xmm2, DWORD PTR _v3SphereLastPosition$[ebp]
  00170	f3 0f 58 d1	 addss	 xmm2, xmm1
  00174	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 342  : 	float fPosition2 = D3DXVec3Dot(&m_attribute.v3Normal, &v3SphereLastPosition);

  00178	f3 0f 11 55 88	 movss	 DWORD PTR _fPosition2$[ebp], xmm2

; 343  : 	
; 344  : 	if (fPosition1 >0.0f && fPosition2 < 0.0f  || fPosition1 <0.0f && fPosition2 >0.0f 
; 345  : 		|| (fPosition1) <= s.fRadius && fPosition1 >= -s.fRadius)

  0017d	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fPosition1$[ebp]
  00182	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00189	76 09		 jbe	 SHORT $LN4@OnCollisio
  0018b	0f 57 c0	 xorps	 xmm0, xmm0
  0018e	0f 2f 45 88	 comiss	 xmm0, DWORD PTR _fPosition2$[ebp]
  00192	77 46		 ja	 SHORT $LN3@OnCollisio
$LN4@OnCollisio:
  00194	0f 57 c0	 xorps	 xmm0, xmm0
  00197	0f 2f 45 c4	 comiss	 xmm0, DWORD PTR _fPosition1$[ebp]
  0019b	76 0e		 jbe	 SHORT $LN5@OnCollisio
  0019d	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _fPosition2$[ebp]
  001a2	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  001a9	77 2f		 ja	 SHORT $LN3@OnCollisio
$LN5@OnCollisio:
  001ab	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001ae	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  001b3	0f 2f 45 c4	 comiss	 xmm0, DWORD PTR _fPosition1$[ebp]
  001b7	0f 82 76 02 00
	00		 jb	 $LN9@OnCollisio
  001bd	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001c0	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  001c5	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001cc	f3 0f 10 4d c4	 movss	 xmm1, DWORD PTR _fPosition1$[ebp]
  001d1	0f 2f c8	 comiss	 xmm1, xmm0
  001d4	0f 82 59 02 00
	00		 jb	 $LN9@OnCollisio
$LN3@OnCollisio:

; 346  : 	{
; 347  : 		D3DXVECTOR3 v3QuadPosition1 = s.v3Position - m_attribute.v3QuadPosition[0];

  001da	6a 0c		 push	 12			; 0000000cH
  001dc	58		 pop	 eax
  001dd	6b c0 00	 imul	 eax, eax, 0
  001e0	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e3	8d 44 01 1c	 lea	 eax, DWORD PTR [ecx+eax+28]
  001e7	89 45 a4	 mov	 DWORD PTR _v$[ebp], eax
  001ea	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001ed	89 45 a8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001f0	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  001f3	8b 4d a4	 mov	 ecx, DWORD PTR _v$[ebp]
  001f6	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001fa	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  001fe	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00206	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00209	8b 4d a4	 mov	 ecx, DWORD PTR _v$[ebp]
  0020c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00211	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00216	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0021e	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00221	8b 4d a4	 mov	 ecx, DWORD PTR _v$[ebp]
  00224	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00229	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0022e	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00236	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0023e	f3 0f 11 45 e4	 movss	 DWORD PTR _v3QuadPosition1$1[ebp], xmm0

; 181  :     y = fy;

  00243	f3 0f 10 85 68
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0024b	f3 0f 11 45 e8	 movss	 DWORD PTR _v3QuadPosition1$1[ebp+4], xmm0

; 182  :     z = fz;

  00250	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00258	f3 0f 11 45 ec	 movss	 DWORD PTR _v3QuadPosition1$1[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 348  : 		D3DXVECTOR3 v3QuadPosition2 = s.v3Position - m_attribute.v3QuadPosition[3];

  0025d	6a 0c		 push	 12			; 0000000cH
  0025f	58		 pop	 eax
  00260	6b c0 03	 imul	 eax, eax, 3
  00263	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00266	8d 44 01 1c	 lea	 eax, DWORD PTR [ecx+eax+28]
  0026a	89 45 9c	 mov	 DWORD PTR _v$[ebp], eax
  0026d	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00270	89 45 a0	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00273	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  00276	8b 4d 9c	 mov	 ecx, DWORD PTR _v$[ebp]
  00279	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0027d	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00281	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00289	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  0028c	8b 4d 9c	 mov	 ecx, DWORD PTR _v$[ebp]
  0028f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00294	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00299	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  002a1	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  002a4	8b 4d 9c	 mov	 ecx, DWORD PTR _v$[ebp]
  002a7	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002ac	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  002b1	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  002b9	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002c1	f3 0f 11 45 f0	 movss	 DWORD PTR _v3QuadPosition2$2[ebp], xmm0

; 181  :     y = fy;

  002c6	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002ce	f3 0f 11 45 f4	 movss	 DWORD PTR _v3QuadPosition2$2[ebp+4], xmm0

; 182  :     z = fz;

  002d3	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002db	f3 0f 11 45 f8	 movss	 DWORD PTR _v3QuadPosition2$2[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 350  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  002e0	6a 0c		 push	 12			; 0000000cH
  002e2	58		 pop	 eax
  002e3	6b c0 00	 imul	 eax, eax, 0
  002e6	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002e9	8d 44 01 4c	 lea	 eax, DWORD PTR [ecx+eax+76]
  002ed	89 45 98	 mov	 DWORD PTR _pV2$[ebp], eax
  002f0	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  002f3	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  002f8	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  002ff	8b 45 98	 mov	 eax, DWORD PTR _pV2$[ebp]
  00302	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _v3QuadPosition1$1[ebp+8]
  00307	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  0030c	8b 45 98	 mov	 eax, DWORD PTR _pV2$[ebp]
  0030f	f3 0f 10 55 e8	 movss	 xmm2, DWORD PTR _v3QuadPosition1$1[ebp+4]
  00314	f3 0f 59 50 04	 mulss	 xmm2, DWORD PTR [eax+4]
  00319	8b 45 98	 mov	 eax, DWORD PTR _pV2$[ebp]
  0031c	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _v3QuadPosition1$1[ebp]
  00321	f3 0f 59 18	 mulss	 xmm3, DWORD PTR [eax]
  00325	f3 0f 58 da	 addss	 xmm3, xmm2
  00329	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 350  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  0032d	0f 2f d8	 comiss	 xmm3, xmm0
  00330	0f 86 fd 00 00
	00		 jbe	 $LN9@OnCollisio

; 351  : 			if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[1]) > -s.fRadius/*0.0f*/)

  00336	6a 0c		 push	 12			; 0000000cH
  00338	58		 pop	 eax
  00339	c1 e0 00	 shl	 eax, 0
  0033c	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0033f	8d 44 01 4c	 lea	 eax, DWORD PTR [ecx+eax+76]
  00343	89 45 8c	 mov	 DWORD PTR _pV2$[ebp], eax
  00346	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00349	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0034e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00355	8b 45 8c	 mov	 eax, DWORD PTR _pV2$[ebp]
  00358	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _v3QuadPosition1$1[ebp+8]
  0035d	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  00362	8b 45 8c	 mov	 eax, DWORD PTR _pV2$[ebp]
  00365	f3 0f 10 55 e8	 movss	 xmm2, DWORD PTR _v3QuadPosition1$1[ebp+4]
  0036a	f3 0f 59 50 04	 mulss	 xmm2, DWORD PTR [eax+4]
  0036f	8b 45 8c	 mov	 eax, DWORD PTR _pV2$[ebp]
  00372	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _v3QuadPosition1$1[ebp]
  00377	f3 0f 59 18	 mulss	 xmm3, DWORD PTR [eax]
  0037b	f3 0f 58 da	 addss	 xmm3, xmm2
  0037f	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 351  : 			if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[1]) > -s.fRadius/*0.0f*/)

  00383	0f 2f d8	 comiss	 xmm3, xmm0
  00386	0f 86 a7 00 00
	00		 jbe	 $LN9@OnCollisio

; 352  : 				if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[2]) > - s.fRadius/*0.0f*/)

  0038c	6a 0c		 push	 12			; 0000000cH
  0038e	58		 pop	 eax
  0038f	d1 e0		 shl	 eax, 1
  00391	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00394	8d 44 01 4c	 lea	 eax, DWORD PTR [ecx+eax+76]
  00398	89 45 90	 mov	 DWORD PTR _pV2$[ebp], eax
  0039b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0039e	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  003a3	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  003aa	8b 45 90	 mov	 eax, DWORD PTR _pV2$[ebp]
  003ad	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _v3QuadPosition2$2[ebp+8]
  003b2	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  003b7	8b 45 90	 mov	 eax, DWORD PTR _pV2$[ebp]
  003ba	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _v3QuadPosition2$2[ebp+4]
  003bf	f3 0f 59 50 04	 mulss	 xmm2, DWORD PTR [eax+4]
  003c4	8b 45 90	 mov	 eax, DWORD PTR _pV2$[ebp]
  003c7	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _v3QuadPosition2$2[ebp]
  003cc	f3 0f 59 18	 mulss	 xmm3, DWORD PTR [eax]
  003d0	f3 0f 58 da	 addss	 xmm3, xmm2
  003d4	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 352  : 				if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[2]) > - s.fRadius/*0.0f*/)

  003d8	0f 2f d8	 comiss	 xmm3, xmm0
  003db	76 56		 jbe	 SHORT $LN9@OnCollisio

; 353  : 					if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[3]) > - s.fRadius/*0.0f*/)

  003dd	6a 0c		 push	 12			; 0000000cH
  003df	58		 pop	 eax
  003e0	6b c0 03	 imul	 eax, eax, 3
  003e3	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  003e6	8d 44 01 4c	 lea	 eax, DWORD PTR [ecx+eax+76]
  003ea	89 45 94	 mov	 DWORD PTR _pV2$[ebp], eax
  003ed	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  003f0	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  003f5	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  003fc	8b 45 94	 mov	 eax, DWORD PTR _pV2$[ebp]
  003ff	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _v3QuadPosition2$2[ebp+8]
  00404	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  00409	8b 45 94	 mov	 eax, DWORD PTR _pV2$[ebp]
  0040c	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _v3QuadPosition2$2[ebp+4]
  00411	f3 0f 59 50 04	 mulss	 xmm2, DWORD PTR [eax+4]
  00416	8b 45 94	 mov	 eax, DWORD PTR _pV2$[ebp]
  00419	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _v3QuadPosition2$2[ebp]
  0041e	f3 0f 59 18	 mulss	 xmm3, DWORD PTR [eax]
  00422	f3 0f 58 da	 addss	 xmm3, xmm2
  00426	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 353  : 					if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[3]) > - s.fRadius/*0.0f*/)

  0042a	0f 2f d8	 comiss	 xmm3, xmm0
  0042d	76 04		 jbe	 SHORT $LN9@OnCollisio

; 354  : 					{
; 355  : 						return true;

  0042f	b0 01		 mov	 al, 1
  00431	eb 02		 jmp	 SHORT $LN1@OnCollisio
$LN9@OnCollisio:

; 356  : 					}
; 357  : 	}
; 358  : 	
; 359  : 	return false;

  00433	32 c0		 xor	 al, al
$LN1@OnCollisio:

; 360  : }

  00435	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00438	33 cd		 xor	 ecx, ebp
  0043a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0043f	c9		 leave
  00440	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CPlaneCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
tv1042 = -272						; size = 8
tv1037 = -264						; size = 8
tv1032 = -256						; size = 8
_fz$ = -248						; size = 4
_fy$ = -244						; size = 4
_fx$ = -240						; size = 4
_fz$ = -236						; size = 4
_fy$ = -232						; size = 4
_fy$ = -228						; size = 4
$T1 = -224						; size = 4
$T2 = -220						; size = 4
_fz$ = -216						; size = 4
_fx$ = -212						; size = 4
_fx$ = -208						; size = 4
_fz$ = -204						; size = 4
_fy$ = -200						; size = 4
_fx$ = -196						; size = 4
_fz$ = -192						; size = 4
_fy$ = -188						; size = 4
_fx$ = -184						; size = 4
_fz$ = -180						; size = 4
_fy$ = -176						; size = 4
_fx$ = -172						; size = 4
_fPosition2$ = -168					; size = 4
_pV2$ = -164						; size = 4
_v$ = -160						; size = 4
_this$ = -156						; size = 4
_pV2$ = -152						; size = 4
_v$ = -148						; size = 4
_this$ = -144						; size = 4
_pV2$ = -140						; size = 4
_pV2$ = -136						; size = 4
_pV2$ = -132						; size = 4
_pV2$ = -128						; size = 4
_v$ = -124						; size = 4
_this$ = -120						; size = 4
_v$ = -116						; size = 4
_this$ = -112						; size = 4
_pV1$ = -108						; size = 4
_pV1$ = -104						; size = 4
_v$ = -100						; size = 4
_this$ = -96						; size = 4
_v$ = -92						; size = 4
_this$ = -88						; size = 4
_fPosition1$ = -84					; size = 4
_this$ = -80						; size = 4
$T3 = -76						; size = 12
_v3SphereLastPosition$ = -64				; size = 12
_v3SpherePosition$ = -52				; size = 12
$T4 = -40						; size = 12
_v3QuadPosition2$5 = -28				; size = 12
_v3QuadPosition1$6 = -16				; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CPlaneCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 307  : 	D3DXVECTOR3 v3SpherePosition = s.v3Position - m_attribute.v3Position;

  00016	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 c0 04	 add	 eax, 4
  0001c	89 45 a4	 mov	 DWORD PTR _v$[ebp], eax
  0001f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00022	89 45 a8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00025	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 4d a4	 mov	 ecx, DWORD PTR _v$[ebp]
  0002b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0002f	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00033	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0003b	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 4d a4	 mov	 ecx, DWORD PTR _v$[ebp]
  00041	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00046	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0004b	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00053	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 4d a4	 mov	 ecx, DWORD PTR _v$[ebp]
  00059	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0005e	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00063	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0006b	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00073	f3 0f 11 45 cc	 movss	 DWORD PTR _v3SpherePosition$[ebp], xmm0

; 181  :     y = fy;

  00078	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00080	f3 0f 11 45 d0	 movss	 DWORD PTR _v3SpherePosition$[ebp+4], xmm0

; 182  :     z = fz;

  00085	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0008d	f3 0f 11 45 d4	 movss	 DWORD PTR _v3SpherePosition$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 308  : 	D3DXVECTOR3 v3SphereLastPosition = s.v3LastPosition - m_attribute.v3Position;

  00092	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00095	83 c0 04	 add	 eax, 4
  00098	89 45 9c	 mov	 DWORD PTR _v$[ebp], eax
  0009b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0009e	83 c0 0c	 add	 eax, 12			; 0000000cH
  000a1	89 45 a0	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000a4	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	8b 4d 9c	 mov	 ecx, DWORD PTR _v$[ebp]
  000aa	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000ae	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  000b2	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  000ba	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	8b 4d 9c	 mov	 ecx, DWORD PTR _v$[ebp]
  000c0	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000c5	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  000ca	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  000d2	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  000d5	8b 4d 9c	 mov	 ecx, DWORD PTR _v$[ebp]
  000d8	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000dd	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  000e2	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  000ea	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000f2	f3 0f 11 45 c0	 movss	 DWORD PTR _v3SphereLastPosition$[ebp], xmm0

; 181  :     y = fy;

  000f7	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  000ff	f3 0f 11 45 c4	 movss	 DWORD PTR _v3SphereLastPosition$[ebp+4], xmm0

; 182  :     z = fz;

  00104	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0010c	f3 0f 11 45 c8	 movss	 DWORD PTR _v3SphereLastPosition$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 310  : 	float fPosition1 = D3DXVec3Dot(&m_attribute.v3Normal, &v3SpherePosition);

  00111	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00114	83 c0 10	 add	 eax, 16			; 00000010H
  00117	89 45 98	 mov	 DWORD PTR _pV1$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0011a	8b 45 98	 mov	 eax, DWORD PTR _pV1$[ebp]
  0011d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00122	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _v3SpherePosition$[ebp+8]
  00127	8b 45 98	 mov	 eax, DWORD PTR _pV1$[ebp]
  0012a	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0012f	f3 0f 59 4d d0	 mulss	 xmm1, DWORD PTR _v3SpherePosition$[ebp+4]
  00134	8b 45 98	 mov	 eax, DWORD PTR _pV1$[ebp]
  00137	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  0013b	f3 0f 59 55 cc	 mulss	 xmm2, DWORD PTR _v3SpherePosition$[ebp]
  00140	f3 0f 58 d1	 addss	 xmm2, xmm1
  00144	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 310  : 	float fPosition1 = D3DXVec3Dot(&m_attribute.v3Normal, &v3SpherePosition);

  00148	f3 0f 11 55 ac	 movss	 DWORD PTR _fPosition1$[ebp], xmm2

; 311  : 	float fPosition2 = D3DXVec3Dot(&m_attribute.v3Normal, &v3SphereLastPosition);

  0014d	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00150	83 c0 10	 add	 eax, 16			; 00000010H
  00153	89 45 94	 mov	 DWORD PTR _pV1$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00156	8b 45 94	 mov	 eax, DWORD PTR _pV1$[ebp]
  00159	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0015e	f3 0f 59 45 c8	 mulss	 xmm0, DWORD PTR _v3SphereLastPosition$[ebp+8]
  00163	8b 45 94	 mov	 eax, DWORD PTR _pV1$[ebp]
  00166	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0016b	f3 0f 59 4d c4	 mulss	 xmm1, DWORD PTR _v3SphereLastPosition$[ebp+4]
  00170	8b 45 94	 mov	 eax, DWORD PTR _pV1$[ebp]
  00173	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00177	f3 0f 59 55 c0	 mulss	 xmm2, DWORD PTR _v3SphereLastPosition$[ebp]
  0017c	f3 0f 58 d1	 addss	 xmm2, xmm1
  00180	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 311  : 	float fPosition2 = D3DXVec3Dot(&m_attribute.v3Normal, &v3SphereLastPosition);

  00184	f3 0f 11 95 58
	ff ff ff	 movss	 DWORD PTR _fPosition2$[ebp], xmm2

; 312  : 
; 313  : 	if (fPosition1 >0.0f && fPosition2 < 0.0f  || fPosition1 <0.0f && fPosition2 >0.0f 
; 314  : 		|| (fPosition1) <= s.fRadius && fPosition1 >= -s.fRadius)

  0018c	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fPosition1$[ebp]
  00191	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00198	76 0c		 jbe	 SHORT $LN4@OnMovement
  0019a	0f 57 c0	 xorps	 xmm0, xmm0
  0019d	0f 2f 85 58 ff
	ff ff		 comiss	 xmm0, DWORD PTR _fPosition2$[ebp]
  001a4	77 49		 ja	 SHORT $LN3@OnMovement
$LN4@OnMovement:
  001a6	0f 57 c0	 xorps	 xmm0, xmm0
  001a9	0f 2f 45 ac	 comiss	 xmm0, DWORD PTR _fPosition1$[ebp]
  001ad	76 11		 jbe	 SHORT $LN5@OnMovement
  001af	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _fPosition2$[ebp]
  001b7	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  001be	77 2f		 ja	 SHORT $LN3@OnMovement
$LN5@OnMovement:
  001c0	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001c3	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  001c8	0f 2f 45 ac	 comiss	 xmm0, DWORD PTR _fPosition1$[ebp]
  001cc	0f 82 c1 04 00
	00		 jb	 $LN10@OnMovement
  001d2	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001d5	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  001da	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001e1	f3 0f 10 4d ac	 movss	 xmm1, DWORD PTR _fPosition1$[ebp]
  001e6	0f 2f c8	 comiss	 xmm1, xmm0
  001e9	0f 82 a4 04 00
	00		 jb	 $LN10@OnMovement
$LN3@OnMovement:

; 315  : 	{
; 316  : 		D3DXVECTOR3 v3QuadPosition1 = s.v3Position - m_attribute.v3QuadPosition[0];

  001ef	6a 0c		 push	 12			; 0000000cH
  001f1	58		 pop	 eax
  001f2	6b c0 00	 imul	 eax, eax, 0
  001f5	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  001f8	8d 44 01 1c	 lea	 eax, DWORD PTR [ecx+eax+28]
  001fc	89 45 8c	 mov	 DWORD PTR _v$[ebp], eax
  001ff	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00202	89 45 90	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00205	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00208	8b 4d 8c	 mov	 ecx, DWORD PTR _v$[ebp]
  0020b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0020f	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00213	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0021b	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0021e	8b 4d 8c	 mov	 ecx, DWORD PTR _v$[ebp]
  00221	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00226	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0022b	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00233	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00236	8b 4d 8c	 mov	 ecx, DWORD PTR _v$[ebp]
  00239	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0023e	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00243	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0024b	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00253	f3 0f 11 45 f0	 movss	 DWORD PTR _v3QuadPosition1$6[ebp], xmm0

; 181  :     y = fy;

  00258	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00260	f3 0f 11 45 f4	 movss	 DWORD PTR _v3QuadPosition1$6[ebp+4], xmm0

; 182  :     z = fz;

  00265	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0026d	f3 0f 11 45 f8	 movss	 DWORD PTR _v3QuadPosition1$6[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 317  : 		D3DXVECTOR3 v3QuadPosition2 = s.v3Position - m_attribute.v3QuadPosition[3];

  00272	6a 0c		 push	 12			; 0000000cH
  00274	58		 pop	 eax
  00275	6b c0 03	 imul	 eax, eax, 3
  00278	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0027b	8d 44 01 1c	 lea	 eax, DWORD PTR [ecx+eax+28]
  0027f	89 45 84	 mov	 DWORD PTR _v$[ebp], eax
  00282	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00285	89 45 88	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00288	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  0028b	8b 4d 84	 mov	 ecx, DWORD PTR _v$[ebp]
  0028e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00292	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00296	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0029e	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  002a1	8b 4d 84	 mov	 ecx, DWORD PTR _v$[ebp]
  002a4	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  002a9	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  002ae	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  002b6	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  002b9	8b 4d 84	 mov	 ecx, DWORD PTR _v$[ebp]
  002bc	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002c1	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  002c6	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  002ce	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002d6	f3 0f 11 45 e4	 movss	 DWORD PTR _v3QuadPosition2$5[ebp], xmm0

; 181  :     y = fy;

  002db	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002e3	f3 0f 11 45 e8	 movss	 DWORD PTR _v3QuadPosition2$5[ebp+4], xmm0

; 182  :     z = fz;

  002e8	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002f0	f3 0f 11 45 ec	 movss	 DWORD PTR _v3QuadPosition2$5[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 319  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  002f5	6a 0c		 push	 12			; 0000000cH
  002f7	58		 pop	 eax
  002f8	6b c0 00	 imul	 eax, eax, 0
  002fb	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  002fe	8d 44 01 4c	 lea	 eax, DWORD PTR [ecx+eax+76]
  00302	89 45 80	 mov	 DWORD PTR _pV2$[ebp], eax
  00305	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00308	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0030d	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00314	8b 45 80	 mov	 eax, DWORD PTR _pV2$[ebp]
  00317	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _v3QuadPosition1$6[ebp+8]
  0031c	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  00321	8b 45 80	 mov	 eax, DWORD PTR _pV2$[ebp]
  00324	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _v3QuadPosition1$6[ebp+4]
  00329	f3 0f 59 50 04	 mulss	 xmm2, DWORD PTR [eax+4]
  0032e	8b 45 80	 mov	 eax, DWORD PTR _pV2$[ebp]
  00331	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _v3QuadPosition1$6[ebp]
  00336	f3 0f 59 18	 mulss	 xmm3, DWORD PTR [eax]
  0033a	f3 0f 58 da	 addss	 xmm3, xmm2
  0033e	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 319  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  00342	0f 2f d8	 comiss	 xmm3, xmm0
  00345	0f 86 48 03 00
	00		 jbe	 $LN10@OnMovement

; 320  : 			if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[1]) > -s.fRadius/*0.0f*/)

  0034b	6a 0c		 push	 12			; 0000000cH
  0034d	58		 pop	 eax
  0034e	c1 e0 00	 shl	 eax, 0
  00351	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00354	8d 44 01 4c	 lea	 eax, DWORD PTR [ecx+eax+76]
  00358	89 85 7c ff ff
	ff		 mov	 DWORD PTR _pV2$[ebp], eax
  0035e	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00361	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00366	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0036d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00373	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _v3QuadPosition1$6[ebp+8]
  00378	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  0037d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00383	f3 0f 10 55 f4	 movss	 xmm2, DWORD PTR _v3QuadPosition1$6[ebp+4]
  00388	f3 0f 59 50 04	 mulss	 xmm2, DWORD PTR [eax+4]
  0038d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00393	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR _v3QuadPosition1$6[ebp]
  00398	f3 0f 59 18	 mulss	 xmm3, DWORD PTR [eax]
  0039c	f3 0f 58 da	 addss	 xmm3, xmm2
  003a0	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 320  : 			if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[1]) > -s.fRadius/*0.0f*/)

  003a4	0f 2f d8	 comiss	 xmm3, xmm0
  003a7	0f 86 e6 02 00
	00		 jbe	 $LN10@OnMovement

; 321  : 				if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[2]) > - s.fRadius/*0.0f*/)

  003ad	6a 0c		 push	 12			; 0000000cH
  003af	58		 pop	 eax
  003b0	d1 e0		 shl	 eax, 1
  003b2	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  003b5	8d 44 01 4c	 lea	 eax, DWORD PTR [ecx+eax+76]
  003b9	89 85 78 ff ff
	ff		 mov	 DWORD PTR _pV2$[ebp], eax
  003bf	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  003c2	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  003c7	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  003ce	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  003d4	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _v3QuadPosition2$5[ebp+8]
  003d9	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  003de	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  003e4	f3 0f 10 55 e8	 movss	 xmm2, DWORD PTR _v3QuadPosition2$5[ebp+4]
  003e9	f3 0f 59 50 04	 mulss	 xmm2, DWORD PTR [eax+4]
  003ee	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  003f4	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _v3QuadPosition2$5[ebp]
  003f9	f3 0f 59 18	 mulss	 xmm3, DWORD PTR [eax]
  003fd	f3 0f 58 da	 addss	 xmm3, xmm2
  00401	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 321  : 				if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[2]) > - s.fRadius/*0.0f*/)

  00405	0f 2f d8	 comiss	 xmm3, xmm0
  00408	0f 86 85 02 00
	00		 jbe	 $LN10@OnMovement

; 322  : 					if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[3]) > - s.fRadius/*0.0f*/)

  0040e	6a 0c		 push	 12			; 0000000cH
  00410	58		 pop	 eax
  00411	6b c0 03	 imul	 eax, eax, 3
  00414	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00417	8d 44 01 4c	 lea	 eax, DWORD PTR [ecx+eax+76]
  0041b	89 85 74 ff ff
	ff		 mov	 DWORD PTR _pV2$[ebp], eax
  00421	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00424	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00429	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00430	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00436	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _v3QuadPosition2$5[ebp+8]
  0043b	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  00440	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00446	f3 0f 10 55 e8	 movss	 xmm2, DWORD PTR _v3QuadPosition2$5[ebp+4]
  0044b	f3 0f 59 50 04	 mulss	 xmm2, DWORD PTR [eax+4]
  00450	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00456	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR _v3QuadPosition2$5[ebp]
  0045b	f3 0f 59 18	 mulss	 xmm3, DWORD PTR [eax]
  0045f	f3 0f 58 da	 addss	 xmm3, xmm2
  00463	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 322  : 					if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[3]) > - s.fRadius/*0.0f*/)

  00467	0f 2f d8	 comiss	 xmm3, xmm0
  0046a	0f 86 23 02 00
	00		 jbe	 $LN10@OnMovement

; 325  : 						if (fabs(D3DXVec3Dot(&(s.v3Position - m_attribute.v3Position), &m_attribute.v3Normal)) <

  00470	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00473	83 c0 04	 add	 eax, 4
  00476	89 85 6c ff ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  0047c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0047f	89 85 70 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00485	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0048b	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00491	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00495	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00499	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  004a1	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004a7	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  004ad	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  004b2	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  004b7	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  004bf	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004c5	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  004cb	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  004d0	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  004d5	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  004dd	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  004e5	f3 0f 11 45 b4	 movss	 DWORD PTR $T3[ebp], xmm0

; 181  :     y = fy;

  004ea	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  004f2	f3 0f 11 45 b8	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 182  :     z = fz;

  004f7	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  004ff	f3 0f 11 45 bc	 movss	 DWORD PTR $T3[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 325  : 						if (fabs(D3DXVec3Dot(&(s.v3Position - m_attribute.v3Position), &m_attribute.v3Normal)) <

  00504	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00507	83 c0 10	 add	 eax, 16			; 00000010H
  0050a	89 85 68 ff ff
	ff		 mov	 DWORD PTR _pV2$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00510	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00516	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR $T3[ebp]
  0051b	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0051f	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00525	f3 0f 10 4d b8	 movss	 xmm1, DWORD PTR $T3[ebp+4]
  0052a	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  0052f	f3 0f 58 c1	 addss	 xmm0, xmm1
  00533	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00539	f3 0f 10 4d bc	 movss	 xmm1, DWORD PTR $T3[ebp+8]
  0053e	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  00543	f3 0f 58 c1	 addss	 xmm0, xmm1
  00547	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR $T2[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 325  : 						if (fabs(D3DXVec3Dot(&(s.v3Position - m_attribute.v3Position), &m_attribute.v3Normal)) <

  0054f	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00552	83 c0 04	 add	 eax, 4
  00555	89 85 60 ff ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  0055b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0055e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00561	89 85 64 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00567	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0056d	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00573	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00577	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0057b	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00583	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00589	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  0058f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00594	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00599	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  005a1	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005a7	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  005ad	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  005b2	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  005b7	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  005bf	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  005c7	f3 0f 11 45 d8	 movss	 DWORD PTR $T4[ebp], xmm0

; 181  :     y = fy;

  005cc	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  005d4	f3 0f 11 45 dc	 movss	 DWORD PTR $T4[ebp+4], xmm0

; 182  :     z = fz;

  005d9	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  005e1	f3 0f 11 45 e0	 movss	 DWORD PTR $T4[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 325  : 						if (fabs(D3DXVec3Dot(&(s.v3Position - m_attribute.v3Position), &m_attribute.v3Normal)) <

  005e6	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  005e9	83 c0 10	 add	 eax, 16			; 00000010H
  005ec	89 85 5c ff ff
	ff		 mov	 DWORD PTR _pV2$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  005f2	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  005f8	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR $T4[ebp]
  005fd	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00601	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00607	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR $T4[ebp+4]
  0060c	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  00611	f3 0f 58 c1	 addss	 xmm0, xmm1
  00615	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  0061b	f3 0f 10 4d e0	 movss	 xmm1, DWORD PTR $T4[ebp+8]
  00620	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  00625	f3 0f 58 c1	 addss	 xmm0, xmm1
  00629	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR $T1[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 325  : 						if (fabs(D3DXVec3Dot(&(s.v3Position - m_attribute.v3Position), &m_attribute.v3Normal)) <

  00631	f3 0f 5a 85 24
	ff ff ff	 cvtss2sd xmm0, DWORD PTR $T2[ebp]
  00639	51		 push	 ecx
  0063a	51		 push	 ecx
  0063b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00640	e8 00 00 00 00	 call	 _fabs
  00645	59		 pop	 ecx
  00646	59		 pop	 ecx
  00647	dd 9d 00 ff ff
	ff		 fstp	 QWORD PTR tv1032[ebp]
  0064d	f2 0f 10 85 00
	ff ff ff	 movsd	 xmm0, QWORD PTR tv1032[ebp]
  00655	f3 0f 5a 8d 20
	ff ff ff	 cvtss2sd xmm1, DWORD PTR $T1[ebp]
  0065d	51		 push	 ecx
  0065e	51		 push	 ecx
  0065f	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00664	f2 0f 11 85 f0
	fe ff ff	 movsd	 QWORD PTR tv1042[ebp], xmm0
  0066c	e8 00 00 00 00	 call	 _fabs
  00671	59		 pop	 ecx
  00672	59		 pop	 ecx
  00673	dd 9d f8 fe ff
	ff		 fstp	 QWORD PTR tv1037[ebp]
  00679	f2 0f 10 85 f8
	fe ff ff	 movsd	 xmm0, QWORD PTR tv1037[ebp]
  00681	f2 0f 10 8d f0
	fe ff ff	 movsd	 xmm1, QWORD PTR tv1042[ebp]
  00689	66 0f 2f c1	 comisd	 xmm0, xmm1
  0068d	76 04		 jbe	 SHORT $LN10@OnMovement

; 326  : 							fabs(D3DXVec3Dot(&(s.v3LastPosition - m_attribute.v3Position), &m_attribute.v3Normal)))
; 327  : 							return true;

  0068f	b0 01		 mov	 al, 1
  00691	eb 02		 jmp	 SHORT $LN1@OnMovement
$LN10@OnMovement:

; 328  : 					}
; 329  : 	}
; 330  : 
; 331  : 	return false;

  00693	32 c0		 xor	 al, al
$LN1@OnMovement:

; 332  : }

  00695	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00698	33 cd		 xor	 ecx, ebp
  0069a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0069f	c9		 leave
  006a0	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CPlaneCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnDestroy@CPlaneCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -8						; size = 4
_this$ = -4						; size = 4
?OnDestroy@CPlaneCollisionInstance@@MAEXXZ PROC		; CPlaneCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 435  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 436  : 	gs_pci.Free(this);

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	89 45 f8	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0000e	8d 45 f8	 lea	 eax, DWORD PTR _pkData$[ebp]
  00011	50		 push	 eax
  00012	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+16
  00017	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@QAEXABQAVCPlaneCollisionInstance@@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::emplace_back<CPlaneCollisionInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 437  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?OnDestroy@CPlaneCollisionInstance@@MAEXXZ ENDP		; CPlaneCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; CPlaneCollisionInstance::Render, COMDAT
; _this$ = ecx

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 430  : 	static CScreen s;

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  0002b	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  00032	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  0003b	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  00041	7e 3c		 jle	 SHORT $LN2@Render
  00043	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00048	e8 00 00 00 00	 call	 __Init_thread_header
  0004d	59		 pop	 ecx
  0004e	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA, -1
  00055	75 28		 jne	 SHORT $LN2@Render
  00057	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00060	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00065	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `CPlaneCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  0006a	e8 00 00 00 00	 call	 _atexit
  0006f	59		 pop	 ecx
  00070	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00074	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00079	e8 00 00 00 00	 call	 __Init_thread_footer
  0007e	59		 pop	 ecx
$LN2@Render:

; 431  : 	s.RenderBar3d(m_attribute.v3QuadPosition);

  0007f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00082	83 c0 1c	 add	 eax, 28			; 0000001cH
  00085	50		 push	 eax
  00086	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  0008b	e8 00 00 00 00	 call	 ?RenderBar3d@CScreen@@QAEXPBUD3DXVECTOR3@@@Z ; CScreen::RenderBar3d

; 432  : }

  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	c9		 leave
  0009c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; CPlaneCollisionInstance::Render
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CPlaneCollisionInstance@@QBEABUSPlaneData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAttribute@CPlaneCollisionInstance@@QBEABUSPlaneData@@XZ PROC ; CPlaneCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 302  : 	return m_attribute;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 303  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetAttribute@CPlaneCollisionInstance@@QBEABUSPlaneData@@XZ ENDP ; CPlaneCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ PROC ; CPlaneCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 297  : 	return m_attribute;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 298  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ ENDP ; CPlaneCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
tv947 = -248						; size = 8
tv922 = -240						; size = 8
tv917 = -232						; size = 8
_fz$ = -224						; size = 4
_fx$ = -220						; size = 4
_fy$ = -216						; size = 4
_fz$ = -212						; size = 4
_fx$ = -208						; size = 4
_fx$ = -204						; size = 4
_fy$ = -200						; size = 4
_fz$ = -196						; size = 4
_fy$ = -192						; size = 4
_fx$ = -188						; size = 4
_fz$ = -184						; size = 4
_fy$ = -180						; size = 4
_fx$ = -176						; size = 4
_fz$ = -172						; size = 4
_fy$ = -168						; size = 4
_fx$ = -164						; size = 4
_fz$ = -160						; size = 4
_fy$ = -156						; size = 4
_sq$ = -152						; size = 4
_mul$ = -148						; size = 4
_v$ = -144						; size = 4
_f$ = -140						; size = 4
_f$ = -136						; size = 4
_v$ = -132						; size = 4
_this$ = -128						; size = 4
_v$ = -124						; size = 4
_this$ = -120						; size = 4
_v$ = -116						; size = 4
_this$ = -112						; size = 4
_this$ = -108						; size = 4
_t2$ = -104						; size = 4
_t1$ = -100						; size = 4
_sum$ = -96						; size = 4
_this$ = -92						; size = 4
_v$1 = -88						; size = 12
$T2 = -76						; size = 12
$T3 = -64						; size = 12
$T4 = -52						; size = 12
$T5 = -40						; size = 12
$T6 = -28						; size = 12
_c$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CSphereCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 255  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	89 4d a4	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 	if (D3DXVec3LengthSq(&(s.v3Position-m_attribute.v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  00018	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c0 04	 add	 eax, 4
  0001e	89 85 70 ff ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  00024	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00027	89 45 94	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0002a	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00033	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00037	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0003b	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00043	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  0004c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00051	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00056	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0005e	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00067	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0006c	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00071	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00079	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00081	f3 0f 11 45 c0	 movss	 DWORD PTR $T3[ebp], xmm0

; 181  :     y = fy;

  00086	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0008e	f3 0f 11 45 c4	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 182  :     z = fz;

  00093	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0009b	f3 0f 11 45 c8	 movss	 DWORD PTR $T3[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 256  : 	if (D3DXVec3LengthSq(&(s.v3Position-m_attribute.v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  000a0	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  000a3	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  000ab	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  000b0	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  000b6	f3 0f 10 48 10	 movss	 xmm1, DWORD PTR [eax+16]
  000bb	f3 0f 58 49 18	 addss	 xmm1, DWORD PTR [ecx+24]
  000c0	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000c4	f3 0f 10 4d c8	 movss	 xmm1, DWORD PTR $T3[ebp+8]
  000c9	f3 0f 59 4d c8	 mulss	 xmm1, DWORD PTR $T3[ebp+8]
  000ce	f3 0f 10 55 c4	 movss	 xmm2, DWORD PTR $T3[ebp+4]
  000d3	f3 0f 59 55 c4	 mulss	 xmm2, DWORD PTR $T3[ebp+4]
  000d8	f3 0f 10 5d c0	 movss	 xmm3, DWORD PTR $T3[ebp]
  000dd	f3 0f 59 5d c0	 mulss	 xmm3, DWORD PTR $T3[ebp]
  000e2	f3 0f 58 da	 addss	 xmm3, xmm2
  000e6	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 256  : 	if (D3DXVec3LengthSq(&(s.v3Position-m_attribute.v3Position))>=(s.fRadius+m_attribute.fRadius)*(m_attribute.fRadius+s.fRadius))

  000ea	0f 2f d8	 comiss	 xmm3, xmm0
  000ed	72 28		 jb	 SHORT $LN2@OnGetColli
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  000ef	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000f2	0f 57 c0	 xorps	 xmm0, xmm0
  000f5	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  000f9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000fc	0f 57 c0	 xorps	 xmm0, xmm0
  000ff	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  00104	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00107	0f 57 c0	 xorps	 xmm0, xmm0
  0010a	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 257  : 		return D3DXVECTOR3(0.0f,0.0f,0.0f);

  0010f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00112	e9 d1 04 00 00	 jmp	 $LN5@OnGetColli
$LN2@OnGetColli:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  00117	0f 57 c0	 xorps	 xmm0, xmm0
  0011a	f3 0f 11 45 d8	 movss	 DWORD PTR $T5[ebp], xmm0

; 181  :     y = fy;

  0011f	0f 57 c0	 xorps	 xmm0, xmm0
  00122	f3 0f 11 45 dc	 movss	 DWORD PTR $T5[ebp+4], xmm0

; 182  :     z = fz;

  00127	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0012f	f3 0f 11 45 e0	 movss	 DWORD PTR $T5[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 259  : 	D3DXVec3Cross(&c, &(s.v3Position-s.v3LastPosition), &D3DXVECTOR3(0.0f,0.0f,1.0f) );

  00134	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00137	83 c0 0c	 add	 eax, 12			; 0000000cH
  0013a	89 45 8c	 mov	 DWORD PTR _v$[ebp], eax
  0013d	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00140	89 45 90	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00143	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00146	8b 4d 8c	 mov	 ecx, DWORD PTR _v$[ebp]
  00149	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0014d	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00151	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00159	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0015c	8b 4d 8c	 mov	 ecx, DWORD PTR _v$[ebp]
  0015f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00164	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00169	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00171	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00174	8b 4d 8c	 mov	 ecx, DWORD PTR _v$[ebp]
  00177	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0017c	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00181	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00189	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00191	f3 0f 11 45 cc	 movss	 DWORD PTR $T4[ebp], xmm0

; 181  :     y = fy;

  00196	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0019e	f3 0f 11 45 d0	 movss	 DWORD PTR $T4[ebp+4], xmm0

; 182  :     z = fz;

  001a3	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  001ab	f3 0f 11 45 d4	 movss	 DWORD PTR $T4[ebp+8], xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  001b0	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR $T4[ebp+4]
  001b5	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR $T5[ebp+8]
  001ba	f3 0f 10 4d d4	 movss	 xmm1, DWORD PTR $T4[ebp+8]
  001bf	f3 0f 59 4d dc	 mulss	 xmm1, DWORD PTR $T5[ebp+4]
  001c4	f3 0f 5c c1	 subss	 xmm0, xmm1
  001c8	f3 0f 11 45 a8	 movss	 DWORD PTR _v$1[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  001cd	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR $T4[ebp+8]
  001d2	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR $T5[ebp]
  001d7	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR $T4[ebp]
  001dc	f3 0f 59 4d e0	 mulss	 xmm1, DWORD PTR $T5[ebp+8]
  001e1	f3 0f 5c c1	 subss	 xmm0, xmm1
  001e5	f3 0f 11 45 ac	 movss	 DWORD PTR _v$1[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  001ea	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR $T4[ebp]
  001ef	f3 0f 59 45 dc	 mulss	 xmm0, DWORD PTR $T5[ebp+4]
  001f4	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR $T4[ebp+4]
  001f9	f3 0f 59 4d d8	 mulss	 xmm1, DWORD PTR $T5[ebp]
  001fe	f3 0f 5c c1	 subss	 xmm0, xmm1
  00202	f3 0f 11 45 b0	 movss	 DWORD PTR _v$1[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  00207	8d 75 a8	 lea	 esi, DWORD PTR _v$1[ebp]
  0020a	8d 7d f0	 lea	 edi, DWORD PTR _c$[ebp]
  0020d	a5		 movsd
  0020e	a5		 movsd
  0020f	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 261  : 	float sum = - D3DXVec3Dot(&c,&(s.v3Position-m_attribute.v3Position));

  00210	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  00213	83 c0 04	 add	 eax, 4
  00216	89 45 84	 mov	 DWORD PTR _v$[ebp], eax
  00219	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0021c	89 45 88	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0021f	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00222	8b 4d 84	 mov	 ecx, DWORD PTR _v$[ebp]
  00225	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00229	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0022d	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00235	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00238	8b 4d 84	 mov	 ecx, DWORD PTR _v$[ebp]
  0023b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00240	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00245	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0024d	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00250	8b 4d 84	 mov	 ecx, DWORD PTR _v$[ebp]
  00253	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00258	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0025d	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00265	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0026d	f3 0f 11 45 b4	 movss	 DWORD PTR $T2[ebp], xmm0

; 181  :     y = fy;

  00272	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0027a	f3 0f 11 45 b8	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 182  :     z = fz;

  0027f	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00287	f3 0f 11 45 bc	 movss	 DWORD PTR $T2[ebp+8], xmm0

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0028c	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _c$[ebp+8]
  00291	f3 0f 59 45 bc	 mulss	 xmm0, DWORD PTR $T2[ebp+8]
  00296	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _c$[ebp+4]
  0029b	f3 0f 59 4d b8	 mulss	 xmm1, DWORD PTR $T2[ebp+4]
  002a0	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _c$[ebp]
  002a5	f3 0f 59 55 b4	 mulss	 xmm2, DWORD PTR $T2[ebp]
  002aa	f3 0f 58 d1	 addss	 xmm2, xmm1
  002ae	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 261  : 	float sum = - D3DXVec3Dot(&c,&(s.v3Position-m_attribute.v3Position));

  002b2	0f 57 15 00 00
	00 00		 xorps	 xmm2, DWORD PTR __xmm@80000000800000008000000080000000
  002b9	f3 0f 11 55 a0	 movss	 DWORD PTR _sum$[ebp], xmm2

; 262  : 	float mul = (s.fRadius+m_attribute.fRadius)*(s.fRadius+m_attribute.fRadius)-D3DXVec3LengthSq(&(s.v3Position-m_attribute.v3Position));

  002be	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  002c1	83 c0 04	 add	 eax, 4
  002c4	89 85 7c ff ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  002ca	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  002cd	89 45 80	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  002d0	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  002d3	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  002d9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002dd	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  002e1	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  002e9	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  002ec	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  002f2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  002f7	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  002fc	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00304	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  00307	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  0030d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00312	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00317	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0031f	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00327	f3 0f 11 45 e4	 movss	 DWORD PTR $T6[ebp], xmm0

; 181  :     y = fy;

  0032c	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00334	f3 0f 11 45 e8	 movss	 DWORD PTR $T6[ebp+4], xmm0

; 182  :     z = fz;

  00339	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00341	f3 0f 11 45 ec	 movss	 DWORD PTR $T6[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 262  : 	float mul = (s.fRadius+m_attribute.fRadius)*(s.fRadius+m_attribute.fRadius)-D3DXVec3LengthSq(&(s.v3Position-m_attribute.v3Position));

  00346	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00349	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  0034c	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00351	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  00356	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00359	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  0035c	f3 0f 10 48 18	 movss	 xmm1, DWORD PTR [eax+24]
  00361	f3 0f 58 49 10	 addss	 xmm1, DWORD PTR [ecx+16]
  00366	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0036a	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR $T6[ebp+8]
  0036f	f3 0f 59 4d ec	 mulss	 xmm1, DWORD PTR $T6[ebp+8]
  00374	f3 0f 10 55 e8	 movss	 xmm2, DWORD PTR $T6[ebp+4]
  00379	f3 0f 59 55 e8	 mulss	 xmm2, DWORD PTR $T6[ebp+4]
  0037e	f3 0f 10 5d e4	 movss	 xmm3, DWORD PTR $T6[ebp]
  00383	f3 0f 59 5d e4	 mulss	 xmm3, DWORD PTR $T6[ebp]
  00388	f3 0f 58 da	 addss	 xmm3, xmm2
  0038c	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 262  : 	float mul = (s.fRadius+m_attribute.fRadius)*(s.fRadius+m_attribute.fRadius)-D3DXVec3LengthSq(&(s.v3Position-m_attribute.v3Position));

  00390	f3 0f 5c c3	 subss	 xmm0, xmm3
  00394	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _mul$[ebp], xmm0

; 263  : 
; 264  : 	if (sum*sum-4*mul<=0)

  0039c	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _sum$[ebp]
  003a1	f3 0f 59 45 a0	 mulss	 xmm0, DWORD PTR _sum$[ebp]
  003a6	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40800000
  003ae	f3 0f 59 8d 6c
	ff ff ff	 mulss	 xmm1, DWORD PTR _mul$[ebp]
  003b6	f3 0f 5c c1	 subss	 xmm0, xmm1
  003ba	0f 57 c9	 xorps	 xmm1, xmm1
  003bd	0f 2f c8	 comiss	 xmm1, xmm0
  003c0	72 28		 jb	 SHORT $LN3@OnGetColli
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  003c2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  003c5	0f 57 c0	 xorps	 xmm0, xmm0
  003c8	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  003cc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  003cf	0f 57 c0	 xorps	 xmm0, xmm0
  003d2	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  003d7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  003da	0f 57 c0	 xorps	 xmm0, xmm0
  003dd	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 265  : 		return D3DXVECTOR3(0.0f,0.0f,0.0f);

  003e2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  003e5	e9 fe 01 00 00	 jmp	 $LN5@OnGetColli
$LN3@OnGetColli:

; 266  : 	float sq = sqrt(sum*sum-4*mul);

  003ea	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _sum$[ebp]
  003ef	f3 0f 59 45 a0	 mulss	 xmm0, DWORD PTR _sum$[ebp]
  003f4	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40800000
  003fc	f3 0f 59 8d 6c
	ff ff ff	 mulss	 xmm1, DWORD PTR _mul$[ebp]
  00404	f3 0f 5c c1	 subss	 xmm0, xmm1
  00408	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0040c	51		 push	 ecx
  0040d	51		 push	 ecx
  0040e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00413	e8 00 00 00 00	 call	 _sqrt
  00418	59		 pop	 ecx
  00419	59		 pop	 ecx
  0041a	d9 9d 68 ff ff
	ff		 fstp	 DWORD PTR _sq$[ebp]

; 267  : 	float t1=-sum-sq, t2=-sum+sq;

  00420	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _sum$[ebp]
  00425	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0042c	f3 0f 5c 85 68
	ff ff ff	 subss	 xmm0, DWORD PTR _sq$[ebp]
  00434	f3 0f 11 45 9c	 movss	 DWORD PTR _t1$[ebp], xmm0
  00439	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _sum$[ebp]
  0043e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00445	f3 0f 58 85 68
	ff ff ff	 addss	 xmm0, DWORD PTR _sq$[ebp]
  0044d	f3 0f 11 45 98	 movss	 DWORD PTR _t2$[ebp], xmm0

; 268  : 	t1*=0.5f;

  00452	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _t1$[ebp]
  00457	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0045f	f3 0f 11 45 9c	 movss	 DWORD PTR _t1$[ebp], xmm0

; 269  : 	t2*=0.5f;

  00464	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _t2$[ebp]
  00469	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00471	f3 0f 11 45 98	 movss	 DWORD PTR _t2$[ebp], xmm0

; 270  : 
; 271  : 	if (fabs(t1)<=fabs(t2))

  00476	f3 0f 5a 45 9c	 cvtss2sd xmm0, DWORD PTR _t1$[ebp]
  0047b	51		 push	 ecx
  0047c	51		 push	 ecx
  0047d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00482	e8 00 00 00 00	 call	 _fabs
  00487	59		 pop	 ecx
  00488	59		 pop	 ecx
  00489	dd 9d 18 ff ff
	ff		 fstp	 QWORD PTR tv917[ebp]
  0048f	f2 0f 10 85 18
	ff ff ff	 movsd	 xmm0, QWORD PTR tv917[ebp]
  00497	f3 0f 5a 4d 98	 cvtss2sd xmm1, DWORD PTR _t2$[ebp]
  0049c	51		 push	 ecx
  0049d	51		 push	 ecx
  0049e	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  004a3	f2 0f 11 85 08
	ff ff ff	 movsd	 QWORD PTR tv947[ebp], xmm0
  004ab	e8 00 00 00 00	 call	 _fabs
  004b0	59		 pop	 ecx
  004b1	59		 pop	 ecx
  004b2	dd 9d 10 ff ff
	ff		 fstp	 QWORD PTR tv922[ebp]
  004b8	f2 0f 10 85 10
	ff ff ff	 movsd	 xmm0, QWORD PTR tv922[ebp]
  004c0	f2 0f 10 8d 08
	ff ff ff	 movsd	 xmm1, QWORD PTR tv947[ebp]
  004c8	66 0f 2f c1	 comisd	 xmm0, xmm1
  004cc	0f 82 90 00 00
	00		 jb	 $LN4@OnGetColli

; 273  : 		return (gc_fReduceMove*t1)*c;

  004d2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  004da	f3 0f 59 45 9c	 mulss	 xmm0, DWORD PTR _t1$[ebp]
  004df	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  004e7	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  004ef	f3 0f 59 45 f0	 mulss	 xmm0, DWORD PTR _c$[ebp]
  004f4	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  004fc	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00504	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _c$[ebp+4]
  00509	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00511	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00519	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _c$[ebp+8]
  0051e	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00526	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00529	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00531	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  00535	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00538	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00540	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  00545	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00548	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00550	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 273  : 		return (gc_fReduceMove*t1)*c;

  00555	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00558	e9 8b 00 00 00	 jmp	 $LN5@OnGetColli

; 274  : 	}

  0055d	e9 86 00 00 00	 jmp	 $LN5@OnGetColli
$LN4@OnGetColli:

; 276  : 		return (gc_fReduceMove*t2)*c;

  00562	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0056a	f3 0f 59 45 98	 mulss	 xmm0, DWORD PTR _t2$[ebp]
  0056f	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00577	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  0057f	f3 0f 59 45 f0	 mulss	 xmm0, DWORD PTR _c$[ebp]
  00584	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0058c	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00594	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _c$[ebp+4]
  00599	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  005a1	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  005a9	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _c$[ebp+8]
  005ae	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  005b6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  005b9	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  005c1	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  005c5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  005c8	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  005d0	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  005d5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  005d8	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  005e0	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 276  : 		return (gc_fReduceMove*t2)*c;

  005e5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@OnGetColli:

; 277  : 
; 278  : 	/*
; 279  : 	D3DXVECTOR3 p1 = s.v3Position+t1*c;
; 280  : 	D3DXVECTOR3 p2 = s.v3Position+t2*c;
; 281  : 	
; 282  : 	if (D3DXVec3LengthSq(&(p2-s.v3Position))>D3DXVec3LengthSq(&(p1-s.v3Position)))
; 283  : 	{
; 284  : 		return p1-s.v3Position;
; 285  : 	}
; 286  : 	else
; 287  : 	{
; 288  : 		return p2-s.v3Position;
; 289  : 	}
; 290  : 	*/
; 291  : }

  005e8	5f		 pop	 edi
  005e9	5e		 pop	 esi
  005ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005ed	33 cd		 xor	 ecx, ebp
  005ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f4	c9		 leave
  005f5	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CSphereCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
tv87 = -8						; size = 4
_this$ = -4						; size = 4
_s$ = 8							; size = 4
?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CSphereCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 244  : 	//Tracef("OnCollisionDynamicSphere\n");
; 245  : 	
; 246  : 	if (square_distance_between_linesegment_and_point(s.v3LastPosition,s.v3Position,m_attribute.v3Position)<(m_attribute.fRadius+s.fRadius)*(m_attribute.fRadius+s.fRadius))

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 c0 04	 add	 eax, 4
  0000e	50		 push	 eax
  0000f	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00012	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00015	83 c0 0c	 add	 eax, 12			; 0000000cH
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z ; square_distance_between_linesegment_and_point
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	d9 5d f8	 fstp	 DWORD PTR tv87[ebp]
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0002a	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0002f	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0003a	f3 0f 10 48 10	 movss	 xmm1, DWORD PTR [eax+16]
  0003f	f3 0f 58 49 18	 addss	 xmm1, DWORD PTR [ecx+24]
  00044	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00048	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR tv87[ebp]
  0004c	76 04		 jbe	 SHORT $LN2@OnCollisio

; 247  : 	{
; 248  : 		return true;

  0004e	b0 01		 mov	 al, 1
  00050	eb 02		 jmp	 SHORT $LN1@OnCollisio
$LN2@OnCollisio:

; 249  : 	}
; 250  : 	
; 251  : 	return false;

  00052	32 c0		 xor	 al, al
$LN1@OnCollisio:

; 252  : }

  00054	c9		 leave
  00055	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CSphereCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv222 = -24						; size = 4
_c_rv3Target$ = -20					; size = 4
_c_rv3Source$ = -16					; size = 4
_c_rv3Target$ = -12					; size = 4
_c_rv3Source$ = -8					; size = 4
_this$ = -4						; size = 4
_s$ = 8							; size = 4
?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CSphereCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  : 	if (square_distance_between_linesegment_and_point(s.v3LastPosition,s.v3Position,m_attribute.v3Position) < (m_attribute.fRadius+s.fRadius)*(m_attribute.fRadius+s.fRadius))

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	50		 push	 eax
  00010	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00013	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z ; square_distance_between_linesegment_and_point
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	d9 5d e8	 fstp	 DWORD PTR tv222[ebp]
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0002b	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00030	f3 0f 58 41 18	 addss	 xmm0, DWORD PTR [ecx+24]
  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0003b	f3 0f 10 48 10	 movss	 xmm1, DWORD PTR [eax+16]
  00040	f3 0f 58 49 18	 addss	 xmm1, DWORD PTR [ecx+24]
  00045	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00049	0f 2f 45 e8	 comiss	 xmm0, DWORD PTR tv222[ebp]
  0004d	0f 86 c0 00 00
	00		 jbe	 $LN3@OnMovement

; 234  : 		if (GetVector3Distance(s.v3Position, m_attribute.v3Position) <

  00053	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00056	83 c0 04	 add	 eax, 4
  00059	89 45 f4	 mov	 DWORD PTR _c_rv3Target$[ebp], eax
  0005c	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0005f	89 45 f8	 mov	 DWORD PTR _c_rv3Source$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00062	8b 45 f8	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  00068	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0006c	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00070	8b 45 f8	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  00073	8b 4d f4	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  00076	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0007a	f3 0f 5c 09	 subss	 xmm1, DWORD PTR [ecx]
  0007e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00082	8b 45 f8	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  00085	8b 4d f4	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  00088	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0008d	f3 0f 5c 49 04	 subss	 xmm1, DWORD PTR [ecx+4]
  00092	8b 45 f8	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  00095	8b 4d f4	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  00098	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [eax+4]
  0009d	f3 0f 5c 51 04	 subss	 xmm2, DWORD PTR [ecx+4]
  000a2	f3 0f 59 ca	 mulss	 xmm1, xmm2
  000a6	f3 0f 58 c1	 addss	 xmm0, xmm1
  000aa	f3 0f 11 45 e4	 movss	 DWORD PTR $T1[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 234  : 		if (GetVector3Distance(s.v3Position, m_attribute.v3Position) <

  000af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	83 c0 04	 add	 eax, 4
  000b5	89 45 ec	 mov	 DWORD PTR _c_rv3Target$[ebp], eax
  000b8	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000bb	83 c0 0c	 add	 eax, 12			; 0000000cH
  000be	89 45 f0	 mov	 DWORD PTR _c_rv3Source$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  000c1	8b 45 f0	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  000c4	8b 4d ec	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  000c7	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000cc	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  000d1	8b 45 f0	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  000d4	8b 4d ec	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  000d7	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  000dc	f3 0f 5c 49 04	 subss	 xmm1, DWORD PTR [ecx+4]
  000e1	f3 0f 59 c8	 mulss	 xmm1, xmm0
  000e5	8b 45 f0	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  000e8	8b 4d ec	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  000eb	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000ef	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  000f3	8b 45 f0	 mov	 eax, DWORD PTR _c_rv3Source$[ebp]
  000f6	8b 4d ec	 mov	 ecx, DWORD PTR _c_rv3Target$[ebp]
  000f9	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  000fd	f3 0f 5c 11	 subss	 xmm2, DWORD PTR [ecx]
  00101	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00105	f3 0f 58 d1	 addss	 xmm2, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 234  : 		if (GetVector3Distance(s.v3Position, m_attribute.v3Position) <

  00109	0f 2f 55 e4	 comiss	 xmm2, DWORD PTR $T1[ebp]
  0010d	76 04		 jbe	 SHORT $LN3@OnMovement

; 235  : 			GetVector3Distance(s.v3LastPosition, m_attribute.v3Position))
; 236  : 			return true;

  0010f	b0 01		 mov	 al, 1
  00111	eb 02		 jmp	 SHORT $LN1@OnMovement
$LN3@OnMovement:

; 237  : 	}
; 238  : 
; 239  : 	return false;

  00113	32 c0		 xor	 al, al
$LN1@OnMovement:

; 240  : }

  00115	c9		 leave
  00116	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CSphereCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?OnDestroy@CSphereCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -8						; size = 4
_this$ = -4						; size = 4
?OnDestroy@CSphereCollisionInstance@@MAEXXZ PROC	; CSphereCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 226  : 	gs_sci.Free(this);

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	89 45 f8	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0000e	8d 45 f8	 lea	 eax, DWORD PTR _pkData$[ebp]
  00011	50		 push	 eax
  00012	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+16
  00017	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@QAEXABQAVCSphereCollisionInstance@@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::emplace_back<CSphereCollisionInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 227  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?OnDestroy@CSphereCollisionInstance@@MAEXXZ ENDP	; CSphereCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_d3dFillMode$ = 8					; size = 4
?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; CSphereCollisionInstance::Render, COMDAT
; _this$ = ecx

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 219  : 	static CScreen s;

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  0002b	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  00032	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  0003b	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  00041	7e 3c		 jle	 SHORT $LN2@Render
  00043	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00048	e8 00 00 00 00	 call	 __Init_thread_header
  0004d	59		 pop	 ecx
  0004e	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA, -1
  00055	75 28		 jne	 SHORT $LN2@Render
  00057	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00060	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00065	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `CSphereCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  0006a	e8 00 00 00 00	 call	 _atexit
  0006f	59		 pop	 ecx
  00070	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00074	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00079	e8 00 00 00 00	 call	 __Init_thread_footer
  0007e	59		 pop	 ecx
$LN2@Render:

; 220  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  0007f	6a ff		 push	 -1
  00081	6a 3c		 push	 60			; 0000003cH
  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00089	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 221  : 	s.RenderSphere(NULL, m_attribute.v3Position.x, m_attribute.v3Position.y, m_attribute.v3Position.z, m_attribute.fRadius, d3dFillMode);

  0008e	ff 75 08	 push	 DWORD PTR _d3dFillMode$[ebp]
  00091	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00094	51		 push	 ecx
  00095	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0009a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	51		 push	 ecx
  000a3	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ad	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	51		 push	 ecx
  000b1	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000be	51		 push	 ecx
  000bf	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c9	6a 00		 push	 0
  000cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  000d0	e8 00 00 00 00	 call	 ?RenderSphere@CScreen@@QAEXPBUD3DXMATRIX@@MMMMW4_D3DFILLMODE@@@Z ; CScreen::RenderSphere

; 222  : }

  000d5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000df	59		 pop	 ecx
  000e0	c9		 leave
  000e1	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; CSphereCollisionInstance::Render
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ PROC ; CSphereCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 214  : 	return m_attribute;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 215  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ ENDP ; CSphereCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ PROC ; CSphereCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 209  : 	return m_attribute;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 210  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ ENDP ; CSphereCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z
_TEXT	SEGMENT
_pOut$ = -1524						; size = 4
_fx$ = -1520						; size = 4
_fy$ = -1516						; size = 4
_fz$ = -1512						; size = 4
_fx$ = -1508						; size = 4
_fy$ = -1504						; size = 4
_fz$ = -1500						; size = 4
_pOut$ = -1496						; size = 4
_pOut$ = -1492						; size = 4
_pOut$ = -1488						; size = 4
_fy$ = -1484						; size = 4
_fz$ = -1480						; size = 4
_fy$ = -1476						; size = 4
_fx$ = -1472						; size = 4
_fz$ = -1468						; size = 4
_fy$ = -1464						; size = 4
_fx$ = -1460						; size = 4
_pOut$ = -1456						; size = 4
_fx$ = -1452						; size = 4
_fy$ = -1448						; size = 4
_fz$ = -1444						; size = 4
_fx$ = -1440						; size = 4
_fz$ = -1436						; size = 4
_ppci$1 = -1432						; size = 4
_paci$2 = -1428						; size = 4
_poci$3 = -1424						; size = 4
_psci$4 = -1420						; size = 4
_pcci$5 = -1416						; size = 4
_this$ = -1412						; size = 4
_v$ = -1408						; size = 4
_this$ = -1404						; size = 4
_v$ = -1400						; size = 4
_this$ = -1396						; size = 4
_v$ = -1392						; size = 4
_this$ = -1388						; size = 4
_v$ = -1384						; size = 4
_fHalfWidth$6 = -1380					; size = 4
_fHalfLength$7 = -1376					; size = 4
_SphereData$8 = -1372					; size = 4
tv65 = -1368						; size = 4
_CylinderData$9 = -1364					; size = 4
_i$10 = -1360						; size = 4
_pV1$ = -1356						; size = 4
_pV2$ = -1352						; size = 4
_pV2$ = -1348						; size = 4
_pV1$ = -1344						; size = 4
_AABBData$11 = -1340					; size = 4
_OBBData$12 = -1336					; size = 4
_pOut$ = -1332						; size = 4
_PlaneData$13 = -1328					; size = 4
_matTranslationLocal$14 = -1324				; size = 64
_matRotation$15 = -1260					; size = 64
_matTransform$16 = -1196				; size = 64
_matTransform$17 = -1132				; size = 64
_matT$18 = -1068					; size = 64
$T19 = -1004						; size = 64
_matT$20 = -940						; size = 64
$T21 = -876						; size = 64
$T22 = -812						; size = 64
_matT$23 = -748						; size = 64
_matT$24 = -684						; size = 64
_matTranslationLocal$25 = -620				; size = 64
_matRotation$26 = -556					; size = 64
_matTransform$27 = -492					; size = 64
_matTranslationLocal$28 = -428				; size = 64
_matTranslationLocal$29 = -364				; size = 64
_matTranslationLocal$30 = -300				; size = 64
_matTranslationWorld$31 = -236				; size = 64
_v$32 = -172						; size = 12
_v$33 = -160						; size = 12
_v$34 = -148						; size = 12
_v$35 = -136						; size = 12
_v$36 = -124						; size = 12
$T37 = -112						; size = 12
_v3Min$38 = -100					; size = 12
_v3Max$39 = -88						; size = 12
_v3Pos$40 = -76						; size = 12
_v3Position$41 = -64					; size = 12
_v3Line3$42 = -52					; size = 12
_v3Line2$43 = -40					; size = 12
_v3Line1$44 = -28					; size = 12
_v3Line0$45 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_c_pCollisionData$ = 8					; size = 4
_pMat$ = 12						; size = 4
?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z PROC ; CBaseCollisionInstance::BuildCollisionInstance, COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 05 00
	00		 sub	 esp, 1524		; 000005f4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi

; 37   : 	switch(c_pCollisionData->dwType)

  00015	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 85 a8 fa ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  00020	83 bd a8 fa ff
	ff 00		 cmp	 DWORD PTR tv65[ebp], 0
  00027	74 39		 je	 SHORT $LN7@BuildColli
  00029	83 bd a8 fa ff
	ff 02		 cmp	 DWORD PTR tv65[ebp], 2
  00030	0f 84 73 11 00
	00		 je	 $LN11@BuildColli
  00036	83 bd a8 fa ff
	ff 03		 cmp	 DWORD PTR tv65[ebp], 3
  0003d	0f 84 53 12 00
	00		 je	 $LN12@BuildColli
  00043	83 bd a8 fa ff
	ff 04		 cmp	 DWORD PTR tv65[ebp], 4
  0004a	0f 84 01 09 00
	00		 je	 $LN9@BuildColli
  00050	83 bd a8 fa ff
	ff 05		 cmp	 DWORD PTR tv65[ebp], 5
  00057	0f 84 7f 0a 00
	00		 je	 $LN10@BuildColli
  0005d	e9 2f 13 00 00	 jmp	 $LN2@BuildColli
$LN7@BuildColli:

; 38   : 	{
; 39   : 		case COLLISION_TYPE_PLANE:
; 40   : 			{
; 41   : 				CPlaneCollisionInstance * ppci = gs_pci.Alloc();

  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A ; gs_pci
  00067	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEPAVCPlaneCollisionInstance@@XZ ; CDynamicPool<CPlaneCollisionInstance>::Alloc
  0006c	89 85 68 fa ff
	ff		 mov	 DWORD PTR _ppci$1[ebp], eax

; 42   : 				D3DXMATRIX matRotation;
; 43   : 				D3DXMATRIX matTranslationLocal;
; 44   : 				D3DXMatrixRotationQuaternion(&matRotation, &c_pCollisionData->quatRotation);

  00072	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  00075	83 c0 40	 add	 eax, 64			; 00000040H
  00078	50		 push	 eax
  00079	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _matRotation$26[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 _D3DXMatrixRotationQuaternion@8

; 45   : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  00085	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  00088	51		 push	 ecx
  00089	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [eax+48]
  0008e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00093	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  00096	51		 push	 ecx
  00097	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  0009c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a1	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  000a4	51		 push	 ecx
  000a5	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  000aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000af	8d 85 94 fd ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$25[ebp]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  000bb	8d 85 94 fd ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$25[ebp]
  000c1	50		 push	 eax
  000c2	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _matRotation$26[ebp]
  000c8	50		 push	 eax
  000c9	8d 85 54 fd ff
	ff		 lea	 eax, DWORD PTR _matT$24[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 581  :     return matT;

  000d5	6a 10		 push	 16			; 00000010H
  000d7	59		 pop	 ecx
  000d8	8d b5 54 fd ff
	ff		 lea	 esi, DWORD PTR _matT$24[ebp]
  000de	8d bd d4 fc ff
	ff		 lea	 edi, DWORD PTR $T22[ebp]
  000e4	f3 a5		 rep movsd

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  000e6	ff 75 0c	 push	 DWORD PTR _pMat$[ebp]
  000e9	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  000ef	50		 push	 eax
  000f0	8d 85 14 fd ff
	ff		 lea	 eax, DWORD PTR _matT$23[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 581  :     return matT;

  000fc	6a 10		 push	 16			; 00000010H
  000fe	59		 pop	 ecx
  000ff	8d b5 14 fd ff
	ff		 lea	 esi, DWORD PTR _matT$23[ebp]
  00105	8d bd 94 fb ff
	ff		 lea	 edi, DWORD PTR _matTransform$17[ebp]
  0010b	f3 a5		 rep movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 48   : 				TPlaneData & PlaneData = ppci->GetAttribute();

  0010d	8b 8d 68 fa ff
	ff		 mov	 ecx, DWORD PTR _ppci$1[ebp]
  00113	e8 00 00 00 00	 call	 ?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ ; CPlaneCollisionInstance::GetAttribute
  00118	89 85 d0 fa ff
	ff		 mov	 DWORD PTR _PlaneData$13[ebp], eax

; 49   : 				D3DXVec3TransformCoord(&PlaneData.v3Position, &c_pCollisionData->v3Position, pMat);

  0011e	ff 75 0c	 push	 DWORD PTR _pMat$[ebp]
  00121	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  00124	83 c0 28	 add	 eax, 40			; 00000028H
  00127	50		 push	 eax
  00128	ff b5 d0 fa ff
	ff		 push	 DWORD PTR _PlaneData$13[ebp]
  0012e	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 50   : 				float fHalfWidth = c_pCollisionData->fDimensions[0] / 2.0f;

  00133	6a 04		 push	 4
  00135	58		 pop	 eax
  00136	6b c0 00	 imul	 eax, eax, 0
  00139	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  0013c	f3 0f 10 44 01
	34		 movss	 xmm0, DWORD PTR [ecx+eax+52]
  00142	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0014a	f3 0f 11 85 9c
	fa ff ff	 movss	 DWORD PTR _fHalfWidth$6[ebp], xmm0

; 51   : 				float fHalfLength = c_pCollisionData->fDimensions[1] / 2.0f;

  00152	6a 04		 push	 4
  00154	58		 pop	 eax
  00155	c1 e0 00	 shl	 eax, 0
  00158	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  0015b	f3 0f 10 44 01
	34		 movss	 xmm0, DWORD PTR [ecx+eax+52]
  00161	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00169	f3 0f 11 85 a0
	fa ff ff	 movss	 DWORD PTR _fHalfLength$7[ebp], xmm0

; 52   : 
; 53   : 				PlaneData.v3QuadPosition[0].x = -fHalfWidth;

  00171	f3 0f 10 85 9c
	fa ff ff	 movss	 xmm0, DWORD PTR _fHalfWidth$6[ebp]
  00179	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00180	6a 0c		 push	 12			; 0000000cH
  00182	58		 pop	 eax
  00183	6b c0 00	 imul	 eax, eax, 0
  00186	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  0018c	f3 0f 11 44 01
	18		 movss	 DWORD PTR [ecx+eax+24], xmm0

; 54   : 				PlaneData.v3QuadPosition[0].y = -fHalfLength;

  00192	f3 0f 10 85 a0
	fa ff ff	 movss	 xmm0, DWORD PTR _fHalfLength$7[ebp]
  0019a	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001a1	6a 0c		 push	 12			; 0000000cH
  001a3	58		 pop	 eax
  001a4	6b c0 00	 imul	 eax, eax, 0
  001a7	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  001ad	f3 0f 11 44 01
	1c		 movss	 DWORD PTR [ecx+eax+28], xmm0

; 55   : 				PlaneData.v3QuadPosition[0].z = 0.0f;

  001b3	6a 0c		 push	 12			; 0000000cH
  001b5	58		 pop	 eax
  001b6	6b c0 00	 imul	 eax, eax, 0
  001b9	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  001bf	0f 57 c0	 xorps	 xmm0, xmm0
  001c2	f3 0f 11 44 01
	20		 movss	 DWORD PTR [ecx+eax+32], xmm0

; 56   : 				PlaneData.v3QuadPosition[1].x = +fHalfWidth;

  001c8	6a 0c		 push	 12			; 0000000cH
  001ca	58		 pop	 eax
  001cb	c1 e0 00	 shl	 eax, 0
  001ce	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  001d4	f3 0f 10 85 9c
	fa ff ff	 movss	 xmm0, DWORD PTR _fHalfWidth$6[ebp]
  001dc	f3 0f 11 44 01
	18		 movss	 DWORD PTR [ecx+eax+24], xmm0

; 57   : 				PlaneData.v3QuadPosition[1].y = -fHalfLength;

  001e2	f3 0f 10 85 a0
	fa ff ff	 movss	 xmm0, DWORD PTR _fHalfLength$7[ebp]
  001ea	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001f1	6a 0c		 push	 12			; 0000000cH
  001f3	58		 pop	 eax
  001f4	c1 e0 00	 shl	 eax, 0
  001f7	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  001fd	f3 0f 11 44 01
	1c		 movss	 DWORD PTR [ecx+eax+28], xmm0

; 58   : 				PlaneData.v3QuadPosition[1].z = 0.0f;

  00203	6a 0c		 push	 12			; 0000000cH
  00205	58		 pop	 eax
  00206	c1 e0 00	 shl	 eax, 0
  00209	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  0020f	0f 57 c0	 xorps	 xmm0, xmm0
  00212	f3 0f 11 44 01
	20		 movss	 DWORD PTR [ecx+eax+32], xmm0

; 59   : 				PlaneData.v3QuadPosition[2].x = -fHalfWidth;

  00218	f3 0f 10 85 9c
	fa ff ff	 movss	 xmm0, DWORD PTR _fHalfWidth$6[ebp]
  00220	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00227	6a 0c		 push	 12			; 0000000cH
  00229	58		 pop	 eax
  0022a	d1 e0		 shl	 eax, 1
  0022c	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  00232	f3 0f 11 44 01
	18		 movss	 DWORD PTR [ecx+eax+24], xmm0

; 60   : 				PlaneData.v3QuadPosition[2].y = +fHalfLength;

  00238	6a 0c		 push	 12			; 0000000cH
  0023a	58		 pop	 eax
  0023b	d1 e0		 shl	 eax, 1
  0023d	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  00243	f3 0f 10 85 a0
	fa ff ff	 movss	 xmm0, DWORD PTR _fHalfLength$7[ebp]
  0024b	f3 0f 11 44 01
	1c		 movss	 DWORD PTR [ecx+eax+28], xmm0

; 61   : 				PlaneData.v3QuadPosition[2].z = 0.0f;

  00251	6a 0c		 push	 12			; 0000000cH
  00253	58		 pop	 eax
  00254	d1 e0		 shl	 eax, 1
  00256	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  0025c	0f 57 c0	 xorps	 xmm0, xmm0
  0025f	f3 0f 11 44 01
	20		 movss	 DWORD PTR [ecx+eax+32], xmm0

; 62   : 				PlaneData.v3QuadPosition[3].x = +fHalfWidth;

  00265	6a 0c		 push	 12			; 0000000cH
  00267	58		 pop	 eax
  00268	6b c0 03	 imul	 eax, eax, 3
  0026b	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  00271	f3 0f 10 85 9c
	fa ff ff	 movss	 xmm0, DWORD PTR _fHalfWidth$6[ebp]
  00279	f3 0f 11 44 01
	18		 movss	 DWORD PTR [ecx+eax+24], xmm0

; 63   : 				PlaneData.v3QuadPosition[3].y = +fHalfLength;

  0027f	6a 0c		 push	 12			; 0000000cH
  00281	58		 pop	 eax
  00282	6b c0 03	 imul	 eax, eax, 3
  00285	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  0028b	f3 0f 10 85 a0
	fa ff ff	 movss	 xmm0, DWORD PTR _fHalfLength$7[ebp]
  00293	f3 0f 11 44 01
	1c		 movss	 DWORD PTR [ecx+eax+28], xmm0

; 64   : 				PlaneData.v3QuadPosition[3].z = 0.0f;

  00299	6a 0c		 push	 12			; 0000000cH
  0029b	58		 pop	 eax
  0029c	6b c0 03	 imul	 eax, eax, 3
  0029f	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  002a5	0f 57 c0	 xorps	 xmm0, xmm0
  002a8	f3 0f 11 44 01
	20		 movss	 DWORD PTR [ecx+eax+32], xmm0

; 65   : 				for (DWORD i = 0; i < 4; ++i)

  002ae	83 a5 b0 fa ff
	ff 00		 and	 DWORD PTR _i$10[ebp], 0
  002b5	eb 0d		 jmp	 SHORT $LN6@BuildColli
$LN4@BuildColli:
  002b7	8b 85 b0 fa ff
	ff		 mov	 eax, DWORD PTR _i$10[ebp]
  002bd	40		 inc	 eax
  002be	89 85 b0 fa ff
	ff		 mov	 DWORD PTR _i$10[ebp], eax
$LN6@BuildColli:
  002c4	83 bd b0 fa ff
	ff 04		 cmp	 DWORD PTR _i$10[ebp], 4
  002cb	73 32		 jae	 SHORT $LN5@BuildColli

; 66   : 					D3DXVec3TransformCoord(&PlaneData.v3QuadPosition[i], &PlaneData.v3QuadPosition[i], &matTransform);

  002cd	8d 85 94 fb ff
	ff		 lea	 eax, DWORD PTR _matTransform$17[ebp]
  002d3	50		 push	 eax
  002d4	6b 85 b0 fa ff
	ff 0c		 imul	 eax, DWORD PTR _i$10[ebp], 12
  002db	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  002e1	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]
  002e5	50		 push	 eax
  002e6	6b 85 b0 fa ff
	ff 0c		 imul	 eax, DWORD PTR _i$10[ebp], 12
  002ed	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  002f3	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]
  002f7	50		 push	 eax
  002f8	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
  002fd	eb b8		 jmp	 SHORT $LN4@BuildColli
$LN5@BuildColli:

; 67   : 				D3DXVECTOR3 v3Line0 = PlaneData.v3QuadPosition[1] - PlaneData.v3QuadPosition[0];

  002ff	6a 0c		 push	 12			; 0000000cH
  00301	58		 pop	 eax
  00302	6b c0 00	 imul	 eax, eax, 0
  00305	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  0030b	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]
  0030f	89 85 80 fa ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  00315	6a 0c		 push	 12			; 0000000cH
  00317	58		 pop	 eax
  00318	c1 e0 00	 shl	 eax, 0
  0031b	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  00321	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]
  00325	89 85 7c fa ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0032b	8b 85 7c fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00331	8b 8d 80 fa ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00337	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0033b	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0033f	f3 0f 11 85 54
	fa ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00347	8b 85 7c fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0034d	8b 8d 80 fa ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00353	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00358	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0035d	f3 0f 11 85 58
	fa ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00365	8b 85 7c fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0036b	8b 8d 80 fa ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00371	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00376	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0037b	f3 0f 11 85 5c
	fa ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00383	f3 0f 10 85 54
	fa ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0038b	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Line0$45[ebp], xmm0

; 181  :     y = fy;

  00390	f3 0f 10 85 58
	fa ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00398	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Line0$45[ebp+4], xmm0

; 182  :     z = fz;

  0039d	f3 0f 10 85 5c
	fa ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  003a5	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Line0$45[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 68   : 				D3DXVECTOR3 v3Line1 = PlaneData.v3QuadPosition[2] - PlaneData.v3QuadPosition[0];

  003aa	6a 0c		 push	 12			; 0000000cH
  003ac	58		 pop	 eax
  003ad	6b c0 00	 imul	 eax, eax, 0
  003b0	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  003b6	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]
  003ba	89 85 88 fa ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  003c0	6a 0c		 push	 12			; 0000000cH
  003c2	58		 pop	 eax
  003c3	d1 e0		 shl	 eax, 1
  003c5	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  003cb	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]
  003cf	89 85 84 fa ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  003d5	8b 85 84 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003db	8b 8d 88 fa ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  003e1	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  003e5	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  003e9	f3 0f 11 85 60
	fa ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  003f1	8b 85 84 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003f7	8b 8d 88 fa ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  003fd	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00402	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00407	f3 0f 11 85 34
	fa ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0040f	8b 85 84 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00415	8b 8d 88 fa ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  0041b	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00420	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00425	f3 0f 11 85 64
	fa ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0042d	f3 0f 10 85 60
	fa ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00435	f3 0f 11 45 e4	 movss	 DWORD PTR _v3Line1$44[ebp], xmm0

; 181  :     y = fy;

  0043a	f3 0f 10 85 34
	fa ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00442	f3 0f 11 45 e8	 movss	 DWORD PTR _v3Line1$44[ebp+4], xmm0

; 182  :     z = fz;

  00447	f3 0f 10 85 64
	fa ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0044f	f3 0f 11 45 ec	 movss	 DWORD PTR _v3Line1$44[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 69   : 				D3DXVECTOR3 v3Line2 = PlaneData.v3QuadPosition[1] - PlaneData.v3QuadPosition[3];

  00454	6a 0c		 push	 12			; 0000000cH
  00456	58		 pop	 eax
  00457	6b c0 03	 imul	 eax, eax, 3
  0045a	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  00460	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]
  00464	89 85 90 fa ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  0046a	6a 0c		 push	 12			; 0000000cH
  0046c	58		 pop	 eax
  0046d	c1 e0 00	 shl	 eax, 0
  00470	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  00476	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]
  0047a	89 85 8c fa ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00480	8b 85 8c fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00486	8b 8d 90 fa ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  0048c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00490	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00494	f3 0f 11 85 10
	fa ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0049c	8b 85 8c fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004a2	8b 8d 90 fa ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  004a8	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  004ad	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  004b2	f3 0f 11 85 14
	fa ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  004ba	8b 85 8c fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004c0	8b 8d 90 fa ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  004c6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  004cb	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  004d0	f3 0f 11 85 18
	fa ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  004d8	f3 0f 10 85 10
	fa ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  004e0	f3 0f 11 45 d8	 movss	 DWORD PTR _v3Line2$43[ebp], xmm0

; 181  :     y = fy;

  004e5	f3 0f 10 85 14
	fa ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  004ed	f3 0f 11 45 dc	 movss	 DWORD PTR _v3Line2$43[ebp+4], xmm0

; 182  :     z = fz;

  004f2	f3 0f 10 85 18
	fa ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  004fa	f3 0f 11 45 e0	 movss	 DWORD PTR _v3Line2$43[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 70   : 				D3DXVECTOR3 v3Line3 = PlaneData.v3QuadPosition[2] - PlaneData.v3QuadPosition[3];

  004ff	6a 0c		 push	 12			; 0000000cH
  00501	58		 pop	 eax
  00502	6b c0 03	 imul	 eax, eax, 3
  00505	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  0050b	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]
  0050f	89 85 98 fa ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  00515	6a 0c		 push	 12			; 0000000cH
  00517	58		 pop	 eax
  00518	d1 e0		 shl	 eax, 1
  0051a	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  00520	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]
  00524	89 85 94 fa ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0052a	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00530	8b 8d 98 fa ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00536	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0053a	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0053e	f3 0f 11 85 1c
	fa ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00546	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0054c	8b 8d 98 fa ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00552	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00557	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0055c	f3 0f 11 85 20
	fa ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00564	8b 85 94 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0056a	8b 8d 98 fa ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  00570	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00575	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0057a	f3 0f 11 85 24
	fa ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00582	f3 0f 10 85 1c
	fa ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0058a	f3 0f 11 45 cc	 movss	 DWORD PTR _v3Line3$42[ebp], xmm0

; 181  :     y = fy;

  0058f	f3 0f 10 85 20
	fa ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00597	f3 0f 11 45 d0	 movss	 DWORD PTR _v3Line3$42[ebp+4], xmm0

; 182  :     z = fz;

  0059c	f3 0f 10 85 24
	fa ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  005a4	f3 0f 11 45 d4	 movss	 DWORD PTR _v3Line3$42[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 71   : 				D3DXVec3Normalize(&v3Line0, &v3Line0);

  005a9	8d 45 f0	 lea	 eax, DWORD PTR _v3Line0$45[ebp]
  005ac	50		 push	 eax
  005ad	8d 45 f0	 lea	 eax, DWORD PTR _v3Line0$45[ebp]
  005b0	50		 push	 eax
  005b1	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 72   : 				D3DXVec3Normalize(&v3Line1, &v3Line1);

  005b6	8d 45 e4	 lea	 eax, DWORD PTR _v3Line1$44[ebp]
  005b9	50		 push	 eax
  005ba	8d 45 e4	 lea	 eax, DWORD PTR _v3Line1$44[ebp]
  005bd	50		 push	 eax
  005be	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 73   : 				D3DXVec3Normalize(&v3Line2, &v3Line2);

  005c3	8d 45 d8	 lea	 eax, DWORD PTR _v3Line2$43[ebp]
  005c6	50		 push	 eax
  005c7	8d 45 d8	 lea	 eax, DWORD PTR _v3Line2$43[ebp]
  005ca	50		 push	 eax
  005cb	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 74   : 				D3DXVec3Normalize(&v3Line3, &v3Line3);

  005d0	8d 45 cc	 lea	 eax, DWORD PTR _v3Line3$42[ebp]
  005d3	50		 push	 eax
  005d4	8d 45 cc	 lea	 eax, DWORD PTR _v3Line3$42[ebp]
  005d7	50		 push	 eax
  005d8	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 75   : 				D3DXVec3Cross(&PlaneData.v3Normal, &v3Line0, &v3Line1);

  005dd	8b 85 d0 fa ff
	ff		 mov	 eax, DWORD PTR _PlaneData$13[ebp]
  005e3	83 c0 0c	 add	 eax, 12			; 0000000cH
  005e6	89 85 28 fa ff
	ff		 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  005ec	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v3Line0$45[ebp+4]
  005f1	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _v3Line1$44[ebp+8]
  005f6	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _v3Line0$45[ebp+8]
  005fb	f3 0f 59 4d e8	 mulss	 xmm1, DWORD PTR _v3Line1$44[ebp+4]
  00600	f3 0f 5c c1	 subss	 xmm0, xmm1
  00604	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _v$32[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0060c	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3Line0$45[ebp+8]
  00611	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _v3Line1$44[ebp]
  00616	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _v3Line0$45[ebp]
  0061b	f3 0f 59 4d ec	 mulss	 xmm1, DWORD PTR _v3Line1$44[ebp+8]
  00620	f3 0f 5c c1	 subss	 xmm0, xmm1
  00624	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _v$32[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0062c	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v3Line0$45[ebp]
  00631	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _v3Line1$44[ebp+4]
  00636	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _v3Line0$45[ebp+4]
  0063b	f3 0f 59 4d e4	 mulss	 xmm1, DWORD PTR _v3Line1$44[ebp]
  00640	f3 0f 5c c1	 subss	 xmm0, xmm1
  00644	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _v$32[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  0064c	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _v$32[ebp]
  00652	8b bd 28 fa ff
	ff		 mov	 edi, DWORD PTR _pOut$[ebp]
  00658	a5		 movsd
  00659	a5		 movsd
  0065a	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 76   : 				D3DXVec3Normalize(&PlaneData.v3Normal, &PlaneData.v3Normal);

  0065b	8b 85 d0 fa ff
	ff		 mov	 eax, DWORD PTR _PlaneData$13[ebp]
  00661	83 c0 0c	 add	 eax, 12			; 0000000cH
  00664	50		 push	 eax
  00665	8b 85 d0 fa ff
	ff		 mov	 eax, DWORD PTR _PlaneData$13[ebp]
  0066b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0066e	50		 push	 eax
  0066f	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 77   : 
; 78   : 				D3DXVec3Cross(&PlaneData.v3InsideVector[0], &PlaneData.v3Normal, &v3Line0 );

  00674	8b 85 d0 fa ff
	ff		 mov	 eax, DWORD PTR _PlaneData$13[ebp]
  0067a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0067d	89 85 b4 fa ff
	ff		 mov	 DWORD PTR _pV1$[ebp], eax
  00683	6a 0c		 push	 12			; 0000000cH
  00685	58		 pop	 eax
  00686	6b c0 00	 imul	 eax, eax, 0
  00689	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  0068f	8d 44 01 48	 lea	 eax, DWORD PTR [ecx+eax+72]
  00693	89 85 30 fa ff
	ff		 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00699	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  0069f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  006a4	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _v3Line0$45[ebp+8]
  006a9	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  006af	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  006b4	f3 0f 59 4d f4	 mulss	 xmm1, DWORD PTR _v3Line0$45[ebp+4]
  006b9	f3 0f 5c c1	 subss	 xmm0, xmm1
  006bd	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _v$33[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  006c5	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  006cb	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  006d0	f3 0f 59 45 f0	 mulss	 xmm0, DWORD PTR _v3Line0$45[ebp]
  006d5	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  006db	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  006df	f3 0f 59 4d f8	 mulss	 xmm1, DWORD PTR _v3Line0$45[ebp+8]
  006e4	f3 0f 5c c1	 subss	 xmm0, xmm1
  006e8	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _v$33[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  006f0	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  006f6	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  006fa	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _v3Line0$45[ebp+4]
  006ff	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  00705	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0070a	f3 0f 59 4d f0	 mulss	 xmm1, DWORD PTR _v3Line0$45[ebp]
  0070f	f3 0f 5c c1	 subss	 xmm0, xmm1
  00713	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _v$33[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  0071b	8d b5 60 ff ff
	ff		 lea	 esi, DWORD PTR _v$33[ebp]
  00721	8b bd 30 fa ff
	ff		 mov	 edi, DWORD PTR _pOut$[ebp]
  00727	a5		 movsd
  00728	a5		 movsd
  00729	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 79   : 				D3DXVec3Cross(&PlaneData.v3InsideVector[1], &v3Line1, &PlaneData.v3Normal);

  0072a	8b 85 d0 fa ff
	ff		 mov	 eax, DWORD PTR _PlaneData$13[ebp]
  00730	83 c0 0c	 add	 eax, 12			; 0000000cH
  00733	89 85 b8 fa ff
	ff		 mov	 DWORD PTR _pV2$[ebp], eax
  00739	6a 0c		 push	 12			; 0000000cH
  0073b	58		 pop	 eax
  0073c	c1 e0 00	 shl	 eax, 0
  0073f	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  00745	8d 44 01 48	 lea	 eax, DWORD PTR [ecx+eax+72]
  00749	89 85 2c fa ff
	ff		 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0074f	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00755	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _v3Line1$44[ebp+4]
  0075a	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  0075f	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00765	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _v3Line1$44[ebp+8]
  0076a	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  0076f	f3 0f 5c c1	 subss	 xmm0, xmm1
  00773	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _v$34[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0077b	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00781	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _v3Line1$44[ebp+8]
  00786	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0078a	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00790	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _v3Line1$44[ebp]
  00795	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  0079a	f3 0f 5c c1	 subss	 xmm0, xmm1
  0079e	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR _v$34[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  007a6	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  007ac	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _v3Line1$44[ebp]
  007b1	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  007b6	8b 85 b8 fa ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  007bc	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _v3Line1$44[ebp+4]
  007c1	f3 0f 59 08	 mulss	 xmm1, DWORD PTR [eax]
  007c5	f3 0f 5c c1	 subss	 xmm0, xmm1
  007c9	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _v$34[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  007d1	8d b5 6c ff ff
	ff		 lea	 esi, DWORD PTR _v$34[ebp]
  007d7	8b bd 2c fa ff
	ff		 mov	 edi, DWORD PTR _pOut$[ebp]
  007dd	a5		 movsd
  007de	a5		 movsd
  007df	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 80   : 				D3DXVec3Cross(&PlaneData.v3InsideVector[2], &v3Line2, &PlaneData.v3Normal);

  007e0	8b 85 d0 fa ff
	ff		 mov	 eax, DWORD PTR _PlaneData$13[ebp]
  007e6	83 c0 0c	 add	 eax, 12			; 0000000cH
  007e9	89 85 bc fa ff
	ff		 mov	 DWORD PTR _pV2$[ebp], eax
  007ef	6a 0c		 push	 12			; 0000000cH
  007f1	58		 pop	 eax
  007f2	d1 e0		 shl	 eax, 1
  007f4	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  007fa	8d 44 01 48	 lea	 eax, DWORD PTR [ecx+eax+72]
  007fe	89 85 0c fa ff
	ff		 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00804	8b 85 bc fa ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  0080a	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _v3Line2$43[ebp+4]
  0080f	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00814	8b 85 bc fa ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  0081a	f3 0f 10 4d e0	 movss	 xmm1, DWORD PTR _v3Line2$43[ebp+8]
  0081f	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  00824	f3 0f 5c c1	 subss	 xmm0, xmm1
  00828	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _v$35[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00830	8b 85 bc fa ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00836	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _v3Line2$43[ebp+8]
  0083b	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0083f	8b 85 bc fa ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00845	f3 0f 10 4d d8	 movss	 xmm1, DWORD PTR _v3Line2$43[ebp]
  0084a	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  0084f	f3 0f 5c c1	 subss	 xmm0, xmm1
  00853	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _v$35[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0085b	8b 85 bc fa ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00861	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _v3Line2$43[ebp]
  00866	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  0086b	8b 85 bc fa ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00871	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR _v3Line2$43[ebp+4]
  00876	f3 0f 59 08	 mulss	 xmm1, DWORD PTR [eax]
  0087a	f3 0f 5c c1	 subss	 xmm0, xmm1
  0087e	f3 0f 11 45 80	 movss	 DWORD PTR _v$35[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  00883	8d b5 78 ff ff
	ff		 lea	 esi, DWORD PTR _v$35[ebp]
  00889	8b bd 0c fa ff
	ff		 mov	 edi, DWORD PTR _pOut$[ebp]
  0088f	a5		 movsd
  00890	a5		 movsd
  00891	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 81   : 				D3DXVec3Cross(&PlaneData.v3InsideVector[3], &PlaneData.v3Normal, &v3Line3);

  00892	8b 85 d0 fa ff
	ff		 mov	 eax, DWORD PTR _PlaneData$13[ebp]
  00898	83 c0 0c	 add	 eax, 12			; 0000000cH
  0089b	89 85 c0 fa ff
	ff		 mov	 DWORD PTR _pV1$[ebp], eax
  008a1	6a 0c		 push	 12			; 0000000cH
  008a3	58		 pop	 eax
  008a4	6b c0 03	 imul	 eax, eax, 3
  008a7	8b 8d d0 fa ff
	ff		 mov	 ecx, DWORD PTR _PlaneData$13[ebp]
  008ad	8d 44 01 48	 lea	 eax, DWORD PTR [ecx+eax+72]
  008b1	89 85 50 fa ff
	ff		 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  008b7	8b 85 c0 fa ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  008bd	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  008c2	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _v3Line3$42[ebp+8]
  008c7	8b 85 c0 fa ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  008cd	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  008d2	f3 0f 59 4d d0	 mulss	 xmm1, DWORD PTR _v3Line3$42[ebp+4]
  008d7	f3 0f 5c c1	 subss	 xmm0, xmm1
  008db	f3 0f 11 45 84	 movss	 DWORD PTR _v$36[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  008e0	8b 85 c0 fa ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  008e6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  008eb	f3 0f 59 45 cc	 mulss	 xmm0, DWORD PTR _v3Line3$42[ebp]
  008f0	8b 85 c0 fa ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  008f6	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  008fa	f3 0f 59 4d d4	 mulss	 xmm1, DWORD PTR _v3Line3$42[ebp+8]
  008ff	f3 0f 5c c1	 subss	 xmm0, xmm1
  00903	f3 0f 11 45 88	 movss	 DWORD PTR _v$36[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00908	8b 85 c0 fa ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  0090e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00912	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR _v3Line3$42[ebp+4]
  00917	8b 85 c0 fa ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  0091d	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00922	f3 0f 59 4d cc	 mulss	 xmm1, DWORD PTR _v3Line3$42[ebp]
  00927	f3 0f 5c c1	 subss	 xmm0, xmm1
  0092b	f3 0f 11 45 8c	 movss	 DWORD PTR _v$36[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  00930	8d 75 84	 lea	 esi, DWORD PTR _v$36[ebp]
  00933	8b bd 50 fa ff
	ff		 mov	 edi, DWORD PTR _pOut$[ebp]
  00939	a5		 movsd
  0093a	a5		 movsd
  0093b	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 83   : 				return ppci;

  0093c	8b 85 68 fa ff
	ff		 mov	 eax, DWORD PTR _ppci$1[ebp]
  00942	e9 4c 0a 00 00	 jmp	 $LN1@BuildColli

; 84   : 			}
; 85   : 			break;

  00947	e9 45 0a 00 00	 jmp	 $LN2@BuildColli

; 86   : 		case COLLISION_TYPE_BOX:
; 87   : 			assert(false && "COLLISION_TYPE_BOX not implemented");
; 88   : 			break;

  0094c	e9 40 0a 00 00	 jmp	 $LN2@BuildColli
$LN9@BuildColli:

; 89   : 		case COLLISION_TYPE_AABB:
; 90   : 			{
; 91   : 				CAABBCollisionInstance * paci = gs_aci.Alloc();

  00951	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A ; gs_aci
  00956	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ ; CDynamicPool<CAABBCollisionInstance>::Alloc
  0095b	89 85 6c fa ff
	ff		 mov	 DWORD PTR _paci$2[ebp], eax

; 92   : 				
; 93   : 				D3DXMATRIX matTranslationLocal;
; 94   : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  00961	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  00964	51		 push	 ecx
  00965	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [eax+48]
  0096a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0096f	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  00972	51		 push	 ecx
  00973	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  00978	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0097d	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  00980	51		 push	 ecx
  00981	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  00986	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0098b	8d 85 54 fe ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$28[ebp]
  00991	50		 push	 eax
  00992	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16

; 95   : 				D3DXMATRIX matTransform = *pMat;

  00997	6a 10		 push	 16			; 00000010H
  00999	59		 pop	 ecx
  0099a	8b 75 0c	 mov	 esi, DWORD PTR _pMat$[ebp]
  0099d	8d bd 14 fe ff
	ff		 lea	 edi, DWORD PTR _matTransform$27[ebp]
  009a3	f3 a5		 rep movsd

; 96   : 
; 97   : 				D3DXVECTOR3 v3Pos;
; 98   : 				v3Pos.x = matTranslationLocal._41;

  009a5	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR _matTranslationLocal$28[ebp+48]
  009ad	f3 0f 11 45 b4	 movss	 DWORD PTR _v3Pos$40[ebp], xmm0

; 99   : 				v3Pos.y = matTranslationLocal._42;

  009b2	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR _matTranslationLocal$28[ebp+52]
  009ba	f3 0f 11 45 b8	 movss	 DWORD PTR _v3Pos$40[ebp+4], xmm0

; 100  : 				v3Pos.z = matTranslationLocal._43;

  009bf	f3 0f 10 85 8c
	fe ff ff	 movss	 xmm0, DWORD PTR _matTranslationLocal$28[ebp+56]
  009c7	f3 0f 11 45 bc	 movss	 DWORD PTR _v3Pos$40[ebp+8], xmm0

; 101  : 
; 102  : 				TAABBData & AABBData = paci->GetAttribute();

  009cc	8b 8d 6c fa ff
	ff		 mov	 ecx, DWORD PTR _paci$2[ebp]
  009d2	e8 00 00 00 00	 call	 ?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ ; CAABBCollisionInstance::GetAttribute
  009d7	89 85 c4 fa ff
	ff		 mov	 DWORD PTR _AABBData$11[ebp], eax

; 103  : 				AABBData.v3Min.x = v3Pos.x - c_pCollisionData->fDimensions[0];

  009dd	6a 04		 push	 4
  009df	58		 pop	 eax
  009e0	6b c0 00	 imul	 eax, eax, 0
  009e3	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  009e6	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _v3Pos$40[ebp]
  009eb	f3 0f 5c 44 01
	34		 subss	 xmm0, DWORD PTR [ecx+eax+52]
  009f1	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _AABBData$11[ebp]
  009f7	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 104  : 				AABBData.v3Min.y = v3Pos.y - c_pCollisionData->fDimensions[1];

  009fb	6a 04		 push	 4
  009fd	58		 pop	 eax
  009fe	c1 e0 00	 shl	 eax, 0
  00a01	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00a04	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _v3Pos$40[ebp+4]
  00a09	f3 0f 5c 44 01
	34		 subss	 xmm0, DWORD PTR [ecx+eax+52]
  00a0f	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _AABBData$11[ebp]
  00a15	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 105  : 				AABBData.v3Min.z = v3Pos.z - c_pCollisionData->fDimensions[2];

  00a1a	6a 04		 push	 4
  00a1c	58		 pop	 eax
  00a1d	d1 e0		 shl	 eax, 1
  00a1f	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00a22	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _v3Pos$40[ebp+8]
  00a27	f3 0f 5c 44 01
	34		 subss	 xmm0, DWORD PTR [ecx+eax+52]
  00a2d	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _AABBData$11[ebp]
  00a33	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 106  : 				AABBData.v3Max.x = v3Pos.x + c_pCollisionData->fDimensions[0];

  00a38	6a 04		 push	 4
  00a3a	58		 pop	 eax
  00a3b	6b c0 00	 imul	 eax, eax, 0
  00a3e	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00a41	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _v3Pos$40[ebp]
  00a46	f3 0f 58 44 01
	34		 addss	 xmm0, DWORD PTR [ecx+eax+52]
  00a4c	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _AABBData$11[ebp]
  00a52	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 107  : 				AABBData.v3Max.y = v3Pos.y + c_pCollisionData->fDimensions[1];

  00a57	6a 04		 push	 4
  00a59	58		 pop	 eax
  00a5a	c1 e0 00	 shl	 eax, 0
  00a5d	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00a60	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _v3Pos$40[ebp+4]
  00a65	f3 0f 58 44 01
	34		 addss	 xmm0, DWORD PTR [ecx+eax+52]
  00a6b	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _AABBData$11[ebp]
  00a71	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 108  : 				AABBData.v3Max.z = v3Pos.z + c_pCollisionData->fDimensions[2];

  00a76	6a 04		 push	 4
  00a78	58		 pop	 eax
  00a79	d1 e0		 shl	 eax, 1
  00a7b	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00a7e	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _v3Pos$40[ebp+8]
  00a83	f3 0f 58 44 01
	34		 addss	 xmm0, DWORD PTR [ecx+eax+52]
  00a89	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _AABBData$11[ebp]
  00a8f	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 109  : 
; 110  : 				D3DXVec3TransformCoord(&AABBData.v3Min, &AABBData.v3Min, &matTransform);

  00a94	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _matTransform$27[ebp]
  00a9a	50		 push	 eax
  00a9b	ff b5 c4 fa ff
	ff		 push	 DWORD PTR _AABBData$11[ebp]
  00aa1	ff b5 c4 fa ff
	ff		 push	 DWORD PTR _AABBData$11[ebp]
  00aa7	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 111  : 				D3DXVec3TransformCoord(&AABBData.v3Max, &AABBData.v3Max, &matTransform);

  00aac	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _matTransform$27[ebp]
  00ab2	50		 push	 eax
  00ab3	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _AABBData$11[ebp]
  00ab9	83 c0 0c	 add	 eax, 12			; 0000000cH
  00abc	50		 push	 eax
  00abd	8b 85 c4 fa ff
	ff		 mov	 eax, DWORD PTR _AABBData$11[ebp]
  00ac3	83 c0 0c	 add	 eax, 12			; 0000000cH
  00ac6	50		 push	 eax
  00ac7	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 112  : 
; 113  : 				return paci;

  00acc	8b 85 6c fa ff
	ff		 mov	 eax, DWORD PTR _paci$2[ebp]
  00ad2	e9 bc 08 00 00	 jmp	 $LN1@BuildColli

; 114  : 			}
; 115  : 			break;

  00ad7	e9 b5 08 00 00	 jmp	 $LN2@BuildColli
$LN10@BuildColli:

; 116  : 			case COLLISION_TYPE_OBB:
; 117  : 			{
; 118  : 				COBBCollisionInstance * poci = gs_oci.Alloc();

  00adc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A ; gs_oci
  00ae1	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEPAVCOBBCollisionInstance@@XZ ; CDynamicPool<COBBCollisionInstance>::Alloc
  00ae6	89 85 70 fa ff
	ff		 mov	 DWORD PTR _poci$3[ebp], eax

; 119  : 				
; 120  : 				D3DXMATRIX matTranslationLocal; D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  00aec	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  00aef	51		 push	 ecx
  00af0	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [eax+48]
  00af5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00afa	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  00afd	51		 push	 ecx
  00afe	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  00b03	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b08	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  00b0b	51		 push	 ecx
  00b0c	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  00b11	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b16	8d 85 d4 fa ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$14[ebp]
  00b1c	50		 push	 eax
  00b1d	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16

; 121  : 				D3DXMATRIX matRotation; D3DXMatrixRotationQuaternion(&matRotation, &c_pCollisionData->quatRotation);

  00b22	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  00b25	83 c0 40	 add	 eax, 64			; 00000040H
  00b28	50		 push	 eax
  00b29	8d 85 14 fb ff
	ff		 lea	 eax, DWORD PTR _matRotation$15[ebp]
  00b2f	50		 push	 eax
  00b30	e8 00 00 00 00	 call	 _D3DXMatrixRotationQuaternion@8
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00b35	6a 10		 push	 16			; 00000010H
  00b37	58		 pop	 eax
  00b38	6b c0 03	 imul	 eax, eax, 3
  00b3b	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00b42	6a 04		 push	 4
  00b44	59		 pop	 ecx
  00b45	d1 e1		 shl	 ecx, 1
  00b47	0f 57 c0	 xorps	 xmm0, xmm0
  00b4a	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00b4f	6a 10		 push	 16			; 00000010H
  00b51	58		 pop	 eax
  00b52	6b c0 03	 imul	 eax, eax, 3
  00b55	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00b5c	6a 04		 push	 4
  00b5e	59		 pop	 ecx
  00b5f	c1 e1 00	 shl	 ecx, 0
  00b62	0f 57 c0	 xorps	 xmm0, xmm0
  00b65	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00b6a	6a 10		 push	 16			; 00000010H
  00b6c	58		 pop	 eax
  00b6d	6b c0 03	 imul	 eax, eax, 3
  00b70	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00b77	6a 04		 push	 4
  00b79	59		 pop	 ecx
  00b7a	6b c9 00	 imul	 ecx, ecx, 0
  00b7d	0f 57 c0	 xorps	 xmm0, xmm0
  00b80	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00b85	6a 10		 push	 16			; 00000010H
  00b87	58		 pop	 eax
  00b88	d1 e0		 shl	 eax, 1
  00b8a	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00b91	6a 04		 push	 4
  00b93	59		 pop	 ecx
  00b94	6b c9 03	 imul	 ecx, ecx, 3
  00b97	0f 57 c0	 xorps	 xmm0, xmm0
  00b9a	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00b9f	6a 10		 push	 16			; 00000010H
  00ba1	58		 pop	 eax
  00ba2	d1 e0		 shl	 eax, 1
  00ba4	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00bab	6a 04		 push	 4
  00bad	59		 pop	 ecx
  00bae	c1 e1 00	 shl	 ecx, 0
  00bb1	0f 57 c0	 xorps	 xmm0, xmm0
  00bb4	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00bb9	6a 10		 push	 16			; 00000010H
  00bbb	58		 pop	 eax
  00bbc	d1 e0		 shl	 eax, 1
  00bbe	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00bc5	6a 04		 push	 4
  00bc7	59		 pop	 ecx
  00bc8	6b c9 00	 imul	 ecx, ecx, 0
  00bcb	0f 57 c0	 xorps	 xmm0, xmm0
  00bce	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00bd3	6a 10		 push	 16			; 00000010H
  00bd5	58		 pop	 eax
  00bd6	c1 e0 00	 shl	 eax, 0
  00bd9	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00be0	6a 04		 push	 4
  00be2	59		 pop	 ecx
  00be3	6b c9 03	 imul	 ecx, ecx, 3
  00be6	0f 57 c0	 xorps	 xmm0, xmm0
  00be9	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00bee	6a 10		 push	 16			; 00000010H
  00bf0	58		 pop	 eax
  00bf1	c1 e0 00	 shl	 eax, 0
  00bf4	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00bfb	6a 04		 push	 4
  00bfd	59		 pop	 ecx
  00bfe	d1 e1		 shl	 ecx, 1
  00c00	0f 57 c0	 xorps	 xmm0, xmm0
  00c03	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00c08	6a 10		 push	 16			; 00000010H
  00c0a	58		 pop	 eax
  00c0b	c1 e0 00	 shl	 eax, 0
  00c0e	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00c15	6a 04		 push	 4
  00c17	59		 pop	 ecx
  00c18	6b c9 00	 imul	 ecx, ecx, 0
  00c1b	0f 57 c0	 xorps	 xmm0, xmm0
  00c1e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00c23	6a 10		 push	 16			; 00000010H
  00c25	58		 pop	 eax
  00c26	6b c0 00	 imul	 eax, eax, 0
  00c29	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00c30	6a 04		 push	 4
  00c32	59		 pop	 ecx
  00c33	6b c9 03	 imul	 ecx, ecx, 3
  00c36	0f 57 c0	 xorps	 xmm0, xmm0
  00c39	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00c3e	6a 10		 push	 16			; 00000010H
  00c40	58		 pop	 eax
  00c41	6b c0 00	 imul	 eax, eax, 0
  00c44	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00c4b	6a 04		 push	 4
  00c4d	59		 pop	 ecx
  00c4e	d1 e1		 shl	 ecx, 1
  00c50	0f 57 c0	 xorps	 xmm0, xmm0
  00c53	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00c58	6a 10		 push	 16			; 00000010H
  00c5a	58		 pop	 eax
  00c5b	6b c0 00	 imul	 eax, eax, 0
  00c5e	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00c65	6a 04		 push	 4
  00c67	59		 pop	 ecx
  00c68	c1 e1 00	 shl	 ecx, 0
  00c6b	0f 57 c0	 xorps	 xmm0, xmm0
  00c6e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00c73	6a 10		 push	 16			; 00000010H
  00c75	58		 pop	 eax
  00c76	6b c0 03	 imul	 eax, eax, 3
  00c79	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00c80	6a 04		 push	 4
  00c82	59		 pop	 ecx
  00c83	6b c9 03	 imul	 ecx, ecx, 3
  00c86	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00c8e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00c93	6a 10		 push	 16			; 00000010H
  00c95	58		 pop	 eax
  00c96	d1 e0		 shl	 eax, 1
  00c98	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00c9f	6a 04		 push	 4
  00ca1	59		 pop	 ecx
  00ca2	d1 e1		 shl	 ecx, 1
  00ca4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00cac	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00cb1	6a 10		 push	 16			; 00000010H
  00cb3	58		 pop	 eax
  00cb4	c1 e0 00	 shl	 eax, 0
  00cb7	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00cbe	6a 04		 push	 4
  00cc0	59		 pop	 ecx
  00cc1	c1 e1 00	 shl	 ecx, 0
  00cc4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ccc	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00cd1	6a 10		 push	 16			; 00000010H
  00cd3	58		 pop	 eax
  00cd4	6b c0 00	 imul	 eax, eax, 0
  00cd7	8d 84 05 14 ff
	ff ff		 lea	 eax, DWORD PTR _matTranslationWorld$31[ebp+eax]
  00cde	6a 04		 push	 4
  00ce0	59		 pop	 ecx
  00ce1	6b c9 00	 imul	 ecx, ecx, 0
  00ce4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00cec	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 124  : 				matTranslationWorld._41 = pMat->_41; matTranslationWorld._42 = pMat->_42; matTranslationWorld._43 = pMat->_43; matTranslationWorld._44 = pMat->_44;

  00cf1	8b 45 0c	 mov	 eax, DWORD PTR _pMat$[ebp]
  00cf4	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [eax+48]
  00cf9	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _matTranslationWorld$31[ebp+48], xmm0
  00d01	8b 45 0c	 mov	 eax, DWORD PTR _pMat$[ebp]
  00d04	f3 0f 10 40 34	 movss	 xmm0, DWORD PTR [eax+52]
  00d09	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _matTranslationWorld$31[ebp+52], xmm0
  00d11	8b 45 0c	 mov	 eax, DWORD PTR _pMat$[ebp]
  00d14	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  00d19	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _matTranslationWorld$31[ebp+56], xmm0
  00d21	8b 45 0c	 mov	 eax, DWORD PTR _pMat$[ebp]
  00d24	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  00d29	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _matTranslationWorld$31[ebp+60], xmm0

; 125  : 				
; 126  : 				D3DXVECTOR3 v3Min, v3Max;
; 127  : 				v3Min.x = c_pCollisionData->v3Position.x - c_pCollisionData->fDimensions[0];

  00d31	6a 04		 push	 4
  00d33	58		 pop	 eax
  00d34	6b c0 00	 imul	 eax, eax, 0
  00d37	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00d3a	8b 55 08	 mov	 edx, DWORD PTR _c_pCollisionData$[ebp]
  00d3d	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [ecx+40]
  00d42	f3 0f 5c 44 02
	34		 subss	 xmm0, DWORD PTR [edx+eax+52]
  00d48	f3 0f 11 45 9c	 movss	 DWORD PTR _v3Min$38[ebp], xmm0

; 128  : 				v3Min.y = c_pCollisionData->v3Position.y - c_pCollisionData->fDimensions[1];

  00d4d	6a 04		 push	 4
  00d4f	58		 pop	 eax
  00d50	c1 e0 00	 shl	 eax, 0
  00d53	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00d56	8b 55 08	 mov	 edx, DWORD PTR _c_pCollisionData$[ebp]
  00d59	f3 0f 10 41 2c	 movss	 xmm0, DWORD PTR [ecx+44]
  00d5e	f3 0f 5c 44 02
	34		 subss	 xmm0, DWORD PTR [edx+eax+52]
  00d64	f3 0f 11 45 a0	 movss	 DWORD PTR _v3Min$38[ebp+4], xmm0

; 129  : 				v3Min.z = c_pCollisionData->v3Position.z - c_pCollisionData->fDimensions[2];

  00d69	6a 04		 push	 4
  00d6b	58		 pop	 eax
  00d6c	d1 e0		 shl	 eax, 1
  00d6e	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00d71	8b 55 08	 mov	 edx, DWORD PTR _c_pCollisionData$[ebp]
  00d74	f3 0f 10 41 30	 movss	 xmm0, DWORD PTR [ecx+48]
  00d79	f3 0f 5c 44 02
	34		 subss	 xmm0, DWORD PTR [edx+eax+52]
  00d7f	f3 0f 11 45 a4	 movss	 DWORD PTR _v3Min$38[ebp+8], xmm0

; 130  : 				v3Max.x = c_pCollisionData->v3Position.x + c_pCollisionData->fDimensions[0];

  00d84	6a 04		 push	 4
  00d86	58		 pop	 eax
  00d87	6b c0 00	 imul	 eax, eax, 0
  00d8a	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00d8d	8b 55 08	 mov	 edx, DWORD PTR _c_pCollisionData$[ebp]
  00d90	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [ecx+40]
  00d95	f3 0f 58 44 02
	34		 addss	 xmm0, DWORD PTR [edx+eax+52]
  00d9b	f3 0f 11 45 a8	 movss	 DWORD PTR _v3Max$39[ebp], xmm0

; 131  : 				v3Max.y = c_pCollisionData->v3Position.y + c_pCollisionData->fDimensions[1];

  00da0	6a 04		 push	 4
  00da2	58		 pop	 eax
  00da3	c1 e0 00	 shl	 eax, 0
  00da6	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00da9	8b 55 08	 mov	 edx, DWORD PTR _c_pCollisionData$[ebp]
  00dac	f3 0f 10 41 2c	 movss	 xmm0, DWORD PTR [ecx+44]
  00db1	f3 0f 58 44 02
	34		 addss	 xmm0, DWORD PTR [edx+eax+52]
  00db7	f3 0f 11 45 ac	 movss	 DWORD PTR _v3Max$39[ebp+4], xmm0

; 132  : 				v3Max.z = c_pCollisionData->v3Position.z + c_pCollisionData->fDimensions[2];

  00dbc	6a 04		 push	 4
  00dbe	58		 pop	 eax
  00dbf	d1 e0		 shl	 eax, 1
  00dc1	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00dc4	8b 55 08	 mov	 edx, DWORD PTR _c_pCollisionData$[ebp]
  00dc7	f3 0f 10 41 30	 movss	 xmm0, DWORD PTR [ecx+48]
  00dcc	f3 0f 58 44 02
	34		 addss	 xmm0, DWORD PTR [edx+eax+52]
  00dd2	f3 0f 11 45 b0	 movss	 DWORD PTR _v3Max$39[ebp+8], xmm0

; 133  : 
; 134  : 				D3DXVec3TransformCoord(&v3Min, &v3Min, pMat);

  00dd7	ff 75 0c	 push	 DWORD PTR _pMat$[ebp]
  00dda	8d 45 9c	 lea	 eax, DWORD PTR _v3Min$38[ebp]
  00ddd	50		 push	 eax
  00dde	8d 45 9c	 lea	 eax, DWORD PTR _v3Min$38[ebp]
  00de1	50		 push	 eax
  00de2	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 135  : 				D3DXVec3TransformCoord(&v3Max, &v3Max, pMat);

  00de7	ff 75 0c	 push	 DWORD PTR _pMat$[ebp]
  00dea	8d 45 a8	 lea	 eax, DWORD PTR _v3Max$39[ebp]
  00ded	50		 push	 eax
  00dee	8d 45 a8	 lea	 eax, DWORD PTR _v3Max$39[ebp]
  00df1	50		 push	 eax
  00df2	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00df7	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _v3Min$38[ebp]
  00dfc	f3 0f 58 45 a8	 addss	 xmm0, DWORD PTR _v3Max$39[ebp]
  00e01	f3 0f 11 85 4c
	fa ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00e09	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _v3Min$38[ebp+4]
  00e0e	f3 0f 58 45 ac	 addss	 xmm0, DWORD PTR _v3Max$39[ebp+4]
  00e13	f3 0f 11 85 48
	fa ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00e1b	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _v3Min$38[ebp+8]
  00e20	f3 0f 58 45 b0	 addss	 xmm0, DWORD PTR _v3Max$39[ebp+8]
  00e25	f3 0f 11 85 44
	fa ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00e2d	f3 0f 10 85 4c
	fa ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00e35	f3 0f 11 45 90	 movss	 DWORD PTR $T37[ebp], xmm0

; 181  :     y = fy;

  00e3a	f3 0f 10 85 48
	fa ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00e42	f3 0f 11 45 94	 movss	 DWORD PTR $T37[ebp+4], xmm0

; 182  :     z = fz;

  00e47	f3 0f 10 85 44
	fa ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00e4f	f3 0f 11 45 98	 movss	 DWORD PTR $T37[ebp+8], xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00e54	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR $T37[ebp]
  00e59	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00e61	f3 0f 11 85 40
	fa ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00e69	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR $T37[ebp+4]
  00e6e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00e76	f3 0f 11 85 3c
	fa ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00e7e	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR $T37[ebp+8]
  00e83	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00e8b	f3 0f 11 85 38
	fa ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00e93	f3 0f 10 85 40
	fa ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00e9b	f3 0f 11 45 c0	 movss	 DWORD PTR _v3Position$41[ebp], xmm0

; 181  :     y = fy;

  00ea0	f3 0f 10 85 3c
	fa ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00ea8	f3 0f 11 45 c4	 movss	 DWORD PTR _v3Position$41[ebp+4], xmm0

; 182  :     z = fz;

  00ead	f3 0f 10 85 38
	fa ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00eb5	f3 0f 11 45 c8	 movss	 DWORD PTR _v3Position$41[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 138  : 				TOBBData & OBBData = poci->GetAttribute();

  00eba	8b 8d 70 fa ff
	ff		 mov	 ecx, DWORD PTR _poci$3[ebp]
  00ec0	e8 00 00 00 00	 call	 ?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ ; COBBCollisionInstance::GetAttribute
  00ec5	89 85 c8 fa ff
	ff		 mov	 DWORD PTR _OBBData$12[ebp], eax

; 139  : 				OBBData.v3Min.x = v3Position.x - c_pCollisionData->fDimensions[0];

  00ecb	6a 04		 push	 4
  00ecd	58		 pop	 eax
  00ece	6b c0 00	 imul	 eax, eax, 0
  00ed1	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00ed4	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _v3Position$41[ebp]
  00ed9	f3 0f 5c 44 01
	34		 subss	 xmm0, DWORD PTR [ecx+eax+52]
  00edf	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _OBBData$12[ebp]
  00ee5	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 140  : 				OBBData.v3Min.y = v3Position.y - c_pCollisionData->fDimensions[1];

  00ee9	6a 04		 push	 4
  00eeb	58		 pop	 eax
  00eec	c1 e0 00	 shl	 eax, 0
  00eef	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00ef2	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _v3Position$41[ebp+4]
  00ef7	f3 0f 5c 44 01
	34		 subss	 xmm0, DWORD PTR [ecx+eax+52]
  00efd	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _OBBData$12[ebp]
  00f03	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 141  : 				OBBData.v3Min.z = v3Position.z - c_pCollisionData->fDimensions[2];

  00f08	6a 04		 push	 4
  00f0a	58		 pop	 eax
  00f0b	d1 e0		 shl	 eax, 1
  00f0d	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00f10	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _v3Position$41[ebp+8]
  00f15	f3 0f 5c 44 01
	34		 subss	 xmm0, DWORD PTR [ecx+eax+52]
  00f1b	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _OBBData$12[ebp]
  00f21	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 142  : 				OBBData.v3Max.x = v3Position.x + c_pCollisionData->fDimensions[0];

  00f26	6a 04		 push	 4
  00f28	58		 pop	 eax
  00f29	6b c0 00	 imul	 eax, eax, 0
  00f2c	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00f2f	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _v3Position$41[ebp]
  00f34	f3 0f 58 44 01
	34		 addss	 xmm0, DWORD PTR [ecx+eax+52]
  00f3a	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _OBBData$12[ebp]
  00f40	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 143  : 				OBBData.v3Max.y = v3Position.y + c_pCollisionData->fDimensions[1];

  00f45	6a 04		 push	 4
  00f47	58		 pop	 eax
  00f48	c1 e0 00	 shl	 eax, 0
  00f4b	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00f4e	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _v3Position$41[ebp+4]
  00f53	f3 0f 58 44 01
	34		 addss	 xmm0, DWORD PTR [ecx+eax+52]
  00f59	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _OBBData$12[ebp]
  00f5f	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 144  : 				OBBData.v3Max.z = v3Position.z + c_pCollisionData->fDimensions[2];

  00f64	6a 04		 push	 4
  00f66	58		 pop	 eax
  00f67	d1 e0		 shl	 eax, 1
  00f69	8b 4d 08	 mov	 ecx, DWORD PTR _c_pCollisionData$[ebp]
  00f6c	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _v3Position$41[ebp+8]
  00f71	f3 0f 58 44 01
	34		 addss	 xmm0, DWORD PTR [ecx+eax+52]
  00f77	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _OBBData$12[ebp]
  00f7d	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 145  : 
; 146  : 				
; 147  : 
; 148  : 				D3DXMATRIX matTransform = *pMat;

  00f82	6a 10		 push	 16			; 00000010H
  00f84	59		 pop	 ecx
  00f85	8b 75 0c	 mov	 esi, DWORD PTR _pMat$[ebp]
  00f88	8d bd 54 fb ff
	ff		 lea	 edi, DWORD PTR _matTransform$16[ebp]
  00f8e	f3 a5		 rep movsd

; 150  : 				D3DXMatrixIdentity(&OBBData.matRot); OBBData.matRot = *pMat;

  00f90	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _OBBData$12[ebp]
  00f96	83 c0 18	 add	 eax, 24			; 00000018H
  00f99	89 85 cc fa ff
	ff		 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00f9f	6a 10		 push	 16			; 00000010H
  00fa1	58		 pop	 eax
  00fa2	6b c0 03	 imul	 eax, eax, 3
  00fa5	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  00fab	6a 04		 push	 4
  00fad	59		 pop	 ecx
  00fae	d1 e1		 shl	 ecx, 1
  00fb0	0f 57 c0	 xorps	 xmm0, xmm0
  00fb3	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00fb8	6a 10		 push	 16			; 00000010H
  00fba	58		 pop	 eax
  00fbb	6b c0 03	 imul	 eax, eax, 3
  00fbe	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  00fc4	6a 04		 push	 4
  00fc6	59		 pop	 ecx
  00fc7	c1 e1 00	 shl	 ecx, 0
  00fca	0f 57 c0	 xorps	 xmm0, xmm0
  00fcd	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00fd2	6a 10		 push	 16			; 00000010H
  00fd4	58		 pop	 eax
  00fd5	6b c0 03	 imul	 eax, eax, 3
  00fd8	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  00fde	6a 04		 push	 4
  00fe0	59		 pop	 ecx
  00fe1	6b c9 00	 imul	 ecx, ecx, 0
  00fe4	0f 57 c0	 xorps	 xmm0, xmm0
  00fe7	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00fec	6a 10		 push	 16			; 00000010H
  00fee	58		 pop	 eax
  00fef	d1 e0		 shl	 eax, 1
  00ff1	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  00ff7	6a 04		 push	 4
  00ff9	59		 pop	 ecx
  00ffa	6b c9 03	 imul	 ecx, ecx, 3
  00ffd	0f 57 c0	 xorps	 xmm0, xmm0
  01000	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  01005	6a 10		 push	 16			; 00000010H
  01007	58		 pop	 eax
  01008	d1 e0		 shl	 eax, 1
  0100a	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  01010	6a 04		 push	 4
  01012	59		 pop	 ecx
  01013	c1 e1 00	 shl	 ecx, 0
  01016	0f 57 c0	 xorps	 xmm0, xmm0
  01019	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0101e	6a 10		 push	 16			; 00000010H
  01020	58		 pop	 eax
  01021	d1 e0		 shl	 eax, 1
  01023	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  01029	6a 04		 push	 4
  0102b	59		 pop	 ecx
  0102c	6b c9 00	 imul	 ecx, ecx, 0
  0102f	0f 57 c0	 xorps	 xmm0, xmm0
  01032	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  01037	6a 10		 push	 16			; 00000010H
  01039	58		 pop	 eax
  0103a	c1 e0 00	 shl	 eax, 0
  0103d	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  01043	6a 04		 push	 4
  01045	59		 pop	 ecx
  01046	6b c9 03	 imul	 ecx, ecx, 3
  01049	0f 57 c0	 xorps	 xmm0, xmm0
  0104c	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  01051	6a 10		 push	 16			; 00000010H
  01053	58		 pop	 eax
  01054	c1 e0 00	 shl	 eax, 0
  01057	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  0105d	6a 04		 push	 4
  0105f	59		 pop	 ecx
  01060	d1 e1		 shl	 ecx, 1
  01062	0f 57 c0	 xorps	 xmm0, xmm0
  01065	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0106a	6a 10		 push	 16			; 00000010H
  0106c	58		 pop	 eax
  0106d	c1 e0 00	 shl	 eax, 0
  01070	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  01076	6a 04		 push	 4
  01078	59		 pop	 ecx
  01079	6b c9 00	 imul	 ecx, ecx, 0
  0107c	0f 57 c0	 xorps	 xmm0, xmm0
  0107f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  01084	6a 10		 push	 16			; 00000010H
  01086	58		 pop	 eax
  01087	6b c0 00	 imul	 eax, eax, 0
  0108a	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  01090	6a 04		 push	 4
  01092	59		 pop	 ecx
  01093	6b c9 03	 imul	 ecx, ecx, 3
  01096	0f 57 c0	 xorps	 xmm0, xmm0
  01099	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0109e	6a 10		 push	 16			; 00000010H
  010a0	58		 pop	 eax
  010a1	6b c0 00	 imul	 eax, eax, 0
  010a4	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  010aa	6a 04		 push	 4
  010ac	59		 pop	 ecx
  010ad	d1 e1		 shl	 ecx, 1
  010af	0f 57 c0	 xorps	 xmm0, xmm0
  010b2	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  010b7	6a 10		 push	 16			; 00000010H
  010b9	58		 pop	 eax
  010ba	6b c0 00	 imul	 eax, eax, 0
  010bd	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  010c3	6a 04		 push	 4
  010c5	59		 pop	 ecx
  010c6	c1 e1 00	 shl	 ecx, 0
  010c9	0f 57 c0	 xorps	 xmm0, xmm0
  010cc	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  010d1	6a 10		 push	 16			; 00000010H
  010d3	58		 pop	 eax
  010d4	6b c0 03	 imul	 eax, eax, 3
  010d7	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  010dd	6a 04		 push	 4
  010df	59		 pop	 ecx
  010e0	6b c9 03	 imul	 ecx, ecx, 3
  010e3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  010eb	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  010f0	6a 10		 push	 16			; 00000010H
  010f2	58		 pop	 eax
  010f3	d1 e0		 shl	 eax, 1
  010f5	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  010fb	6a 04		 push	 4
  010fd	59		 pop	 ecx
  010fe	d1 e1		 shl	 ecx, 1
  01100	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01108	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0110d	6a 10		 push	 16			; 00000010H
  0110f	58		 pop	 eax
  01110	c1 e0 00	 shl	 eax, 0
  01113	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  01119	6a 04		 push	 4
  0111b	59		 pop	 ecx
  0111c	c1 e1 00	 shl	 ecx, 0
  0111f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01127	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0112c	6a 10		 push	 16			; 00000010H
  0112e	58		 pop	 eax
  0112f	6b c0 00	 imul	 eax, eax, 0
  01132	03 85 cc fa ff
	ff		 add	 eax, DWORD PTR _pOut$[ebp]
  01138	6a 04		 push	 4
  0113a	59		 pop	 ecx
  0113b	6b c9 00	 imul	 ecx, ecx, 0
  0113e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01146	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 150  : 				D3DXMatrixIdentity(&OBBData.matRot); OBBData.matRot = *pMat;

  0114b	8b bd c8 fa ff
	ff		 mov	 edi, DWORD PTR _OBBData$12[ebp]
  01151	83 c7 18	 add	 edi, 24			; 00000018H
  01154	6a 10		 push	 16			; 00000010H
  01156	59		 pop	 ecx
  01157	8b 75 0c	 mov	 esi, DWORD PTR _pMat$[ebp]
  0115a	f3 a5		 rep movsd

; 151  : 				OBBData.matRot._41 = 0; OBBData.matRot._42 = 0; OBBData.matRot._43 = 0; OBBData.matRot._44 = 1;

  0115c	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _OBBData$12[ebp]
  01162	0f 57 c0	 xorps	 xmm0, xmm0
  01165	f3 0f 11 40 48	 movss	 DWORD PTR [eax+72], xmm0
  0116a	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _OBBData$12[ebp]
  01170	0f 57 c0	 xorps	 xmm0, xmm0
  01173	f3 0f 11 40 4c	 movss	 DWORD PTR [eax+76], xmm0
  01178	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _OBBData$12[ebp]
  0117e	0f 57 c0	 xorps	 xmm0, xmm0
  01181	f3 0f 11 40 50	 movss	 DWORD PTR [eax+80], xmm0
  01186	8b 85 c8 fa ff
	ff		 mov	 eax, DWORD PTR _OBBData$12[ebp]
  0118c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01194	f3 0f 11 40 54	 movss	 DWORD PTR [eax+84], xmm0

; 152  : 
; 153  : 
; 154  : 
; 155  : 
; 156  : 				return poci;

  01199	8b 85 70 fa ff
	ff		 mov	 eax, DWORD PTR _poci$3[ebp]
  0119f	e9 ef 01 00 00	 jmp	 $LN1@BuildColli

; 157  : 			}
; 158  : 			break;

  011a4	e9 e8 01 00 00	 jmp	 $LN2@BuildColli
$LN11@BuildColli:

; 159  : 		case COLLISION_TYPE_SPHERE:
; 160  : 			{
; 161  : 				CSphereCollisionInstance * psci = gs_sci.Alloc();

  011a9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A ; gs_sci
  011ae	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEPAVCSphereCollisionInstance@@XZ ; CDynamicPool<CSphereCollisionInstance>::Alloc
  011b3	89 85 74 fa ff
	ff		 mov	 DWORD PTR _psci$4[ebp], eax

; 162  : 
; 163  : 				D3DXMATRIX matTranslationLocal;
; 164  : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  011b9	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  011bc	51		 push	 ecx
  011bd	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [eax+48]
  011c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011c7	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  011ca	51		 push	 ecx
  011cb	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  011d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011d5	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  011d8	51		 push	 ecx
  011d9	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  011de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  011e3	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$30[ebp]
  011e9	50		 push	 eax
  011ea	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  011ef	ff 75 0c	 push	 DWORD PTR _pMat$[ebp]
  011f2	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$30[ebp]
  011f8	50		 push	 eax
  011f9	8d 85 d4 fb ff
	ff		 lea	 eax, DWORD PTR _matT$18[ebp]
  011ff	50		 push	 eax
  01200	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 581  :     return matT;

  01205	6a 10		 push	 16			; 00000010H
  01207	59		 pop	 ecx
  01208	8d b5 d4 fb ff
	ff		 lea	 esi, DWORD PTR _matT$18[ebp]
  0120e	8d bd 14 fc ff
	ff		 lea	 edi, DWORD PTR $T19[ebp]
  01214	f3 a5		 rep movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 165  : 				matTranslationLocal = matTranslationLocal * *pMat;

  01216	6a 10		 push	 16			; 00000010H
  01218	59		 pop	 ecx
  01219	8d b5 14 fc ff
	ff		 lea	 esi, DWORD PTR $T19[ebp]
  0121f	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR _matTranslationLocal$30[ebp]
  01225	f3 a5		 rep movsd

; 166  : 
; 167  : 				TSphereData & SphereData = psci->GetAttribute();

  01227	8b 8d 74 fa ff
	ff		 mov	 ecx, DWORD PTR _psci$4[ebp]
  0122d	e8 00 00 00 00	 call	 ?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ ; CSphereCollisionInstance::GetAttribute
  01232	89 85 a4 fa ff
	ff		 mov	 DWORD PTR _SphereData$8[ebp], eax

; 168  : 				SphereData.v3Position.x = matTranslationLocal._41;

  01238	8b 85 a4 fa ff
	ff		 mov	 eax, DWORD PTR _SphereData$8[ebp]
  0123e	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _matTranslationLocal$30[ebp+48]
  01246	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 169  : 				SphereData.v3Position.y = matTranslationLocal._42;

  0124a	8b 85 a4 fa ff
	ff		 mov	 eax, DWORD PTR _SphereData$8[ebp]
  01250	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _matTranslationLocal$30[ebp+52]
  01258	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 170  : 				SphereData.v3Position.z = matTranslationLocal._43;

  0125d	8b 85 a4 fa ff
	ff		 mov	 eax, DWORD PTR _SphereData$8[ebp]
  01263	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _matTranslationLocal$30[ebp+56]
  0126b	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 171  : 				SphereData.fRadius = c_pCollisionData->fDimensions[0];

  01270	6a 04		 push	 4
  01272	58		 pop	 eax
  01273	6b c0 00	 imul	 eax, eax, 0
  01276	8b 8d a4 fa ff
	ff		 mov	 ecx, DWORD PTR _SphereData$8[ebp]
  0127c	8b 55 08	 mov	 edx, DWORD PTR _c_pCollisionData$[ebp]
  0127f	8b 44 02 34	 mov	 eax, DWORD PTR [edx+eax+52]
  01283	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 172  : 
; 173  : 				return psci;

  01286	8b 85 74 fa ff
	ff		 mov	 eax, DWORD PTR _psci$4[ebp]
  0128c	e9 02 01 00 00	 jmp	 $LN1@BuildColli

; 174  : 			}
; 175  : 			break;

  01291	e9 fb 00 00 00	 jmp	 $LN2@BuildColli
$LN12@BuildColli:

; 176  : 		case COLLISION_TYPE_CYLINDER:
; 177  : 			{
; 178  : 				CCylinderCollisionInstance * pcci = gs_cci.Alloc();

  01296	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A ; gs_cci
  0129b	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEPAVCCylinderCollisionInstance@@XZ ; CDynamicPool<CCylinderCollisionInstance>::Alloc
  012a0	89 85 78 fa ff
	ff		 mov	 DWORD PTR _pcci$5[ebp], eax

; 179  : 
; 180  : 				D3DXMATRIX matTranslationLocal;
; 181  : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  012a6	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  012a9	51		 push	 ecx
  012aa	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [eax+48]
  012af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  012b4	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  012b7	51		 push	 ecx
  012b8	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  012bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  012c2	8b 45 08	 mov	 eax, DWORD PTR _c_pCollisionData$[ebp]
  012c5	51		 push	 ecx
  012c6	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  012cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  012d0	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$29[ebp]
  012d6	50		 push	 eax
  012d7	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  012dc	ff 75 0c	 push	 DWORD PTR _pMat$[ebp]
  012df	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$29[ebp]
  012e5	50		 push	 eax
  012e6	8d 85 54 fc ff
	ff		 lea	 eax, DWORD PTR _matT$20[ebp]
  012ec	50		 push	 eax
  012ed	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 581  :     return matT;

  012f2	6a 10		 push	 16			; 00000010H
  012f4	59		 pop	 ecx
  012f5	8d b5 54 fc ff
	ff		 lea	 esi, DWORD PTR _matT$20[ebp]
  012fb	8d bd 94 fc ff
	ff		 lea	 edi, DWORD PTR $T21[ebp]
  01301	f3 a5		 rep movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp

; 182  : 				matTranslationLocal = matTranslationLocal * *pMat;

  01303	6a 10		 push	 16			; 00000010H
  01305	59		 pop	 ecx
  01306	8d b5 94 fc ff
	ff		 lea	 esi, DWORD PTR $T21[ebp]
  0130c	8d bd 94 fe ff
	ff		 lea	 edi, DWORD PTR _matTranslationLocal$29[ebp]
  01312	f3 a5		 rep movsd

; 183  : 
; 184  : 				TCylinderData & CylinderData = pcci->GetAttribute();

  01314	8b 8d 78 fa ff
	ff		 mov	 ecx, DWORD PTR _pcci$5[ebp]
  0131a	e8 00 00 00 00	 call	 ?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ ; CCylinderCollisionInstance::GetAttribute
  0131f	89 85 ac fa ff
	ff		 mov	 DWORD PTR _CylinderData$9[ebp], eax

; 185  : 				CylinderData.fRadius = c_pCollisionData->fDimensions[0];

  01325	6a 04		 push	 4
  01327	58		 pop	 eax
  01328	6b c0 00	 imul	 eax, eax, 0
  0132b	8b 8d ac fa ff
	ff		 mov	 ecx, DWORD PTR _CylinderData$9[ebp]
  01331	8b 55 08	 mov	 edx, DWORD PTR _c_pCollisionData$[ebp]
  01334	8b 44 02 34	 mov	 eax, DWORD PTR [edx+eax+52]
  01338	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 186  : 				CylinderData.fHeight = c_pCollisionData->fDimensions[1];

  0133b	6a 04		 push	 4
  0133d	58		 pop	 eax
  0133e	c1 e0 00	 shl	 eax, 0
  01341	8b 8d ac fa ff
	ff		 mov	 ecx, DWORD PTR _CylinderData$9[ebp]
  01347	8b 55 08	 mov	 edx, DWORD PTR _c_pCollisionData$[ebp]
  0134a	8b 44 02 34	 mov	 eax, DWORD PTR [edx+eax+52]
  0134e	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 187  : 				CylinderData.v3Position.x = matTranslationLocal._41;

  01351	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR _CylinderData$9[ebp]
  01357	f3 0f 10 85 c4
	fe ff ff	 movss	 xmm0, DWORD PTR _matTranslationLocal$29[ebp+48]
  0135f	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 188  : 				CylinderData.v3Position.y = matTranslationLocal._42;

  01363	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR _CylinderData$9[ebp]
  01369	f3 0f 10 85 c8
	fe ff ff	 movss	 xmm0, DWORD PTR _matTranslationLocal$29[ebp+52]
  01371	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 189  : 				CylinderData.v3Position.z = matTranslationLocal._43 /*+ CylinderData.fHeight/2.0f*/;

  01376	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR _CylinderData$9[ebp]
  0137c	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _matTranslationLocal$29[ebp+56]
  01384	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 190  : 
; 191  : 				return pcci;

  01389	8b 85 78 fa ff
	ff		 mov	 eax, DWORD PTR _pcci$5[ebp]
  0138f	eb 02		 jmp	 SHORT $LN1@BuildColli
$LN2@BuildColli:

; 192  : 			}
; 193  : 			break;
; 194  : 	}
; 195  : 	assert(false && "NOT_REACHED");
; 196  : 	return 0;

  01391	33 c0		 xor	 eax, eax
$LN1@BuildColli:

; 197  : }

  01393	5f		 pop	 edi
  01394	5e		 pop	 esi
  01395	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01398	33 cd		 xor	 ecx, ebp
  0139a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0139f	c9		 leave
  013a0	c3		 ret	 0
?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z ENDP ; CBaseCollisionInstance::BuildCollisionInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?Destroy@CBaseCollisionInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Destroy@CBaseCollisionInstance@@QAEXXZ PROC		; CBaseCollisionInstance::Destroy, COMDAT
; _this$ = ecx

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 201  : 	OnDestroy();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 50 10	 call	 DWORD PTR [eax+16]

; 202  : }

  00012	c9		 leave
  00013	c3		 ret	 0
?Destroy@CBaseCollisionInstance@@QAEXXZ ENDP		; CBaseCollisionInstance::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.cpp
;	COMDAT ?DestroyCollisionInstanceSystem@@YAXXZ
_TEXT	SEGMENT
?DestroyCollisionInstanceSystem@@YAXXZ PROC		; DestroyCollisionInstanceSystem, COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 26   : 	gs_sci.Destroy();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A ; gs_sci
  00008	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCSphereCollisionInstance@@@@QAEXXZ ; CDynamicPool<CSphereCollisionInstance>::Destroy

; 27   : 	gs_cci.Destroy();

  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A ; gs_cci
  00012	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCCylinderCollisionInstance@@@@QAEXXZ ; CDynamicPool<CCylinderCollisionInstance>::Destroy

; 28   : 	gs_pci.Destroy();

  00017	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A ; gs_pci
  0001c	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCPlaneCollisionInstance@@@@QAEXXZ ; CDynamicPool<CPlaneCollisionInstance>::Destroy

; 29   : 	gs_aci.Destroy();

  00021	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A ; gs_aci
  00026	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEXXZ ; CDynamicPool<CAABBCollisionInstance>::Destroy

; 30   : 	gs_oci.Destroy();

  0002b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A ; gs_oci
  00030	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCOBBCollisionInstance@@@@QAEXXZ ; CDynamicPool<COBBCollisionInstance>::Destroy

; 31   : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?DestroyCollisionInstanceSystem@@YAXXZ ENDP		; DestroyCollisionInstanceSystem
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0SPlaneData@@QAE@XZ
_TEXT	SEGMENT
tv70 = -28						; size = 4
tv84 = -24						; size = 4
___t$ = -20						; size = 4
___t$ = -16						; size = 4
_this$ = -12						; size = 4
___n$ = -8						; size = 4
___n$ = -4						; size = 4
??0SPlaneData@@QAE@XZ PROC				; SPlaneData::SPlaneData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR ___n$[ebp], 4
  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 18	 add	 eax, 24			; 00000018H
  00016	89 45 f0	 mov	 DWORD PTR ___t$[ebp], eax
$LN8@SPlaneData:
  00019	8b 45 fc	 mov	 eax, DWORD PTR ___n$[ebp]
  0001c	89 45 e8	 mov	 DWORD PTR tv84[ebp], eax
  0001f	8b 45 fc	 mov	 eax, DWORD PTR ___n$[ebp]
  00022	48		 dec	 eax
  00023	89 45 fc	 mov	 DWORD PTR ___n$[ebp], eax
  00026	83 7d e8 00	 cmp	 DWORD PTR tv84[ebp], 0
  0002a	76 0b		 jbe	 SHORT $LN7@SPlaneData
  0002c	8b 45 f0	 mov	 eax, DWORD PTR ___t$[ebp]
  0002f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00032	89 45 f0	 mov	 DWORD PTR ___t$[ebp], eax
  00035	eb e2		 jmp	 SHORT $LN8@SPlaneData
$LN7@SPlaneData:
  00037	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR ___n$[ebp], 4
  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c0 48	 add	 eax, 72			; 00000048H
  00044	89 45 ec	 mov	 DWORD PTR ___t$[ebp], eax
$LN14@SPlaneData:
  00047	8b 45 f8	 mov	 eax, DWORD PTR ___n$[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR tv70[ebp], eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR ___n$[ebp]
  00050	48		 dec	 eax
  00051	89 45 f8	 mov	 DWORD PTR ___n$[ebp], eax
  00054	83 7d e4 00	 cmp	 DWORD PTR tv70[ebp], 0
  00058	76 0b		 jbe	 SHORT $LN1@SPlaneData
  0005a	8b 45 ec	 mov	 eax, DWORD PTR ___t$[ebp]
  0005d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00060	89 45 ec	 mov	 DWORD PTR ___t$[ebp], eax
  00063	eb e2		 jmp	 SHORT $LN14@SPlaneData
$LN1@SPlaneData:
  00065	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00068	c9		 leave
  00069	c3		 ret	 0
??0SPlaneData@@QAE@XZ ENDP				; SPlaneData::SPlaneData
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
