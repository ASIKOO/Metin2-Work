; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z ; std::allocator<D3DXVECTOR3>::deallocate
PUBLIC	??0?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
PUBLIC	?clear@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::clear
PUBLIC	?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXPAUD3DXVECTOR3@@0@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Change_array
PUBLIC	?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
PUBLIC	?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
PUBLIC	?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Getal
PUBLIC	??0CAttributeInstance@@QAE@XZ			; CAttributeInstance::CAttributeInstance
PUBLIC	??1CAttributeInstance@@UAE@XZ			; CAttributeInstance::~CAttributeInstance
PUBLIC	?Clear@CAttributeInstance@@QAEXXZ		; CAttributeInstance::Clear
PUBLIC	?IsEmpty@CAttributeInstance@@QBEHXZ		; CAttributeInstance::IsEmpty
PUBLIC	?GetDataFileName@CAttributeInstance@@QBEPBDXZ	; CAttributeInstance::GetDataFileName
PUBLIC	?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z ; CAttributeInstance::SetObjectPointer
PUBLIC	?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z ; CAttributeInstance::RefreshObject
PUBLIC	?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ ; CAttributeInstance::GetObjectPointer
PUBLIC	?Picking@CAttributeInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z ; CAttributeInstance::Picking
PUBLIC	?IsInHeight@CAttributeInstance@@QAEHMM@Z	; CAttributeInstance::IsInHeight
PUBLIC	?GetHeight@CAttributeInstance@@QAEHMMPAM@Z	; CAttributeInstance::GetHeight
PUBLIC	?deallocate@?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QAEXQAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@I@Z ; std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::deallocate
PUBLIC	?clear@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@QAEXXZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::clear
PUBLIC	?_Destroy@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@0@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@ABEII@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXQAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@II@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Change_array
PUBLIC	?_Tidy@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Xlength
PUBLIC	?_Getal@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@XZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Getal
PUBLIC	?SetPointer@?$CRef@VCAttributeData@@@@QAEXPAVCReferenceObject@@@Z ; CRef<CAttributeData>::SetPointer
PUBLIC	?CreateSystem@CAttributeInstance@@SAXI@Z	; CAttributeInstance::CreateSystem
PUBLIC	?DestroySystem@CAttributeInstance@@SAXXZ	; CAttributeInstance::DestroySystem
PUBLIC	?New@CAttributeInstance@@SAPAV1@XZ		; CAttributeInstance::New
PUBLIC	?Delete@CAttributeInstance@@SAXPAV1@@Z		; CAttributeInstance::Delete
PUBLIC	??_GCAttributeInstance@@UAEPAXI@Z		; CAttributeInstance::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCAttributeInstance@@@@QAE@XZ	; CDynamicPool<CAttributeInstance>::CDynamicPool<CAttributeInstance>
PUBLIC	??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ	; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCAttributeInstance@@@@QAEXXZ ; CDynamicPool<CAttributeInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ ; CDynamicPool<CAttributeInstance>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z ; CDynamicPool<CAttributeInstance>::Delete
PUBLIC	?deallocate@?$allocator@PAVCAttributeInstance@@@std@@QAEXQAPAVCAttributeInstance@@I@Z ; std::allocator<CAttributeInstance *>::deallocate
PUBLIC	?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Reallocate_exactly
PUBLIC	?reserve@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXI@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::reserve
PUBLIC	?clear@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXPAPAVCAttributeInstance@@0@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@ABEII@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
PUBLIC	?_Getal@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEAAV?$allocator@PAVCAttributeInstance@@@2@XZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Getal
PUBLIC	??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z ; CDynamicPool<CAttributeInstance>::`scalar deleting destructor'
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@std@@P6AXPAVCAttributeInstance@@@Z@std@@YAP6AXPAVCAttributeInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAttributeInstance *> > >,void (__cdecl*)(CAttributeInstance *)>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize<std::_Value_init_tag>
PUBLIC	??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::emplace_back<CAttributeInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_back_with_unused_capacity<CAttributeInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
PUBLIC	??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@IAAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<D3DXVECTOR3> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > *,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
PUBLIC	??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >
PUBLIC	??$_Emplace_back@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAEX$$QAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Emplace_back<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A ; CAttributeInstance::ms_kPool
PUBLIC	??_7CAttributeInstance@@6B@			; CAttributeInstance::`vftable'
PUBLIC	??_7?$CDynamicPool@VCAttributeInstance@@@@6B@	; CDynamicPool<CAttributeInstance>::`vftable'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CAttributeInstance@@6B@			; CAttributeInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCAttributeInstance@@@8			; CAttributeInstance `RTTI Type Descriptor'
PUBLIC	??_R3CAttributeInstance@@8			; CAttributeInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CAttributeInstance@@8			; CAttributeInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CAttributeInstance@@8		; CAttributeInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@	; CDynamicPool<CAttributeInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8 ; CDynamicPool<CAttributeInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCAttributeInstance@@@@8	; CDynamicPool<CAttributeInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCAttributeInstance@@@@8	; CDynamicPool<CAttributeInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8 ; CDynamicPool<CAttributeInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f800000
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memmove:PROC
EXTRN	_sqrt:PROC
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	_D3DXVec3TransformCoord@12:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?fMAX@@YAMMM@Z:PROC				; fMAX
EXTRN	?AddReference@CReferenceObject@@QAEXXZ:PROC	; CReferenceObject::AddReference
EXTRN	?Release@CReferenceObject@@QAEXXZ:PROC		; CReferenceObject::Release
EXTRN	?GetHeightDataCount@CAttributeData@@QBEKXZ:PROC	; CAttributeData::GetHeightDataCount
EXTRN	?GetHeightDataPointer@CAttributeData@@QBEHKPAPBUSHeightData@@@Z:PROC ; CAttributeData::GetHeightDataPointer
EXTRN	?GetMaximizeRadius@CAttributeData@@QAEMXZ:PROC	; CAttributeData::GetMaximizeRadius
EXTRN	??_ECAttributeInstance@@UAEPAXI@Z:PROC		; CAttributeInstance::`vector deleting destructor'
EXTRN	?IsInTriangle2D@@YA_NMMMMMMMM@Z:PROC		; IsInTriangle2D
EXTRN	??_E?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CAttributeInstance>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A DB 024H DUP (?) ; CAttributeInstance::ms_kPool
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CAttributeInstance@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CAttributeInstance@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8 ; CDynamicPool<CAttributeInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCAttributeInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8 ; CDynamicPool<CAttributeInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCAttributeInstance@@@@8 DD 00H	; CDynamicPool<CAttributeInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CAttributeInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCAttributeInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@ DD 00H	; CDynamicPool<CAttributeInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CAttributeInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CAttributeInstance@@8 DD FLAT:??_R0?AVCAttributeInstance@@@8 ; CAttributeInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CAttributeInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CAttributeInstance@@8
rdata$r	SEGMENT
??_R2CAttributeInstance@@8 DD FLAT:??_R1A@?0A@EA@CAttributeInstance@@8 ; CAttributeInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CAttributeInstance@@8
rdata$r	SEGMENT
??_R3CAttributeInstance@@8 DD 00H			; CAttributeInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CAttributeInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCAttributeInstance@@@8
data$rs	SEGMENT
??_R0?AVCAttributeInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CAttributeInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAttributeInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CAttributeInstance@@6B@
rdata$r	SEGMENT
??_R4CAttributeInstance@@6B@ DD 00H			; CAttributeInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCAttributeInstance@@@8
	DD	FLAT:??_R3CAttributeInstance@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCAttributeInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCAttributeInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@ ; CDynamicPool<CAttributeInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CAttributeInstance@@6B@
CONST	SEGMENT
??_7CAttributeInstance@@6B@ DD FLAT:??_R4CAttributeInstance@@6B@ ; CAttributeInstance::`vftable'
	DD	FLAT:??_ECAttributeInstance@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z$26
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z$0
__unwindtable$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z$11
__ehfuncinfo$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CAttributeInstance@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1CAttributeInstance@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CAttributeInstance@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAEX$$QAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = -28					; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAEX$$QAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Emplace_back<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00018	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00024	89 45 e4	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00027	8b 45 f4	 mov	 eax, DWORD PTR $T4[ebp]
  0002a	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00030	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00033	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00036	8b 4d e8	 mov	 ecx, DWORD PTR $T1[ebp]
  00039	e8 00 00 00 00	 call	 ??0?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >

; 1547 :         ++_Last;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 0c	 add	 eax, 12			; 0000000cH
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  0004d	c9		 leave
  0004e	c2 04 00	 ret	 4
??$_Emplace_back@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAEX$$QAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Emplace_back<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z
_TEXT	SEGMENT
__Backout$1 = -52					; size = 12
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
$T7 = -12						; size = 4
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z PROC ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00008	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00014	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00017	89 45 cc	 mov	 DWORD PTR __Backout$1[ebp], eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	89 45 d0	 mov	 DWORD PTR __Backout$1[ebp+4], eax
  00020	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00023	89 45 d4	 mov	 DWORD PTR __Backout$1[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00026	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00028	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0002b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0002e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00031	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00034	3b 45 f8	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00037	74 3e		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00039	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR $T7[ebp], eax

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003f	8b 45 f4	 mov	 eax, DWORD PTR $T7[ebp]
  00042	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00045	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  00048	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004b	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00051	8b 45 d4	 mov	 eax, DWORD PTR __Backout$1[ebp+8]
  00054	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00057	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  0005a	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0005d	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00060	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00063	8b 75 e4	 mov	 esi, DWORD PTR $T4[ebp]
  00066	8b 7d e0	 mov	 edi, DWORD PTR $T3[ebp]
  00069	a5		 movsd
  0006a	a5		 movsd
  0006b	a5		 movsd

; 1547 :         ++_Last;

  0006c	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  0006f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00072	89 45 d0	 mov	 DWORD PTR __Backout$1[ebp+4], eax

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }

  00075	eb b1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  00077	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  0007a	89 45 cc	 mov	 DWORD PTR __Backout$1[ebp], eax

; 1552 :         return _Last;

  0007d	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  00080	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00083	ff 75 d4	 push	 DWORD PTR __Backout$1[ebp+8]
  00086	ff 75 d0	 push	 DWORD PTR __Backout$1[ebp+4]
  00089	ff 75 cc	 push	 DWORD PTR __Backout$1[ebp]
  0008c	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  00094	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]

; 1702 :     }
; 1703 : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	c9		 leave
  0009a	c3		 ret	 0
??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ENDP ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__ULast$ = -20						; size = 4
__UFirst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > *,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00031	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00034	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax
  00037	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003a	89 45 dc	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  0003d	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00040	89 45 e0	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00043	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00047	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00049	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	83 c0 0c	 add	 eax, 12			; 0000000cH
  0004f	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00052	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00055	3b 45 ec	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00058	74 13		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0005a	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0005d	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));

  00060	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  00063	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Emplace_back@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAEX$$QAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Emplace_back<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >

; 1699 :         }

  0006b	eb dc		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  0006d	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00070	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  00073	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00076	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1700 : 
; 1701 :         return _Backout._Release();

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  0007d	ff 75 e0	 push	 DWORD PTR __Backout$2[ebp+8]
  00080	ff 75 dc	 push	 DWORD PTR __Backout$2[ebp+4]
  00083	ff 75 d8	 push	 DWORD PTR __Backout$2[ebp]
  00086	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  0008e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]

; 1702 :     }
; 1703 : }

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009b	59		 pop	 ecx
  0009c	c9		 leave
  0009d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > *,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
___formal$ = -28					; size = 4
_this$1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__Ptr$ = -12						; size = 4
_this$4 = -8						; size = 4
_this$ = -4						; size = 4
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001e	89 45 e4	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00027	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  0002a	89 45 e8	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002d	8b 45 e8	 mov	 eax, DWORD PTR _this$1[ebp]
  00030	89 45 f8	 mov	 DWORD PTR _this$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$4[ebp]
  00036	83 20 00	 and	 DWORD PTR [eax], 0
  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$4[ebp]
  0003c	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$4[ebp]
  00043	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1547 :         ++_Last;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  00056	c9		 leave
  00057	c3		 ret	 0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >, COMDAT
; _this$ = ecx

; 1540 :     ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff 70 08	 push	 DWORD PTR [eax+8]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	ff 70 04	 push	 DWORD PTR [eax+4]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	ff 30		 push	 DWORD PTR [eax]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1542 :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@IAAV?$allocator@UD3DXVECTOR3@@@0@@Z
_TEXT	SEGMENT
__Backout$1 = -32					; size = 12
$T2 = -20						; size = 4
___formal$ = -16					; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
__Ptr$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@IAAV?$allocator@UD3DXVECTOR3@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<D3DXVECTOR3> >, COMDAT

; 1862 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 e0	 mov	 DWORD PTR __Backout$1[ebp], eax
  0000c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000f	89 45 e4	 mov	 DWORD PTR __Backout$1[ebp+4], eax
  00012	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00015	89 45 e8	 mov	 DWORD PTR __Backout$1[ebp+8], eax

; 1863 :     // value-initialize _Count objects to raw _First, using _Al
; 1864 :     using _Ptrty = typename _Alloc::value_type*;
; 1865 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1866 :         auto _PFirst = _Unfancy(_First);
; 1867 :         _Zero_range(_PFirst, _PFirst + _Count);
; 1868 :         return _First + _Count;
; 1869 :     } else {
; 1870 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1871 :         for (; 0 < _Count; --_Count) {

  00018	eb 07		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0001d	48		 dec	 eax
  0001e	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
$LN4@Uninitiali:
  00021	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00025	76 23		 jbe	 SHORT $LN3@Uninitiali

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00027	8b 45 e4	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  0002a	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00030	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00033	8b 45 e8	 mov	 eax, DWORD PTR __Backout$1[ebp+8]
  00036	89 45 f0	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00039	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  0003c	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1547 :         ++_Last;

  0003f	8b 45 e4	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  00042	83 c0 0c	 add	 eax, 12			; 0000000cH
  00045	89 45 e4	 mov	 DWORD PTR __Backout$1[ebp+4], eax

; 1872 :             _Backout._Emplace_back();
; 1873 :         }

  00048	eb d0		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  0004d	89 45 e0	 mov	 DWORD PTR __Backout$1[ebp], eax

; 1552 :         return _Last;

  00050	8b 45 e4	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  00053	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00056	ff 75 e8	 push	 DWORD PTR __Backout$1[ebp+8]
  00059	ff 75 e4	 push	 DWORD PTR __Backout$1[ebp+4]
  0005c	ff 75 e0	 push	 DWORD PTR __Backout$1[ebp]
  0005f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1874 : 
; 1875 :         return _Backout._Release();

  00067	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]

; 1876 :     }
; 1877 : }

  0006a	c9		 leave
  0006b	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@IAAV?$allocator@UD3DXVECTOR3@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -28					; size = 12
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >, COMDAT

; 1862 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 e4	 mov	 DWORD PTR __Backout$2[ebp], eax
  0002b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002e	89 45 e8	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  00031	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00034	89 45 ec	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1863 :     // value-initialize _Count objects to raw _First, using _Al
; 1864 :     using _Ptrty = typename _Alloc::value_type*;
; 1865 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1866 :         auto _PFirst = _Unfancy(_First);
; 1867 :         _Zero_range(_PFirst, _PFirst + _Count);
; 1868 :         return _First + _Count;
; 1869 :     } else {
; 1870 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1871 :         for (; 0 < _Count; --_Count) {

  0003b	eb 07		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  0003d	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00040	48		 dec	 eax
  00041	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
$LN4@Uninitiali:
  00044	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00048	76 0a		 jbe	 SHORT $LN3@Uninitiali

; 1872 :             _Backout._Emplace_back();

  0004a	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  0004d	e8 00 00 00 00	 call	 ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Emplace_back<>

; 1873 :         }

  00052	eb e9		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  00054	8b 45 e8	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00057	89 45 e4	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  0005a	8b 45 e8	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  0005d	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax

; 1874 : 
; 1875 :         return _Backout._Release();

  00060	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00064	ff 75 ec	 push	 DWORD PTR __Backout$2[ebp+8]
  00067	ff 75 e8	 push	 DWORD PTR __Backout$2[ebp+4]
  0006a	ff 75 e4	 push	 DWORD PTR __Backout$2[ebp]
  0006d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1874 : 
; 1875 :         return _Backout._Release();

  00075	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]

; 1876 :     }
; 1877 : }

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	c9		 leave
  00084	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Max_possible$2 = -148					; size = 4
$T3 = -144						; size = 4
$T4 = -140						; size = 4
__First$ = -136						; size = 4
__Last$ = -132						; size = 4
$T5 = -128						; size = 4
$T6 = -124						; size = 4
tv244 = -120						; size = 4
$T7 = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
$T12 = -96						; size = 4
$T13 = -92						; size = 4
$T14 = -88						; size = 4
$T15 = -84						; size = 4
__Appended_last$ = -80					; size = 4
__Myfirst$ = -76					; size = 4
__Mylast$ = -72						; size = 4
__Oldsize$ = -68					; size = 4
__My_data$ = -64					; size = 4
tv147 = -60						; size = 4
$T16 = -56						; size = 4
$T17 = -52						; size = 4
__Appended_first$ = -48					; size = 4
___formal$ = -44					; size = 1
___formal$ = -40					; size = 1
__Overflow_is_possible$18 = -33				; size = 1
__Newvec$ = -32						; size = 4
__Newcapacity$ = -28					; size = 4
$T19 = -21						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00035	89 45 ac	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00038	8b 45 ac	 mov	 eax, DWORD PTR $T15[ebp]
  0003b	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00041	c7 45 cc 55 55
	55 15		 mov	 DWORD PTR $T17[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00048	c7 45 a8 ff ff
	ff 7f		 mov	 DWORD PTR $T14[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0004f	8b 45 a8	 mov	 eax, DWORD PTR $T14[ebp]
  00052	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00055	8b 45 cc	 mov	 eax, DWORD PTR $T17[ebp]
  00058	3b 45 c8	 cmp	 eax, DWORD PTR $T16[ebp]
  0005b	73 08		 jae	 SHORT $LN26@Resize_rea
  0005d	8d 45 cc	 lea	 eax, DWORD PTR $T17[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
  00063	eb 06		 jmp	 SHORT $LN27@Resize_rea
$LN26@Resize_rea:
  00065	8d 45 c8	 lea	 eax, DWORD PTR $T16[ebp]
  00068	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
$LN27@Resize_rea:
  0006b	8b 45 c4	 mov	 eax, DWORD PTR tv147[ebp]
  0006e	89 45 a4	 mov	 DWORD PTR $T13[ebp], eax
  00071	8b 45 a4	 mov	 eax, DWORD PTR $T13[ebp]
  00074	89 45 a0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00077	8b 45 a0	 mov	 eax, DWORD PTR $T12[ebp]
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	89 45 9c	 mov	 DWORD PTR $T11[ebp], eax

; 1183 :         if (_Newsize > max_size()) {

  0007f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00082	3b 45 9c	 cmp	 eax, DWORD PTR $T11[ebp]
  00085	76 05		 jbe	 SHORT $LN2@Resize_rea

; 1184 :             _Xlength();

  00087	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
$LN2@Resize_rea:

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;

  0008c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	89 45 c0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1188 :         pointer& _Myfirst = _My_data._Myfirst;

  00092	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00095	89 45 b4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1189 :         pointer& _Mylast  = _My_data._Mylast;

  00098	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0009b	83 c0 04	 add	 eax, 4
  0009e	89 45 b8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  000a1	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a4	8b 4d b4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	2b 01		 sub	 eax, DWORD PTR [ecx]
  000ab	99		 cdq
  000ac	6a 0c		 push	 12			; 0000000cH
  000ae	59		 pop	 ecx
  000af	f7 f9		 idiv	 ecx
  000b1	89 45 bc	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000b4	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Calculate_growth
  000bf	89 45 e4	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  000c2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c5	89 45 98	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000c8	8b 45 98	 mov	 eax, DWORD PTR $T10[ebp]
  000cb	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000d1	c6 45 df 01	 mov	 BYTE PTR __Overflow_is_possible$18[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000d5	c7 85 6c ff ff
	ff 55 55 55 15	 mov	 DWORD PTR __Max_possible$2[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  000df	81 7d e4 55 55
	55 15		 cmp	 DWORD PTR __Newcapacity$[ebp], 357913941 ; 15555555H
  000e6	76 05		 jbe	 SHORT $LN65@Resize_rea

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000e8	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN65@Resize_rea:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000ed	6b 45 e4 0c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 12
  000f1	89 45 94	 mov	 DWORD PTR $T9[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000f4	ff 75 94	 push	 DWORD PTR $T9[ebp]
  000f7	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000fc	59		 pop	 ecx
  000fd	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  00100	6b 45 bc 0c	 imul	 eax, DWORD PTR __Oldsize$[ebp], 12
  00104	03 45 e0	 add	 eax, DWORD PTR __Newvec$[ebp]
  00107	89 45 d0	 mov	 DWORD PTR __Appended_first$[ebp], eax

; 1196 :         pointer _Appended_last        = _Appended_first;

  0010a	8b 45 d0	 mov	 eax, DWORD PTR __Appended_first$[ebp]
  0010d	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1197 : 
; 1198 :         _TRY_BEGIN

  00110	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00114	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00117	8a 00		 mov	 al, BYTE PTR [eax]
  00119	88 45 d8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0011c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0011f	89 45 90	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00122	8b 45 90	 mov	 eax, DWORD PTR $T8[ebp]
  00125	89 45 8c	 mov	 DWORD PTR $T7[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00128	ff 75 8c	 push	 DWORD PTR $T7[ebp]

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  0012b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0012e	2b 45 bc	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00131	50		 push	 eax
  00132	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00135	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@IAAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<D3DXVECTOR3> >
  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013d	89 45 88	 mov	 DWORD PTR tv244[ebp], eax

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00140	8b 45 88	 mov	 eax, DWORD PTR tv244[ebp]
  00143	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00146	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00149	8b 00		 mov	 eax, DWORD PTR [eax]
  0014b	89 85 7c ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00151	8b 45 b4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00154	8b 00		 mov	 eax, DWORD PTR [eax]
  00156	89 85 78 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0015c	33 c0		 xor	 eax, eax
  0015e	88 45 eb	 mov	 BYTE PTR $T19[ebp], al
  00161	8a 45 eb	 mov	 al, BYTE PTR $T19[ebp]
  00164	88 45 d4	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00167	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0016a	89 45 84	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0016d	8b 45 84	 mov	 eax, DWORD PTR $T6[ebp]
  00170	89 45 80	 mov	 DWORD PTR $T5[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00173	ff 75 80	 push	 DWORD PTR $T5[ebp]
  00176	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  00179	ff b5 7c ff ff
	ff		 push	 DWORD PTR __Last$[ebp]
  0017f	ff b5 78 ff ff
	ff		 push	 DWORD PTR __First$[ebp]
  00185	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >
  0018a	83 c4 10	 add	 esp, 16			; 00000010H

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0018d	eb 32		 jmp	 SHORT $LN5@Resize_rea
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);

  0018f	ff 75 b0	 push	 DWORD PTR __Appended_last$[ebp]
  00192	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00195	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXPAUD3DXVECTOR3@@0@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy

; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);

  0019d	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001a0	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001a3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a6	e8 00 00 00 00	 call	 ?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Getal
  001ab	8b c8		 mov	 ecx, eax
  001ad	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z ; std::allocator<D3DXVECTOR3>::deallocate

; 1204 :         _RERAISE;

  001b2	6a 00		 push	 0
  001b4	6a 00		 push	 0
  001b6	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1205 :         _CATCH_END

  001bb	b8 00 00 00 00	 mov	 eax, $LN8@Resize_rea
  001c0	c3		 ret	 0
$LN5@Resize_rea:
  001c1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  001c5	eb 04		 jmp	 SHORT __tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1
$LN8@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  001c7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001cb	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001ce	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  001d1	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001d7	e8 00 00 00 00	 call	 ?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Change_array
$LN68@Resize_rea:

; 1208 :     }

  001dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e6	59		 pop	 ecx
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx
  001ea	c9		 leave
  001eb	c2 08 00	 ret	 8
  001ee	cc		 int	 3
  001ef	cc		 int	 3
  001f0	cc		 int	 3
  001f1	cc		 int	 3
  001f2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Max_possible$2 = -148					; size = 4
$T3 = -144						; size = 4
$T4 = -140						; size = 4
__First$ = -136						; size = 4
__Last$ = -132						; size = 4
$T5 = -128						; size = 4
$T6 = -124						; size = 4
tv244 = -120						; size = 4
$T7 = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
$T12 = -96						; size = 4
$T13 = -92						; size = 4
$T14 = -88						; size = 4
$T15 = -84						; size = 4
__Appended_last$ = -80					; size = 4
__Myfirst$ = -76					; size = 4
__Mylast$ = -72						; size = 4
__Oldsize$ = -68					; size = 4
__My_data$ = -64					; size = 4
tv147 = -60						; size = 4
$T16 = -56						; size = 4
$T17 = -52						; size = 4
__Appended_first$ = -48					; size = 4
___formal$ = -44					; size = 1
___formal$ = -40					; size = 1
__Overflow_is_possible$18 = -33				; size = 1
__Newvec$ = -32						; size = 4
__Newcapacity$ = -28					; size = 4
$T19 = -21						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00035	89 45 ac	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00038	8b 45 ac	 mov	 eax, DWORD PTR $T15[ebp]
  0003b	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00041	c7 45 cc 55 55
	55 15		 mov	 DWORD PTR $T17[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00048	c7 45 a8 ff ff
	ff 7f		 mov	 DWORD PTR $T14[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0004f	8b 45 a8	 mov	 eax, DWORD PTR $T14[ebp]
  00052	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00055	8b 45 cc	 mov	 eax, DWORD PTR $T17[ebp]
  00058	3b 45 c8	 cmp	 eax, DWORD PTR $T16[ebp]
  0005b	73 08		 jae	 SHORT $LN26@Resize_rea
  0005d	8d 45 cc	 lea	 eax, DWORD PTR $T17[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
  00063	eb 06		 jmp	 SHORT $LN27@Resize_rea
$LN26@Resize_rea:
  00065	8d 45 c8	 lea	 eax, DWORD PTR $T16[ebp]
  00068	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
$LN27@Resize_rea:
  0006b	8b 45 c4	 mov	 eax, DWORD PTR tv147[ebp]
  0006e	89 45 a4	 mov	 DWORD PTR $T13[ebp], eax
  00071	8b 45 a4	 mov	 eax, DWORD PTR $T13[ebp]
  00074	89 45 a0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00077	8b 45 a0	 mov	 eax, DWORD PTR $T12[ebp]
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	89 45 9c	 mov	 DWORD PTR $T11[ebp], eax

; 1183 :         if (_Newsize > max_size()) {

  0007f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00082	3b 45 9c	 cmp	 eax, DWORD PTR $T11[ebp]
  00085	76 05		 jbe	 SHORT $LN2@Resize_rea

; 1184 :             _Xlength();

  00087	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Xlength
$LN2@Resize_rea:

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;

  0008c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	89 45 c0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1188 :         pointer& _Myfirst = _My_data._Myfirst;

  00092	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00095	89 45 b4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1189 :         pointer& _Mylast  = _My_data._Mylast;

  00098	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0009b	83 c0 04	 add	 eax, 4
  0009e	89 45 b8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  000a1	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a4	8b 4d b4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	2b 01		 sub	 eax, DWORD PTR [ecx]
  000ab	99		 cdq
  000ac	6a 0c		 push	 12			; 0000000cH
  000ae	59		 pop	 ecx
  000af	f7 f9		 idiv	 ecx
  000b1	89 45 bc	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000b4	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@ABEII@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Calculate_growth
  000bf	89 45 e4	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  000c2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c5	89 45 98	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000c8	8b 45 98	 mov	 eax, DWORD PTR $T10[ebp]
  000cb	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000d1	c6 45 df 01	 mov	 BYTE PTR __Overflow_is_possible$18[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000d5	c7 85 6c ff ff
	ff 55 55 55 15	 mov	 DWORD PTR __Max_possible$2[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  000df	81 7d e4 55 55
	55 15		 cmp	 DWORD PTR __Newcapacity$[ebp], 357913941 ; 15555555H
  000e6	76 05		 jbe	 SHORT $LN65@Resize_rea

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000e8	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN65@Resize_rea:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000ed	6b 45 e4 0c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 12
  000f1	89 45 94	 mov	 DWORD PTR $T9[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000f4	ff 75 94	 push	 DWORD PTR $T9[ebp]
  000f7	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000fc	59		 pop	 ecx
  000fd	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  00100	6b 45 bc 0c	 imul	 eax, DWORD PTR __Oldsize$[ebp], 12
  00104	03 45 e0	 add	 eax, DWORD PTR __Newvec$[ebp]
  00107	89 45 d0	 mov	 DWORD PTR __Appended_first$[ebp], eax

; 1196 :         pointer _Appended_last        = _Appended_first;

  0010a	8b 45 d0	 mov	 eax, DWORD PTR __Appended_first$[ebp]
  0010d	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1197 : 
; 1198 :         _TRY_BEGIN

  00110	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00114	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00117	8a 00		 mov	 al, BYTE PTR [eax]
  00119	88 45 d8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0011c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0011f	89 45 90	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00122	8b 45 90	 mov	 eax, DWORD PTR $T8[ebp]
  00125	89 45 8c	 mov	 DWORD PTR $T7[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00128	ff 75 8c	 push	 DWORD PTR $T7[ebp]

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  0012b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0012e	2b 45 bc	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00131	50		 push	 eax
  00132	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00135	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013d	89 45 88	 mov	 DWORD PTR tv244[ebp], eax

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00140	8b 45 88	 mov	 eax, DWORD PTR tv244[ebp]
  00143	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00146	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00149	8b 00		 mov	 eax, DWORD PTR [eax]
  0014b	89 85 7c ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00151	8b 45 b4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00154	8b 00		 mov	 eax, DWORD PTR [eax]
  00156	89 85 78 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0015c	33 c0		 xor	 eax, eax
  0015e	88 45 eb	 mov	 BYTE PTR $T19[ebp], al
  00161	8a 45 eb	 mov	 al, BYTE PTR $T19[ebp]
  00164	88 45 d4	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00167	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0016a	89 45 84	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0016d	8b 45 84	 mov	 eax, DWORD PTR $T6[ebp]
  00170	89 45 80	 mov	 DWORD PTR $T5[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00173	ff 75 80	 push	 DWORD PTR $T5[ebp]
  00176	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  00179	ff b5 7c ff ff
	ff		 push	 DWORD PTR __Last$[ebp]
  0017f	ff b5 78 ff ff
	ff		 push	 DWORD PTR __First$[ebp]
  00185	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@0PAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > *,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  0018a	83 c4 10	 add	 esp, 16			; 00000010H

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0018d	eb 32		 jmp	 SHORT $LN5@Resize_rea
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);

  0018f	ff 75 b0	 push	 DWORD PTR __Appended_last$[ebp]
  00192	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00195	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@0@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Destroy

; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);

  0019d	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001a0	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001a3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a6	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@XZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Getal
  001ab	8b c8		 mov	 ecx, eax
  001ad	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QAEXQAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@I@Z ; std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::deallocate

; 1204 :         _RERAISE;

  001b2	6a 00		 push	 0
  001b4	6a 00		 push	 0
  001b6	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1205 :         _CATCH_END

  001bb	b8 00 00 00 00	 mov	 eax, $LN8@Resize_rea
  001c0	c3		 ret	 0
$LN5@Resize_rea:
  001c1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  001c5	eb 04		 jmp	 SHORT __tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z$1
$LN8@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  001c7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001cb	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001ce	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  001d1	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001d7	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXQAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@II@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Change_array
$LN68@Resize_rea:

; 1208 :     }

  001dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e6	59		 pop	 ecx
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx
  001ea	c9		 leave
  001eb	c2 08 00	 ret	 8
  001ee	cc		 int	 3
  001ef	cc		 int	 3
  001f0	cc		 int	 3
  001f1	cc		 int	 3
  001f2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z PROC ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CAttributeInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z PROC ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {

  00004	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	83 c0 0c	 add	 eax, 12			; 0000000cH
  0000c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00012	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00015	74 23		 je	 SHORT $LN5@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
  00025	33 c0		 xor	 eax, eax
  00027	83 e0 01	 and	 eax, 1
  0002a	74 0c		 je	 SHORT $LN9@Destroy_ra
  0002c	6a 0c		 push	 12			; 0000000cH
  0002e	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx
$LN9@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 968  :         }

  00038	eb cc		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 969  :     }
; 970  : }

  0003a	c9		 leave
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@ABEII@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXPAPAVCAttributeInstance@@0@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCAttributeInstance@@@std@@QAEXQAPAVCAttributeInstance@@I@Z ; std::allocator<CAttributeInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXABQAVCAttributeInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXABQAVCAttributeInstance@@@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_back_with_unused_capacity<CAttributeInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXABQAVCAttributeInstance@@@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_back_with_unused_capacity<CAttributeInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::emplace_back<CAttributeInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_back_with_unused_capacity<CAttributeInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::emplace_back<CAttributeInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldlast$1 = -56					; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
__Oldcapacity$4 = -44					; size = 4
__Last$ = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
__Newlast$7 = -28					; size = 4
__Oldsize$ = -24					; size = 4
__Myfirst$ = -20					; size = 4
__My_data$ = -16					; size = 4
_this$ = -12						; size = 4
__Mylast$ = -8						; size = 4
___formal$ = -4						; size = 1
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1211 :     void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1212 :         auto& _My_data      = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1213 :         pointer& _Myfirst   = _My_data._Myfirst;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1214 :         pointer& _Mylast    = _My_data._Mylast;

  00015	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	2b 01		 sub	 eax, DWORD PTR [ecx]
  00028	99		 cdq
  00029	6a 0c		 push	 12			; 0000000cH
  0002b	59		 pop	 ecx
  0002c	f7 f9		 idiv	 ecx
  0002e	89 45 e8	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1216 :         if (_Newsize < _Oldsize) { // trim

  00031	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00034	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00037	73 3b		 jae	 SHORT $LN2@Resize

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00039	6b 45 08 0c	 imul	 eax, DWORD PTR __Newsize$[ebp], 12
  0003d	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00040	03 01		 add	 eax, DWORD PTR [ecx]
  00042	89 45 e4	 mov	 DWORD PTR __Newlast$7[ebp], eax

; 1218 :             _Orphan_range(_Newlast, _Mylast);
; 1219 :             _Destroy(_Newlast, _Mylast);

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 d8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0004d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00050	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00053	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  00056	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00059	ff 75 dc	 push	 DWORD PTR $T5[ebp]
  0005c	ff 75 d8	 push	 DWORD PTR __Last$[ebp]
  0005f	ff 75 e4	 push	 DWORD PTR __Newlast$7[ebp]
  00062	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1220 :             _Mylast = _Newlast;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR __Newlast$7[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 1221 :             return;

  00072	eb 6a		 jmp	 SHORT $LN1@Resize
$LN2@Resize:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  00074	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00077	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  0007a	76 62		 jbe	 SHORT $LN1@Resize

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0007c	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00082	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00085	2b 01		 sub	 eax, DWORD PTR [ecx]
  00087	99		 cdq
  00088	6a 0c		 push	 12			; 0000000cH
  0008a	59		 pop	 ecx
  0008b	f7 f9		 idiv	 ecx
  0008d	89 45 d4	 mov	 DWORD PTR __Oldcapacity$4[ebp], eax

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  00090	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00093	3b 45 d4	 cmp	 eax, DWORD PTR __Oldcapacity$4[ebp]
  00096	76 10		 jbe	 SHORT $LN4@Resize

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  00098	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0009b	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  000a6	eb 36		 jmp	 SHORT $LN1@Resize
$LN4@Resize:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;

  000a8	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000ab	8b 00		 mov	 eax, DWORD PTR [eax]
  000ad	89 45 c8	 mov	 DWORD PTR __Oldlast$1[ebp], eax

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000b3	8a 00		 mov	 al, BYTE PTR [eax]
  000b5	88 45 fc	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000b8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000bb	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000be	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  000c1	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c4	ff 75 cc	 push	 DWORD PTR $T2[ebp]

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000c7	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000ca	2b 45 e8	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000cd	50		 push	 eax
  000ce	ff 75 c8	 push	 DWORD PTR __Oldlast$1[ebp]
  000d1	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@PAU1@IAAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<D3DXVECTOR3> >
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000d9	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000dc	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Resize:

; 1233 :             _Orphan_range(_Oldlast, _Oldlast);
; 1234 :         }
; 1235 : 
; 1236 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1237 :     }

  000de	c9		 leave
  000df	c2 08 00	 ret	 8
??$_Resize@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldlast$1 = -56					; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
__Oldcapacity$4 = -44					; size = 4
__Last$ = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
__Newlast$7 = -28					; size = 4
__Oldsize$ = -24					; size = 4
__Myfirst$ = -20					; size = 4
__My_data$ = -16					; size = 4
_this$ = -12						; size = 4
__Mylast$ = -8						; size = 4
___formal$ = -4						; size = 1
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1211 :     void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1212 :         auto& _My_data      = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1213 :         pointer& _Myfirst   = _My_data._Myfirst;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1214 :         pointer& _Mylast    = _My_data._Mylast;

  00015	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	2b 01		 sub	 eax, DWORD PTR [ecx]
  00028	99		 cdq
  00029	6a 0c		 push	 12			; 0000000cH
  0002b	59		 pop	 ecx
  0002c	f7 f9		 idiv	 ecx
  0002e	89 45 e8	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1216 :         if (_Newsize < _Oldsize) { // trim

  00031	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00034	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00037	73 3b		 jae	 SHORT $LN2@Resize

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00039	6b 45 08 0c	 imul	 eax, DWORD PTR __Newsize$[ebp], 12
  0003d	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00040	03 01		 add	 eax, DWORD PTR [ecx]
  00042	89 45 e4	 mov	 DWORD PTR __Newlast$7[ebp], eax

; 1218 :             _Orphan_range(_Newlast, _Mylast);
; 1219 :             _Destroy(_Newlast, _Mylast);

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 d8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0004d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00050	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00053	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  00056	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00059	ff 75 dc	 push	 DWORD PTR $T5[ebp]
  0005c	ff 75 d8	 push	 DWORD PTR __Last$[ebp]
  0005f	ff 75 e4	 push	 DWORD PTR __Newlast$7[ebp]
  00062	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1220 :             _Mylast = _Newlast;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR __Newlast$7[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 1221 :             return;

  00072	eb 6a		 jmp	 SHORT $LN1@Resize
$LN2@Resize:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  00074	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00077	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  0007a	76 62		 jbe	 SHORT $LN1@Resize

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0007c	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00082	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00085	2b 01		 sub	 eax, DWORD PTR [ecx]
  00087	99		 cdq
  00088	6a 0c		 push	 12			; 0000000cH
  0008a	59		 pop	 ecx
  0008b	f7 f9		 idiv	 ecx
  0008d	89 45 d4	 mov	 DWORD PTR __Oldcapacity$4[ebp], eax

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  00090	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00093	3b 45 d4	 cmp	 eax, DWORD PTR __Oldcapacity$4[ebp]
  00096	76 10		 jbe	 SHORT $LN4@Resize

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  00098	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0009b	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  000a6	eb 36		 jmp	 SHORT $LN1@Resize
$LN4@Resize:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;

  000a8	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000ab	8b 00		 mov	 eax, DWORD PTR [eax]
  000ad	89 45 c8	 mov	 DWORD PTR __Oldlast$1[ebp], eax

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000b3	8a 00		 mov	 al, BYTE PTR [eax]
  000b5	88 45 fc	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000b8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000bb	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000be	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  000c1	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c4	ff 75 cc	 push	 DWORD PTR $T2[ebp]

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000c7	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000ca	2b 45 e8	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000cd	50		 push	 eax
  000ce	ff 75 c8	 push	 DWORD PTR __Oldlast$1[ebp]
  000d1	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000d9	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000dc	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Resize:

; 1233 :             _Orphan_range(_Oldlast, _Oldlast);
; 1234 :         }
; 1235 : 
; 1236 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1237 :     }

  000de	c9		 leave
  000df	c2 08 00	 ret	 8
??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@std@@P6AXPAVCAttributeInstance@@@Z@std@@YAP6AXPAVCAttributeInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@std@@P6AXPAVCAttributeInstance@@@Z@std@@YAP6AXPAVCAttributeInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAttributeInstance *> > >,void (__cdecl*)(CAttributeInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@std@@P6AXPAVCAttributeInstance@@@Z@std@@YAP6AXPAVCAttributeInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAttributeInstance *> > >,void (__cdecl*)(CAttributeInstance *)>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CAttributeInstance::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A ; CAttributeInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ ; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CAttributeInstance::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ??__E?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CAttributeInstance::ms_kPool'', COMDAT

; 6    : CDynamicPool<CAttributeInstance> CAttributeInstance::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A ; CAttributeInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCAttributeInstance@@@@QAE@XZ ; CDynamicPool<CAttributeInstance>::CDynamicPool<CAttributeInstance>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CAttributeInstance::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CAttributeInstance::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CAttributeInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ ; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CAttributeInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEAAV?$allocator@PAVCAttributeInstance@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEAAV?$allocator@PAVCAttributeInstance@@@2@XZ PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEAAV?$allocator@PAVCAttributeInstance@@@2@XZ ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXPAPAVCAttributeInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXPAPAVCAttributeInstance@@0@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXPAPAVCAttributeInstance@@0@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?reserve@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
$T7 = -24						; size = 4
tv81 = -20						; size = 4
$T8 = -16						; size = 4
$T9 = -12						; size = 4
__My_data$10 = -8					; size = 4
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXI@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::reserve, COMDAT
; _this$ = ecx

; 1304 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 e8	 mov	 DWORD PTR $T7[ebp], eax

; 1305 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1306 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00020	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00023	3b 45 e8	 cmp	 eax, DWORD PTR $T7[ebp]
  00026	76 62		 jbe	 SHORT $LN4@reserve

; 1737 :         return _Mypair._Get_first();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T6[ebp]
  00031	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00034	c7 45 f4 ff ff
	ff 3f		 mov	 DWORD PTR $T9[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0003b	c7 45 e0 ff ff
	ff 7f		 mov	 DWORD PTR $T5[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00042	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00045	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00048	8b 45 f4	 mov	 eax, DWORD PTR $T9[ebp]
  0004b	3b 45 f0	 cmp	 eax, DWORD PTR $T8[ebp]
  0004e	73 08		 jae	 SHORT $LN25@reserve
  00050	8d 45 f4	 lea	 eax, DWORD PTR $T9[ebp]
  00053	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
  00056	eb 06		 jmp	 SHORT $LN26@reserve
$LN25@reserve:
  00058	8d 45 f0	 lea	 eax, DWORD PTR $T8[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
$LN26@reserve:
  0005e	8b 45 ec	 mov	 eax, DWORD PTR tv81[ebp]
  00061	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
  00064	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  00067	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0006a	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0006d	8b 00		 mov	 eax, DWORD PTR [eax]
  0006f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 1307 :             if (_Newcapacity > max_size()) {

  00072	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00075	3b 45 d4	 cmp	 eax, DWORD PTR $T2[ebp]
  00078	76 05		 jbe	 SHORT $LN3@reserve

; 1308 :                 _Xlength();

  0007a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
$LN3@reserve:

; 1309 :             }
; 1310 : 
; 1311 :             _Reallocate_exactly(_Newcapacity);

  0007f	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Reallocate_exactly
$LN4@reserve:

; 1312 :         }
; 1313 :     }

  0008a	c9		 leave
  0008b	c2 04 00	 ret	 4
?reserve@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::reserve
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Max_possible$2 = -80					; size = 4
$T3 = -76						; size = 4
__Size$ = -72						; size = 4
__First$ = -68						; size = 4
__Last$ = -64						; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
$T7 = -48						; size = 4
__Myfirst$ = -44					; size = 4
__Mylast$ = -40						; size = 4
__My_data$ = -36					; size = 4
__Newvec$ = -32						; size = 4
_this$ = -28						; size = 4
___formal$ = -24					; size = 1
__Overflow_is_possible$8 = -18				; size = 1
$T9 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1251 :     void _Reallocate_exactly(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 40	 sub	 esp, 64			; 00000040H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1253 :         auto& _My_data    = _Mypair._Myval2;

  0002f	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00032	89 45 dc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1254 :         pointer& _Myfirst = _My_data._Myfirst;

  00035	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00038	89 45 d4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1255 :         pointer& _Mylast  = _My_data._Mylast;

  0003b	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003e	83 c0 04	 add	 eax, 4
  00041	89 45 d8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1256 : 
; 1257 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  00044	8b 45 d8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00047	8b 4d d4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004e	c1 f8 02	 sar	 eax, 2
  00051	89 45 b8	 mov	 DWORD PTR __Size$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00054	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00057	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0005a	8b 45 d0	 mov	 eax, DWORD PTR $T7[ebp]
  0005d	89 45 b4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00060	c6 45 ee 01	 mov	 BYTE PTR __Overflow_is_possible$8[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00064	c7 45 b0 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  0006b	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  00072	76 05		 jbe	 SHORT $LN17@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00074	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN17@Reallocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00079	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0007c	c1 e0 02	 shl	 eax, 2
  0007f	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00082	ff 75 cc	 push	 DWORD PTR $T6[ebp]
  00085	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0008a	59		 pop	 ecx
  0008b	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1261 :         _TRY_BEGIN

  0008e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1262 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00092	8b 45 d8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00095	8b 00		 mov	 eax, DWORD PTR [eax]
  00097	89 45 c0	 mov	 DWORD PTR __Last$[ebp], eax
  0009a	8b 45 d4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0009d	8b 00		 mov	 eax, DWORD PTR [eax]
  0009f	89 45 bc	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  000a2	33 c0		 xor	 eax, eax
  000a4	88 45 ef	 mov	 BYTE PTR $T9[ebp], al
  000a7	8a 45 ef	 mov	 al, BYTE PTR $T9[ebp]
  000aa	88 45 e8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000ad	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b0	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000b3	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  000b6	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000b9	ff 75 c4	 push	 DWORD PTR $T4[ebp]
  000bc	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  000bf	ff 75 c0	 push	 DWORD PTR __Last$[ebp]
  000c2	ff 75 bc	 push	 DWORD PTR __First$[ebp]
  000c5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
  000ca	83 c4 10	 add	 esp, 16			; 00000010H

; 1262 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  000cd	eb 24		 jmp	 SHORT $LN4@Reallocate
__catch$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z$0:

; 1263 :         _CATCH_ALL
; 1264 :         _Getal().deallocate(_Newvec, _Newcapacity);

  000cf	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  000d2	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  000d5	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEAAV?$allocator@PAVCAttributeInstance@@@2@XZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Getal
  000dd	8b c8		 mov	 ecx, eax
  000df	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCAttributeInstance@@@std@@QAEXQAPAVCAttributeInstance@@I@Z ; std::allocator<CAttributeInstance *>::deallocate

; 1265 :         _RERAISE;

  000e4	6a 00		 push	 0
  000e6	6a 00		 push	 0
  000e8	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1266 :         _CATCH_END

  000ed	b8 00 00 00 00	 mov	 eax, $LN7@Reallocate
  000f2	c3		 ret	 0
$LN4@Reallocate:
  000f3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  000f7	eb 04		 jmp	 SHORT __tryend$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z$1
$LN7@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  000f9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1267 : 
; 1268 :         _Change_array(_Newvec, _Size, _Newcapacity);

  000fd	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  00100	ff 75 b8	 push	 DWORD PTR __Size$[ebp]
  00103	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  00106	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array
$LN20@Reallocate:

; 1269 :     }

  0010e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00111	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00118	59		 pop	 ecx
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	c9		 leave
  0011d	c2 04 00	 ret	 4
  00120	cc		 int	 3
  00121	cc		 int	 3
  00122	cc		 int	 3
  00123	cc		 int	 3
  00124	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Reallocate_exactly
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCAttributeInstance@@@std@@QAEXQAPAVCAttributeInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCAttributeInstance@@@std@@QAEXQAPAVCAttributeInstance@@I@Z PROC ; std::allocator<CAttributeInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCAttributeInstance@@@std@@QAEXQAPAVCAttributeInstance@@I@Z ENDP ; std::allocator<CAttributeInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z PROC ; CDynamicPool<CAttributeInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 110  : 			delete pkData;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0000f	74 11		 je	 SHORT $LN3@Delete
  00011	6a 01		 push	 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001b	ff 10		 call	 DWORD PTR [eax]
  0001d	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00020	eb 04		 jmp	 SHORT $LN1@Delete
$LN3@Delete:
  00022	83 65 f8 00	 and	 DWORD PTR tv70[ebp], 0
$LN1@Delete:

; 111  : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z ENDP ; CDynamicPool<CAttributeInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
$T10 = -36						; size = 4
tv130 = -32						; size = 4
__My_data$11 = -28					; size = 4
__Mylast$12 = -24					; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ PROC ; CDynamicPool<CAttributeInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00034	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 e0 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 e0	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 57		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	6a 5c		 push	 92			; 0000005cH
  0005b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00060	59		 pop	 ecx
  00061	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  00064	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	83 7d dc 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006c	74 0d		 je	 SHORT $LN4@Alloc
  0006e	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  00071	e8 00 00 00 00	 call	 ??0CAttributeInstance@@QAE@XZ ; CAttributeInstance::CAttributeInstance
  00076	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  00079	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0007b	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  0007f	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  00082	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00085	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00089	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0008c	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0008f	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  00092	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00099	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::emplace_back<CAttributeInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  0009e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a4	40		 inc	 eax
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000ab	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000ae	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000b0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	83 c0 10	 add	 eax, 16			; 00000010H
  000b6	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000b9	6a 04		 push	 4
  000bb	58		 pop	 eax
  000bc	6b c0 ff	 imul	 eax, eax, -1
  000bf	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000c2	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c5	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000c8	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000cb	8b 00		 mov	 eax, DWORD PTR [eax]
  000cd	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000d0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	83 c0 10	 add	 eax, 16			; 00000010H
  000d6	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000d9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000df	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000e2	83 c0 04	 add	 eax, 4
  000e5	89 45 e8	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000e8	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	83 e8 04	 sub	 eax, 4
  000f0	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f3	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f6	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000f9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000fc	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000ff	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  00102	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00105	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  00108	8b 00		 mov	 eax, DWORD PTR [eax]
  0010a	83 e8 04	 sub	 eax, 4
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  00110	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 73   : 			return pkFreeData;

  00112	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	c9		 leave
  00121	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ$0:
  00000	6a 5c		 push	 92			; 0000005cH
  00002	ff 75 dc	 push	 DWORD PTR $T10[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ ENDP ; CDynamicPool<CAttributeInstance>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCAttributeInstance@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCAttributeInstance@@@@QAEXXZ PROC ; CDynamicPool<CAttributeInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z ; CDynamicPool<CAttributeInstance>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@std@@P6AXPAVCAttributeInstance@@@Z@std@@YAP6AXPAVCAttributeInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAttributeInstance *> > >,void (__cdecl*)(CAttributeInstance *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCAttributeInstance@@@@QAEXXZ ENDP ; CDynamicPool<CAttributeInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ PROC	; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCAttributeInstance@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ ENDP	; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCAttributeInstance@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCAttributeInstance@@@@QAE@XZ PROC	; CDynamicPool<CAttributeInstance>::CDynamicPool<CAttributeInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCAttributeInstance@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCAttributeInstance@@@@QAE@XZ ENDP	; CDynamicPool<CAttributeInstance>::CDynamicPool<CAttributeInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCAttributeInstance@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCAttributeInstance@@UAEPAXI@Z PROC			; CAttributeInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CAttributeInstance@@UAE@XZ ; CAttributeInstance::~CAttributeInstance
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 5c		 push	 92			; 0000005cH
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GCAttributeInstance@@UAEPAXI@Z ENDP			; CAttributeInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?Delete@CAttributeInstance@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
_pkInst$ = 8						; size = 4
?Delete@CAttributeInstance@@SAXPAV1@@Z PROC		; CAttributeInstance::Delete, COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 188  : 	ms_kPool.Free(pkInst);

  00004	8b 45 08	 mov	 eax, DWORD PTR _pkInst$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0000a	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
  0000d	50		 push	 eax
  0000e	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+16
  00013	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::emplace_back<CAttributeInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 189  : }

  00018	c9		 leave
  00019	c3		 ret	 0
?Delete@CAttributeInstance@@SAXPAV1@@Z ENDP		; CAttributeInstance::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?New@CAttributeInstance@@SAPAV1@XZ
_TEXT	SEGMENT
?New@CAttributeInstance@@SAPAV1@XZ PROC			; CAttributeInstance::New, COMDAT

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  : 	return ms_kPool.Alloc();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A ; CAttributeInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ ; CDynamicPool<CAttributeInstance>::Alloc

; 184  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?New@CAttributeInstance@@SAPAV1@XZ ENDP			; CAttributeInstance::New
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?DestroySystem@CAttributeInstance@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CAttributeInstance@@SAXXZ PROC		; CAttributeInstance::DestroySystem, COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 178  : 	ms_kPool.Destroy();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A ; CAttributeInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCAttributeInstance@@@@QAEXXZ ; CDynamicPool<CAttributeInstance>::Destroy

; 179  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?DestroySystem@CAttributeInstance@@SAXXZ ENDP		; CAttributeInstance::DestroySystem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?CreateSystem@CAttributeInstance@@SAXI@Z
_TEXT	SEGMENT
_uCapacity$ = 8						; size = 4
?CreateSystem@CAttributeInstance@@SAXI@Z PROC		; CAttributeInstance::CreateSystem, COMDAT

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 57   : 			m_uInitCapacity=uCapacity;

  00003	8b 45 08	 mov	 eax, DWORD PTR _uCapacity$[ebp]
  00006	a3 1c 00 00 00	 mov	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+28, eax

; 58   : 			m_kVct_pkData.reserve(uCapacity);

  0000b	ff 75 08	 push	 DWORD PTR _uCapacity$[ebp]
  0000e	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+4
  00013	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXI@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::reserve

; 59   : 			m_kVct_pkFree.reserve(uCapacity);

  00018	ff 75 08	 push	 DWORD PTR _uCapacity$[ebp]
  0001b	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+16
  00020	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXI@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::reserve
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 174  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?CreateSystem@CAttributeInstance@@SAXI@Z ENDP		; CAttributeInstance::CreateSystem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
;	COMDAT ?SetPointer@?$CRef@VCAttributeData@@@@QAEXPAVCReferenceObject@@@Z
_TEXT	SEGMENT
_pOldObject$ = -8					; size = 4
_this$ = -4						; size = 4
_pObject$ = 8						; size = 4
?SetPointer@?$CRef@VCAttributeData@@@@QAEXPAVCReferenceObject@@@Z PROC ; CRef<CAttributeData>::SetPointer, COMDAT
; _this$ = ecx

; 66   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 67   : 			CReferenceObject* pOldObject = m_pObject;

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 f8	 mov	 DWORD PTR _pOldObject$[ebp], eax

; 68   : 
; 69   : 			m_pObject = pObject;

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pObject$[ebp]
  00016	89 08		 mov	 DWORD PTR [eax], ecx

; 70   : 
; 71   : 			if (m_pObject)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001e	74 0a		 je	 SHORT $LN2@SetPointer

; 72   : 				m_pObject->AddReference();

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference
$LN2@SetPointer:

; 73   : 
; 74   : 			if (pOldObject)

  0002a	83 7d f8 00	 cmp	 DWORD PTR _pOldObject$[ebp], 0
  0002e	74 08		 je	 SHORT $LN1@SetPointer

; 75   : 				pOldObject->Release();

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _pOldObject$[ebp]
  00033	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN1@SetPointer:

; 76   : 		}

  00038	c9		 leave
  00039	c2 04 00	 ret	 4
?SetPointer@?$CRef@VCAttributeData@@@@QAEXPAVCReferenceObject@@@Z ENDP ; CRef<CAttributeData>::SetPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@XZ PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXQAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXQAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@II@Z PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 0c	 imul	 eax, DWORD PTR __Newsize$[ebp], 12
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 0c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 12
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXQAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@II@Z ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@ABEII@Z PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 0c		 push	 12			; 0000000cH
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 55 55
	55 15		 mov	 DWORD PTR $T7[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@ABEII@Z ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@0@Z PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@0@Z ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QAEXQAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QAEXQAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@I@Z PROC ; std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@QAEXQAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@2@I@Z ENDP ; std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?GetHeight@CAttributeInstance@@QAEHMMPAM@Z
_TEXT	SEGMENT
$T1 = -64						; size = 4
$T2 = -60						; size = 4
__My_data$3 = -56					; size = 4
__My_data$4 = -52					; size = 4
_fm$5 = -48						; size = 4
_fd$6 = -44						; size = 4
_fz$ = -40						; size = 4
_fy$ = -36						; size = 4
_fx$ = -32						; size = 4
_fz$ = -28						; size = 4
_fy$ = -24						; size = 4
_fx$ = -20						; size = 4
__My_data$7 = -16					; size = 4
$T8 = -12						; size = 4
__My_data$9 = -8					; size = 4
__My_data$10 = -4					; size = 4
__My_data$11 = 0					; size = 4
$T12 = 4						; size = 4
$T13 = 8						; size = 4
__My_data$14 = 12					; size = 4
$T15 = 16						; size = 4
_bFlag$ = 20						; size = 4
__My_data$16 = 24					; size = 4
__My_data$17 = 28					; size = 4
_j$18 = 32						; size = 4
_i$19 = 36						; size = 4
_this$ = 40						; size = 4
_c_rv3Vertex2$20 = 44					; size = 4
_c_rv3Vertex1$21 = 48					; size = 4
_c_rv3Vertex0$22 = 52					; size = 4
_v$23 = 56						; size = 12
_v3Line1$24 = 68					; size = 12
_v3Line2$25 = 80					; size = 12
_v3Cross$26 = 92					; size = 12
__$ArrayPad$ = 104					; size = 4
_fx$ = 116						; size = 4
_fy$ = 120						; size = 4
_pfHeight$ = 124					; size = 4
?GetHeight@CAttributeInstance@@QAEHMMPAM@Z PROC		; CAttributeInstance::GetHeight, COMDAT
; _this$ = ecx

; 67   : {	

  00000	55		 push	 ebp
  00001	8d 6c 24 94	 lea	 ebp, DWORD PTR [esp-108]
  00005	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 68	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	89 4d 28	 mov	 DWORD PTR _this$[ebp], ecx

; 68   : 	if(IsEmpty())

  0001a	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?IsEmpty@CAttributeInstance@@QBEHXZ ; CAttributeInstance::IsEmpty
  00022	85 c0		 test	 eax, eax
  00024	74 07		 je	 SHORT $LN8@GetHeight

; 69   : 		return FALSE;

  00026	33 c0		 xor	 eax, eax
  00028	e9 22 04 00 00	 jmp	 $LN1@GetHeight
$LN8@GetHeight:

; 70   : 
; 71   : 	fy *= -1.0f;

  0002d	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00032	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@bf800000
  0003a	f3 0f 11 45 78	 movss	 DWORD PTR _fy$[ebp], xmm0

; 72   : 
; 73   : 	if (!IsInHeight(fx, fy))

  0003f	51		 push	 ecx
  00040	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00045	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004a	51		 push	 ecx
  0004b	f3 0f 10 45 74	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00050	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00055	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?IsInHeight@CAttributeInstance@@QAEHMM@Z ; CAttributeInstance::IsInHeight
  0005d	85 c0		 test	 eax, eax
  0005f	75 07		 jne	 SHORT $LN9@GetHeight

; 74   : 		return FALSE;

  00061	33 c0		 xor	 eax, eax
  00063	e9 e7 03 00 00	 jmp	 $LN1@GetHeight
$LN9@GetHeight:

; 75   : 
; 76   : 	BOOL bFlag = FALSE;

  00068	83 65 14 00	 and	 DWORD PTR _bFlag$[ebp], 0

; 78   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  0006c	83 65 24 00	 and	 DWORD PTR _i$19[ebp], 0
  00070	eb 07		 jmp	 SHORT $LN4@GetHeight
$LN2@GetHeight:
  00072	8b 45 24	 mov	 eax, DWORD PTR _i$19[ebp]
  00075	40		 inc	 eax
  00076	89 45 24	 mov	 DWORD PTR _i$19[ebp], eax
$LN4@GetHeight:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00079	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	83 c0 4c	 add	 eax, 76			; 0000004cH
  0007f	89 45 1c	 mov	 DWORD PTR __My_data$17[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00082	8b 45 1c	 mov	 eax, DWORD PTR __My_data$17[ebp]
  00085	8b 4d 1c	 mov	 ecx, DWORD PTR __My_data$17[ebp]
  00088	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0008d	99		 cdq
  0008e	6a 0c		 push	 12			; 0000000cH
  00090	59		 pop	 ecx
  00091	f7 f9		 idiv	 ecx
  00093	89 45 10	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 78   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  00096	8b 45 24	 mov	 eax, DWORD PTR _i$19[ebp]
  00099	3b 45 10	 cmp	 eax, DWORD PTR $T15[ebp]
  0009c	0f 83 aa 03 00
	00		 jae	 $LN3@GetHeight

; 79   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  000a2	83 65 20 00	 and	 DWORD PTR _j$18[ebp], 0
  000a6	eb 09		 jmp	 SHORT $LN7@GetHeight
$LN5@GetHeight:
  000a8	8b 45 20	 mov	 eax, DWORD PTR _j$18[ebp]
  000ab	83 c0 03	 add	 eax, 3
  000ae	89 45 20	 mov	 DWORD PTR _j$18[ebp], eax
$LN7@GetHeight:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000b1	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	83 c0 4c	 add	 eax, 76			; 0000004cH
  000b7	89 45 0c	 mov	 DWORD PTR __My_data$14[ebp], eax

; 1504 :         return _My_data._Myfirst[_Pos];

  000ba	6b 45 24 0c	 imul	 eax, DWORD PTR _i$19[ebp], 12
  000be	8b 4d 0c	 mov	 ecx, DWORD PTR __My_data$14[ebp]
  000c1	03 01		 add	 eax, DWORD PTR [ecx]
  000c3	89 45 08	 mov	 DWORD PTR $T13[ebp], eax

; 1483 :         auto& _My_data = _Mypair._Myval2;

  000c6	8b 45 08	 mov	 eax, DWORD PTR $T13[ebp]
  000c9	89 45 18	 mov	 DWORD PTR __My_data$16[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000cc	8b 45 18	 mov	 eax, DWORD PTR __My_data$16[ebp]
  000cf	8b 4d 18	 mov	 ecx, DWORD PTR __My_data$16[ebp]
  000d2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d5	2b 01		 sub	 eax, DWORD PTR [ecx]
  000d7	99		 cdq
  000d8	6a 0c		 push	 12			; 0000000cH
  000da	59		 pop	 ecx
  000db	f7 f9		 idiv	 ecx
  000dd	89 45 04	 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 79   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  000e0	8b 45 20	 mov	 eax, DWORD PTR _j$18[ebp]
  000e3	3b 45 04	 cmp	 eax, DWORD PTR $T12[ebp]
  000e6	0f 83 5b 03 00
	00		 jae	 $LN6@GetHeight
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000ec	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	83 c0 4c	 add	 eax, 76			; 0000004cH
  000f2	89 45 00	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1504 :         return _My_data._Myfirst[_Pos];

  000f5	6b 45 24 0c	 imul	 eax, DWORD PTR _i$19[ebp], 12
  000f9	8b 4d 00	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  000fc	03 01		 add	 eax, DWORD PTR [ecx]
  000fe	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00101	8b 45 c4	 mov	 eax, DWORD PTR $T2[ebp]
  00104	89 45 c8	 mov	 DWORD PTR __My_data$3[ebp], eax

; 1504 :         return _My_data._Myfirst[_Pos];

  00107	6b 45 20 0c	 imul	 eax, DWORD PTR _j$18[ebp], 12
  0010b	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$3[ebp]
  0010e	03 01		 add	 eax, DWORD PTR [ecx]
  00110	89 45 34	 mov	 DWORD PTR _c_rv3Vertex0$22[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00113	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00116	83 c0 4c	 add	 eax, 76			; 0000004cH
  00119	89 45 cc	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1504 :         return _My_data._Myfirst[_Pos];

  0011c	6b 45 24 0c	 imul	 eax, DWORD PTR _i$19[ebp], 12
  00120	8b 4d cc	 mov	 ecx, DWORD PTR __My_data$4[ebp]
  00123	03 01		 add	 eax, DWORD PTR [ecx]
  00125	89 45 c0	 mov	 DWORD PTR $T1[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00128	8b 45 c0	 mov	 eax, DWORD PTR $T1[ebp]
  0012b	89 45 fc	 mov	 DWORD PTR __My_data$10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 82   : 		const D3DXVECTOR3 & c_rv3Vertex1 = m_v3HeightDataVector[i][j+1];

  0012e	8b 45 20	 mov	 eax, DWORD PTR _j$18[ebp]
  00131	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00132	6b c0 0c	 imul	 eax, eax, 12
  00135	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00138	03 01		 add	 eax, DWORD PTR [ecx]
  0013a	89 45 30	 mov	 DWORD PTR _c_rv3Vertex1$21[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0013d	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00140	83 c0 4c	 add	 eax, 76			; 0000004cH
  00143	89 45 f8	 mov	 DWORD PTR __My_data$9[ebp], eax

; 1504 :         return _My_data._Myfirst[_Pos];

  00146	6b 45 24 0c	 imul	 eax, DWORD PTR _i$19[ebp], 12
  0014a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$9[ebp]
  0014d	03 01		 add	 eax, DWORD PTR [ecx]
  0014f	89 45 f4	 mov	 DWORD PTR $T8[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00152	8b 45 f4	 mov	 eax, DWORD PTR $T8[ebp]
  00155	89 45 f0	 mov	 DWORD PTR __My_data$7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 83   : 		const D3DXVECTOR3 & c_rv3Vertex2 = m_v3HeightDataVector[i][j+2];

  00158	8b 45 20	 mov	 eax, DWORD PTR _j$18[ebp]
  0015b	40		 inc	 eax
  0015c	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  0015d	6b c0 0c	 imul	 eax, eax, 12
  00160	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  00163	03 01		 add	 eax, DWORD PTR [ecx]
  00165	89 45 2c	 mov	 DWORD PTR _c_rv3Vertex2$20[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 88   : 			fy<c_rv3Vertex0.y && fy<c_rv3Vertex1.y && fy<c_rv3Vertex2.y ||

  00168	8b 45 34	 mov	 eax, DWORD PTR _c_rv3Vertex0$22[ebp]
  0016b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0016f	0f 2f 45 74	 comiss	 xmm0, DWORD PTR _fx$[ebp]
  00173	76 1a		 jbe	 SHORT $LN12@GetHeight
  00175	8b 45 30	 mov	 eax, DWORD PTR _c_rv3Vertex1$21[ebp]
  00178	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0017c	0f 2f 45 74	 comiss	 xmm0, DWORD PTR _fx$[ebp]
  00180	76 0d		 jbe	 SHORT $LN12@GetHeight
  00182	8b 45 2c	 mov	 eax, DWORD PTR _c_rv3Vertex2$20[ebp]
  00185	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00189	0f 2f 45 74	 comiss	 xmm0, DWORD PTR _fx$[ebp]
  0018d	77 7b		 ja	 SHORT $LN11@GetHeight
$LN12@GetHeight:
  0018f	8b 45 34	 mov	 eax, DWORD PTR _c_rv3Vertex0$22[ebp]
  00192	f3 0f 10 45 74	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00197	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  0019a	76 1a		 jbe	 SHORT $LN13@GetHeight
  0019c	8b 45 30	 mov	 eax, DWORD PTR _c_rv3Vertex1$21[ebp]
  0019f	f3 0f 10 45 74	 movss	 xmm0, DWORD PTR _fx$[ebp]
  001a4	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  001a7	76 0d		 jbe	 SHORT $LN13@GetHeight
  001a9	8b 45 2c	 mov	 eax, DWORD PTR _c_rv3Vertex2$20[ebp]
  001ac	f3 0f 10 45 74	 movss	 xmm0, DWORD PTR _fx$[ebp]
  001b1	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  001b4	77 54		 ja	 SHORT $LN11@GetHeight
$LN13@GetHeight:
  001b6	8b 45 34	 mov	 eax, DWORD PTR _c_rv3Vertex0$22[ebp]
  001b9	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001be	0f 2f 45 78	 comiss	 xmm0, DWORD PTR _fy$[ebp]
  001c2	76 1c		 jbe	 SHORT $LN14@GetHeight
  001c4	8b 45 30	 mov	 eax, DWORD PTR _c_rv3Vertex1$21[ebp]
  001c7	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001cc	0f 2f 45 78	 comiss	 xmm0, DWORD PTR _fy$[ebp]
  001d0	76 0e		 jbe	 SHORT $LN14@GetHeight
  001d2	8b 45 2c	 mov	 eax, DWORD PTR _c_rv3Vertex2$20[ebp]
  001d5	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001da	0f 2f 45 78	 comiss	 xmm0, DWORD PTR _fy$[ebp]
  001de	77 2a		 ja	 SHORT $LN11@GetHeight
$LN14@GetHeight:
  001e0	8b 45 34	 mov	 eax, DWORD PTR _c_rv3Vertex0$22[ebp]
  001e3	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fy$[ebp]
  001e8	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  001ec	76 21		 jbe	 SHORT $LN10@GetHeight
  001ee	8b 45 30	 mov	 eax, DWORD PTR _c_rv3Vertex1$21[ebp]
  001f1	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fy$[ebp]
  001f6	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  001fa	76 13		 jbe	 SHORT $LN10@GetHeight
  001fc	8b 45 2c	 mov	 eax, DWORD PTR _c_rv3Vertex2$20[ebp]
  001ff	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00204	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00208	76 05		 jbe	 SHORT $LN10@GetHeight
$LN11@GetHeight:

; 89   : 			fy>c_rv3Vertex0.y && fy>c_rv3Vertex1.y && fy>c_rv3Vertex2.y
; 90   : 			)
; 91   : 			continue;

  0020a	e9 99 fe ff ff	 jmp	 $LN5@GetHeight
$LN10@GetHeight:

; 92   : 
; 93   : 		if (IsInTriangle2D(c_rv3Vertex0.x, c_rv3Vertex0.y,

  0020f	51		 push	 ecx
  00210	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00215	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0021a	51		 push	 ecx
  0021b	f3 0f 10 45 74	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00220	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00225	8b 45 2c	 mov	 eax, DWORD PTR _c_rv3Vertex2$20[ebp]
  00228	51		 push	 ecx
  00229	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0022e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00233	8b 45 2c	 mov	 eax, DWORD PTR _c_rv3Vertex2$20[ebp]
  00236	51		 push	 ecx
  00237	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0023b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00240	8b 45 30	 mov	 eax, DWORD PTR _c_rv3Vertex1$21[ebp]
  00243	51		 push	 ecx
  00244	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00249	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0024e	8b 45 30	 mov	 eax, DWORD PTR _c_rv3Vertex1$21[ebp]
  00251	51		 push	 ecx
  00252	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00256	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0025b	8b 45 34	 mov	 eax, DWORD PTR _c_rv3Vertex0$22[ebp]
  0025e	51		 push	 ecx
  0025f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00264	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00269	8b 45 34	 mov	 eax, DWORD PTR _c_rv3Vertex0$22[ebp]
  0026c	51		 push	 ecx
  0026d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00271	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00276	e8 00 00 00 00	 call	 ?IsInTriangle2D@@YA_NMMMMMMMM@Z ; IsInTriangle2D
  0027b	83 c4 20	 add	 esp, 32			; 00000020H
  0027e	0f b6 c0	 movzx	 eax, al
  00281	85 c0		 test	 eax, eax
  00283	0f 84 b9 01 00
	00		 je	 $LN16@GetHeight
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00289	8b 45 30	 mov	 eax, DWORD PTR _c_rv3Vertex1$21[ebp]
  0028c	8b 4d 34	 mov	 ecx, DWORD PTR _c_rv3Vertex0$22[ebp]
  0028f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00293	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00297	f3 0f 11 45 ec	 movss	 DWORD PTR _fx$[ebp], xmm0
  0029c	8b 45 30	 mov	 eax, DWORD PTR _c_rv3Vertex1$21[ebp]
  0029f	8b 4d 34	 mov	 ecx, DWORD PTR _c_rv3Vertex0$22[ebp]
  002a2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  002a7	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  002ac	f3 0f 11 45 e8	 movss	 DWORD PTR _fy$[ebp], xmm0
  002b1	8b 45 30	 mov	 eax, DWORD PTR _c_rv3Vertex1$21[ebp]
  002b4	8b 4d 34	 mov	 ecx, DWORD PTR _c_rv3Vertex0$22[ebp]
  002b7	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002bc	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  002c1	f3 0f 11 45 e4	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  002c6	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002cb	f3 0f 11 45 44	 movss	 DWORD PTR _v3Line1$24[ebp], xmm0

; 181  :     y = fy;

  002d0	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002d5	f3 0f 11 45 48	 movss	 DWORD PTR _v3Line1$24[ebp+4], xmm0

; 182  :     z = fz;

  002da	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002df	f3 0f 11 45 4c	 movss	 DWORD PTR _v3Line1$24[ebp+8], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  002e4	8b 45 2c	 mov	 eax, DWORD PTR _c_rv3Vertex2$20[ebp]
  002e7	8b 4d 34	 mov	 ecx, DWORD PTR _c_rv3Vertex0$22[ebp]
  002ea	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002ee	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  002f2	f3 0f 11 45 e0	 movss	 DWORD PTR _fx$[ebp], xmm0
  002f7	8b 45 2c	 mov	 eax, DWORD PTR _c_rv3Vertex2$20[ebp]
  002fa	8b 4d 34	 mov	 ecx, DWORD PTR _c_rv3Vertex0$22[ebp]
  002fd	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00302	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00307	f3 0f 11 45 dc	 movss	 DWORD PTR _fy$[ebp], xmm0
  0030c	8b 45 2c	 mov	 eax, DWORD PTR _c_rv3Vertex2$20[ebp]
  0030f	8b 4d 34	 mov	 ecx, DWORD PTR _c_rv3Vertex0$22[ebp]
  00312	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00317	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0031c	f3 0f 11 45 d8	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00321	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00326	f3 0f 11 45 50	 movss	 DWORD PTR _v3Line2$25[ebp], xmm0

; 181  :     y = fy;

  0032b	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00330	f3 0f 11 45 54	 movss	 DWORD PTR _v3Line2$25[ebp+4], xmm0

; 182  :     z = fz;

  00335	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0033a	f3 0f 11 45 58	 movss	 DWORD PTR _v3Line2$25[ebp+8], xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0033f	f3 0f 10 45 48	 movss	 xmm0, DWORD PTR _v3Line1$24[ebp+4]
  00344	f3 0f 59 45 58	 mulss	 xmm0, DWORD PTR _v3Line2$25[ebp+8]
  00349	f3 0f 10 4d 4c	 movss	 xmm1, DWORD PTR _v3Line1$24[ebp+8]
  0034e	f3 0f 59 4d 54	 mulss	 xmm1, DWORD PTR _v3Line2$25[ebp+4]
  00353	f3 0f 5c c1	 subss	 xmm0, xmm1
  00357	f3 0f 11 45 38	 movss	 DWORD PTR _v$23[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0035c	f3 0f 10 45 4c	 movss	 xmm0, DWORD PTR _v3Line1$24[ebp+8]
  00361	f3 0f 59 45 50	 mulss	 xmm0, DWORD PTR _v3Line2$25[ebp]
  00366	f3 0f 10 4d 44	 movss	 xmm1, DWORD PTR _v3Line1$24[ebp]
  0036b	f3 0f 59 4d 58	 mulss	 xmm1, DWORD PTR _v3Line2$25[ebp+8]
  00370	f3 0f 5c c1	 subss	 xmm0, xmm1
  00374	f3 0f 11 45 3c	 movss	 DWORD PTR _v$23[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00379	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR _v3Line1$24[ebp]
  0037e	f3 0f 59 45 54	 mulss	 xmm0, DWORD PTR _v3Line2$25[ebp+4]
  00383	f3 0f 10 4d 48	 movss	 xmm1, DWORD PTR _v3Line1$24[ebp+4]
  00388	f3 0f 59 4d 50	 mulss	 xmm1, DWORD PTR _v3Line2$25[ebp]
  0038d	f3 0f 5c c1	 subss	 xmm0, xmm1
  00391	f3 0f 11 45 40	 movss	 DWORD PTR _v$23[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  00396	8d 75 38	 lea	 esi, DWORD PTR _v$23[ebp]
  00399	8d 7d 5c	 lea	 edi, DWORD PTR _v3Cross$26[ebp]
  0039c	a5		 movsd
  0039d	a5		 movsd
  0039e	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 102  : 			D3DXVec3Normalize(&v3Cross, &v3Cross);

  0039f	8d 45 5c	 lea	 eax, DWORD PTR _v3Cross$26[ebp]
  003a2	50		 push	 eax
  003a3	8d 45 5c	 lea	 eax, DWORD PTR _v3Cross$26[ebp]
  003a6	50		 push	 eax
  003a7	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 103  : 
; 104  : 			if (0.0f != v3Cross.z)

  003ac	0f 57 c0	 xorps	 xmm0, xmm0
  003af	0f 2e 45 64	 ucomiss xmm0, DWORD PTR _v3Cross$26[ebp+8]
  003b3	9f		 lahf
  003b4	f6 c4 44	 test	 ah, 68			; 00000044H
  003b7	0f 8b 85 00 00
	00		 jnp	 $LN16@GetHeight

; 105  : 			{
; 106  : 				float fd = (v3Cross.x*c_rv3Vertex0.x + v3Cross.y*c_rv3Vertex0.y + v3Cross.z*c_rv3Vertex0.z);

  003bd	8b 45 34	 mov	 eax, DWORD PTR _c_rv3Vertex0$22[ebp]
  003c0	f3 0f 10 45 5c	 movss	 xmm0, DWORD PTR _v3Cross$26[ebp]
  003c5	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  003c9	8b 45 34	 mov	 eax, DWORD PTR _c_rv3Vertex0$22[ebp]
  003cc	f3 0f 10 4d 60	 movss	 xmm1, DWORD PTR _v3Cross$26[ebp+4]
  003d1	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  003d6	f3 0f 58 c1	 addss	 xmm0, xmm1
  003da	8b 45 34	 mov	 eax, DWORD PTR _c_rv3Vertex0$22[ebp]
  003dd	f3 0f 10 4d 64	 movss	 xmm1, DWORD PTR _v3Cross$26[ebp+8]
  003e2	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  003e7	f3 0f 58 c1	 addss	 xmm0, xmm1
  003eb	f3 0f 11 45 d4	 movss	 DWORD PTR _fd$6[ebp], xmm0

; 107  : 				float fm = (v3Cross.x*fx + v3Cross.y*fy);

  003f0	f3 0f 10 45 5c	 movss	 xmm0, DWORD PTR _v3Cross$26[ebp]
  003f5	f3 0f 59 45 74	 mulss	 xmm0, DWORD PTR _fx$[ebp]
  003fa	f3 0f 10 4d 60	 movss	 xmm1, DWORD PTR _v3Cross$26[ebp+4]
  003ff	f3 0f 59 4d 78	 mulss	 xmm1, DWORD PTR _fy$[ebp]
  00404	f3 0f 58 c1	 addss	 xmm0, xmm1
  00408	f3 0f 11 45 d0	 movss	 DWORD PTR _fm$5[ebp], xmm0

; 108  : 				*pfHeight = fMAX((fd - fm) / v3Cross.z, *pfHeight);

  0040d	8b 45 7c	 mov	 eax, DWORD PTR _pfHeight$[ebp]
  00410	51		 push	 ecx
  00411	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00415	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0041a	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _fd$6[ebp]
  0041f	f3 0f 5c 45 d0	 subss	 xmm0, DWORD PTR _fm$5[ebp]
  00424	f3 0f 5e 45 64	 divss	 xmm0, DWORD PTR _v3Cross$26[ebp+8]
  00429	51		 push	 ecx
  0042a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0042f	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX
  00434	59		 pop	 ecx
  00435	59		 pop	 ecx
  00436	8b 45 7c	 mov	 eax, DWORD PTR _pfHeight$[ebp]
  00439	d9 18		 fstp	 DWORD PTR [eax]

; 109  : 
; 110  : 				bFlag = TRUE;

  0043b	c7 45 14 01 00
	00 00		 mov	 DWORD PTR _bFlag$[ebp], 1
$LN16@GetHeight:

; 111  : 			}
; 112  : 		}
; 113  : 	}

  00442	e9 61 fc ff ff	 jmp	 $LN5@GetHeight
$LN6@GetHeight:
  00447	e9 26 fc ff ff	 jmp	 $LN2@GetHeight
$LN3@GetHeight:

; 114  : 
; 115  : 	return bFlag;

  0044c	8b 45 14	 mov	 eax, DWORD PTR _bFlag$[ebp]
$LN1@GetHeight:

; 116  : }

  0044f	5f		 pop	 edi
  00450	5e		 pop	 esi
  00451	8b 4d 68	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00454	33 cd		 xor	 ecx, ebp
  00456	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045b	83 c5 6c	 add	 ebp, 108		; 0000006cH
  0045e	c9		 leave
  0045f	c2 0c 00	 ret	 12			; 0000000cH
?GetHeight@CAttributeInstance@@QAEHMMPAM@Z ENDP		; CAttributeInstance::GetHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?IsInHeight@CAttributeInstance@@QAEHMM@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
_fdx$ = -12						; size = 4
_fdy$ = -8						; size = 4
_this$ = -4						; size = 4
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
?IsInHeight@CAttributeInstance@@QAEHMM@Z PROC		; CAttributeInstance::IsInHeight, COMDAT
; _this$ = ecx

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 124  : 	float fdx = m_matGlobal._41 - fx;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  00011	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _fx$[ebp]
  00016	f3 0f 11 45 f4	 movss	 DWORD PTR _fdx$[ebp], xmm0

; 125  : 	float fdy = m_matGlobal._42 - fy;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  00023	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _fy$[ebp]
  00028	f3 0f 11 45 f8	 movss	 DWORD PTR _fdy$[ebp], xmm0

; 126  : 	if (sqrtf(fdx*fdx + fdy*fdy) > m_fHeightRadius)

  0002d	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fdy$[ebp]
  00032	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _fdy$[ebp]
  00037	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _fdx$[ebp]
  0003c	f3 0f 59 4d f4	 mulss	 xmm1, DWORD PTR _fdx$[ebp]
  00041	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00045	f3 0f 5a c1	 cvtss2sd xmm0, xmm1
  00049	51		 push	 ecx
  0004a	51		 push	 ecx
  0004b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00050	e8 00 00 00 00	 call	 _sqrt
  00055	59		 pop	 ecx
  00056	59		 pop	 ecx
  00057	d9 5d f0	 fstp	 DWORD PTR $T1[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 126  : 	if (sqrtf(fdx*fdx + fdy*fdy) > m_fHeightRadius)

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR $T1[ebp]
  00062	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  00066	76 04		 jbe	 SHORT $LN2@IsInHeight

; 127  : 		return FALSE;

  00068	33 c0		 xor	 eax, eax
  0006a	eb 03		 jmp	 SHORT $LN1@IsInHeight
$LN2@IsInHeight:

; 128  : 
; 129  : 	return TRUE;

  0006c	33 c0		 xor	 eax, eax
  0006e	40		 inc	 eax
$LN1@IsInHeight:

; 130  : }

  0006f	c9		 leave
  00070	c2 08 00	 ret	 8
?IsInHeight@CAttributeInstance@@QAEHMM@Z ENDP		; CAttributeInstance::IsInHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?Picking@CAttributeInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z
_TEXT	SEGMENT
_fz$ = -456						; size = 4
__My_data$1 = -452					; size = 4
__My_data$2 = -448					; size = 4
$T3 = -444						; size = 4
__My_data$4 = -440					; size = 4
_fx$ = -436						; size = 4
_fy$ = -432						; size = 4
_fz$ = -428						; size = 4
_fx$ = -424						; size = 4
_fx$ = -420						; size = 4
_fy$ = -416						; size = 4
_fz$ = -412						; size = 4
_fx$ = -408						; size = 4
_fy$ = -404						; size = 4
_fz$ = -400						; size = 4
$T5 = -396						; size = 4
_fx$ = -392						; size = 4
_fy$ = -388						; size = 4
_fz$ = -384						; size = 4
_fy$ = -380						; size = 4
_fx$ = -376						; size = 4
_fz$ = -372						; size = 4
_fy$ = -368						; size = 4
_fx$ = -364						; size = 4
_fz$ = -360						; size = 4
_fy$ = -356						; size = 4
_fx$ = -352						; size = 4
_fz$ = -348						; size = 4
_fy$ = -344						; size = 4
_fx$ = -340						; size = 4
_fz$ = -336						; size = 4
_fy$ = -332						; size = 4
_fx$ = -328						; size = 4
_fz$ = -324						; size = 4
_fy$ = -320						; size = 4
_fx$ = -316						; size = 4
_fz$ = -312						; size = 4
_fy$ = -308						; size = 4
$T6 = -304						; size = 4
__My_data$7 = -300					; size = 4
__My_data$8 = -296					; size = 4
$T9 = -292						; size = 4
__My_data$10 = -288					; size = 4
$T11 = -284						; size = 4
$T12 = -280						; size = 4
__My_data$13 = -276					; size = 4
$T14 = -272						; size = 4
__My_data$15 = -268					; size = 4
__My_data$16 = -264					; size = 4
_t$17 = -260						; size = 4
_ny$ = -256						; size = 4
_nx$ = -252						; size = 4
_j$18 = -248						; size = 4
_this$ = -244						; size = 4
_i$19 = -240						; size = 4
_cv2$20 = -236						; size = 4
_cv1$21 = -232						; size = 4
_cv0$22 = -228						; size = 4
_bPicked$ = -221					; size = 1
_v$23 = -220						; size = 12
$T24 = -208						; size = 12
_v$25 = -196						; size = 12
_v$26 = -184						; size = 12
_v$27 = -172						; size = 12
$T28 = -160						; size = 12
$T29 = -148						; size = 12
$T30 = -136						; size = 12
$T31 = -124						; size = 12
$T32 = -112						; size = 12
$T33 = -100						; size = 12
$T34 = -88						; size = 12
$T35 = -76						; size = 12
$T36 = -64						; size = 12
$T37 = -52						; size = 12
_temp$38 = -40						; size = 12
_n$39 = -28						; size = 12
_x$40 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_v$ = 8							; size = 4
_dir$ = 12						; size = 4
_out_x$ = 16						; size = 4
_out_y$ = 20						; size = 4
?Picking@CAttributeInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z PROC ; CAttributeInstance::Picking, COMDAT
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 01 00
	00		 sub	 esp, 456		; 000001c8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 	if (IsEmpty())

  0001b	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?IsEmpty@CAttributeInstance@@QBEHXZ ; CAttributeInstance::IsEmpty
  00026	85 c0		 test	 eax, eax
  00028	74 07		 je	 SHORT $LN8@Picking

; 13   : 		return FALSE;

  0002a	32 c0		 xor	 al, al
  0002c	e9 e9 0a 00 00	 jmp	 $LN1@Picking
$LN8@Picking:

; 14   : 	//fy *= -1.0f;
; 15   : 
; 16   : 	bool bPicked = false;

  00031	c6 85 23 ff ff
	ff 00		 mov	 BYTE PTR _bPicked$[ebp], 0

; 17   : 	float nx = 0;

  00038	0f 57 c0	 xorps	 xmm0, xmm0
  0003b	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _nx$[ebp], xmm0

; 18   : 	float ny = 0;

  00043	0f 57 c0	 xorps	 xmm0, xmm0
  00046	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _ny$[ebp], xmm0

; 20   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  0004e	83 a5 10 ff ff
	ff 00		 and	 DWORD PTR _i$19[ebp], 0
  00055	eb 0d		 jmp	 SHORT $LN4@Picking
$LN2@Picking:
  00057	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _i$19[ebp]
  0005d	40		 inc	 eax
  0005e	89 85 10 ff ff
	ff		 mov	 DWORD PTR _i$19[ebp], eax
$LN4@Picking:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00064	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0006a	83 c0 4c	 add	 eax, 76			; 0000004cH
  0006d	89 85 f8 fe ff
	ff		 mov	 DWORD PTR __My_data$16[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00073	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$16[ebp]
  00079	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$16[ebp]
  0007f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00082	2b 01		 sub	 eax, DWORD PTR [ecx]
  00084	99		 cdq
  00085	6a 0c		 push	 12			; 0000000cH
  00087	59		 pop	 ecx
  00088	f7 f9		 idiv	 ecx
  0008a	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 20   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  00090	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _i$19[ebp]
  00096	3b 85 f0 fe ff
	ff		 cmp	 eax, DWORD PTR $T14[ebp]
  0009c	0f 83 49 0a 00
	00		 jae	 $LN3@Picking

; 21   : 		for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  000a2	83 a5 08 ff ff
	ff 00		 and	 DWORD PTR _j$18[ebp], 0
  000a9	eb 0f		 jmp	 SHORT $LN7@Picking
$LN5@Picking:
  000ab	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _j$18[ebp]
  000b1	83 c0 03	 add	 eax, 3
  000b4	89 85 08 ff ff
	ff		 mov	 DWORD PTR _j$18[ebp], eax
$LN7@Picking:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000ba	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000c0	83 c0 4c	 add	 eax, 76			; 0000004cH
  000c3	89 85 ec fe ff
	ff		 mov	 DWORD PTR __My_data$13[ebp], eax

; 1504 :         return _My_data._Myfirst[_Pos];

  000c9	6b 85 10 ff ff
	ff 0c		 imul	 eax, DWORD PTR _i$19[ebp], 12
  000d0	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$13[ebp]
  000d6	03 01		 add	 eax, DWORD PTR [ecx]
  000d8	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T12[ebp], eax

; 1483 :         auto& _My_data = _Mypair._Myval2;

  000de	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  000e4	89 85 f4 fe ff
	ff		 mov	 DWORD PTR __My_data$15[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000ea	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$15[ebp]
  000f0	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$15[ebp]
  000f6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f9	2b 01		 sub	 eax, DWORD PTR [ecx]
  000fb	99		 cdq
  000fc	6a 0c		 push	 12			; 0000000cH
  000fe	59		 pop	 ecx
  000ff	f7 f9		 idiv	 ecx
  00101	89 85 e4 fe ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 21   : 		for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  00107	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _j$18[ebp]
  0010d	3b 85 e4 fe ff
	ff		 cmp	 eax, DWORD PTR $T11[ebp]
  00113	0f 83 cd 09 00
	00		 jae	 $LN6@Picking
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00119	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0011f	83 c0 4c	 add	 eax, 76			; 0000004cH
  00122	89 85 e0 fe ff
	ff		 mov	 DWORD PTR __My_data$10[ebp], eax

; 1504 :         return _My_data._Myfirst[_Pos];

  00128	6b 85 10 ff ff
	ff 0c		 imul	 eax, DWORD PTR _i$19[ebp], 12
  0012f	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00135	03 01		 add	 eax, DWORD PTR [ecx]
  00137	89 85 dc fe ff
	ff		 mov	 DWORD PTR $T9[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0013d	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00143	89 85 d8 fe ff
	ff		 mov	 DWORD PTR __My_data$8[ebp], eax

; 1504 :         return _My_data._Myfirst[_Pos];

  00149	6b 85 08 ff ff
	ff 0c		 imul	 eax, DWORD PTR _j$18[ebp], 12
  00150	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00156	03 01		 add	 eax, DWORD PTR [ecx]
  00158	89 85 1c ff ff
	ff		 mov	 DWORD PTR _cv0$22[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0015e	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00164	83 c0 4c	 add	 eax, 76			; 0000004cH
  00167	89 85 d4 fe ff
	ff		 mov	 DWORD PTR __My_data$7[ebp], eax

; 1504 :         return _My_data._Myfirst[_Pos];

  0016d	6b 85 10 ff ff
	ff 0c		 imul	 eax, DWORD PTR _i$19[ebp], 12
  00174	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$7[ebp]
  0017a	03 01		 add	 eax, DWORD PTR [ecx]
  0017c	89 85 d0 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00182	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  00188	89 85 3c fe ff
	ff		 mov	 DWORD PTR __My_data$1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 24   : 			const D3DXVECTOR3 & cv2 = m_v3HeightDataVector[i][j+1];

  0018e	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _j$18[ebp]
  00194	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00195	6b c0 0c	 imul	 eax, eax, 12
  00198	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$1[ebp]
  0019e	03 01		 add	 eax, DWORD PTR [ecx]
  001a0	89 85 14 ff ff
	ff		 mov	 DWORD PTR _cv2$20[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  001a6	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001ac	83 c0 4c	 add	 eax, 76			; 0000004cH
  001af	89 85 40 fe ff
	ff		 mov	 DWORD PTR __My_data$2[ebp], eax

; 1504 :         return _My_data._Myfirst[_Pos];

  001b5	6b 85 10 ff ff
	ff 0c		 imul	 eax, DWORD PTR _i$19[ebp], 12
  001bc	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$2[ebp]
  001c2	03 01		 add	 eax, DWORD PTR [ecx]
  001c4	89 85 44 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  001ca	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  001d0	89 85 48 fe ff
	ff		 mov	 DWORD PTR __My_data$4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 25   : 			const D3DXVECTOR3 & cv1 = m_v3HeightDataVector[i][j+2];

  001d6	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _j$18[ebp]
  001dc	40		 inc	 eax
  001dd	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  001de	6b c0 0c	 imul	 eax, eax, 12
  001e1	8b 8d 48 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$4[ebp]
  001e7	03 01		 add	 eax, DWORD PTR [ecx]
  001e9	89 85 18 ff ff
	ff		 mov	 DWORD PTR _cv1$21[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001ef	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cv2$20[ebp]
  001f5	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _cv0$22[ebp]
  001fb	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001ff	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00203	f3 0f 11 85 4c
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0020b	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cv2$20[ebp]
  00211	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _cv0$22[ebp]
  00217	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0021c	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00221	f3 0f 11 85 50
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00229	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cv2$20[ebp]
  0022f	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _cv0$22[ebp]
  00235	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0023a	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0023f	f3 0f 11 85 54
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00247	f3 0f 10 85 4c
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0024f	f3 0f 11 45 90	 movss	 DWORD PTR $T32[ebp], xmm0

; 181  :     y = fy;

  00254	f3 0f 10 85 50
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0025c	f3 0f 11 45 94	 movss	 DWORD PTR $T32[ebp+4], xmm0

; 182  :     z = fz;

  00261	f3 0f 10 85 54
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00269	f3 0f 11 45 98	 movss	 DWORD PTR $T32[ebp+8], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0026e	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cv1$21[ebp]
  00274	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _cv0$22[ebp]
  0027a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0027e	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00282	f3 0f 11 85 58
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0028a	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cv1$21[ebp]
  00290	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _cv0$22[ebp]
  00296	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0029b	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  002a0	f3 0f 11 85 60
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  002a8	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cv1$21[ebp]
  002ae	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _cv0$22[ebp]
  002b4	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002b9	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  002be	f3 0f 11 85 64
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  002c6	f3 0f 10 85 58
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002ce	f3 0f 11 45 84	 movss	 DWORD PTR $T31[ebp], xmm0

; 181  :     y = fy;

  002d3	f3 0f 10 85 60
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002db	f3 0f 11 45 88	 movss	 DWORD PTR $T31[ebp+4], xmm0

; 182  :     z = fz;

  002e0	f3 0f 10 85 64
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002e8	f3 0f 11 45 8c	 movss	 DWORD PTR $T31[ebp+8], xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  002ed	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR $T31[ebp+4]
  002f2	f3 0f 59 45 98	 mulss	 xmm0, DWORD PTR $T32[ebp+8]
  002f7	f3 0f 10 4d 8c	 movss	 xmm1, DWORD PTR $T31[ebp+8]
  002fc	f3 0f 59 4d 94	 mulss	 xmm1, DWORD PTR $T32[ebp+4]
  00301	f3 0f 5c c1	 subss	 xmm0, xmm1
  00305	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _v$23[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0030d	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR $T31[ebp+8]
  00312	f3 0f 59 45 90	 mulss	 xmm0, DWORD PTR $T32[ebp]
  00317	f3 0f 10 4d 84	 movss	 xmm1, DWORD PTR $T31[ebp]
  0031c	f3 0f 59 4d 98	 mulss	 xmm1, DWORD PTR $T32[ebp+8]
  00321	f3 0f 5c c1	 subss	 xmm0, xmm1
  00325	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _v$23[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0032d	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR $T31[ebp]
  00332	f3 0f 59 45 94	 mulss	 xmm0, DWORD PTR $T32[ebp+4]
  00337	f3 0f 10 4d 88	 movss	 xmm1, DWORD PTR $T31[ebp+4]
  0033c	f3 0f 59 4d 90	 mulss	 xmm1, DWORD PTR $T32[ebp]
  00341	f3 0f 5c c1	 subss	 xmm0, xmm1
  00345	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _v$23[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  0034d	8d b5 24 ff ff
	ff		 lea	 esi, DWORD PTR _v$23[ebp]
  00353	8d 7d e4	 lea	 edi, DWORD PTR _n$39[ebp]
  00356	a5		 movsd
  00357	a5		 movsd
  00358	a5		 movsd

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00359	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0035c	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _cv0$22[ebp]
  00362	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00366	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0036a	f3 0f 11 85 68
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00372	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00375	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _cv0$22[ebp]
  0037b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00380	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00385	f3 0f 11 85 6c
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0038d	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00390	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _cv0$22[ebp]
  00396	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0039b	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  003a0	f3 0f 11 85 70
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  003a8	f3 0f 10 85 68
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  003b0	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR $T28[ebp], xmm0

; 181  :     y = fy;

  003b8	f3 0f 10 85 6c
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  003c0	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR $T28[ebp+4], xmm0

; 182  :     z = fz;

  003c8	f3 0f 10 85 70
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  003d0	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR $T28[ebp+8], xmm0

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  003d8	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR $T28[ebp]
  003e0	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _n$39[ebp]
  003e5	f3 0f 10 8d 64
	ff ff ff	 movss	 xmm1, DWORD PTR $T28[ebp+4]
  003ed	f3 0f 59 4d e8	 mulss	 xmm1, DWORD PTR _n$39[ebp+4]
  003f2	f3 0f 58 c1	 addss	 xmm0, xmm1
  003f6	f3 0f 10 8d 68
	ff ff ff	 movss	 xmm1, DWORD PTR $T28[ebp+8]
  003fe	f3 0f 59 4d ec	 mulss	 xmm1, DWORD PTR _n$39[ebp+8]
  00403	f3 0f 58 c1	 addss	 xmm0, xmm1
  00407	f3 0f 11 85 74
	fe ff ff	 movss	 DWORD PTR $T5[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 31   : 			t = - D3DXVec3Dot(&(v-cv0),&n)/D3DXVec3Dot(&dir,&n);

  0040f	f3 0f 10 85 74
	fe ff ff	 movss	 xmm0, DWORD PTR $T5[ebp]
  00417	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0041e	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  00421	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00426	f3 0f 59 4d ec	 mulss	 xmm1, DWORD PTR _n$39[ebp+8]
  0042b	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  0042e	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [eax+4]
  00433	f3 0f 59 55 e8	 mulss	 xmm2, DWORD PTR _n$39[ebp+4]
  00438	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  0043b	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  0043f	f3 0f 59 5d e4	 mulss	 xmm3, DWORD PTR _n$39[ebp]
  00444	f3 0f 58 da	 addss	 xmm3, xmm2
  00448	f3 0f 58 d9	 addss	 xmm3, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 31   : 			t = - D3DXVec3Dot(&(v-cv0),&n)/D3DXVec3Dot(&dir,&n);

  0044c	f3 0f 5e c3	 divss	 xmm0, xmm3
  00450	f3 0f 11 85 fc
	fe ff ff	 movss	 DWORD PTR _t$17[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00458	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  0045b	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _t$17[ebp]
  00463	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00467	f3 0f 11 85 78
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0046f	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  00472	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _t$17[ebp]
  0047a	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  0047f	f3 0f 11 85 7c
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00487	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  0048a	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _t$17[ebp]
  00492	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00497	f3 0f 11 85 80
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0049f	f3 0f 10 85 78
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  004a7	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR $T29[ebp], xmm0

; 181  :     y = fy;

  004af	f3 0f 10 85 7c
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  004b7	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR $T29[ebp+4], xmm0

; 182  :     z = fz;

  004bf	f3 0f 10 85 80
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  004c7	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR $T29[ebp+8], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  004cf	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  004d2	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  004d6	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR $T29[ebp]
  004de	f3 0f 11 85 5c
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  004e6	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  004e9	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  004ee	f3 0f 58 85 70
	ff ff ff	 addss	 xmm0, DWORD PTR $T29[ebp+4]
  004f6	f3 0f 11 85 cc
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  004fe	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00501	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00506	f3 0f 58 85 74
	ff ff ff	 addss	 xmm0, DWORD PTR $T29[ebp+8]
  0050e	f3 0f 11 85 c8
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00516	f3 0f 10 85 5c
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0051e	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR $T24[ebp], xmm0

; 181  :     y = fy;

  00526	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0052e	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR $T24[ebp+4], xmm0

; 182  :     z = fz;

  00536	f3 0f 10 85 c8
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0053e	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR $T24[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 33   : 			x = v+t*dir;

  00546	8d b5 30 ff ff
	ff		 lea	 esi, DWORD PTR $T24[ebp]
  0054c	8d 7d f0	 lea	 edi, DWORD PTR _x$40[ebp]
  0054f	a5		 movsd
  00550	a5		 movsd
  00551	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00552	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _cv0$22[ebp]
  00558	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _x$40[ebp]
  0055d	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00561	f3 0f 11 85 c4
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00569	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _cv0$22[ebp]
  0056f	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _x$40[ebp+4]
  00574	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  00579	f3 0f 11 85 c0
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00581	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _cv0$22[ebp]
  00587	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _x$40[ebp+8]
  0058c	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [eax+8]
  00591	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00599	f3 0f 10 85 c4
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  005a1	f3 0f 11 45 a8	 movss	 DWORD PTR $T34[ebp], xmm0

; 181  :     y = fy;

  005a6	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  005ae	f3 0f 11 45 ac	 movss	 DWORD PTR $T34[ebp+4], xmm0

; 182  :     z = fz;

  005b3	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  005bb	f3 0f 11 45 b0	 movss	 DWORD PTR $T34[ebp+8], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  005c0	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cv1$21[ebp]
  005c6	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _cv0$22[ebp]
  005cc	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  005d0	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  005d4	f3 0f 11 85 b8
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  005dc	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cv1$21[ebp]
  005e2	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _cv0$22[ebp]
  005e8	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  005ed	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  005f2	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  005fa	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cv1$21[ebp]
  00600	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR _cv0$22[ebp]
  00606	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0060b	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00610	f3 0f 11 85 b0
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00618	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00620	f3 0f 11 45 9c	 movss	 DWORD PTR $T33[ebp], xmm0

; 181  :     y = fy;

  00625	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0062d	f3 0f 11 45 a0	 movss	 DWORD PTR $T33[ebp+4], xmm0

; 182  :     z = fz;

  00632	f3 0f 10 85 b0
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0063a	f3 0f 11 45 a4	 movss	 DWORD PTR $T33[ebp+8], xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0063f	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR $T33[ebp+4]
  00644	f3 0f 59 45 b0	 mulss	 xmm0, DWORD PTR $T34[ebp+8]
  00649	f3 0f 10 4d a4	 movss	 xmm1, DWORD PTR $T33[ebp+8]
  0064e	f3 0f 59 4d ac	 mulss	 xmm1, DWORD PTR $T34[ebp+4]
  00653	f3 0f 5c c1	 subss	 xmm0, xmm1
  00657	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _v$25[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0065f	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR $T33[ebp+8]
  00664	f3 0f 59 45 a8	 mulss	 xmm0, DWORD PTR $T34[ebp]
  00669	f3 0f 10 4d 9c	 movss	 xmm1, DWORD PTR $T33[ebp]
  0066e	f3 0f 59 4d b0	 mulss	 xmm1, DWORD PTR $T34[ebp+8]
  00673	f3 0f 5c c1	 subss	 xmm0, xmm1
  00677	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _v$25[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0067f	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR $T33[ebp]
  00684	f3 0f 59 45 ac	 mulss	 xmm0, DWORD PTR $T34[ebp+4]
  00689	f3 0f 10 4d a0	 movss	 xmm1, DWORD PTR $T33[ebp+4]
  0068e	f3 0f 59 4d a8	 mulss	 xmm1, DWORD PTR $T34[ebp]
  00693	f3 0f 5c c1	 subss	 xmm0, xmm1
  00697	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _v$25[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  0069f	8d b5 3c ff ff
	ff		 lea	 esi, DWORD PTR _v$25[ebp]
  006a5	8d 7d d8	 lea	 edi, DWORD PTR _temp$38[ebp]
  006a8	a5		 movsd
  006a9	a5		 movsd
  006aa	a5		 movsd

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  006ab	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _temp$38[ebp+8]
  006b0	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _n$39[ebp+8]
  006b5	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR _temp$38[ebp+4]
  006ba	f3 0f 59 4d e8	 mulss	 xmm1, DWORD PTR _n$39[ebp+4]
  006bf	f3 0f 10 55 d8	 movss	 xmm2, DWORD PTR _temp$38[ebp]
  006c4	f3 0f 59 55 e4	 mulss	 xmm2, DWORD PTR _n$39[ebp]
  006c9	f3 0f 58 d1	 addss	 xmm2, xmm1
  006cd	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 37   : 			if (D3DXVec3Dot(&temp,&n)<0) continue;

  006d1	0f 57 c0	 xorps	 xmm0, xmm0
  006d4	0f 2f c2	 comiss	 xmm0, xmm2
  006d7	76 05		 jbe	 SHORT $LN9@Picking
  006d9	e9 cd f9 ff ff	 jmp	 $LN5@Picking
$LN9@Picking:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  006de	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cv1$21[ebp]
  006e4	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _x$40[ebp]
  006e9	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  006ed	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  006f5	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cv1$21[ebp]
  006fb	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _x$40[ebp+4]
  00700	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  00705	f3 0f 11 85 a8
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0070d	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _cv1$21[ebp]
  00713	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _x$40[ebp+8]
  00718	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [eax+8]
  0071d	f3 0f 11 85 a4
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00725	f3 0f 10 85 ac
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0072d	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR $T30[ebp], xmm0

; 181  :     y = fy;

  00735	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0073d	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR $T30[ebp+4], xmm0

; 182  :     z = fz;

  00745	f3 0f 10 85 a4
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0074d	f3 0f 11 45 80	 movss	 DWORD PTR $T30[ebp+8], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00752	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cv2$20[ebp]
  00758	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _cv1$21[ebp]
  0075e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00762	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00766	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0076e	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cv2$20[ebp]
  00774	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _cv1$21[ebp]
  0077a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0077f	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00784	f3 0f 11 85 9c
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0078c	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cv2$20[ebp]
  00792	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _cv1$21[ebp]
  00798	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0079d	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  007a2	f3 0f 11 85 98
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  007aa	f3 0f 10 85 a0
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  007b2	f3 0f 11 45 b4	 movss	 DWORD PTR $T35[ebp], xmm0

; 181  :     y = fy;

  007b7	f3 0f 10 85 9c
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  007bf	f3 0f 11 45 b8	 movss	 DWORD PTR $T35[ebp+4], xmm0

; 182  :     z = fz;

  007c4	f3 0f 10 85 98
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  007cc	f3 0f 11 45 bc	 movss	 DWORD PTR $T35[ebp+8], xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  007d1	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR $T35[ebp+4]
  007d6	f3 0f 59 45 80	 mulss	 xmm0, DWORD PTR $T30[ebp+8]
  007db	f3 0f 10 4d bc	 movss	 xmm1, DWORD PTR $T35[ebp+8]
  007e0	f3 0f 59 8d 7c
	ff ff ff	 mulss	 xmm1, DWORD PTR $T30[ebp+4]
  007e8	f3 0f 5c c1	 subss	 xmm0, xmm1
  007ec	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _v$26[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  007f4	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR $T35[ebp+8]
  007f9	f3 0f 59 85 78
	ff ff ff	 mulss	 xmm0, DWORD PTR $T30[ebp]
  00801	f3 0f 10 4d b4	 movss	 xmm1, DWORD PTR $T35[ebp]
  00806	f3 0f 59 4d 80	 mulss	 xmm1, DWORD PTR $T30[ebp+8]
  0080b	f3 0f 5c c1	 subss	 xmm0, xmm1
  0080f	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _v$26[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00817	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR $T35[ebp]
  0081c	f3 0f 59 85 7c
	ff ff ff	 mulss	 xmm0, DWORD PTR $T30[ebp+4]
  00824	f3 0f 10 4d b8	 movss	 xmm1, DWORD PTR $T35[ebp+4]
  00829	f3 0f 59 8d 78
	ff ff ff	 mulss	 xmm1, DWORD PTR $T30[ebp]
  00831	f3 0f 5c c1	 subss	 xmm0, xmm1
  00835	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _v$26[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  0083d	8d b5 48 ff ff
	ff		 lea	 esi, DWORD PTR _v$26[ebp]
  00843	8d 7d d8	 lea	 edi, DWORD PTR _temp$38[ebp]
  00846	a5		 movsd
  00847	a5		 movsd
  00848	a5		 movsd

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00849	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _temp$38[ebp+8]
  0084e	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _n$39[ebp+8]
  00853	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR _temp$38[ebp+4]
  00858	f3 0f 59 4d e8	 mulss	 xmm1, DWORD PTR _n$39[ebp+4]
  0085d	f3 0f 10 55 d8	 movss	 xmm2, DWORD PTR _temp$38[ebp]
  00862	f3 0f 59 55 e4	 mulss	 xmm2, DWORD PTR _n$39[ebp]
  00867	f3 0f 58 d1	 addss	 xmm2, xmm1
  0086b	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 39   : 			if (D3DXVec3Dot(&temp,&n)<0) continue;

  0086f	0f 57 c0	 xorps	 xmm0, xmm0
  00872	0f 2f c2	 comiss	 xmm0, xmm2
  00875	76 05		 jbe	 SHORT $LN10@Picking
  00877	e9 2f f8 ff ff	 jmp	 $LN5@Picking
$LN10@Picking:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0087c	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cv2$20[ebp]
  00882	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _x$40[ebp]
  00887	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  0088b	f3 0f 11 85 94
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00893	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cv2$20[ebp]
  00899	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _x$40[ebp+4]
  0089e	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  008a3	f3 0f 11 85 90
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  008ab	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _cv2$20[ebp]
  008b1	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _x$40[ebp+8]
  008b6	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [eax+8]
  008bb	f3 0f 11 85 8c
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  008c3	f3 0f 10 85 94
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  008cb	f3 0f 11 45 cc	 movss	 DWORD PTR $T37[ebp], xmm0

; 181  :     y = fy;

  008d0	f3 0f 10 85 90
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  008d8	f3 0f 11 45 d0	 movss	 DWORD PTR $T37[ebp+4], xmm0

; 182  :     z = fz;

  008dd	f3 0f 10 85 8c
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  008e5	f3 0f 11 45 d4	 movss	 DWORD PTR $T37[ebp+8], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  008ea	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _cv0$22[ebp]
  008f0	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _cv2$20[ebp]
  008f6	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  008fa	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  008fe	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00906	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _cv0$22[ebp]
  0090c	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _cv2$20[ebp]
  00912	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00917	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0091c	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00924	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _cv0$22[ebp]
  0092a	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _cv2$20[ebp]
  00930	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00935	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0093a	f3 0f 11 85 38
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00942	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0094a	f3 0f 11 45 c0	 movss	 DWORD PTR $T36[ebp], xmm0

; 181  :     y = fy;

  0094f	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00957	f3 0f 11 45 c4	 movss	 DWORD PTR $T36[ebp+4], xmm0

; 182  :     z = fz;

  0095c	f3 0f 10 85 38
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00964	f3 0f 11 45 c8	 movss	 DWORD PTR $T36[ebp+8], xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00969	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR $T36[ebp+4]
  0096e	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR $T37[ebp+8]
  00973	f3 0f 10 4d c8	 movss	 xmm1, DWORD PTR $T36[ebp+8]
  00978	f3 0f 59 4d d0	 mulss	 xmm1, DWORD PTR $T37[ebp+4]
  0097d	f3 0f 5c c1	 subss	 xmm0, xmm1
  00981	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _v$27[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00989	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR $T36[ebp+8]
  0098e	f3 0f 59 45 cc	 mulss	 xmm0, DWORD PTR $T37[ebp]
  00993	f3 0f 10 4d c0	 movss	 xmm1, DWORD PTR $T36[ebp]
  00998	f3 0f 59 4d d4	 mulss	 xmm1, DWORD PTR $T37[ebp+8]
  0099d	f3 0f 5c c1	 subss	 xmm0, xmm1
  009a1	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _v$27[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  009a9	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR $T36[ebp]
  009ae	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR $T37[ebp+4]
  009b3	f3 0f 10 4d c4	 movss	 xmm1, DWORD PTR $T36[ebp+4]
  009b8	f3 0f 59 4d cc	 mulss	 xmm1, DWORD PTR $T37[ebp]
  009bd	f3 0f 5c c1	 subss	 xmm0, xmm1
  009c1	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _v$27[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  009c9	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _v$27[ebp]
  009cf	8d 7d d8	 lea	 edi, DWORD PTR _temp$38[ebp]
  009d2	a5		 movsd
  009d3	a5		 movsd
  009d4	a5		 movsd

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  009d5	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _temp$38[ebp+8]
  009da	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _n$39[ebp+8]
  009df	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR _temp$38[ebp+4]
  009e4	f3 0f 59 4d e8	 mulss	 xmm1, DWORD PTR _n$39[ebp+4]
  009e9	f3 0f 10 55 d8	 movss	 xmm2, DWORD PTR _temp$38[ebp]
  009ee	f3 0f 59 55 e4	 mulss	 xmm2, DWORD PTR _n$39[ebp]
  009f3	f3 0f 58 d1	 addss	 xmm2, xmm1
  009f7	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 41   : 			if (D3DXVec3Dot(&temp,&n)<0) continue;

  009fb	0f 57 c0	 xorps	 xmm0, xmm0
  009fe	0f 2f c2	 comiss	 xmm0, xmm2
  00a01	76 05		 jbe	 SHORT $LN11@Picking
  00a03	e9 a3 f6 ff ff	 jmp	 $LN5@Picking
$LN11@Picking:

; 42   : 
; 43   : 			if (bPicked)

  00a08	0f b6 85 23 ff
	ff ff		 movzx	 eax, BYTE PTR _bPicked$[ebp]
  00a0f	85 c0		 test	 eax, eax
  00a11	0f 84 a9 00 00
	00		 je	 $LN12@Picking

; 44   : 			{
; 45   : 				if ((v.x-x.x)*(v.x-x.x)+(v.y-x.y)*(v.y-x.y)<(v.x-nx)*(v.x-nx)+(v.y-ny)*(v.y-ny))

  00a17	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00a1a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00a1e	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _x$40[ebp]
  00a23	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00a26	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00a2a	f3 0f 5c 4d f0	 subss	 xmm1, DWORD PTR _x$40[ebp]
  00a2f	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00a33	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00a36	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00a3b	f3 0f 5c 4d f4	 subss	 xmm1, DWORD PTR _x$40[ebp+4]
  00a40	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00a43	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [eax+4]
  00a48	f3 0f 5c 55 f4	 subss	 xmm2, DWORD PTR _x$40[ebp+4]
  00a4d	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00a51	f3 0f 58 c1	 addss	 xmm0, xmm1
  00a55	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00a58	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  00a5c	f3 0f 5c 8d 04
	ff ff ff	 subss	 xmm1, DWORD PTR _nx$[ebp]
  00a64	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00a67	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00a6b	f3 0f 5c 95 04
	ff ff ff	 subss	 xmm2, DWORD PTR _nx$[ebp]
  00a73	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00a77	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00a7a	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [eax+4]
  00a7f	f3 0f 5c 95 00
	ff ff ff	 subss	 xmm2, DWORD PTR _ny$[ebp]
  00a87	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00a8a	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  00a8f	f3 0f 5c 9d 00
	ff ff ff	 subss	 xmm3, DWORD PTR _ny$[ebp]
  00a97	f3 0f 59 d3	 mulss	 xmm2, xmm3
  00a9b	f3 0f 58 ca	 addss	 xmm1, xmm2
  00a9f	0f 2f c8	 comiss	 xmm1, xmm0
  00aa2	76 1a		 jbe	 SHORT $LN14@Picking

; 46   : 				{
; 47   : 					nx=x.x;

  00aa4	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _x$40[ebp]
  00aa9	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _nx$[ebp], xmm0

; 48   : 					ny=x.y;

  00ab1	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _x$40[ebp+4]
  00ab6	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _ny$[ebp], xmm0
$LN14@Picking:

; 49   : 				}
; 50   : 			}

  00abe	eb 1a		 jmp	 SHORT $LN13@Picking
$LN12@Picking:

; 51   : 			else
; 52   : 			{
; 53   : 				nx = x.x;

  00ac0	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _x$40[ebp]
  00ac5	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _nx$[ebp], xmm0

; 54   : 				ny = x.y;

  00acd	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _x$40[ebp+4]
  00ad2	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _ny$[ebp], xmm0
$LN13@Picking:

; 55   : 			}
; 56   : 			bPicked = true;

  00ada	c6 85 23 ff ff
	ff 01		 mov	 BYTE PTR _bPicked$[ebp], 1

; 57   : 	}	

  00ae1	e9 c5 f5 ff ff	 jmp	 $LN5@Picking
$LN6@Picking:
  00ae6	e9 6c f5 ff ff	 jmp	 $LN2@Picking
$LN3@Picking:

; 58   : 	if (bPicked)

  00aeb	0f b6 85 23 ff
	ff ff		 movzx	 eax, BYTE PTR _bPicked$[ebp]
  00af2	85 c0		 test	 eax, eax
  00af4	74 1e		 je	 SHORT $LN15@Picking

; 59   : 	{
; 60   : 		out_x = nx;

  00af6	8b 45 10	 mov	 eax, DWORD PTR _out_x$[ebp]
  00af9	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _nx$[ebp]
  00b01	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 61   : 		out_y = ny;

  00b05	8b 45 14	 mov	 eax, DWORD PTR _out_y$[ebp]
  00b08	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _ny$[ebp]
  00b10	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
$LN15@Picking:

; 62   : 	} 
; 63   : 	return bPicked;

  00b14	8a 85 23 ff ff
	ff		 mov	 al, BYTE PTR _bPicked$[ebp]
$LN1@Picking:

; 64   : }

  00b1a	5f		 pop	 edi
  00b1b	5e		 pop	 esi
  00b1c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b1f	33 cd		 xor	 ecx, ebp
  00b21	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b26	c9		 leave
  00b27	c2 10 00	 ret	 16			; 00000010H
?Picking@CAttributeInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z ENDP ; CAttributeInstance::Picking
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ PROC ; CAttributeInstance::GetObjectPointer, COMDAT
; _this$ = ecx

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 80   : 			return static_cast<T*>(m_pObject);

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 40 58	 mov	 eax, DWORD PTR [eax+88]
  0000e	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 120  : 	return m_roAttributeData.GetPointer();

  00011	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 121  : }

  00014	c9		 leave
  00015	c3		 ret	 0
?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ ENDP ; CAttributeInstance::GetObjectPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z
_TEXT	SEGMENT
$T1 = -92						; size = 4
$T2 = -88						; size = 4
__My_data$3 = -84					; size = 4
$T4 = -80						; size = 4
__My_data$5 = -76					; size = 4
__My_data$6 = -72					; size = 4
_this$ = -68						; size = 4
$T7 = -64						; size = 4
__My_data$8 = -60					; size = 4
$T9 = -56						; size = 4
__My_data$10 = -52					; size = 4
_this$ = -48						; size = 4
$T11 = -44						; size = 4
$T12 = -40						; size = 4
$T13 = -36						; size = 4
_c_pHeightData$14 = -32					; size = 4
_dwVertexCount$15 = -28					; size = 4
__My_data$16 = -24					; size = 4
_dwHeightDataCount$ = -20				; size = 4
_j$17 = -16						; size = 4
_i$18 = -12						; size = 4
_this$ = -8						; size = 4
$T19 = -2						; size = 1
$T20 = -1						; size = 1
_c_rmatGlobal$ = 8					; size = 4
?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z PROC ; CAttributeInstance::RefreshObject, COMDAT
; _this$ = ecx

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 140  : 	assert(!m_roAttributeData.IsNull());
; 141  : 
; 142  : 	m_matGlobal = c_rmatGlobal;

  0000b	8b 7d f8	 mov	 edi, DWORD PTR _this$[ebp]
  0000e	83 c7 0c	 add	 edi, 12			; 0000000cH
  00011	6a 10		 push	 16			; 00000010H
  00013	59		 pop	 ecx
  00014	8b 75 08	 mov	 esi, DWORD PTR _c_rmatGlobal$[ebp]
  00017	f3 a5		 rep movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 86   : 			return static_cast<T*>(m_pObject);

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 40 58	 mov	 eax, DWORD PTR [eax+88]
  0001f	89 45 dc	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 145  : 	m_fHeightRadius = m_roAttributeData->GetMaximizeRadius();

  00022	8b 4d dc	 mov	 ecx, DWORD PTR $T13[ebp]
  00025	e8 00 00 00 00	 call	 ?GetMaximizeRadius@CAttributeData@@QAEMXZ ; CAttributeData::GetMaximizeRadius
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	d9 58 08	 fstp	 DWORD PTR [eax+8]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 86   : 			return static_cast<T*>(m_pObject);

  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 40 58	 mov	 eax, DWORD PTR [eax+88]
  00036	89 45 d8	 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 147  : 	DWORD dwHeightDataCount = m_roAttributeData->GetHeightDataCount();

  00039	8b 4d d8	 mov	 ecx, DWORD PTR $T12[ebp]
  0003c	e8 00 00 00 00	 call	 ?GetHeightDataCount@CAttributeData@@QBEKXZ ; CAttributeData::GetHeightDataCount
  00041	89 45 ec	 mov	 DWORD PTR _dwHeightDataCount$[ebp], eax

; 148  : 	m_v3HeightDataVector.clear();

  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0004a	e8 00 00 00 00	 call	 ?clear@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@QAEXXZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  0004f	8d 45 ff	 lea	 eax, DWORD PTR $T20[ebp]
  00052	50		 push	 eax
  00053	ff 75 ec	 push	 DWORD PTR _dwHeightDataCount$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 149  : 	m_v3HeightDataVector.resize(dwHeightDataCount);

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	83 c1 4c	 add	 ecx, 76			; 0000004cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  0005c	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 150  : 	for (DWORD i = 0; i < dwHeightDataCount; ++i)

  00061	83 65 f4 00	 and	 DWORD PTR _i$18[ebp], 0
  00065	eb 07		 jmp	 SHORT $LN4@RefreshObj
$LN2@RefreshObj:
  00067	8b 45 f4	 mov	 eax, DWORD PTR _i$18[ebp]
  0006a	40		 inc	 eax
  0006b	89 45 f4	 mov	 DWORD PTR _i$18[ebp], eax
$LN4@RefreshObj:
  0006e	8b 45 f4	 mov	 eax, DWORD PTR _i$18[ebp]
  00071	3b 45 ec	 cmp	 eax, DWORD PTR _dwHeightDataCount$[ebp]
  00074	0f 83 f2 00 00
	00		 jae	 $LN3@RefreshObj
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 86   : 			return static_cast<T*>(m_pObject);

  0007a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 40 58	 mov	 eax, DWORD PTR [eax+88]
  00080	89 45 d4	 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 153  : 		if (!m_roAttributeData->GetHeightDataPointer(i, &c_pHeightData))

  00083	8d 45 e0	 lea	 eax, DWORD PTR _c_pHeightData$14[ebp]
  00086	50		 push	 eax
  00087	ff 75 f4	 push	 DWORD PTR _i$18[ebp]
  0008a	8b 4d d4	 mov	 ecx, DWORD PTR $T11[ebp]
  0008d	e8 00 00 00 00	 call	 ?GetHeightDataPointer@CAttributeData@@QBEHKPAPBUSHeightData@@@Z ; CAttributeData::GetHeightDataPointer
  00092	85 c0		 test	 eax, eax
  00094	75 02		 jne	 SHORT $LN8@RefreshObj

; 154  : 			continue;

  00096	eb cf		 jmp	 SHORT $LN2@RefreshObj
$LN8@RefreshObj:

; 155  : 
; 156  : 		DWORD dwVertexCount = c_pHeightData->v3VertexVector.size();

  00098	8b 45 e0	 mov	 eax, DWORD PTR _c_pHeightData$14[ebp]
  0009b	83 c0 24	 add	 eax, 36			; 00000024H
  0009e	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  000a1	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	89 45 e8	 mov	 DWORD PTR __My_data$16[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000a7	8b 45 e8	 mov	 eax, DWORD PTR __My_data$16[ebp]
  000aa	8b 4d e8	 mov	 ecx, DWORD PTR __My_data$16[ebp]
  000ad	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b0	2b 01		 sub	 eax, DWORD PTR [ecx]
  000b2	99		 cdq
  000b3	6a 0c		 push	 12			; 0000000cH
  000b5	59		 pop	 ecx
  000b6	f7 f9		 idiv	 ecx
  000b8	89 45 e4	 mov	 DWORD PTR _dwVertexCount$15[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000bb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000be	83 c0 4c	 add	 eax, 76			; 0000004cH
  000c1	89 45 cc	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  000c4	6b 45 f4 0c	 imul	 eax, DWORD PTR _i$18[ebp], 12
  000c8	8b 4d cc	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  000cb	03 01		 add	 eax, DWORD PTR [ecx]
  000cd	89 45 c8	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 157  : 		m_v3HeightDataVector[i].clear();

  000d0	8b 4d c8	 mov	 ecx, DWORD PTR $T9[ebp]
  000d3	e8 00 00 00 00	 call	 ?clear@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000d8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000db	83 c0 4c	 add	 eax, 76			; 0000004cH
  000de	89 45 c4	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  000e1	6b 45 f4 0c	 imul	 eax, DWORD PTR _i$18[ebp], 12
  000e5	8b 4d c4	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  000e8	03 01		 add	 eax, DWORD PTR [ecx]
  000ea	89 45 c0	 mov	 DWORD PTR $T7[ebp], eax

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  000ed	8d 45 fe	 lea	 eax, DWORD PTR $T19[ebp]
  000f0	50		 push	 eax
  000f1	ff 75 e4	 push	 DWORD PTR _dwVertexCount$15[ebp]
  000f4	8b 4d c0	 mov	 ecx, DWORD PTR $T7[ebp]
  000f7	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 159  : 		for (DWORD j = 0; j < dwVertexCount; ++j)

  000fc	83 65 f0 00	 and	 DWORD PTR _j$17[ebp], 0
  00100	eb 07		 jmp	 SHORT $LN7@RefreshObj
$LN5@RefreshObj:
  00102	8b 45 f0	 mov	 eax, DWORD PTR _j$17[ebp]
  00105	40		 inc	 eax
  00106	89 45 f0	 mov	 DWORD PTR _j$17[ebp], eax
$LN7@RefreshObj:
  00109	8b 45 f0	 mov	 eax, DWORD PTR _j$17[ebp]
  0010c	3b 45 e4	 cmp	 eax, DWORD PTR _dwVertexCount$15[ebp]
  0010f	73 56		 jae	 SHORT $LN6@RefreshObj

; 161  : 			D3DXVec3TransformCoord(&m_v3HeightDataVector[i][j], &c_pHeightData->v3VertexVector[j], &m_matGlobal);

  00111	8b 45 e0	 mov	 eax, DWORD PTR _c_pHeightData$14[ebp]
  00114	83 c0 24	 add	 eax, 36			; 00000024H
  00117	89 45 bc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  0011a	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0011d	89 45 b8	 mov	 DWORD PTR __My_data$6[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  00120	6b 45 f0 0c	 imul	 eax, DWORD PTR _j$17[ebp], 12
  00124	8b 4d b8	 mov	 ecx, DWORD PTR __My_data$6[ebp]
  00127	03 01		 add	 eax, DWORD PTR [ecx]
  00129	89 45 a8	 mov	 DWORD PTR $T2[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0012c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0012f	83 c0 4c	 add	 eax, 76			; 0000004cH
  00132	89 45 b4	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00135	6b 45 f4 0c	 imul	 eax, DWORD PTR _i$18[ebp], 12
  00139	8b 4d b4	 mov	 ecx, DWORD PTR __My_data$5[ebp]
  0013c	03 01		 add	 eax, DWORD PTR [ecx]
  0013e	89 45 b0	 mov	 DWORD PTR $T4[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00141	8b 45 b0	 mov	 eax, DWORD PTR $T4[ebp]
  00144	89 45 ac	 mov	 DWORD PTR __My_data$3[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00147	6b 45 f0 0c	 imul	 eax, DWORD PTR _j$17[ebp], 12
  0014b	8b 4d ac	 mov	 ecx, DWORD PTR __My_data$3[ebp]
  0014e	03 01		 add	 eax, DWORD PTR [ecx]
  00150	89 45 a4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 161  : 			D3DXVec3TransformCoord(&m_v3HeightDataVector[i][j], &c_pHeightData->v3VertexVector[j], &m_matGlobal);

  00153	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00156	83 c0 0c	 add	 eax, 12			; 0000000cH
  00159	50		 push	 eax
  0015a	ff 75 a8	 push	 DWORD PTR $T2[ebp]
  0015d	ff 75 a4	 push	 DWORD PTR $T1[ebp]
  00160	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 162  : 		}

  00165	eb 9b		 jmp	 SHORT $LN5@RefreshObj
$LN6@RefreshObj:

; 163  : 	}

  00167	e9 fb fe ff ff	 jmp	 $LN2@RefreshObj
$LN3@RefreshObj:

; 164  : }

  0016c	5f		 pop	 edi
  0016d	5e		 pop	 esi
  0016e	c9		 leave
  0016f	c2 04 00	 ret	 4
?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z ENDP ; CAttributeInstance::RefreshObject
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pAttributeData$ = 8					; size = 4
?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z PROC ; CAttributeInstance::SetObjectPointer, COMDAT
; _this$ = ecx

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 134  : 	Clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Clear@CAttributeInstance@@QAEXXZ ; CAttributeInstance::Clear

; 135  : 	m_roAttributeData.SetPointer(pAttributeData);

  0000f	ff 75 08	 push	 DWORD PTR _pAttributeData$[ebp]
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 58	 add	 ecx, 88			; 00000058H
  00018	e8 00 00 00 00	 call	 ?SetPointer@?$CRef@VCAttributeData@@@@QAEXPAVCReferenceObject@@@Z ; CRef<CAttributeData>::SetPointer

; 136  : }

  0001d	c9		 leave
  0001e	c2 04 00	 ret	 4
?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z ENDP ; CAttributeInstance::SetObjectPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?GetDataFileName@CAttributeInstance@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?GetDataFileName@CAttributeInstance@@QBEPBDXZ PROC	; CAttributeInstance::GetDataFileName, COMDAT
; _this$ = ecx

; 167  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 86   : 			return static_cast<T*>(m_pObject);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 58	 mov	 eax, DWORD PTR [eax+88]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00012	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00015	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00018	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001d	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 168  : 	return m_roAttributeData->GetFileName();

  00020	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 169  : }

  00023	c9		 leave
  00024	c3		 ret	 0
?GetDataFileName@CAttributeInstance@@QBEPBDXZ ENDP	; CAttributeInstance::GetDataFileName
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?IsEmpty@CAttributeInstance@@QBEHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv74 = -12						; size = 4
__My_data$1 = -8					; size = 4
$T2 = -1						; size = 1
?IsEmpty@CAttributeInstance@@QBEHXZ PROC		; CAttributeInstance::IsEmpty, COMDAT
; _this$ = ecx

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 4c	 add	 eax, 76			; 0000004cH
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$1[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$1[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$1[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0001d	75 09		 jne	 SHORT $LN6@IsEmpty
  0001f	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00026	eb 04		 jmp	 SHORT $LN7@IsEmpty
$LN6@IsEmpty:
  00028	83 65 f4 00	 and	 DWORD PTR tv74[ebp], 0
$LN7@IsEmpty:
  0002c	8a 45 f4	 mov	 al, BYTE PTR tv74[ebp]
  0002f	88 45 ff	 mov	 BYTE PTR $T2[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 193  : 	if (!m_v3HeightDataVector.empty())

  00032	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]
  00036	85 c0		 test	 eax, eax
  00038	75 04		 jne	 SHORT $LN2@IsEmpty

; 194  : 		return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 03		 jmp	 SHORT $LN1@IsEmpty
$LN2@IsEmpty:

; 195  : 
; 196  : 	return TRUE;

  0003e	33 c0		 xor	 eax, eax
  00040	40		 inc	 eax
$LN1@IsEmpty:

; 197  : }

  00041	c9		 leave
  00042	c3		 ret	 0
?IsEmpty@CAttributeInstance@@QBEHXZ ENDP		; CAttributeInstance::IsEmpty
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ?Clear@CAttributeInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pOut$ = -4						; size = 4
?Clear@CAttributeInstance@@QAEXXZ PROC			; CAttributeInstance::Clear, COMDAT
; _this$ = ecx

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 201  : 	m_fHeightRadius = 0.0f;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	0f 57 c0	 xorps	 xmm0, xmm0
  0000e	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 202  : 	m_fCollisionRadius = 0.0f;

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	0f 57 c0	 xorps	 xmm0, xmm0
  00019	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 203  : 	D3DXMatrixIdentity(&m_matGlobal);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c0 0c	 add	 eax, 12			; 0000000cH
  00024	89 45 fc	 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00027	6a 10		 push	 16			; 00000010H
  00029	58		 pop	 eax
  0002a	6b c0 03	 imul	 eax, eax, 3
  0002d	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  00030	6a 04		 push	 4
  00032	59		 pop	 ecx
  00033	d1 e1		 shl	 ecx, 1
  00035	0f 57 c0	 xorps	 xmm0, xmm0
  00038	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0003d	6a 10		 push	 16			; 00000010H
  0003f	58		 pop	 eax
  00040	6b c0 03	 imul	 eax, eax, 3
  00043	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  00046	6a 04		 push	 4
  00048	59		 pop	 ecx
  00049	c1 e1 00	 shl	 ecx, 0
  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00054	6a 10		 push	 16			; 00000010H
  00056	58		 pop	 eax
  00057	6b c0 03	 imul	 eax, eax, 3
  0005a	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  0005d	6a 04		 push	 4
  0005f	59		 pop	 ecx
  00060	6b c9 00	 imul	 ecx, ecx, 0
  00063	0f 57 c0	 xorps	 xmm0, xmm0
  00066	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0006b	6a 10		 push	 16			; 00000010H
  0006d	58		 pop	 eax
  0006e	d1 e0		 shl	 eax, 1
  00070	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  00073	6a 04		 push	 4
  00075	59		 pop	 ecx
  00076	6b c9 03	 imul	 ecx, ecx, 3
  00079	0f 57 c0	 xorps	 xmm0, xmm0
  0007c	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00081	6a 10		 push	 16			; 00000010H
  00083	58		 pop	 eax
  00084	d1 e0		 shl	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  00089	6a 04		 push	 4
  0008b	59		 pop	 ecx
  0008c	c1 e1 00	 shl	 ecx, 0
  0008f	0f 57 c0	 xorps	 xmm0, xmm0
  00092	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00097	6a 10		 push	 16			; 00000010H
  00099	58		 pop	 eax
  0009a	d1 e0		 shl	 eax, 1
  0009c	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  0009f	6a 04		 push	 4
  000a1	59		 pop	 ecx
  000a2	6b c9 00	 imul	 ecx, ecx, 0
  000a5	0f 57 c0	 xorps	 xmm0, xmm0
  000a8	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000ad	6a 10		 push	 16			; 00000010H
  000af	58		 pop	 eax
  000b0	c1 e0 00	 shl	 eax, 0
  000b3	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  000b6	6a 04		 push	 4
  000b8	59		 pop	 ecx
  000b9	6b c9 03	 imul	 ecx, ecx, 3
  000bc	0f 57 c0	 xorps	 xmm0, xmm0
  000bf	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000c4	6a 10		 push	 16			; 00000010H
  000c6	58		 pop	 eax
  000c7	c1 e0 00	 shl	 eax, 0
  000ca	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  000cd	6a 04		 push	 4
  000cf	59		 pop	 ecx
  000d0	d1 e1		 shl	 ecx, 1
  000d2	0f 57 c0	 xorps	 xmm0, xmm0
  000d5	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000da	6a 10		 push	 16			; 00000010H
  000dc	58		 pop	 eax
  000dd	c1 e0 00	 shl	 eax, 0
  000e0	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  000e3	6a 04		 push	 4
  000e5	59		 pop	 ecx
  000e6	6b c9 00	 imul	 ecx, ecx, 0
  000e9	0f 57 c0	 xorps	 xmm0, xmm0
  000ec	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000f1	6a 10		 push	 16			; 00000010H
  000f3	58		 pop	 eax
  000f4	6b c0 00	 imul	 eax, eax, 0
  000f7	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  000fa	6a 04		 push	 4
  000fc	59		 pop	 ecx
  000fd	6b c9 03	 imul	 ecx, ecx, 3
  00100	0f 57 c0	 xorps	 xmm0, xmm0
  00103	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00108	6a 10		 push	 16			; 00000010H
  0010a	58		 pop	 eax
  0010b	6b c0 00	 imul	 eax, eax, 0
  0010e	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  00111	6a 04		 push	 4
  00113	59		 pop	 ecx
  00114	d1 e1		 shl	 ecx, 1
  00116	0f 57 c0	 xorps	 xmm0, xmm0
  00119	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0011e	6a 10		 push	 16			; 00000010H
  00120	58		 pop	 eax
  00121	6b c0 00	 imul	 eax, eax, 0
  00124	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  00127	6a 04		 push	 4
  00129	59		 pop	 ecx
  0012a	c1 e1 00	 shl	 ecx, 0
  0012d	0f 57 c0	 xorps	 xmm0, xmm0
  00130	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00135	6a 10		 push	 16			; 00000010H
  00137	58		 pop	 eax
  00138	6b c0 03	 imul	 eax, eax, 3
  0013b	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  0013e	6a 04		 push	 4
  00140	59		 pop	 ecx
  00141	6b c9 03	 imul	 ecx, ecx, 3
  00144	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0014c	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00151	6a 10		 push	 16			; 00000010H
  00153	58		 pop	 eax
  00154	d1 e0		 shl	 eax, 1
  00156	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  00159	6a 04		 push	 4
  0015b	59		 pop	 ecx
  0015c	d1 e1		 shl	 ecx, 1
  0015e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00166	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0016b	6a 10		 push	 16			; 00000010H
  0016d	58		 pop	 eax
  0016e	c1 e0 00	 shl	 eax, 0
  00171	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  00174	6a 04		 push	 4
  00176	59		 pop	 ecx
  00177	c1 e1 00	 shl	 ecx, 0
  0017a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00182	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00187	6a 10		 push	 16			; 00000010H
  00189	58		 pop	 eax
  0018a	6b c0 00	 imul	 eax, eax, 0
  0018d	03 45 fc	 add	 eax, DWORD PTR _pOut$[ebp]
  00190	6a 04		 push	 4
  00192	59		 pop	 ecx
  00193	6b c9 00	 imul	 ecx, ecx, 0
  00196	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0019e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 205  : 	m_v3HeightDataVector.clear();

  001a3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a6	83 c1 4c	 add	 ecx, 76			; 0000004cH
  001a9	e8 00 00 00 00	 call	 ?clear@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@QAEXXZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::clear

; 206  : 
; 207  : 	m_roAttributeData.SetPointer(NULL);

  001ae	6a 00		 push	 0
  001b0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	83 c1 58	 add	 ecx, 88			; 00000058H
  001b6	e8 00 00 00 00	 call	 ?SetPointer@?$CRef@VCAttributeData@@@@QAEXPAVCReferenceObject@@@Z ; CRef<CAttributeData>::SetPointer

; 208  : }

  001bb	c9		 leave
  001bc	c3		 ret	 0
?Clear@CAttributeInstance@@QAEXXZ ENDP			; CAttributeInstance::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ??1CAttributeInstance@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAttributeInstance@@UAE@XZ PROC			; CAttributeInstance::~CAttributeInstance, COMDAT
; _this$ = ecx

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAttributeInstance@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CAttributeInstance@@6B@

; 215  : }

  00030	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 c0 58	 add	 eax, 88			; 00000058H
  00036	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 37   : 		{

  00039	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 53   : 			if (m_pObject)

  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 38 00	 cmp	 DWORD PTR [eax], 0
  00043	74 10		 je	 SHORT $LN3@CAttribute

; 54   : 			{
; 55   : 				m_pObject->Release();

  00045	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@CAttribute:

; 39   : 		}

  00055	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 215  : }

  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	83 c1 4c	 add	 ecx, 76			; 0000004cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0005f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 215  : }

  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	c9		 leave
  00070	c3		 ret	 0
  00071	cc		 int	 3
  00072	cc		 int	 3
  00073	cc		 int	 3
  00074	cc		 int	 3
  00075	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAttributeInstance@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAttributeInstance@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAttributeInstance@@UAE@XZ ENDP			; CAttributeInstance::~CAttributeInstance
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp
;	COMDAT ??0CAttributeInstance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
_this$1 = -8						; size = 4
_this$ = -4						; size = 4
??0CAttributeInstance@@QAE@XZ PROC			; CAttributeInstance::CAttributeInstance, COMDAT
; _this$ = ecx

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CAttributeInstance@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 4c	 add	 eax, 76			; 0000004cH
  00018	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$1[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$1[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$1[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 211  : {

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 58	 add	 eax, 88			; 00000058H
  00041	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 20   : 		CRef() : m_pObject(NULL)

  00044	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00047	83 20 00	 and	 DWORD PTR [eax], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\AttributeInstance.cpp

; 212  : }

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c9		 leave
  0004e	c3		 ret	 0
??0CAttributeInstance@@QAE@XZ ENDP			; CAttributeInstance::CAttributeInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEAAV?$allocator@UD3DXVECTOR3@@@2@XZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 0c	 imul	 eax, DWORD PTR __Newsize$[ebp], 12
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 0c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 12
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 0c		 push	 12			; 0000000cH
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 55 55
	55 15		 mov	 DWORD PTR $T7[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXPAUD3DXVECTOR3@@0@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXPAUD3DXVECTOR3@@0@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
_this$ = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__Right$ = -12						; size = 4
___formal$ = -8						; size = 1
$T4 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 581  :     vector(vector&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00015	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 581  :     vector(vector&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  0001b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 582  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 583  :         _Move_construct(_Right, true_type{});

  0003b	33 c0		 xor	 eax, eax
  0003d	88 45 ff	 mov	 BYTE PTR $T4[ebp], al
  00040	8a 45 ff	 mov	 al, BYTE PTR $T4[ebp]
  00043	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 557  :         _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00049	89 45 f4	 mov	 DWORD PTR __Right$[ebp], eax
  0004c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 386  :         _Myfirst = _Right._Myfirst;

  00052	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  00058	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0005a	89 08		 mov	 DWORD PTR [eax], ecx

; 387  :         _Mylast  = _Right._Mylast;

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  00062	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00065	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 388  :         _Myend   = _Right._Myend;

  00068	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  0006e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00071	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 389  : 
; 390  :         _Right._Myfirst = pointer();

  00074	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  00077	83 20 00	 and	 DWORD PTR [eax], 0

; 391  :         _Right._Mylast  = pointer();

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  0007d	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 392  :         _Right._Myend   = pointer();

  00081	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  00084	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 584  :     }

  00088	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	c9		 leave
  0008c	c2 04 00	 ret	 4
??0?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z PROC ; std::allocator<D3DXVECTOR3>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z ENDP ; std::allocator<D3DXVECTOR3>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
