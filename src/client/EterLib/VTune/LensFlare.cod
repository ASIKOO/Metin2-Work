; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?Draw@CFlare@@QAEXMHHHH@Z			; CFlare::Draw
PUBLIC	?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CFlare::Init
PUBLIC	??0CFlare@@QAE@XZ				; CFlare::CFlare
PUBLIC	??1CFlare@@UAE@XZ				; CFlare::~CFlare
PUBLIC	??0SFlarePiece@CFlare@@QAE@XZ			; CFlare::SFlarePiece::SFlarePiece
PUBLIC	?deallocate@?$allocator@PAUSFlarePiece@CFlare@@@std@@QAEXQAPAUSFlarePiece@CFlare@@I@Z ; std::allocator<CFlare::SFlarePiece *>::deallocate
PUBLIC	?_Destroy@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXPAPAUSFlarePiece@CFlare@@0@Z ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@ABEII@Z ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXQAPAUSFlarePiece@CFlare@@II@Z ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXXZ ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@CAXXZ ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Xlength
PUBLIC	??_GCFlare@@UAEPAXI@Z				; CFlare::`scalar deleting destructor'
PUBLIC	??0CLensFlare@@QAE@XZ				; CLensFlare::CLensFlare
PUBLIC	??1CLensFlare@@UAE@XZ				; CLensFlare::~CLensFlare
PUBLIC	?Compute@CLensFlare@@QAEXABUD3DXVECTOR3@@@Z	; CLensFlare::Compute
PUBLIC	?DrawBeforeFlare@CLensFlare@@QAEXXZ		; CLensFlare::DrawBeforeFlare
PUBLIC	?DrawAfterFlare@CLensFlare@@QAEXXZ		; CLensFlare::DrawAfterFlare
PUBLIC	?DrawFlare@CLensFlare@@QAEXXZ			; CLensFlare::DrawFlare
PUBLIC	?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; CLensFlare::SetMainFlare
PUBLIC	?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CLensFlare::Initialize
PUBLIC	?SetFlareLocation@CLensFlare@@QAEXNN@Z		; CLensFlare::SetFlareLocation
PUBLIC	?SetBrightnesses@CLensFlare@@QAEXMM@Z		; CLensFlare::SetBrightnesses
PUBLIC	?ReadControlPixels@CLensFlare@@QAEXXZ		; CLensFlare::ReadControlPixels
PUBLIC	?AdjustBrightness@CLensFlare@@QAEXXZ		; CLensFlare::AdjustBrightness
PUBLIC	?CharacterizeFlare@CLensFlare@@QAEX_N0MABUD3DXCOLOR@@@Z ; CLensFlare::CharacterizeFlare
PUBLIC	?Interpolate@CLensFlare@@IAEMMMM@Z		; CLensFlare::Interpolate
PUBLIC	?ReadDepthPixels@CLensFlare@@AAEXPAM@Z		; CLensFlare::ReadDepthPixels
PUBLIC	?ClampBrightness@CLensFlare@@AAEXXZ		; CLensFlare::ClampBrightness
PUBLIC	??_GCLensFlare@@UAEPAXI@Z			; CLensFlare::`scalar deleting destructor'
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$emplace_back@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEXABQAUSFlarePiece@CFlare@@@Z ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::emplace_back<CFlare::SFlarePiece * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXABQAUSFlarePiece@CFlare@@@Z ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Emplace_back_with_unused_capacity<CFlare::SFlarePiece * const &>
PUBLIC	??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Emplace_reallocate<CFlare::SFlarePiece * const &>
PUBLIC	??$_Destroy_range@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAXPAPAUSFlarePiece@CFlare@@QAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z ; std::_Destroy_range<std::allocator<CFlare::SFlarePiece *> >
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Uninitialized_move@PAPAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAPAPAUSFlarePiece@CFlare@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z ; std::_Uninitialized_move<CFlare::SFlarePiece * *,std::allocator<CFlare::SFlarePiece *> >
PUBLIC	??$_Copy_memmove@PAPAUSFlarePiece@CFlare@@PAPAU12@@std@@YAPAPAUSFlarePiece@CFlare@@PAPAU12@00@Z ; std::_Copy_memmove<CFlare::SFlarePiece * *,CFlare::SFlarePiece * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7CFlare@@6B@					; CFlare::`vftable'
PUBLIC	??_7CLensFlare@@6B@				; CLensFlare::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	??_C@_0L@FDOKIIIA@flare2?4dds@			; `string'
PUBLIC	??_C@_0L@NFHOPKCO@flare1?4dds@			; `string'
PUBLIC	??_C@_0L@MIHLMKJG@flare6?4dds@			; `string'
PUBLIC	??_C@_0L@IFLDGLJN@flare4?4dds@			; `string'
PUBLIC	??_C@_0L@JILGFLCF@flare3?4dds@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CFlare@@6B@				; CFlare::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCFlare@@@8				; CFlare `RTTI Type Descriptor'
PUBLIC	??_R3CFlare@@8					; CFlare::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CFlare@@8					; CFlare::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CFlare@@8				; CFlare::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CLensFlare@@6B@				; CLensFlare::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCLensFlare@@@8				; CLensFlare `RTTI Type Descriptor'
PUBLIC	??_R3CLensFlare@@8				; CLensFlare::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CLensFlare@@8				; CLensFlare::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CLensFlare@@8			; CLensFlare::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CScreen@@8			; CScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCScreen@@@8				; CScreen `RTTI Type Descriptor'
PUBLIC	??_R3CScreen@@8					; CScreen::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CScreen@@8					; CScreen::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicCollisionObject@@8	; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicCollisionObject@@@8		; CGraphicCollisionObject `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicBase@@8			; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicBase@@@8			; CGraphicBase `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicBase@@8				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicBase@@8				; CGraphicBase::`RTTI Base Class Array'
PUBLIC	__real@00000000
PUBLIC	__real@3ee66666
PUBLIC	__real@3f000000
PUBLIC	__real@3f59999a
PUBLIC	__real@3f800000
PUBLIC	__real@3fc90fdb
PUBLIC	__real@40000000
PUBLIC	__real@43610000
PUBLIC	__real@437f0000
PUBLIC	__real@44800000
PUBLIC	__real@4cbebc20
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_strlen:PROC
EXTRN	_acos:PROC
EXTRN	_sqrt:PROC
EXTRN	_D3DXMatrixTranslation@16:PROC
EXTRN	_D3DXMatrixOrthoOffCenterRH@28:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?IsType@CResource@@QAE_NK@Z:PROC		; CResource::IsType
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	?Type@CGraphicImage@@SAKXZ:PROC			; CGraphicImage::Type
EXTRN	??0CGraphicImageInstance@@QAE@XZ:PROC		; CGraphicImageInstance::CGraphicImageInstance
EXTRN	??1CGraphicImageInstance@@UAE@XZ:PROC		; CGraphicImageInstance::~CGraphicImageInstance
EXTRN	?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::SetImagePointer
EXTRN	?IsEmpty@CGraphicImageInstance@@QBE_NXZ:PROC	; CGraphicImageInstance::IsEmpty
EXTRN	?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ:PROC ; CGraphicImageInstance::GetTexturePointer
EXTRN	??0CScreen@@QAE@XZ:PROC				; CScreen::CScreen
EXTRN	??1CScreen@@UAE@XZ:PROC				; CScreen::~CScreen
EXTRN	?RenderBar2d@CScreen@@QAEXMMMMM@Z:PROC		; CScreen::RenderBar2d
EXTRN	?SetDiffuseColor@CScreen@@QAEXMMMM@Z:PROC	; CScreen::SetDiffuseColor
EXTRN	?ProjectPosition@CScreen@@QAEXMMMPAM0@Z:PROC	; CScreen::ProjectPosition
EXTRN	??_ECFlare@@UAEPAXI@Z:PROC			; CFlare::`vector deleting destructor'
EXTRN	??_ECLensFlare@@UAEPAXI@Z:PROC			; CLensFlare::`vector deleting destructor'
EXTRN	?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ:PROC ; CCameraManager::GetCurrentCamera
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SaveTransform
EXTRN	?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z:PROC ; CStateManager::RestoreTransform
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z:PROC ; CStateManager::DrawPrimitiveUP
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A:BYTE ; CGraphicBase::ms_matIdentity
EXTRN	?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A:BYTE	; CGraphicBase::ms_matView
EXTRN	?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A:BYTE ; CGraphicBase::ms_Viewport
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A DD 01H DUP (?) ; CSingleton<CCameraManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 0d8H DUP (?) ; g_strFiles
_BSS	ENDS
CRT$XCU	SEGMENT
?g_strFiles$initializer$@@3P6AXXZA DD FLAT:??__Eg_strFiles@@YAXXZ ; g_strFiles$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@4cbebc20
CONST	SEGMENT
__real@4cbebc20 DD 04cbebc20r			; 1e+08
CONST	ENDS
;	COMDAT __real@44800000
CONST	SEGMENT
__real@44800000 DD 044800000r			; 1024
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43610000
CONST	SEGMENT
__real@43610000 DD 043610000r			; 225
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f59999a
CONST	SEGMENT
__real@3f59999a DD 03f59999ar			; 0.85
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ee66666
CONST	SEGMENT
__real@3ee66666 DD 03ee66666r			; 0.45
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R2CGraphicBase@@8
rdata$r	SEGMENT
??_R2CGraphicBase@@8 DD FLAT:??_R1A@?0A@EA@CGraphicBase@@8 ; CGraphicBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicBase@@8
rdata$r	SEGMENT
??_R3CGraphicBase@@8 DD 00H				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicBase@@@8
data$rs	SEGMENT
??_R0?AVCGraphicBase@@@8 DD FLAT:??_7type_info@@6B@	; CGraphicBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicBase@@8 DD FLAT:??_R0?AVCGraphicBase@@@8 ; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R2CGraphicCollisionObject@@8 DD FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8 ; CGraphicCollisionObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R3CGraphicCollisionObject@@8 DD 00H			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicCollisionObject@@@8
data$rs	SEGMENT
??_R0?AVCGraphicCollisionObject@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicCollisionObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicCollisionObject@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicCollisionObject@@8 DD FLAT:??_R0?AVCGraphicCollisionObject@@@8 ; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CScreen@@8
rdata$r	SEGMENT
??_R2CScreen@@8 DD FLAT:??_R1A@?0A@EA@CScreen@@8	; CScreen::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CScreen@@8
rdata$r	SEGMENT
??_R3CScreen@@8 DD 00H					; CScreen::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CScreen@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCScreen@@@8
data$rs	SEGMENT
??_R0?AVCScreen@@@8 DD FLAT:??_7type_info@@6B@		; CScreen `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCScreen@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CScreen@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CScreen@@8 DD FLAT:??_R0?AVCScreen@@@8	; CScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CScreen@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CLensFlare@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CLensFlare@@8 DD FLAT:??_R0?AVCLensFlare@@@8 ; CLensFlare::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CLensFlare@@8
rdata$r	ENDS
;	COMDAT ??_R2CLensFlare@@8
rdata$r	SEGMENT
??_R2CLensFlare@@8 DD FLAT:??_R1A@?0A@EA@CLensFlare@@8	; CLensFlare::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CScreen@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CLensFlare@@8
rdata$r	SEGMENT
??_R3CLensFlare@@8 DD 00H				; CLensFlare::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CLensFlare@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCLensFlare@@@8
data$rs	SEGMENT
??_R0?AVCLensFlare@@@8 DD FLAT:??_7type_info@@6B@	; CLensFlare `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCLensFlare@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CLensFlare@@6B@
rdata$r	SEGMENT
??_R4CLensFlare@@6B@ DD 00H				; CLensFlare::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCLensFlare@@@8
	DD	FLAT:??_R3CLensFlare@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CFlare@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CFlare@@8 DD FLAT:??_R0?AVCFlare@@@8	; CFlare::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CFlare@@8
rdata$r	ENDS
;	COMDAT ??_R2CFlare@@8
rdata$r	SEGMENT
??_R2CFlare@@8 DD FLAT:??_R1A@?0A@EA@CFlare@@8		; CFlare::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CFlare@@8
rdata$r	SEGMENT
??_R3CFlare@@8 DD 00H					; CFlare::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CFlare@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCFlare@@@8
data$rs	SEGMENT
??_R0?AVCFlare@@@8 DD FLAT:??_7type_info@@6B@		; CFlare `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCFlare@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CFlare@@6B@
rdata$r	SEGMENT
??_R4CFlare@@6B@ DD 00H					; CFlare::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCFlare@@@8
	DD	FLAT:??_R3CFlare@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?g_fPosition@@3PAMA DD 0bf0ccccdr		; -0.55	; g_fPosition
	DD	0bf000000r			; -0.5
	DD	0bee66666r			; -0.45
	DD	03e4ccccdr			; 0.2
	DD	03e99999ar			; 0.3
	DD	03f733333r			; 0.95
	DD	03f666666r			; 0.9
	DD	03f800000r			; 1
?g_fWidth@@3PAMA DD 041a00000r			; 20	; g_fWidth
	DD	042000000r			; 32
	DD	041a00000r			; 20
	DD	042000000r			; 32
	DD	042c80000r			; 100
	DD	042000000r			; 32
	DD	041a00000r			; 20
	DD	0437a0000r			; 250
?g_afColors@@3PAY03MA DD 03f800000r		; 1	; g_afColors
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03f4ccccdr			; 0.8
	DD	03e99999ar			; 0.3
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
	DD	03f666666r			; 0.9
	DD	03e99999ar			; 0.3
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
	DD	03f19999ar			; 0.6
	DD	03f800000r			; 1
	DD	03f19999ar			; 0.6
	DD	03f666666r			; 0.9
	DD	03ecccccdr			; 0.4
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
	DD	03f19999ar			; 0.6
	DD	03e99999ar			; 0.3
	DD	03ecccccdr			; 0.4
_DATA	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JILGFLCF@flare3?4dds@
CONST	SEGMENT
??_C@_0L@JILGFLCF@flare3?4dds@ DB 'flare3.dds', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IFLDGLJN@flare4?4dds@
CONST	SEGMENT
??_C@_0L@IFLDGLJN@flare4?4dds@ DB 'flare4.dds', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MIHLMKJG@flare6?4dds@
CONST	SEGMENT
??_C@_0L@MIHLMKJG@flare6?4dds@ DB 'flare6.dds', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NFHOPKCO@flare1?4dds@
CONST	SEGMENT
??_C@_0L@NFHOPKCO@flare1?4dds@ DB 'flare1.dds', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FDOKIIIA@flare2?4dds@
CONST	SEGMENT
??_C@_0L@FDOKIIIA@flare2?4dds@ DB 'flare2.dds', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7CLensFlare@@6B@
CONST	SEGMENT
??_7CLensFlare@@6B@ DD FLAT:??_R4CLensFlare@@6B@	; CLensFlare::`vftable'
	DD	FLAT:??_ECLensFlare@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CFlare@@6B@
CONST	SEGMENT
??_7CFlare@@6B@ DD FLAT:??_R4CFlare@@6B@		; CFlare::`vftable'
	DD	FLAT:??_ECFlare@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??__Eg_strFiles@@YAXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??__Eg_strFiles@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??__Eg_strFiles@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__Eg_strFiles@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??__Eg_strFiles@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??__Eg_strFiles@@YAXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??__Eg_strFiles@@YAXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??__Eg_strFiles@@YAXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??__Eg_strFiles@@YAXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??__Eg_strFiles@@YAXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??__Eg_strFiles@@YAXXZ$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z$0
__ehfuncinfo$?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CLensFlare@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CLensFlare@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CLensFlare@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CLensFlare@@QAE@XZ$2
__ehfuncinfo$??0CLensFlare@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CLensFlare@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAUSFlarePiece@CFlare@@PAPAU12@@std@@YAPAPAUSFlarePiece@CFlare@@PAPAU12@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAUSFlarePiece@CFlare@@PAPAU12@@std@@YAPAPAUSFlarePiece@CFlare@@PAPAU12@00@Z PROC ; std::_Copy_memmove<CFlare::SFlarePiece * *,CFlare::SFlarePiece * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAUSFlarePiece@CFlare@@PAPAU12@@std@@YAPAPAUSFlarePiece@CFlare@@PAPAU12@00@Z ENDP ; std::_Copy_memmove<CFlare::SFlarePiece * *,CFlare::SFlarePiece * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAPAPAUSFlarePiece@CFlare@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAPAPAUSFlarePiece@CFlare@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z PROC ; std::_Uninitialized_move<CFlare::SFlarePiece * *,std::allocator<CFlare::SFlarePiece *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSFlarePiece@CFlare@@PAPAU12@@std@@YAPAPAUSFlarePiece@CFlare@@PAPAU12@00@Z ; std::_Copy_memmove<CFlare::SFlarePiece * *,CFlare::SFlarePiece * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAPAPAUSFlarePiece@CFlare@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z ENDP ; std::_Uninitialized_move<CFlare::SFlarePiece * *,std::allocator<CFlare::SFlarePiece *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4564 : _NODISCARD bool operator==(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4565 :     return _Left._Equal(_Right);

  00003	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00009	e8 00 00 00 00	 call	 ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal

; 4566 : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAXPAPAUSFlarePiece@CFlare@@QAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAXPAPAUSFlarePiece@CFlare@@QAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CFlare::SFlarePiece *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAXPAPAUSFlarePiece@CFlare@@QAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CFlare::SFlarePiece *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z PROC ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Emplace_reallocate<CFlare::SFlarePiece * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@CAXXZ ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@ABEII@Z ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAPAPAUSFlarePiece@CFlare@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z ; std::_Uninitialized_move<CFlare::SFlarePiece * *,std::allocator<CFlare::SFlarePiece *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAPAPAUSFlarePiece@CFlare@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z ; std::_Uninitialized_move<CFlare::SFlarePiece * *,std::allocator<CFlare::SFlarePiece *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAPAPAUSFlarePiece@CFlare@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z ; std::_Uninitialized_move<CFlare::SFlarePiece * *,std::allocator<CFlare::SFlarePiece *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXPAPAUSFlarePiece@CFlare@@0@Z ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAUSFlarePiece@CFlare@@@std@@QAEXQAPAUSFlarePiece@CFlare@@I@Z ; std::allocator<CFlare::SFlarePiece *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXQAPAUSFlarePiece@CFlare@@II@Z ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z ENDP ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Emplace_reallocate<CFlare::SFlarePiece * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXABQAUSFlarePiece@CFlare@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXABQAUSFlarePiece@CFlare@@@Z PROC ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Emplace_back_with_unused_capacity<CFlare::SFlarePiece * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXABQAUSFlarePiece@CFlare@@@Z ENDP ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Emplace_back_with_unused_capacity<CFlare::SFlarePiece * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEXABQAUSFlarePiece@CFlare@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEXABQAUSFlarePiece@CFlare@@@Z PROC ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::emplace_back<CFlare::SFlarePiece * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXABQAUSFlarePiece@CFlare@@@Z ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Emplace_back_with_unused_capacity<CFlare::SFlarePiece * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEPAPAUSFlarePiece@CFlare@@QAPAU23@ABQAU23@@Z ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Emplace_reallocate<CFlare::SFlarePiece * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEXABQAUSFlarePiece@CFlare@@@Z ENDP ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::emplace_back<CFlare::SFlarePiece * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
$T2 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4516 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	83 65 fc 00	 and	 DWORD PTR $T2[ebp], 0

; 4517 : #if _ITERATOR_DEBUG_LEVEL == 2
; 4518 :     _STL_VERIFY(_STD addressof(_Left) != _STD addressof(_Right),
; 4519 :         "You cannot concatenate the same moved string to itself. See "
; 4520 :         "N4849 [res.on.arguments]/1.3: If a function argument binds to an rvalue reference "
; 4521 :         "parameter, the implementation may assume that this parameter is a unique reference "
; 4522 :         "to this argument");
; 4523 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 4524 :     return {_String_constructor_concat_tag{}, _Left, _Right};

  00009	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  0000f	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001a	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  0001d	83 c8 01	 or	 eax, 1
  00020	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4525 : }

  00026	c9		 leave
  00027	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
_TEXT	SEGMENT
$T1 = -28						; size = 1
tv86 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__Left_size$ = -12					; size = 4
__Right_size$ = -8					; size = 4
$T4 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4480 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	83 65 f0 00	 and	 DWORD PTR $T3[ebp], 0

; 3770 :         return _Mypair._Myval2._Mysize;

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  0000d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00010	89 45 f4	 mov	 DWORD PTR __Left_size$[ebp], eax

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00013	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00016	e8 00 00 00 00	 call	 _strlen
  0001b	59		 pop	 ecx
  0001c	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0001f	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00022	89 45 f8	 mov	 DWORD PTR __Right_size$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4484 :     if (_Left.max_size() - _Left_size < _Right_size) {

  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00028	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0002d	2b 45 f4	 sub	 eax, DWORD PTR __Left_size$[ebp]
  00030	3b 45 f8	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  00033	73 05		 jae	 SHORT $LN2@operator

; 4485 :         _Xlen_string();

  00035	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@operator:

; 4486 :     }
; 4487 : 
; 4488 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

  0003a	8a 45 ff	 mov	 al, BYTE PTR $T4[ebp]
  0003d	88 45 e4	 mov	 BYTE PTR $T1[ebp], al
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00043	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00048	89 45 e8	 mov	 DWORD PTR tv86[ebp], eax
  0004b	ff 75 f8	 push	 DWORD PTR __Right_size$[ebp]
  0004e	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00051	ff 75 f4	 push	 DWORD PTR __Left_size$[ebp]
  00054	ff 75 e8	 push	 DWORD PTR tv86[ebp]
  00057	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  0005a	ff 75 e4	 push	 DWORD PTR $T1[ebp]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00060	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00065	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00068	83 c8 01	 or	 eax, 1
  0006b	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@operator:

; 4489 : }

  00071	c9		 leave
  00072	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z PROC ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4580 : _NODISCARD bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4581 :     return !(_Left == _Right);

  00004	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  00007	ff 75 08	 push	 DWORD PTR __Left$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0000f	59		 pop	 ecx
  00010	59		 pop	 ecx
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	75 09		 jne	 SHORT $LN3@operator
  00018	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00021	83 65 fc 00	 and	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00025	8a 45 fc	 mov	 al, BYTE PTR tv69[ebp]

; 4582 : }

  00028	c9		 leave
  00029	c3		 ret	 0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fg_strFiles@@YAXXZ
text$yd	SEGMENT
??__Fg_strFiles@@YAXXZ PROC				; `dynamic atexit destructor for 'g_strFiles'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	6a 09		 push	 9
  0000a	6a 18		 push	 24			; 00000018H
  0000c	68 00 00 00 00	 push	 OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00011	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??__Fg_strFiles@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_strFiles''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ??__Eg_strFiles@@YAXXZ
text$di	SEGMENT
__$EHRec$ = -12						; size = 12
??__Eg_strFiles@@YAXXZ PROC				; `dynamic initializer for 'g_strFiles'', COMDAT

; 50   : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??__Eg_strFiles@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 40   : {
; 41   : 	"flare2.dds",

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FDOKIIIA@flare2?4dds@
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  0002c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00031	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 42   : 	"flare1.dds",

  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NFHOPKCO@flare1?4dds@
  0003a	b9 18 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24
  0003f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00044	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 43   : 	"flare2.dds",

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FDOKIIIA@flare2?4dds@
  0004d	b9 30 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+48
  00052	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00057	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 44   : 	"flare1.dds",

  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NFHOPKCO@flare1?4dds@
  00060	b9 48 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+72
  00065	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0006a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 45   : 	"flare6.dds",

  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MIHLMKJG@flare6?4dds@
  00073	b9 60 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+96
  00078	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0007d	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 46   : 	"flare4.dds",

  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IFLDGLJN@flare4?4dds@
  00086	b9 78 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+120
  0008b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00090	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 47   : 	"flare2.dds",

  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FDOKIIIA@flare2?4dds@
  00099	b9 90 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+144
  0009e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000a3	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 48   : 	"flare3.dds",

  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JILGFLCF@flare3?4dds@
  000ac	b9 a8 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+168
  000b1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000b6	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7

; 49   : 	""

  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  000bf	b9 c0 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+192
  000c4	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 39   : static string g_strFiles[] = 

  000c9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000cd	68 00 00 00 00	 push	 OFFSET ??__Fg_strFiles@@YAXXZ ; `dynamic atexit destructor for 'g_strFiles''
  000d2	e8 00 00 00 00	 call	 _atexit
  000d7	59		 pop	 ecx
  000d8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000db	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e2	59		 pop	 ecx
  000e3	c9		 leave
  000e4	c3		 ret	 0
text$di	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__Eg_strFiles@@YAXXZ$0:
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00005	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??__Eg_strFiles@@YAXXZ$1:
  0000a	b9 18 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24
  0000f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??__Eg_strFiles@@YAXXZ$2:
  00014	b9 30 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+48
  00019	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??__Eg_strFiles@@YAXXZ$3:
  0001e	b9 48 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+72
  00023	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??__Eg_strFiles@@YAXXZ$4:
  00028	b9 60 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+96
  0002d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??__Eg_strFiles@@YAXXZ$5:
  00032	b9 78 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+120
  00037	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??__Eg_strFiles@@YAXXZ$6:
  0003c	b9 90 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+144
  00041	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??__Eg_strFiles@@YAXXZ$7:
  00046	b9 a8 00 00 00	 mov	 ecx, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+168
  0004b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00050	cc		 int	 3
  00051	cc		 int	 3
  00052	cc		 int	 3
  00053	cc		 int	 3
  00054	cc		 int	 3
__ehhandler$??__Eg_strFiles@@YAXXZ:
  00055	90		 npad	 1
  00056	90		 npad	 1
  00057	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0005e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00061	33 c8		 xor	 ecx, eax
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__Eg_strFiles@@YAXXZ
  0006d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__Eg_strFiles@@YAXXZ ENDP				; `dynamic initializer for 'g_strFiles''
; Function compile flags: /Odspy
;	COMDAT ??_GCLensFlare@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCLensFlare@@UAEPAXI@Z PROC				; CLensFlare::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CLensFlare@@UAE@XZ	; CLensFlare::~CLensFlare
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 74		 push	 116			; 00000074H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GCLensFlare@@UAEPAXI@Z ENDP				; CLensFlare::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?ClampBrightness@CLensFlare@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClampBrightness@CLensFlare@@AAEXXZ PROC		; CLensFlare::ClampBrightness, COMDAT
; _this$ = ecx

; 469  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 470  : 	// before
; 471  :     if (m_fBeforeBright < 0.0f)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  00011	76 0d		 jbe	 SHORT $LN2@ClampBrigh

; 472  :         m_fBeforeBright = 0.0f;

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	0f 57 c0	 xorps	 xmm0, xmm0
  00019	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0
  0001e	eb 21		 jmp	 SHORT $LN4@ClampBrigh
$LN2@ClampBrigh:

; 473  :     else if (m_fBeforeBright > 1.0f)

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00028	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0002f	76 10		 jbe	 SHORT $LN4@ClampBrigh

; 474  :         m_fBeforeBright = 1.0f;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0003c	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0
$LN4@ClampBrigh:

; 475  : 
; 476  : 	m_fBeforeBright *= m_fMaxBrightness;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0004c	f3 0f 59 41 40	 mulss	 xmm0, DWORD PTR [ecx+64]
  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 477  : 
; 478  :     if (m_fAfterBright < 0.0f)

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	0f 57 c0	 xorps	 xmm0, xmm0
  0005f	0f 2f 40 18	 comiss	 xmm0, DWORD PTR [eax+24]
  00063	76 0d		 jbe	 SHORT $LN5@ClampBrigh

; 479  :         m_fAfterBright = 0.0f;

  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	0f 57 c0	 xorps	 xmm0, xmm0
  0006b	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
  00070	eb 21		 jmp	 SHORT $LN7@ClampBrigh
$LN5@ClampBrigh:

; 480  :     else if (m_fAfterBright > 1.0f)

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0007a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00081	76 10		 jbe	 SHORT $LN7@ClampBrigh

; 481  :         m_fAfterBright = 1.0f;

  00083	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00086	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0008e	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
$LN7@ClampBrigh:

; 482  : 	
; 483  : 	m_fAfterBright *= m_fMaxBrightness;

  00093	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00096	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0009e	f3 0f 59 41 40	 mulss	 xmm0, DWORD PTR [ecx+64]
  000a3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 484  : }

  000ab	c9		 leave
  000ac	c3		 ret	 0
?ClampBrightness@CLensFlare@@AAEXXZ ENDP		; CLensFlare::ClampBrightness
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?ReadDepthPixels@CLensFlare@@AAEXPAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?ReadDepthPixels@CLensFlare@@AAEXPAM@Z PROC		; CLensFlare::ReadDepthPixels, COMDAT
; _this$ = ecx

; 446  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 447  : 	/*
; 448  : 	LPDIRECT3DSURFACE8 lpSurface;
; 449  : 	if (FAILED(ms_lpd3dDevice->GetDepthStencilSurface(&lpSurface)))
; 450  : 		assert(false);
; 451  : 
; 452  : 	D3DLOCKED_RECT rect;
; 453  : 	lpSurface->LockRect(&rect, NULL, D3DLOCK_READONLY | D3DLOCK_NO_DIRTY_UPDATE);
; 454  : 
; 455  : 	lpSurface->UnlockRect();
; 456  : 	*/
; 457  : 	/*
; 458  : 	glReadPixels(GLint(m_afFlareWinPos[0] - c_nDepthTestDimension / 2),
; 459  : 				 GLint(m_afFlareWinPos[1] - c_nDepthTestDimension / 2),
; 460  : 				 c_nDepthTestDimension, c_nDepthTestDimension,
; 461  : 				 GL_DEPTH_COMPONENT, GL_FLOAT, pPixels);
; 462  : 	*/
; 463  : }

  00007	c9		 leave
  00008	c2 04 00	 ret	 4
?ReadDepthPixels@CLensFlare@@AAEXPAM@Z ENDP		; CLensFlare::ReadDepthPixels
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?Interpolate@CLensFlare@@IAEMMMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv70 = -4						; size = 4
_fStart$ = 8						; size = 4
_fEnd$ = 12						; size = 4
_fPercent$ = 16						; size = 4
?Interpolate@CLensFlare@@IAEMMMM@Z PROC			; CLensFlare::Interpolate, COMDAT
; _this$ = ecx

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 	return fStart + (fEnd - fStart) * fPercent;

  00008	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fEnd$[ebp]
  0000d	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _fStart$[ebp]
  00012	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _fPercent$[ebp]
  00017	f3 0f 58 45 08	 addss	 xmm0, DWORD PTR _fStart$[ebp]
  0001c	f3 0f 11 45 fc	 movss	 DWORD PTR tv70[ebp], xmm0
  00021	d9 45 fc	 fld	 DWORD PTR tv70[ebp]

; 122  : }

  00024	c9		 leave
  00025	c2 0c 00	 ret	 12			; 0000000cH
?Interpolate@CLensFlare@@IAEMMMM@Z ENDP			; CLensFlare::Interpolate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?CharacterizeFlare@CLensFlare@@QAEX_N0MABUD3DXCOLOR@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bEnabled$ = 8						; size = 1
_bShowMainFlare$ = 12					; size = 1
_fMaxBrightness$ = 16					; size = 4
_c_rColor$ = 20						; size = 4
?CharacterizeFlare@CLensFlare@@QAEX_N0MABUD3DXCOLOR@@@Z PROC ; CLensFlare::CharacterizeFlare, COMDAT
; _this$ = ecx

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 361  : 	m_bEnabled = bEnabled;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 4d 08	 mov	 cl, BYTE PTR _bEnabled$[ebp]
  0000d	88 48 3c	 mov	 BYTE PTR [eax+60], cl

; 362  : 	m_bShowMainFlare = bShowMainFlare;

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8a 4d 0c	 mov	 cl, BYTE PTR _bShowMainFlare$[ebp]
  00016	88 48 3d	 mov	 BYTE PTR [eax+61], cl

; 363  : 	m_fMaxBrightness = fMaxBrightness;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fMaxBrightness$[ebp]
  00021	f3 0f 11 40 40	 movss	 DWORD PTR [eax+64], xmm0

; 364  : 
; 365  : 	m_afColor[0] = c_rColor.r;

  00026	6a 04		 push	 4
  00028	58		 pop	 eax
  00029	6b c0 00	 imul	 eax, eax, 0
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 55 14	 mov	 edx, DWORD PTR _c_rColor$[ebp]
  00032	8b 12		 mov	 edx, DWORD PTR [edx]
  00034	89 54 01 44	 mov	 DWORD PTR [ecx+eax+68], edx

; 366  : 	m_afColor[1] = c_rColor.g;

  00038	6a 04		 push	 4
  0003a	58		 pop	 eax
  0003b	c1 e0 00	 shl	 eax, 0
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	8b 55 14	 mov	 edx, DWORD PTR _c_rColor$[ebp]
  00044	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00047	89 54 01 44	 mov	 DWORD PTR [ecx+eax+68], edx

; 367  : 	m_afColor[2] = c_rColor.b;

  0004b	6a 04		 push	 4
  0004d	58		 pop	 eax
  0004e	d1 e0		 shl	 eax, 1
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 55 14	 mov	 edx, DWORD PTR _c_rColor$[ebp]
  00056	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00059	89 54 01 44	 mov	 DWORD PTR [ecx+eax+68], edx

; 368  : }

  0005d	c9		 leave
  0005e	c2 10 00	 ret	 16			; 00000010H
?CharacterizeFlare@CLensFlare@@QAEX_N0MABUD3DXCOLOR@@@Z ENDP ; CLensFlare::CharacterizeFlare
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?AdjustBrightness@CLensFlare@@QAEXXZ
_TEXT	SEGMENT
tv142 = -24						; size = 4
tv141 = -20						; size = 4
_fAdjust$1 = -16					; size = 4
_nDifferent$2 = -12					; size = 4
_i$3 = -8						; size = 4
_this$ = -4						; size = 4
?AdjustBrightness@CLensFlare@@QAEXXZ PROC		; CLensFlare::AdjustBrightness, COMDAT
; _this$ = ecx

; 424  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 425  : 	if (m_bEnabled)

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	0f b6 40 3c	 movzx	 eax, BYTE PTR [eax+60]
  00011	85 c0		 test	 eax, eax
  00013	0f 84 af 00 00
	00		 je	 $LN5@AdjustBrig

; 426  : 	{
; 427  : 		ReadDepthPixels(m_pTestPixels);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	ff 70 38	 push	 DWORD PTR [eax+56]
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?ReadDepthPixels@CLensFlare@@AAEXPAM@Z ; CLensFlare::ReadDepthPixels

; 428  : 
; 429  : 		int nDifferent = 0;

  00027	83 65 f4 00	 and	 DWORD PTR _nDifferent$2[ebp], 0

; 430  : 
; 431  : 		for (int i = 0; i < c_nDepthTestDimension * c_nDepthTestDimension; ++i)

  0002b	83 65 f8 00	 and	 DWORD PTR _i$3[ebp], 0
  0002f	eb 07		 jmp	 SHORT $LN4@AdjustBrig
$LN2@AdjustBrig:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _i$3[ebp]
  00034	40		 inc	 eax
  00035	89 45 f8	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@AdjustBrig:
  00038	81 7d f8 e1 00
	00 00		 cmp	 DWORD PTR _i$3[ebp], 225 ; 000000e1H
  0003f	7d 2a		 jge	 SHORT $LN3@AdjustBrig

; 432  : 			if (m_pTestPixels[i] != m_pControlPixels[i])

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  0004d	8b 55 f8	 mov	 edx, DWORD PTR _i$3[ebp]
  00050	8b 75 f8	 mov	 esi, DWORD PTR _i$3[ebp]
  00053	f3 0f 10 04 90	 movss	 xmm0, DWORD PTR [eax+edx*4]
  00058	0f 2e 04 b1	 ucomiss xmm0, DWORD PTR [ecx+esi*4]
  0005c	9f		 lahf
  0005d	f6 c4 44	 test	 ah, 68			; 00000044H
  00060	7b 07		 jnp	 SHORT $LN6@AdjustBrig

; 433  : 				++nDifferent;

  00062	8b 45 f4	 mov	 eax, DWORD PTR _nDifferent$2[ebp]
  00065	40		 inc	 eax
  00066	89 45 f4	 mov	 DWORD PTR _nDifferent$2[ebp], eax
$LN6@AdjustBrig:
  00069	eb c6		 jmp	 SHORT $LN2@AdjustBrig
$LN3@AdjustBrig:

; 434  : 
; 435  : 		float fAdjust = (static_cast<float>(nDifferent) / (c_nDepthTestDimension * c_nDepthTestDimension));

  0006b	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _nDifferent$2[ebp]
  00070	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@43610000
  00078	f3 0f 11 45 f0	 movss	 DWORD PTR _fAdjust$1[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  0007d	f3 0f 5a 45 f0	 cvtss2sd xmm0, DWORD PTR _fAdjust$1[ebp]
  00082	51		 push	 ecx
  00083	51		 push	 ecx
  00084	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00089	e8 00 00 00 00	 call	 _sqrt
  0008e	59		 pop	 ecx
  0008f	59		 pop	 ecx
  00090	d9 5d ec	 fstp	 DWORD PTR tv141[ebp]
  00093	d9 45 ec	 fld	 DWORD PTR tv141[ebp]
  00096	d9 5d e8	 fstp	 DWORD PTR tv142[ebp]
  00099	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR tv142[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 436  : 		fAdjust = sqrtf(fAdjust) * 0.85f;

  0009e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f59999a
  000a6	f3 0f 11 45 f0	 movss	 DWORD PTR _fAdjust$1[ebp], xmm0

; 437  : 		m_fAfterBright *= 1.0f - fAdjust;

  000ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000b3	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _fAdjust$1[ebp]
  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	f3 0f 59 40 18	 mulss	 xmm0, DWORD PTR [eax+24]
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
$LN5@AdjustBrig:

; 438  : 	}
; 439  : }

  000c8	5e		 pop	 esi
  000c9	c9		 leave
  000ca	c3		 ret	 0
?AdjustBrightness@CLensFlare@@QAEXXZ ENDP		; CLensFlare::AdjustBrightness
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?ReadControlPixels@CLensFlare@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReadControlPixels@CLensFlare@@QAEXXZ PROC		; CLensFlare::ReadControlPixels, COMDAT
; _this$ = ecx

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 415  : 	if (m_bEnabled)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 40 3c	 movzx	 eax, BYTE PTR [eax+60]
  0000e	85 c0		 test	 eax, eax
  00010	74 0e		 je	 SHORT $LN1@ReadContro

; 416  : 		ReadDepthPixels(m_pControlPixels);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	ff 70 34	 push	 DWORD PTR [eax+52]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?ReadDepthPixels@CLensFlare@@AAEXPAM@Z ; CLensFlare::ReadDepthPixels
$LN1@ReadContro:

; 417  : }

  00020	c9		 leave
  00021	c3		 ret	 0
?ReadControlPixels@CLensFlare@@QAEXXZ ENDP		; CLensFlare::ReadControlPixels
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?SetBrightnesses@CLensFlare@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fBeforeBright$ = 8					; size = 4
_fAfterBright$ = 12					; size = 4
?SetBrightnesses@CLensFlare@@QAEXMM@Z PROC		; CLensFlare::SetBrightnesses, COMDAT
; _this$ = ecx

; 399  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 400  : 	if (m_bEnabled)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 40 3c	 movzx	 eax, BYTE PTR [eax+60]
  0000e	85 c0		 test	 eax, eax
  00010	74 22		 je	 SHORT $LN2@SetBrightn

; 401  : 	{
; 402  : 	    m_fBeforeBright = fBeforeBright;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fBeforeBright$[ebp]
  0001a	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 403  : 	    m_fAfterBright = fAfterBright;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fAfterBright$[ebp]
  00027	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 404  : 
; 405  : 		ClampBrightness();

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?ClampBrightness@CLensFlare@@AAEXXZ ; CLensFlare::ClampBrightness
$LN2@SetBrightn:

; 406  : 	}
; 407  : }

  00034	c9		 leave
  00035	c2 08 00	 ret	 8
?SetBrightnesses@CLensFlare@@QAEXMM@Z ENDP		; CLensFlare::SetBrightnesses
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?SetFlareLocation@CLensFlare@@QAEXNN@Z
_TEXT	SEGMENT
tv139 = -28						; size = 8
tv128 = -20						; size = 8
tv135 = -12						; size = 4
tv92 = -8						; size = 4
_this$ = -4						; size = 4
_dX$ = 8						; size = 8
_dY$ = 16						; size = 8
?SetFlareLocation@CLensFlare@@QAEXNN@Z PROC		; CLensFlare::SetFlareLocation, COMDAT
; _this$ = ecx

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 384  : 	if (m_bEnabled)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 40 3c	 movzx	 eax, BYTE PTR [eax+60]
  00010	85 c0		 test	 eax, eax
  00012	0f 84 a4 00 00
	00		 je	 $LN2@SetFlareLo

; 385  : 	{
; 386  : 		m_afFlareWinPos[0] = float(dX);

  00018	f2 0f 5a 45 08	 cvtsd2ss xmm0, QWORD PTR _dX$[ebp]
  0001d	6a 04		 push	 4
  0001f	58		 pop	 eax
  00020	6b c0 00	 imul	 eax, eax, 0
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	f3 0f 11 44 01
	0c		 movss	 DWORD PTR [ecx+eax+12], xmm0

; 387  : 		m_afFlareWinPos[1] = float(dY);

  0002c	f2 0f 5a 45 10	 cvtsd2ss xmm0, QWORD PTR _dY$[ebp]
  00031	6a 04		 push	 4
  00033	58		 pop	 eax
  00034	c1 e0 00	 shl	 eax, 0
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	f3 0f 11 44 01
	0c		 movss	 DWORD PTR [ecx+eax+12], xmm0

; 388  : 
; 389  : 		m_afFlarePos[0] = float(dX) / ms_Viewport.Width;

  00040	f2 0f 5a 45 08	 cvtsd2ss xmm0, QWORD PTR _dX$[ebp]
  00045	a1 08 00 00 00	 mov	 eax, DWORD PTR ?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A+8
  0004a	89 45 f8	 mov	 DWORD PTR tv92[ebp], eax
  0004d	f2 0f 2a 4d f8	 cvtsi2sd xmm1, DWORD PTR tv92[ebp]
  00052	8b 45 f8	 mov	 eax, DWORD PTR tv92[ebp]
  00055	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00058	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00061	f2 0f 11 4d ec	 movsd	 QWORD PTR tv128[ebp], xmm1
  00066	f2 0f 5a 4d ec	 cvtsd2ss xmm1, QWORD PTR tv128[ebp]
  0006b	f3 0f 5e c1	 divss	 xmm0, xmm1
  0006f	6a 04		 push	 4
  00071	58		 pop	 eax
  00072	6b c0 00	 imul	 eax, eax, 0
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 390  : 		m_afFlarePos[1] = float(dY) / ms_Viewport.Height;

  0007e	f2 0f 5a 45 10	 cvtsd2ss xmm0, QWORD PTR _dY$[ebp]
  00083	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A+12
  00088	89 45 f4	 mov	 DWORD PTR tv135[ebp], eax
  0008b	f2 0f 2a 4d f4	 cvtsi2sd xmm1, DWORD PTR tv135[ebp]
  00090	8b 45 f4	 mov	 eax, DWORD PTR tv135[ebp]
  00093	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00096	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0009f	f2 0f 11 4d e4	 movsd	 QWORD PTR tv139[ebp], xmm1
  000a4	f2 0f 5a 4d e4	 cvtsd2ss xmm1, QWORD PTR tv139[ebp]
  000a9	f3 0f 5e c1	 divss	 xmm0, xmm1
  000ad	6a 04		 push	 4
  000af	58		 pop	 eax
  000b0	c1 e0 00	 shl	 eax, 0
  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0
$LN2@SetFlareLo:

; 391  : 	}
; 392  : }

  000bc	c9		 leave
  000bd	c2 10 00	 ret	 16			; 00000010H
?SetFlareLocation@CLensFlare@@QAEXNN@Z ENDP		; CLensFlare::SetFlareLocation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_strPath$ = 8						; size = 24
?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CLensFlare::Initialize, COMDAT
; _this$ = ecx

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 375  : 	if (m_bEnabled)

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	0f b6 40 3c	 movzx	 eax, BYTE PTR [eax+60]
  00032	85 c0		 test	 eax, eax
  00034	74 1c		 je	 SHORT $LN2@Initialize

; 376  : 		m_cFlare.Init(strPath);

  00036	83 ec 18	 sub	 esp, 24			; 00000018H
  00039	8b cc		 mov	 ecx, esp
  0003b	89 65 ec	 mov	 DWORD PTR $T2[ebp], esp
  0003e	8d 45 08	 lea	 eax, DWORD PTR _strPath$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00047	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	83 c1 24	 add	 ecx, 36			; 00000024H
  0004d	e8 00 00 00 00	 call	 ?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CFlare::Init
$LN2@Initialize:

; 377  : }

  00052	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00056	8d 4d 08	 lea	 ecx, DWORD PTR _strPath$[ebp]
  00059	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 377  : }

  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00061	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00068	59		 pop	 ecx
  00069	c9		 leave
  0006a	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strPath$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CLensFlare::Initialize
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z
_TEXT	SEGMENT
$T2 = -24						; size = 4
_pResource$3 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_strSunFile$ = 8					; size = 24
_fSunSize$ = 32						; size = 4
?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z PROC ; CLensFlare::SetMainFlare, COMDAT
; _this$ = ecx

; 297  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 298  : 	if (m_bEnabled && m_bShowMainFlare)

  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	0f b6 40 3c	 movzx	 eax, BYTE PTR [eax+60]
  00033	85 c0		 test	 eax, eax
  00035	74 50		 je	 SHORT $LN2@SetMainFla
  00037	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	0f b6 40 3d	 movzx	 eax, BYTE PTR [eax+61]
  0003e	85 c0		 test	 eax, eax
  00040	74 45		 je	 SHORT $LN2@SetMainFla

; 299  : 	{
; 300  : 		m_fSunSize = fSunSize;

  00042	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00045	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _fSunSize$[ebp]
  0004a	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00054	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 301  : 		CResource * pResource = CResourceManager::Instance().GetResourcePointer(strSunFile.c_str()); 

  00057	8d 4d 08	 lea	 ecx, DWORD PTR _strSunFile$[ebp]
  0005a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0005f	50		 push	 eax
  00060	8b 4d e8	 mov	 ecx, DWORD PTR $T2[ebp]
  00063	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00068	89 45 ec	 mov	 DWORD PTR _pResource$3[ebp], eax

; 302  : 
; 303  : 		if (!pResource->IsType(CGraphicImage::Type()))

  0006b	e8 00 00 00 00	 call	 ?Type@CGraphicImage@@SAKXZ ; CGraphicImage::Type
  00070	50		 push	 eax
  00071	8b 4d ec	 mov	 ecx, DWORD PTR _pResource$3[ebp]
  00074	e8 00 00 00 00	 call	 ?IsType@CResource@@QAE_NK@Z ; CResource::IsType

; 304  : 			assert(false);
; 305  : 		
; 306  : 		m_SunFlareImageInstance.SetImagePointer(static_cast<CGraphicImage *> (pResource));

  00079	ff 75 ec	 push	 DWORD PTR _pResource$3[ebp]
  0007c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	83 c1 54	 add	 ecx, 84			; 00000054H
  00082	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer
$LN2@SetMainFla:

; 308  : }

  00087	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0008b	8d 4d 08	 lea	 ecx, DWORD PTR _strSunFile$[ebp]
  0008e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 308  : }

  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009d	59		 pop	 ecx
  0009e	c9		 leave
  0009f	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strSunFile$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ENDP ; CLensFlare::SetMainFlare
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?DrawFlare@CLensFlare@@QAEXXZ
_TEXT	SEGMENT
tv222 = -96						; size = 8
tv213 = -88						; size = 8
tv218 = -80						; size = 4
tv209 = -76						; size = 4
_this$ = -72						; size = 4
_matProj$1 = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
?DrawFlare@CLensFlare@@QAEXXZ PROC			; CLensFlare::DrawFlare, COMDAT
; _this$ = ecx

; 315  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx

; 316  : 	if (m_bEnabled && m_bFlareVisible && m_bDrawFlare && m_fAfterBright != 0.0f)

  00013	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	0f b6 40 3c	 movzx	 eax, BYTE PTR [eax+60]
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 f7 01 00
	00		 je	 $LN2@DrawFlare
  00022	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00025	0f b6 40 1c	 movzx	 eax, BYTE PTR [eax+28]
  00029	85 c0		 test	 eax, eax
  0002b	0f 84 e8 01 00
	00		 je	 $LN2@DrawFlare
  00031	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	0f b6 40 1d	 movzx	 eax, BYTE PTR [eax+29]
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 d9 01 00
	00		 je	 $LN2@DrawFlare
  00040	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00048	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0004f	9f		 lahf
  00050	f6 c4 44	 test	 ah, 68			; 00000044H
  00053	0f 8b c0 01 00
	00		 jnp	 $LN2@DrawFlare

; 317  : 	{
; 318  :         //glPushAttrib(GL_ENABLE_BIT);
; 319  : 		STATEMANAGER.SaveRenderState(D3DRS_LIGHTING, FALSE); // glDisable(GL_LIGHTING);

  00059	6a 00		 push	 0
  0005b	68 89 00 00 00	 push	 137			; 00000089H
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00066	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 320  : 		STATEMANAGER.SaveRenderState(D3DRS_ZENABLE, FALSE); // glDisable(GL_DEPTH_TEST);

  0006b	6a 00		 push	 0
  0006d	6a 07		 push	 7
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00075	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 321  : 		STATEMANAGER.SaveRenderState(D3DRS_CULLMODE, D3DCULL_NONE); // glDisable(GL_CULL_FACE);

  0007a	6a 01		 push	 1
  0007c	6a 16		 push	 22			; 00000016H
  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00084	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 322  : 		STATEMANAGER.SaveRenderState(D3DRS_ALPHATESTENABLE, FALSE); // glDisable(GL_ALPHA_TEST);

  00089	6a 00		 push	 0
  0008b	6a 0f		 push	 15			; 0000000fH
  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00093	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 323  : 		STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE); // glEnable(GL_BLEND);

  00098	6a 01		 push	 1
  0009a	6a 1b		 push	 27			; 0000001bH
  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000a2	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 324  : 
; 325  : 		D3DXMATRIX matProj;
; 326  : 		D3DXMatrixOrthoOffCenterRH(&matProj, 0.0f, ms_Viewport.Width, ms_Viewport.Height, 0.0f, -1.0f, 1.0f);

  000a7	51		 push	 ecx
  000a8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000b0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b5	51		 push	 ecx
  000b6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c3	51		 push	 ecx
  000c4	0f 57 c0	 xorps	 xmm0, xmm0
  000c7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cc	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A+12
  000d1	89 45 b4	 mov	 DWORD PTR tv209[ebp], eax
  000d4	f2 0f 2a 45 b4	 cvtsi2sd xmm0, DWORD PTR tv209[ebp]
  000d9	8b 45 b4	 mov	 eax, DWORD PTR tv209[ebp]
  000dc	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000df	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  000e8	f2 0f 11 45 a8	 movsd	 QWORD PTR tv213[ebp], xmm0
  000ed	f2 0f 5a 45 a8	 cvtsd2ss xmm0, QWORD PTR tv213[ebp]
  000f2	51		 push	 ecx
  000f3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f8	a1 08 00 00 00	 mov	 eax, DWORD PTR ?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A+8
  000fd	89 45 b0	 mov	 DWORD PTR tv218[ebp], eax
  00100	f2 0f 2a 45 b0	 cvtsi2sd xmm0, DWORD PTR tv218[ebp]
  00105	8b 45 b0	 mov	 eax, DWORD PTR tv218[ebp]
  00108	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0010b	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00114	f2 0f 11 45 a0	 movsd	 QWORD PTR tv222[ebp], xmm0
  00119	f2 0f 5a 45 a0	 cvtsd2ss xmm0, QWORD PTR tv222[ebp]
  0011e	51		 push	 ecx
  0011f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00124	51		 push	 ecx
  00125	0f 57 c0	 xorps	 xmm0, xmm0
  00128	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012d	8d 45 bc	 lea	 eax, DWORD PTR _matProj$1[ebp]
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _D3DXMatrixOrthoOffCenterRH@28

; 327  : 		STATEMANAGER.SaveTransform(D3DTS_PROJECTION, &matProj);

  00136	8d 45 bc	 lea	 eax, DWORD PTR _matProj$1[ebp]
  00139	50		 push	 eax
  0013a	6a 03		 push	 3
  0013c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00142	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 328  : 		STATEMANAGER.SaveTransform(D3DTS_VIEW, &ms_matIdentity);

  00147	68 00 00 00 00	 push	 OFFSET ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A ; CGraphicBase::ms_matIdentity
  0014c	6a 02		 push	 2
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00154	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 329  : 
; 330  : 		STATEMANAGER.SetTransform(D3DTS_WORLD, &ms_matIdentity);

  00159	68 00 00 00 00	 push	 OFFSET ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A ; CGraphicBase::ms_matIdentity
  0015e	68 00 01 00 00	 push	 256			; 00000100H
  00163	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00169	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 331  : 		//glMatrixMode(GL_MODELVIEW);
; 332  : 		//glLoadIdentity();
; 333  : 
; 334  : 		//glDisable(GL_TEXTURE_2D);
; 335  : 		DrawAfterFlare();

  0016e	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?DrawAfterFlare@CLensFlare@@QAEXXZ ; CLensFlare::DrawAfterFlare

; 336  : 
; 337  : 		//glEnable(GL_TEXTURE_2D);
; 338  : 		m_cFlare.Draw(m_fAfterBright,

  00176	6a 04		 push	 4
  00178	58		 pop	 eax
  00179	c1 e0 00	 shl	 eax, 0
  0017c	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017f	f3 0f 2c 44 01
	0c		 cvttss2si eax, DWORD PTR [ecx+eax+12]
  00185	50		 push	 eax
  00186	6a 04		 push	 4
  00188	58		 pop	 eax
  00189	6b c0 00	 imul	 eax, eax, 0
  0018c	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	f3 0f 2c 44 01
	0c		 cvttss2si eax, DWORD PTR [ecx+eax+12]
  00195	50		 push	 eax
  00196	ff 35 0c 00 00
	00		 push	 DWORD PTR ?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A+12
  0019c	ff 35 08 00 00
	00		 push	 DWORD PTR ?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A+8
  001a2	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  001a5	51		 push	 ecx
  001a6	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  001ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b0	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	83 c1 24	 add	 ecx, 36			; 00000024H
  001b6	e8 00 00 00 00	 call	 ?Draw@CFlare@@QAEXMHHHH@Z ; CFlare::Draw

; 339  : 					  ms_Viewport.Width,
; 340  : 					  ms_Viewport.Height,
; 341  : 					  static_cast<int>(m_afFlareWinPos[0]),
; 342  : 					  static_cast<int>(m_afFlareWinPos[1]));
; 343  : 
; 344  : 		STATEMANAGER.RestoreRenderState(D3DRS_LIGHTING); // glDisable(GL_LIGHTING);

  001bb	68 89 00 00 00	 push	 137			; 00000089H
  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c6	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 345  : 		STATEMANAGER.RestoreRenderState(D3DRS_ZENABLE); // glDisable(GL_DEPTH_TEST);

  001cb	6a 07		 push	 7
  001cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001d3	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 346  : 		STATEMANAGER.RestoreRenderState(D3DRS_CULLMODE); // glDisable(GL_CULL_FACE);

  001d8	6a 16		 push	 22			; 00000016H
  001da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001e0	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 347  : 		STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE); // glEnable(GL_BLEND);

  001e5	6a 1b		 push	 27			; 0000001bH
  001e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001ed	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 348  : 		STATEMANAGER.RestoreRenderState(D3DRS_ALPHATESTENABLE); // glDisable(GL_ALPHA_TEST);

  001f2	6a 0f		 push	 15			; 0000000fH
  001f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001fa	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 349  : 
; 350  : 		STATEMANAGER.RestoreTransform(D3DTS_PROJECTION);

  001ff	6a 03		 push	 3
  00201	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00207	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform

; 351  : 		STATEMANAGER.RestoreTransform(D3DTS_VIEW);

  0020c	6a 02		 push	 2
  0020e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00214	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform
$LN2@DrawFlare:

; 352  : 		//glDisable(GL_TEXTURE_2D);
; 353  :         //glPopAttrib();
; 354  : 	}
; 355  : }

  00219	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021c	33 cd		 xor	 ecx, ebp
  0021e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00223	c9		 leave
  00224	c3		 ret	 0
?DrawFlare@CLensFlare@@QAEXXZ ENDP			; CLensFlare::DrawFlare
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?DrawAfterFlare@CLensFlare@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DrawAfterFlare@CLensFlare@@QAEXXZ PROC			; CLensFlare::DrawAfterFlare, COMDAT
; _this$ = ecx

; 284  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 285  : 	if (m_bEnabled && m_fAfterBright != 0.0f && m_bDrawBrightScreen)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 40 3c	 movzx	 eax, BYTE PTR [eax+60]
  0000e	85 c0		 test	 eax, eax
  00010	0f 84 bb 00 00
	00		 je	 $LN2@DrawAfterF
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0001e	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00025	9f		 lahf
  00026	f6 c4 44	 test	 ah, 68			; 00000044H
  00029	0f 8b a2 00 00
	00		 jnp	 $LN2@DrawAfterF
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	0f b6 40 1e	 movzx	 eax, BYTE PTR [eax+30]
  00036	85 c0		 test	 eax, eax
  00038	0f 84 93 00 00
	00		 je	 $LN2@DrawAfterF

; 286  : 	{
; 287  : 		SetDiffuseColor(m_afColor[0], m_afColor[1], m_afColor[2], m_fAfterBright);

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	51		 push	 ecx
  00042	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00047	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004c	6a 04		 push	 4
  0004e	58		 pop	 eax
  0004f	d1 e0		 shl	 eax, 1
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	51		 push	 ecx
  00055	f3 0f 10 44 01
	44		 movss	 xmm0, DWORD PTR [ecx+eax+68]
  0005b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00060	6a 04		 push	 4
  00062	58		 pop	 eax
  00063	c1 e0 00	 shl	 eax, 0
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	51		 push	 ecx
  0006a	f3 0f 10 44 01
	44		 movss	 xmm0, DWORD PTR [ecx+eax+68]
  00070	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00075	6a 04		 push	 4
  00077	58		 pop	 eax
  00078	6b c0 00	 imul	 eax, eax, 0
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	51		 push	 ecx
  0007f	f3 0f 10 44 01
	44		 movss	 xmm0, DWORD PTR [ecx+eax+68]
  00085	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?SetDiffuseColor@CScreen@@QAEXMMMM@Z ; CScreen::SetDiffuseColor

; 288  : 		RenderBar2d(0.0f, 0.0f, 1024.0f, 1024.0f);

  00092	51		 push	 ecx
  00093	0f 57 c0	 xorps	 xmm0, xmm0
  00096	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009b	51		 push	 ecx
  0009c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44800000
  000a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a9	51		 push	 ecx
  000aa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44800000
  000b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b7	51		 push	 ecx
  000b8	0f 57 c0	 xorps	 xmm0, xmm0
  000bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c0	51		 push	 ecx
  000c1	0f 57 c0	 xorps	 xmm0, xmm0
  000c4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	e8 00 00 00 00	 call	 ?RenderBar2d@CScreen@@QAEXMMMMM@Z ; CScreen::RenderBar2d
$LN2@DrawAfterF:

; 289  : 	}
; 290  : }

  000d1	c9		 leave
  000d2	c3		 ret	 0
?DrawAfterFlare@CLensFlare@@QAEXXZ ENDP			; CLensFlare::DrawAfterFlare
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?DrawBeforeFlare@CLensFlare@@QAEXXZ
_TEXT	SEGMENT
tv648 = -476						; size = 8
tv639 = -468						; size = 8
_dwB$1 = -460						; size = 4
_dwA$2 = -456						; size = 4
_dwR$3 = -452						; size = 4
_dwG$4 = -448						; size = 4
$T5 = -444						; size = 4
_dwG$6 = -440						; size = 4
_dwA$7 = -436						; size = 4
_dwR$8 = -432						; size = 4
_dwG$9 = -428						; size = 4
_dwB$10 = -424						; size = 4
_dwA$11 = -420						; size = 4
_dwR$12 = -416						; size = 4
_fAspectRatio$ = -412					; size = 4
_dwB$13 = -408						; size = 4
_dwA$14 = -404						; size = 4
_dwR$15 = -400						; size = 4
_dwG$16 = -396						; size = 4
_dwB$17 = -392						; size = 4
tv386 = -388						; size = 4
tv385 = -384						; size = 4
tv644 = -380						; size = 4
tv635 = -376						; size = 4
tv566 = -372						; size = 4
tv565 = -368						; size = 4
tv555 = -364						; size = 4
tv554 = -360						; size = 4
tv544 = -356						; size = 4
tv543 = -352						; size = 4
tv533 = -348						; size = 4
tv532 = -344						; size = 4
tv517 = -340						; size = 4
tv516 = -336						; size = 4
tv506 = -332						; size = 4
tv505 = -328						; size = 4
tv495 = -324						; size = 4
tv494 = -320						; size = 4
tv484 = -316						; size = 4
tv483 = -312						; size = 4
tv468 = -308						; size = 4
tv467 = -304						; size = 4
tv457 = -300						; size = 4
tv456 = -296						; size = 4
tv446 = -292						; size = 4
tv445 = -288						; size = 4
tv435 = -284						; size = 4
tv434 = -280						; size = 4
tv419 = -276						; size = 4
tv418 = -272						; size = 4
tv408 = -268						; size = 4
tv407 = -264						; size = 4
tv397 = -260						; size = 4
tv396 = -256						; size = 4
_fHeight$ = -252					; size = 4
_color$ = -248						; size = 16
_this$ = -232						; size = 4
_matWorld$ = -228					; size = 64
_matProj$ = -164					; size = 64
_vertices$ = -100					; size = 96
__$ArrayPad$ = -4					; size = 4
?DrawBeforeFlare@CLensFlare@@QAEXXZ PROC		; CLensFlare::DrawBeforeFlare, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 01 00
	00		 sub	 esp, 476		; 000001dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 184  :     if (!m_bFlareVisible || !m_bEnabled || !m_bShowMainFlare)

  0001a	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00020	0f b6 40 1c	 movzx	 eax, BYTE PTR [eax+28]
  00024	85 c0		 test	 eax, eax
  00026	74 1c		 je	 SHORT $LN3@DrawBefore
  00028	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0002e	0f b6 40 3c	 movzx	 eax, BYTE PTR [eax+60]
  00032	85 c0		 test	 eax, eax
  00034	74 0e		 je	 SHORT $LN3@DrawBefore
  00036	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0003c	0f b6 40 3d	 movzx	 eax, BYTE PTR [eax+61]
  00040	85 c0		 test	 eax, eax
  00042	75 05		 jne	 SHORT $LN2@DrawBefore
$LN3@DrawBefore:

; 185  :         return;

  00044	e9 a4 0c 00 00	 jmp	 $LN1@DrawBefore
$LN2@DrawBefore:

; 186  : 
; 187  : 	if (m_SunFlareImageInstance.IsEmpty())

  00049	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	83 c1 54	 add	 ecx, 84			; 00000054H
  00052	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  00057	0f b6 c0	 movzx	 eax, al
  0005a	85 c0		 test	 eax, eax
  0005c	74 05		 je	 SHORT $LN4@DrawBefore

; 188  : 		return;

  0005e	e9 8a 0c 00 00	 jmp	 $LN1@DrawBefore
$LN4@DrawBefore:

; 189  : 
; 190  : 	D3DXMATRIX matProj;
; 191  : 	D3DXMatrixOrthoOffCenterRH(&matProj, 0.0f, 1.0f, 1.0f, 0.0f, -1.0f, 1.0f);

  00063	51		 push	 ecx
  00064	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0006c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00071	51		 push	 ecx
  00072	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0007a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007f	51		 push	 ecx
  00080	0f 57 c0	 xorps	 xmm0, xmm0
  00083	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00088	51		 push	 ecx
  00089	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00091	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00096	51		 push	 ecx
  00097	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0009f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a4	51		 push	 ecx
  000a5	0f 57 c0	 xorps	 xmm0, xmm0
  000a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ad	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _matProj$[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _D3DXMatrixOrthoOffCenterRH@28

; 192  : 	STATEMANAGER.SaveTransform(D3DTS_PROJECTION, &matProj);

  000b9	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _matProj$[ebp]
  000bf	50		 push	 eax
  000c0	6a 03		 push	 3
  000c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000c8	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 193  : 	STATEMANAGER.SaveTransform(D3DTS_VIEW, &ms_matIdentity);

  000cd	68 00 00 00 00	 push	 OFFSET ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A ; CGraphicBase::ms_matIdentity
  000d2	6a 02		 push	 2
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000da	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 194  : 
; 195  : 	D3DXMATRIX matWorld;
; 196  : 	D3DXMatrixTranslation(&matWorld, m_afFlarePos[0], m_afFlarePos[1], 0.0f);

  000df	51		 push	 ecx
  000e0	0f 57 c0	 xorps	 xmm0, xmm0
  000e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e8	6a 04		 push	 4
  000ea	58		 pop	 eax
  000eb	c1 e0 00	 shl	 eax, 0
  000ee	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	51		 push	 ecx
  000f5	f3 0f 10 44 01
	04		 movss	 xmm0, DWORD PTR [ecx+eax+4]
  000fb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00100	6a 04		 push	 4
  00102	58		 pop	 eax
  00103	6b c0 00	 imul	 eax, eax, 0
  00106	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	51		 push	 ecx
  0010d	f3 0f 10 44 01
	04		 movss	 xmm0, DWORD PTR [ecx+eax+4]
  00113	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00118	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _matWorld$[ebp]
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16

; 197  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &matWorld);

  00124	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR _matWorld$[ebp]
  0012a	50		 push	 eax
  0012b	68 00 01 00 00	 push	 256			; 00000100H
  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00136	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 198  : 
; 199  : 	STATEMANAGER.SaveRenderState(D3DRS_LIGHTING, FALSE);

  0013b	6a 00		 push	 0
  0013d	68 89 00 00 00	 push	 137			; 00000089H
  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00148	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 200  : 	STATEMANAGER.SaveRenderState(D3DRS_ZENABLE, FALSE);					// glDisable(GL_DEPTH_TEST);

  0014d	6a 00		 push	 0
  0014f	6a 07		 push	 7
  00151	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00157	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 201  : 	STATEMANAGER.SaveRenderState(D3DRS_ZWRITEENABLE, FALSE);

  0015c	6a 00		 push	 0
  0015e	6a 0e		 push	 14			; 0000000eH
  00160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00166	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 202  : 	STATEMANAGER.SaveRenderState(D3DRS_CULLMODE, D3DCULL_NONE);			// glDisable(GL_CULL_FACE);

  0016b	6a 01		 push	 1
  0016d	6a 16		 push	 22			; 00000016H
  0016f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00175	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 203  : 	STATEMANAGER.SaveRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);		// glShadeModel(GL_FLAT);

  0017a	6a 01		 push	 1
  0017c	6a 09		 push	 9
  0017e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00184	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 204  :     STATEMANAGER.SaveRenderState(D3DRS_ALPHATESTENABLE, FALSE);			// glDisable(GL_ALPHA_TEST);

  00189	6a 00		 push	 0
  0018b	6a 0f		 push	 15			; 0000000fH
  0018d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00193	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 205  :     STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);			// glEnable(GL_BLEND);

  00198	6a 01		 push	 1
  0019a	6a 1b		 push	 27			; 0000001bH
  0019c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001a2	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 206  : 	STATEMANAGER.SaveRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

  001a7	6a 05		 push	 5
  001a9	6a 13		 push	 19			; 00000013H
  001ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001b1	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 207  : 	STATEMANAGER.SaveRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

  001b6	6a 06		 push	 6
  001b8	6a 14		 push	 20			; 00000014H
  001ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c0	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 208  : 	/*
; 209  : 	if (m_fBeforeBright != 0.0f && m_bDrawFlare && m_bDrawBrightScreen && false)	//  false?
; 210  : 	{
; 211  : 		glColor4f(1.0f, 1.0f, 1.0f, m_fBeforeBright);
; 212  : 		glDisable(GL_TEXTURE_2D);
; 213  : 		glBegin(GL_TRIANGLE_STRIP);
; 214  : 			glVertex2f(0.0f, 0.0f);
; 215  : 			glVertex2f(0.0f, 1.0f);
; 216  : 			glVertex2f(1.0f, 0.0f);
; 217  : 			glVertex2f(1.0f, 1.0f);
; 218  : 		glEnd();
; 219  : 	}
; 220  : 	*/
; 221  : 	float fAspectRatio = ms_Viewport.Width / float(ms_Viewport.Height);

  001c5	a1 08 00 00 00	 mov	 eax, DWORD PTR ?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A+8
  001ca	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv635[ebp], eax
  001d0	f2 0f 2a 85 88
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv635[ebp]
  001d8	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR tv635[ebp]
  001de	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001e1	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  001ea	f2 0f 11 85 2c
	fe ff ff	 movsd	 QWORD PTR tv639[ebp], xmm0
  001f2	f2 0f 5a 85 2c
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv639[ebp]
  001fa	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A+12
  001ff	89 85 84 fe ff
	ff		 mov	 DWORD PTR tv644[ebp], eax
  00205	f2 0f 2a 8d 84
	fe ff ff	 cvtsi2sd xmm1, DWORD PTR tv644[ebp]
  0020d	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv644[ebp]
  00213	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00216	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0021f	f2 0f 11 8d 24
	fe ff ff	 movsd	 QWORD PTR tv648[ebp], xmm1
  00227	f2 0f 5a 8d 24
	fe ff ff	 cvtsd2ss xmm1, QWORD PTR tv648[ebp]
  0022f	f3 0f 5e c1	 divss	 xmm0, xmm1
  00233	f3 0f 11 85 64
	fe ff ff	 movss	 DWORD PTR _fAspectRatio$[ebp], xmm0

; 222  : 	float fHeight = m_fSunSize * fAspectRatio;

  0023b	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00241	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [eax+32]
  00246	f3 0f 59 85 64
	fe ff ff	 mulss	 xmm0, DWORD PTR _fAspectRatio$[ebp]
  0024e	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _fHeight$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 920  :     r = fr;

  00256	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0025e	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR _color$[ebp], xmm0

; 921  :     g = fg;

  00266	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0026e	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR _color$[ebp+4], xmm0

; 922  :     b = fb;

  00276	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0027e	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _color$[ebp+8], xmm0

; 923  :     a = fa;

  00286	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0028e	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _color$[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 226  : 	vertices[0].x = -m_fSunSize;

  00296	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0029c	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [eax+32]
  002a1	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  002a8	6a 18		 push	 24			; 00000018H
  002aa	58		 pop	 eax
  002ab	6b c0 00	 imul	 eax, eax, 0
  002ae	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0

; 227  : 	vertices[0].y = -fHeight;

  002b4	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _fHeight$[ebp]
  002bc	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  002c3	6a 18		 push	 24			; 00000018H
  002c5	58		 pop	 eax
  002c6	6b c0 00	 imul	 eax, eax, 0
  002c9	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0

; 228  : 	vertices[0].z = 0.0f;

  002cf	6a 18		 push	 24			; 00000018H
  002d1	58		 pop	 eax
  002d2	6b c0 00	 imul	 eax, eax, 0
  002d5	0f 57 c0	 xorps	 xmm0, xmm0
  002d8	f3 0f 11 44 05
	a4		 movss	 DWORD PTR _vertices$[ebp+eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  002de	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp]
  002e6	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  002ed	72 0c		 jb	 SHORT $LN40@DrawBefore
  002ef	c7 85 7c fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv386[ebp], 255 ; 000000ffH
  002f9	eb 44		 jmp	 SHORT $LN41@DrawBefore
$LN40@DrawBefore:
  002fb	0f 57 c0	 xorps	 xmm0, xmm0
  002fe	0f 2f 85 08 ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp]
  00305	72 09		 jb	 SHORT $LN38@DrawBefore
  00307	83 a5 80 fe ff
	ff 00		 and	 DWORD PTR tv385[ebp], 0
  0030e	eb 23		 jmp	 SHORT $LN39@DrawBefore
$LN38@DrawBefore:
  00310	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp]
  00318	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00320	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00328	e8 00 00 00 00	 call	 __ftoui3
  0032d	89 85 80 fe ff
	ff		 mov	 DWORD PTR tv385[ebp], eax
$LN39@DrawBefore:
  00333	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR tv385[ebp]
  00339	89 85 7c fe ff
	ff		 mov	 DWORD PTR tv386[ebp], eax
$LN41@DrawBefore:
  0033f	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR tv386[ebp]
  00345	89 85 3c fe ff
	ff		 mov	 DWORD PTR _dwR$3[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0034b	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+4]
  00353	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0035a	72 0c		 jb	 SHORT $LN44@DrawBefore
  0035c	c7 85 fc fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv397[ebp], 255 ; 000000ffH
  00366	eb 44		 jmp	 SHORT $LN45@DrawBefore
$LN44@DrawBefore:
  00368	0f 57 c0	 xorps	 xmm0, xmm0
  0036b	0f 2f 85 0c ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp+4]
  00372	72 09		 jb	 SHORT $LN42@DrawBefore
  00374	83 a5 00 ff ff
	ff 00		 and	 DWORD PTR tv396[ebp], 0
  0037b	eb 23		 jmp	 SHORT $LN43@DrawBefore
$LN42@DrawBefore:
  0037d	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+4]
  00385	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0038d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00395	e8 00 00 00 00	 call	 __ftoui3
  0039a	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv396[ebp], eax
$LN43@DrawBefore:
  003a0	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv396[ebp]
  003a6	89 85 fc fe ff
	ff		 mov	 DWORD PTR tv397[ebp], eax
$LN45@DrawBefore:
  003ac	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv397[ebp]
  003b2	89 85 40 fe ff
	ff		 mov	 DWORD PTR _dwG$4[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  003b8	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+8]
  003c0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  003c7	72 0c		 jb	 SHORT $LN48@DrawBefore
  003c9	c7 85 f4 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv408[ebp], 255 ; 000000ffH
  003d3	eb 44		 jmp	 SHORT $LN49@DrawBefore
$LN48@DrawBefore:
  003d5	0f 57 c0	 xorps	 xmm0, xmm0
  003d8	0f 2f 85 10 ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp+8]
  003df	72 09		 jb	 SHORT $LN46@DrawBefore
  003e1	83 a5 f8 fe ff
	ff 00		 and	 DWORD PTR tv407[ebp], 0
  003e8	eb 23		 jmp	 SHORT $LN47@DrawBefore
$LN46@DrawBefore:
  003ea	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+8]
  003f2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  003fa	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00402	e8 00 00 00 00	 call	 __ftoui3
  00407	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv407[ebp], eax
$LN47@DrawBefore:
  0040d	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv407[ebp]
  00413	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv408[ebp], eax
$LN49@DrawBefore:
  00419	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv408[ebp]
  0041f	89 85 78 fe ff
	ff		 mov	 DWORD PTR _dwB$17[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00425	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+12]
  0042d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00434	72 0c		 jb	 SHORT $LN52@DrawBefore
  00436	c7 85 ec fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv419[ebp], 255 ; 000000ffH
  00440	eb 44		 jmp	 SHORT $LN53@DrawBefore
$LN52@DrawBefore:
  00442	0f 57 c0	 xorps	 xmm0, xmm0
  00445	0f 2f 85 14 ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp+12]
  0044c	72 09		 jb	 SHORT $LN50@DrawBefore
  0044e	83 a5 f0 fe ff
	ff 00		 and	 DWORD PTR tv418[ebp], 0
  00455	eb 23		 jmp	 SHORT $LN51@DrawBefore
$LN50@DrawBefore:
  00457	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+12]
  0045f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00467	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0046f	e8 00 00 00 00	 call	 __ftoui3
  00474	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv418[ebp], eax
$LN51@DrawBefore:
  0047a	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv418[ebp]
  00480	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv419[ebp], eax
$LN53@DrawBefore:
  00486	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv419[ebp]
  0048c	89 85 38 fe ff
	ff		 mov	 DWORD PTR _dwA$2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 229  : 	vertices[0].color = color;

  00492	6a 18		 push	 24			; 00000018H
  00494	58		 pop	 eax
  00495	6b c0 00	 imul	 eax, eax, 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00498	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR _dwG$4[ebp]
  0049e	c1 e1 08	 shl	 ecx, 8
  004a1	8b 95 3c fe ff
	ff		 mov	 edx, DWORD PTR _dwR$3[ebp]
  004a7	c1 e2 10	 shl	 edx, 16			; 00000010H
  004aa	8b b5 38 fe ff
	ff		 mov	 esi, DWORD PTR _dwA$2[ebp]
  004b0	c1 e6 18	 shl	 esi, 24			; 00000018H
  004b3	0b f2		 or	 esi, edx
  004b5	0b f1		 or	 esi, ecx
  004b7	0b b5 78 fe ff
	ff		 or	 esi, DWORD PTR _dwB$17[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 229  : 	vertices[0].color = color;

  004bd	89 74 05 a8	 mov	 DWORD PTR _vertices$[ebp+eax+12], esi

; 230  : 	vertices[0].u = 0.0f;

  004c1	6a 18		 push	 24			; 00000018H
  004c3	58		 pop	 eax
  004c4	6b c0 00	 imul	 eax, eax, 0
  004c7	0f 57 c0	 xorps	 xmm0, xmm0
  004ca	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _vertices$[ebp+eax+16], xmm0

; 231  : 	vertices[0].v = 0.0f;

  004d0	6a 18		 push	 24			; 00000018H
  004d2	58		 pop	 eax
  004d3	6b c0 00	 imul	 eax, eax, 0
  004d6	0f 57 c0	 xorps	 xmm0, xmm0
  004d9	f3 0f 11 44 05
	b0		 movss	 DWORD PTR _vertices$[ebp+eax+20], xmm0

; 232  : 
; 233  : 	vertices[1].x = -m_fSunSize;

  004df	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004e5	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [eax+32]
  004ea	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  004f1	6a 18		 push	 24			; 00000018H
  004f3	58		 pop	 eax
  004f4	c1 e0 00	 shl	 eax, 0
  004f7	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0

; 234  : 	vertices[1].y = fHeight;

  004fd	6a 18		 push	 24			; 00000018H
  004ff	58		 pop	 eax
  00500	c1 e0 00	 shl	 eax, 0
  00503	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _fHeight$[ebp]
  0050b	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0

; 235  : 	vertices[1].z = 0.0f;

  00511	6a 18		 push	 24			; 00000018H
  00513	58		 pop	 eax
  00514	c1 e0 00	 shl	 eax, 0
  00517	0f 57 c0	 xorps	 xmm0, xmm0
  0051a	f3 0f 11 44 05
	a4		 movss	 DWORD PTR _vertices$[ebp+eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00520	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp]
  00528	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0052f	72 0c		 jb	 SHORT $LN58@DrawBefore
  00531	c7 85 e4 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv435[ebp], 255 ; 000000ffH
  0053b	eb 44		 jmp	 SHORT $LN59@DrawBefore
$LN58@DrawBefore:
  0053d	0f 57 c0	 xorps	 xmm0, xmm0
  00540	0f 2f 85 08 ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp]
  00547	72 09		 jb	 SHORT $LN56@DrawBefore
  00549	83 a5 e8 fe ff
	ff 00		 and	 DWORD PTR tv434[ebp], 0
  00550	eb 23		 jmp	 SHORT $LN57@DrawBefore
$LN56@DrawBefore:
  00552	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp]
  0055a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00562	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0056a	e8 00 00 00 00	 call	 __ftoui3
  0056f	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv434[ebp], eax
$LN57@DrawBefore:
  00575	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv434[ebp]
  0057b	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv435[ebp], eax
$LN59@DrawBefore:
  00581	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR tv435[ebp]
  00587	89 85 70 fe ff
	ff		 mov	 DWORD PTR _dwR$15[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0058d	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+4]
  00595	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0059c	72 0c		 jb	 SHORT $LN62@DrawBefore
  0059e	c7 85 dc fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv446[ebp], 255 ; 000000ffH
  005a8	eb 44		 jmp	 SHORT $LN63@DrawBefore
$LN62@DrawBefore:
  005aa	0f 57 c0	 xorps	 xmm0, xmm0
  005ad	0f 2f 85 0c ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp+4]
  005b4	72 09		 jb	 SHORT $LN60@DrawBefore
  005b6	83 a5 e0 fe ff
	ff 00		 and	 DWORD PTR tv445[ebp], 0
  005bd	eb 23		 jmp	 SHORT $LN61@DrawBefore
$LN60@DrawBefore:
  005bf	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+4]
  005c7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  005cf	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  005d7	e8 00 00 00 00	 call	 __ftoui3
  005dc	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv445[ebp], eax
$LN61@DrawBefore:
  005e2	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv445[ebp]
  005e8	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv446[ebp], eax
$LN63@DrawBefore:
  005ee	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv446[ebp]
  005f4	89 85 74 fe ff
	ff		 mov	 DWORD PTR _dwG$16[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  005fa	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+8]
  00602	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00609	72 0c		 jb	 SHORT $LN66@DrawBefore
  0060b	c7 85 d4 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv457[ebp], 255 ; 000000ffH
  00615	eb 44		 jmp	 SHORT $LN67@DrawBefore
$LN66@DrawBefore:
  00617	0f 57 c0	 xorps	 xmm0, xmm0
  0061a	0f 2f 85 10 ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp+8]
  00621	72 09		 jb	 SHORT $LN64@DrawBefore
  00623	83 a5 d8 fe ff
	ff 00		 and	 DWORD PTR tv456[ebp], 0
  0062a	eb 23		 jmp	 SHORT $LN65@DrawBefore
$LN64@DrawBefore:
  0062c	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+8]
  00634	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0063c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00644	e8 00 00 00 00	 call	 __ftoui3
  00649	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv456[ebp], eax
$LN65@DrawBefore:
  0064f	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR tv456[ebp]
  00655	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv457[ebp], eax
$LN67@DrawBefore:
  0065b	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv457[ebp]
  00661	89 85 68 fe ff
	ff		 mov	 DWORD PTR _dwB$13[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00667	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+12]
  0066f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00676	72 0c		 jb	 SHORT $LN70@DrawBefore
  00678	c7 85 cc fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv468[ebp], 255 ; 000000ffH
  00682	eb 44		 jmp	 SHORT $LN71@DrawBefore
$LN70@DrawBefore:
  00684	0f 57 c0	 xorps	 xmm0, xmm0
  00687	0f 2f 85 14 ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp+12]
  0068e	72 09		 jb	 SHORT $LN68@DrawBefore
  00690	83 a5 d0 fe ff
	ff 00		 and	 DWORD PTR tv467[ebp], 0
  00697	eb 23		 jmp	 SHORT $LN69@DrawBefore
$LN68@DrawBefore:
  00699	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+12]
  006a1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  006a9	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  006b1	e8 00 00 00 00	 call	 __ftoui3
  006b6	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv467[ebp], eax
$LN69@DrawBefore:
  006bc	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv467[ebp]
  006c2	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv468[ebp], eax
$LN71@DrawBefore:
  006c8	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR tv468[ebp]
  006ce	89 85 6c fe ff
	ff		 mov	 DWORD PTR _dwA$14[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 236  : 	vertices[1].color = color;

  006d4	6a 18		 push	 24			; 00000018H
  006d6	58		 pop	 eax
  006d7	c1 e0 00	 shl	 eax, 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  006da	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _dwG$16[ebp]
  006e0	c1 e1 08	 shl	 ecx, 8
  006e3	8b 95 70 fe ff
	ff		 mov	 edx, DWORD PTR _dwR$15[ebp]
  006e9	c1 e2 10	 shl	 edx, 16			; 00000010H
  006ec	8b b5 6c fe ff
	ff		 mov	 esi, DWORD PTR _dwA$14[ebp]
  006f2	c1 e6 18	 shl	 esi, 24			; 00000018H
  006f5	0b f2		 or	 esi, edx
  006f7	0b f1		 or	 esi, ecx
  006f9	0b b5 68 fe ff
	ff		 or	 esi, DWORD PTR _dwB$13[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 236  : 	vertices[1].color = color;

  006ff	89 74 05 a8	 mov	 DWORD PTR _vertices$[ebp+eax+12], esi

; 237  : 	vertices[1].u = 0.0f;

  00703	6a 18		 push	 24			; 00000018H
  00705	58		 pop	 eax
  00706	c1 e0 00	 shl	 eax, 0
  00709	0f 57 c0	 xorps	 xmm0, xmm0
  0070c	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _vertices$[ebp+eax+16], xmm0

; 238  : 	vertices[1].v = 1.0f;

  00712	6a 18		 push	 24			; 00000018H
  00714	58		 pop	 eax
  00715	c1 e0 00	 shl	 eax, 0
  00718	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00720	f3 0f 11 44 05
	b0		 movss	 DWORD PTR _vertices$[ebp+eax+20], xmm0

; 239  : 
; 240  : 	vertices[2].x = m_fSunSize;

  00726	6a 18		 push	 24			; 00000018H
  00728	58		 pop	 eax
  00729	d1 e0		 shl	 eax, 1
  0072b	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00731	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00734	89 4c 05 9c	 mov	 DWORD PTR _vertices$[ebp+eax], ecx

; 241  : 	vertices[2].y = -fHeight;

  00738	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _fHeight$[ebp]
  00740	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00747	6a 18		 push	 24			; 00000018H
  00749	58		 pop	 eax
  0074a	d1 e0		 shl	 eax, 1
  0074c	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0

; 242  : 	vertices[2].z = 0.0f;

  00752	6a 18		 push	 24			; 00000018H
  00754	58		 pop	 eax
  00755	d1 e0		 shl	 eax, 1
  00757	0f 57 c0	 xorps	 xmm0, xmm0
  0075a	f3 0f 11 44 05
	a4		 movss	 DWORD PTR _vertices$[ebp+eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00760	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp]
  00768	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0076f	72 0c		 jb	 SHORT $LN76@DrawBefore
  00771	c7 85 c4 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv484[ebp], 255 ; 000000ffH
  0077b	eb 44		 jmp	 SHORT $LN77@DrawBefore
$LN76@DrawBefore:
  0077d	0f 57 c0	 xorps	 xmm0, xmm0
  00780	0f 2f 85 08 ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp]
  00787	72 09		 jb	 SHORT $LN74@DrawBefore
  00789	83 a5 c8 fe ff
	ff 00		 and	 DWORD PTR tv483[ebp], 0
  00790	eb 23		 jmp	 SHORT $LN75@DrawBefore
$LN74@DrawBefore:
  00792	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp]
  0079a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  007a2	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  007aa	e8 00 00 00 00	 call	 __ftoui3
  007af	89 85 c8 fe ff
	ff		 mov	 DWORD PTR tv483[ebp], eax
$LN75@DrawBefore:
  007b5	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR tv483[ebp]
  007bb	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv484[ebp], eax
$LN77@DrawBefore:
  007c1	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR tv484[ebp]
  007c7	89 85 60 fe ff
	ff		 mov	 DWORD PTR _dwR$12[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  007cd	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+4]
  007d5	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  007dc	72 0c		 jb	 SHORT $LN80@DrawBefore
  007de	c7 85 bc fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv495[ebp], 255 ; 000000ffH
  007e8	eb 44		 jmp	 SHORT $LN81@DrawBefore
$LN80@DrawBefore:
  007ea	0f 57 c0	 xorps	 xmm0, xmm0
  007ed	0f 2f 85 0c ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp+4]
  007f4	72 09		 jb	 SHORT $LN78@DrawBefore
  007f6	83 a5 c0 fe ff
	ff 00		 and	 DWORD PTR tv494[ebp], 0
  007fd	eb 23		 jmp	 SHORT $LN79@DrawBefore
$LN78@DrawBefore:
  007ff	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+4]
  00807	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0080f	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00817	e8 00 00 00 00	 call	 __ftoui3
  0081c	89 85 c0 fe ff
	ff		 mov	 DWORD PTR tv494[ebp], eax
$LN79@DrawBefore:
  00822	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR tv494[ebp]
  00828	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv495[ebp], eax
$LN81@DrawBefore:
  0082e	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR tv495[ebp]
  00834	89 85 48 fe ff
	ff		 mov	 DWORD PTR _dwG$6[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  0083a	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+8]
  00842	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00849	72 0c		 jb	 SHORT $LN84@DrawBefore
  0084b	c7 85 b4 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv506[ebp], 255 ; 000000ffH
  00855	eb 44		 jmp	 SHORT $LN85@DrawBefore
$LN84@DrawBefore:
  00857	0f 57 c0	 xorps	 xmm0, xmm0
  0085a	0f 2f 85 10 ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp+8]
  00861	72 09		 jb	 SHORT $LN82@DrawBefore
  00863	83 a5 b8 fe ff
	ff 00		 and	 DWORD PTR tv505[ebp], 0
  0086a	eb 23		 jmp	 SHORT $LN83@DrawBefore
$LN82@DrawBefore:
  0086c	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+8]
  00874	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0087c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00884	e8 00 00 00 00	 call	 __ftoui3
  00889	89 85 b8 fe ff
	ff		 mov	 DWORD PTR tv505[ebp], eax
$LN83@DrawBefore:
  0088f	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv505[ebp]
  00895	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv506[ebp], eax
$LN85@DrawBefore:
  0089b	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR tv506[ebp]
  008a1	89 85 58 fe ff
	ff		 mov	 DWORD PTR _dwB$10[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  008a7	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+12]
  008af	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  008b6	72 0c		 jb	 SHORT $LN88@DrawBefore
  008b8	c7 85 ac fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv517[ebp], 255 ; 000000ffH
  008c2	eb 44		 jmp	 SHORT $LN89@DrawBefore
$LN88@DrawBefore:
  008c4	0f 57 c0	 xorps	 xmm0, xmm0
  008c7	0f 2f 85 14 ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp+12]
  008ce	72 09		 jb	 SHORT $LN86@DrawBefore
  008d0	83 a5 b0 fe ff
	ff 00		 and	 DWORD PTR tv516[ebp], 0
  008d7	eb 23		 jmp	 SHORT $LN87@DrawBefore
$LN86@DrawBefore:
  008d9	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+12]
  008e1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  008e9	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  008f1	e8 00 00 00 00	 call	 __ftoui3
  008f6	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv516[ebp], eax
$LN87@DrawBefore:
  008fc	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR tv516[ebp]
  00902	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv517[ebp], eax
$LN89@DrawBefore:
  00908	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR tv517[ebp]
  0090e	89 85 5c fe ff
	ff		 mov	 DWORD PTR _dwA$11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 243  : 	vertices[2].color = color;

  00914	6a 18		 push	 24			; 00000018H
  00916	58		 pop	 eax
  00917	d1 e0		 shl	 eax, 1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00919	8b 8d 48 fe ff
	ff		 mov	 ecx, DWORD PTR _dwG$6[ebp]
  0091f	c1 e1 08	 shl	 ecx, 8
  00922	8b 95 60 fe ff
	ff		 mov	 edx, DWORD PTR _dwR$12[ebp]
  00928	c1 e2 10	 shl	 edx, 16			; 00000010H
  0092b	8b b5 5c fe ff
	ff		 mov	 esi, DWORD PTR _dwA$11[ebp]
  00931	c1 e6 18	 shl	 esi, 24			; 00000018H
  00934	0b f2		 or	 esi, edx
  00936	0b f1		 or	 esi, ecx
  00938	0b b5 58 fe ff
	ff		 or	 esi, DWORD PTR _dwB$10[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 243  : 	vertices[2].color = color;

  0093e	89 74 05 a8	 mov	 DWORD PTR _vertices$[ebp+eax+12], esi

; 244  : 	vertices[2].u = 1.0f;

  00942	6a 18		 push	 24			; 00000018H
  00944	58		 pop	 eax
  00945	d1 e0		 shl	 eax, 1
  00947	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0094f	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _vertices$[ebp+eax+16], xmm0

; 245  : 	vertices[2].v = 0.0f;

  00955	6a 18		 push	 24			; 00000018H
  00957	58		 pop	 eax
  00958	d1 e0		 shl	 eax, 1
  0095a	0f 57 c0	 xorps	 xmm0, xmm0
  0095d	f3 0f 11 44 05
	b0		 movss	 DWORD PTR _vertices$[ebp+eax+20], xmm0

; 246  : 
; 247  : 	vertices[3].x = m_fSunSize;

  00963	6a 18		 push	 24			; 00000018H
  00965	58		 pop	 eax
  00966	6b c0 03	 imul	 eax, eax, 3
  00969	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0096f	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00972	89 4c 05 9c	 mov	 DWORD PTR _vertices$[ebp+eax], ecx

; 248  : 	vertices[3].y = fHeight;

  00976	6a 18		 push	 24			; 00000018H
  00978	58		 pop	 eax
  00979	6b c0 03	 imul	 eax, eax, 3
  0097c	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _fHeight$[ebp]
  00984	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0

; 249  : 	vertices[3].z = 0.0f;

  0098a	6a 18		 push	 24			; 00000018H
  0098c	58		 pop	 eax
  0098d	6b c0 03	 imul	 eax, eax, 3
  00990	0f 57 c0	 xorps	 xmm0, xmm0
  00993	f3 0f 11 44 05
	a4		 movss	 DWORD PTR _vertices$[ebp+eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00999	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp]
  009a1	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  009a8	72 0c		 jb	 SHORT $LN94@DrawBefore
  009aa	c7 85 a4 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv533[ebp], 255 ; 000000ffH
  009b4	eb 44		 jmp	 SHORT $LN95@DrawBefore
$LN94@DrawBefore:
  009b6	0f 57 c0	 xorps	 xmm0, xmm0
  009b9	0f 2f 85 08 ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp]
  009c0	72 09		 jb	 SHORT $LN92@DrawBefore
  009c2	83 a5 a8 fe ff
	ff 00		 and	 DWORD PTR tv532[ebp], 0
  009c9	eb 23		 jmp	 SHORT $LN93@DrawBefore
$LN92@DrawBefore:
  009cb	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp]
  009d3	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  009db	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  009e3	e8 00 00 00 00	 call	 __ftoui3
  009e8	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv532[ebp], eax
$LN93@DrawBefore:
  009ee	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR tv532[ebp]
  009f4	89 85 a4 fe ff
	ff		 mov	 DWORD PTR tv533[ebp], eax
$LN95@DrawBefore:
  009fa	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv533[ebp]
  00a00	89 85 50 fe ff
	ff		 mov	 DWORD PTR _dwR$8[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00a06	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+4]
  00a0e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00a15	72 0c		 jb	 SHORT $LN98@DrawBefore
  00a17	c7 85 9c fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv544[ebp], 255 ; 000000ffH
  00a21	eb 44		 jmp	 SHORT $LN99@DrawBefore
$LN98@DrawBefore:
  00a23	0f 57 c0	 xorps	 xmm0, xmm0
  00a26	0f 2f 85 0c ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp+4]
  00a2d	72 09		 jb	 SHORT $LN96@DrawBefore
  00a2f	83 a5 a0 fe ff
	ff 00		 and	 DWORD PTR tv543[ebp], 0
  00a36	eb 23		 jmp	 SHORT $LN97@DrawBefore
$LN96@DrawBefore:
  00a38	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+4]
  00a40	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00a48	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00a50	e8 00 00 00 00	 call	 __ftoui3
  00a55	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv543[ebp], eax
$LN97@DrawBefore:
  00a5b	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR tv543[ebp]
  00a61	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv544[ebp], eax
$LN99@DrawBefore:
  00a67	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv544[ebp]
  00a6d	89 85 54 fe ff
	ff		 mov	 DWORD PTR _dwG$9[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00a73	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+8]
  00a7b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00a82	72 0c		 jb	 SHORT $LN102@DrawBefore
  00a84	c7 85 94 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv555[ebp], 255 ; 000000ffH
  00a8e	eb 44		 jmp	 SHORT $LN103@DrawBefore
$LN102@DrawBefore:
  00a90	0f 57 c0	 xorps	 xmm0, xmm0
  00a93	0f 2f 85 10 ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp+8]
  00a9a	72 09		 jb	 SHORT $LN100@DrawBefore
  00a9c	83 a5 98 fe ff
	ff 00		 and	 DWORD PTR tv554[ebp], 0
  00aa3	eb 23		 jmp	 SHORT $LN101@DrawBefore
$LN100@DrawBefore:
  00aa5	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+8]
  00aad	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00ab5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00abd	e8 00 00 00 00	 call	 __ftoui3
  00ac2	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv554[ebp], eax
$LN101@DrawBefore:
  00ac8	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR tv554[ebp]
  00ace	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv555[ebp], eax
$LN103@DrawBefore:
  00ad4	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv555[ebp]
  00ada	89 85 34 fe ff
	ff		 mov	 DWORD PTR _dwB$1[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00ae0	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+12]
  00ae8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00aef	72 0c		 jb	 SHORT $LN106@DrawBefore
  00af1	c7 85 8c fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv566[ebp], 255 ; 000000ffH
  00afb	eb 44		 jmp	 SHORT $LN107@DrawBefore
$LN106@DrawBefore:
  00afd	0f 57 c0	 xorps	 xmm0, xmm0
  00b00	0f 2f 85 14 ff
	ff ff		 comiss	 xmm0, DWORD PTR _color$[ebp+12]
  00b07	72 09		 jb	 SHORT $LN104@DrawBefore
  00b09	83 a5 90 fe ff
	ff 00		 and	 DWORD PTR tv565[ebp], 0
  00b10	eb 23		 jmp	 SHORT $LN105@DrawBefore
$LN104@DrawBefore:
  00b12	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _color$[ebp+12]
  00b1a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00b22	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00b2a	e8 00 00 00 00	 call	 __ftoui3
  00b2f	89 85 90 fe ff
	ff		 mov	 DWORD PTR tv565[ebp], eax
$LN105@DrawBefore:
  00b35	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR tv565[ebp]
  00b3b	89 85 8c fe ff
	ff		 mov	 DWORD PTR tv566[ebp], eax
$LN107@DrawBefore:
  00b41	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv566[ebp]
  00b47	89 85 4c fe ff
	ff		 mov	 DWORD PTR _dwA$7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 250  : 	vertices[3].color = color;

  00b4d	6a 18		 push	 24			; 00000018H
  00b4f	58		 pop	 eax
  00b50	6b c0 03	 imul	 eax, eax, 3
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00b53	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _dwG$9[ebp]
  00b59	c1 e1 08	 shl	 ecx, 8
  00b5c	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR _dwR$8[ebp]
  00b62	c1 e2 10	 shl	 edx, 16			; 00000010H
  00b65	8b b5 4c fe ff
	ff		 mov	 esi, DWORD PTR _dwA$7[ebp]
  00b6b	c1 e6 18	 shl	 esi, 24			; 00000018H
  00b6e	0b f2		 or	 esi, edx
  00b70	0b f1		 or	 esi, ecx
  00b72	0b b5 34 fe ff
	ff		 or	 esi, DWORD PTR _dwB$1[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 250  : 	vertices[3].color = color;

  00b78	89 74 05 a8	 mov	 DWORD PTR _vertices$[ebp+eax+12], esi

; 251  : 	vertices[3].u = 1.0f;

  00b7c	6a 18		 push	 24			; 00000018H
  00b7e	58		 pop	 eax
  00b7f	6b c0 03	 imul	 eax, eax, 3
  00b82	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b8a	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _vertices$[ebp+eax+16], xmm0

; 252  : 	vertices[3].v = 1.0f;

  00b90	6a 18		 push	 24			; 00000018H
  00b92	58		 pop	 eax
  00b93	6b c0 03	 imul	 eax, eax, 3
  00b96	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b9e	f3 0f 11 44 05
	b0		 movss	 DWORD PTR _vertices$[ebp+eax+20], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00ba4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00ba9	89 85 44 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 254  : 	STATEMANAGER.SetTexture(0, m_SunFlareImageInstance.GetTexturePointer()->GetD3DTexture());

  00baf	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00bb5	83 c1 54	 add	 ecx, 84			; 00000054H
  00bb8	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  00bbd	8b c8		 mov	 ecx, eax
  00bbf	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00bc4	50		 push	 eax
  00bc5	6a 00		 push	 0
  00bc7	8b 8d 44 fe ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  00bcd	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 255  : 	STATEMANAGER.SetTexture(1, NULL);

  00bd2	6a 00		 push	 0
  00bd4	6a 01		 push	 1
  00bd6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00bdc	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 256  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);

  00be1	6a 04		 push	 4
  00be3	6a 01		 push	 1
  00be5	6a 00		 push	 0
  00be7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00bed	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 257  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00bf2	6a 02		 push	 2
  00bf4	6a 02		 push	 2
  00bf6	6a 00		 push	 0
  00bf8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00bfe	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 258  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

  00c03	6a 00		 push	 0
  00c05	6a 03		 push	 3
  00c07	6a 00		 push	 0
  00c09	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c0f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 259  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

  00c14	6a 02		 push	 2
  00c16	6a 04		 push	 4
  00c18	6a 00		 push	 0
  00c1a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c20	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 260  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00c25	6a 02		 push	 2
  00c27	6a 02		 push	 2
  00c29	6a 00		 push	 0
  00c2b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c31	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 261  : 	
; 262  : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1);

  00c36	68 42 01 00 00	 push	 322			; 00000142H
  00c3b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c41	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 263  : 	STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, vertices, sizeof(SVertex));

  00c46	6a 18		 push	 24			; 00000018H
  00c48	8d 45 9c	 lea	 eax, DWORD PTR _vertices$[ebp]
  00c4b	50		 push	 eax
  00c4c	6a 02		 push	 2
  00c4e	6a 05		 push	 5
  00c50	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c56	e8 00 00 00 00	 call	 ?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z ; CStateManager::DrawPrimitiveUP

; 264  : 
; 265  : 	STATEMANAGER.RestoreRenderState(D3DRS_LIGHTING);

  00c5b	68 89 00 00 00	 push	 137			; 00000089H
  00c60	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c66	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 266  : 	STATEMANAGER.RestoreRenderState(D3DRS_ZENABLE); // glDisable(GL_DEPTH_TEST);

  00c6b	6a 07		 push	 7
  00c6d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c73	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 267  : 	STATEMANAGER.RestoreRenderState(D3DRS_ZWRITEENABLE);

  00c78	6a 0e		 push	 14			; 0000000eH
  00c7a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c80	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 268  : 	STATEMANAGER.RestoreRenderState(D3DRS_CULLMODE); // glDisable(GL_CULL_FACE);

  00c85	6a 16		 push	 22			; 00000016H
  00c87	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c8d	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 269  : 	STATEMANAGER.RestoreRenderState(D3DRS_SHADEMODE); // glShadeModel(GL_FLAT);

  00c92	6a 09		 push	 9
  00c94	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c9a	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 270  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHATESTENABLE); // glDisable(GL_ALPHA_TEST);

  00c9f	6a 0f		 push	 15			; 0000000fH
  00ca1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00ca7	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 271  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE); // glEnable(GL_BLEND);

  00cac	6a 1b		 push	 27			; 0000001bH
  00cae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00cb4	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 272  : 	STATEMANAGER.RestoreRenderState(D3DRS_SRCBLEND);

  00cb9	6a 13		 push	 19			; 00000013H
  00cbb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00cc1	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 273  : 	STATEMANAGER.RestoreRenderState(D3DRS_DESTBLEND);

  00cc6	6a 14		 push	 20			; 00000014H
  00cc8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00cce	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 274  : 
; 275  : 	STATEMANAGER.RestoreTransform(D3DTS_VIEW);

  00cd3	6a 02		 push	 2
  00cd5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00cdb	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform

; 276  : 	STATEMANAGER.RestoreTransform(D3DTS_PROJECTION);

  00ce0	6a 03		 push	 3
  00ce2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00ce8	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform
$LN1@DrawBefore:

; 277  : }

  00ced	5e		 pop	 esi
  00cee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cf1	33 cd		 xor	 ecx, ebp
  00cf3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cf8	c9		 leave
  00cf9	c3		 ret	 0
?DrawBeforeFlare@CLensFlare@@QAEXXZ ENDP		; CLensFlare::DrawBeforeFlare
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Camera.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?Compute@CLensFlare@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv412 = -132						; size = 8
tv402 = -124						; size = 8
_fBeforeBright$ = -116					; size = 4
_fAfterBright$ = -112					; size = 4
__X$ = -108						; size = 4
tv393 = -104						; size = 4
tv392 = -100						; size = 4
_fDotProduct$ = -96					; size = 4
__X$ = -92						; size = 4
_this$ = -88						; size = 4
$T1 = -84						; size = 4
_fDistance$ = -80					; size = 4
tv408 = -76						; size = 4
tv398 = -72						; size = 4
_fSunVectorMagnitude$ = -68				; size = 4
_fX$ = -64						; size = 4
_fY$ = -60						; size = 4
_this$ = -56						; size = 4
_v3Target$ = -52					; size = 12
_afCameraDirection$ = -40				; size = 12
_afSunVector$ = -28					; size = 12
_afSunPos$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_c_rv3LightDirection$ = 8				; size = 4
?Compute@CLensFlare@@QAEXABUD3DXVECTOR3@@@Z PROC	; CLensFlare::Compute, COMDAT
; _this$ = ecx

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  0001d	89 45 ac	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 131  : 	D3DXVECTOR3 v3Target = CCameraManager::Instance().GetCurrentCamera()->GetTarget();

  00020	8b 4d ac	 mov	 ecx, DWORD PTR $T1[ebp]
  00023	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  00028	89 45 a8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Camera.h

; 169  : 		const D3DXVECTOR3 & GetTarget() const	{ return m_v3Target; }

  0002b	8b 75 a8	 mov	 esi, DWORD PTR _this$[ebp]
  0002e	83 c6 3c	 add	 esi, 60			; 0000003cH
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 131  : 	D3DXVECTOR3 v3Target = CCameraManager::Instance().GetCurrentCamera()->GetTarget();

  00031	8d 7d cc	 lea	 edi, DWORD PTR _v3Target$[ebp]
  00034	a5		 movsd
  00035	a5		 movsd
  00036	a5		 movsd

; 132  : 	
; 133  : 	afSunPos[0]	= v3Target.x - c_rv3LightDirection.x * 99999999.0f;

  00037	8b 45 08	 mov	 eax, DWORD PTR _c_rv3LightDirection$[ebp]
  0003a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0003e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@4cbebc20
  00046	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR _v3Target$[ebp]
  0004b	f3 0f 5c c8	 subss	 xmm1, xmm0
  0004f	6a 04		 push	 4
  00051	58		 pop	 eax
  00052	6b c0 00	 imul	 eax, eax, 0
  00055	f3 0f 11 4c 05
	f0		 movss	 DWORD PTR _afSunPos$[ebp+eax], xmm1

; 134  : 	afSunPos[1]	= v3Target.y - c_rv3LightDirection.y * 99999999.0f;

  0005b	8b 45 08	 mov	 eax, DWORD PTR _c_rv3LightDirection$[ebp]
  0005e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00063	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@4cbebc20
  0006b	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR _v3Target$[ebp+4]
  00070	f3 0f 5c c8	 subss	 xmm1, xmm0
  00074	6a 04		 push	 4
  00076	58		 pop	 eax
  00077	c1 e0 00	 shl	 eax, 0
  0007a	f3 0f 11 4c 05
	f0		 movss	 DWORD PTR _afSunPos$[ebp+eax], xmm1

; 135  : 	afSunPos[2]	= v3Target.z - c_rv3LightDirection.z * 99999999.0f;

  00080	8b 45 08	 mov	 eax, DWORD PTR _c_rv3LightDirection$[ebp]
  00083	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00088	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@4cbebc20
  00090	f3 0f 10 4d d4	 movss	 xmm1, DWORD PTR _v3Target$[ebp+8]
  00095	f3 0f 5c c8	 subss	 xmm1, xmm0
  00099	6a 04		 push	 4
  0009b	58		 pop	 eax
  0009c	d1 e0		 shl	 eax, 1
  0009e	f3 0f 11 4c 05
	f0		 movss	 DWORD PTR _afSunPos$[ebp+eax], xmm1

; 136  : 	
; 137  : 	float fX, fY;
; 138  : 	ProjectPosition(afSunPos[0], afSunPos[1], afSunPos[2], &fX, &fY);

  000a4	8d 45 c4	 lea	 eax, DWORD PTR _fY$[ebp]
  000a7	50		 push	 eax
  000a8	8d 45 c0	 lea	 eax, DWORD PTR _fX$[ebp]
  000ab	50		 push	 eax
  000ac	6a 04		 push	 4
  000ae	58		 pop	 eax
  000af	d1 e0		 shl	 eax, 1
  000b1	51		 push	 ecx
  000b2	f3 0f 10 44 05
	f0		 movss	 xmm0, DWORD PTR _afSunPos$[ebp+eax]
  000b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bd	6a 04		 push	 4
  000bf	58		 pop	 eax
  000c0	c1 e0 00	 shl	 eax, 0
  000c3	51		 push	 ecx
  000c4	f3 0f 10 44 05
	f0		 movss	 xmm0, DWORD PTR _afSunPos$[ebp+eax]
  000ca	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cf	6a 04		 push	 4
  000d1	58		 pop	 eax
  000d2	6b c0 00	 imul	 eax, eax, 0
  000d5	51		 push	 ecx
  000d6	f3 0f 10 44 05
	f0		 movss	 xmm0, DWORD PTR _afSunPos$[ebp+eax]
  000dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e1	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ?ProjectPosition@CScreen@@QAEXMMMPAM0@Z ; CScreen::ProjectPosition

; 139  : 	
; 140  : 	// set flare location
; 141  : 	SetFlareLocation(fX, fY);

  000e9	f3 0f 5a 45 c4	 cvtss2sd xmm0, DWORD PTR _fY$[ebp]
  000ee	51		 push	 ecx
  000ef	51		 push	 ecx
  000f0	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000f5	f3 0f 5a 45 c0	 cvtss2sd xmm0, DWORD PTR _fX$[ebp]
  000fa	51		 push	 ecx
  000fb	51		 push	 ecx
  000fc	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00101	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	e8 00 00 00 00	 call	 ?SetFlareLocation@CLensFlare@@QAEXNN@Z ; CLensFlare::SetFlareLocation

; 144  : 	float fSunVectorMagnitude = sqrtf(afSunPos[0] * afSunPos[0] +

  00109	6a 04		 push	 4
  0010b	58		 pop	 eax
  0010c	d1 e0		 shl	 eax, 1
  0010e	6a 04		 push	 4
  00110	59		 pop	 ecx
  00111	d1 e1		 shl	 ecx, 1
  00113	f3 0f 10 44 0d
	f0		 movss	 xmm0, DWORD PTR _afSunPos$[ebp+ecx]
  00119	f3 0f 59 44 05
	f0		 mulss	 xmm0, DWORD PTR _afSunPos$[ebp+eax]
  0011f	6a 04		 push	 4
  00121	58		 pop	 eax
  00122	c1 e0 00	 shl	 eax, 0
  00125	6a 04		 push	 4
  00127	59		 pop	 ecx
  00128	c1 e1 00	 shl	 ecx, 0
  0012b	f3 0f 10 4c 0d
	f0		 movss	 xmm1, DWORD PTR _afSunPos$[ebp+ecx]
  00131	f3 0f 59 4c 05
	f0		 mulss	 xmm1, DWORD PTR _afSunPos$[ebp+eax]
  00137	6a 04		 push	 4
  00139	58		 pop	 eax
  0013a	6b c0 00	 imul	 eax, eax, 0
  0013d	6a 04		 push	 4
  0013f	59		 pop	 ecx
  00140	6b c9 00	 imul	 ecx, ecx, 0
  00143	f3 0f 10 54 0d
	f0		 movss	 xmm2, DWORD PTR _afSunPos$[ebp+ecx]
  00149	f3 0f 59 54 05
	f0		 mulss	 xmm2, DWORD PTR _afSunPos$[ebp+eax]
  0014f	f3 0f 58 d1	 addss	 xmm2, xmm1
  00153	f3 0f 58 d0	 addss	 xmm2, xmm0
  00157	f3 0f 11 55 a4	 movss	 DWORD PTR __X$[ebp], xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  0015c	f3 0f 5a 45 a4	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00161	51		 push	 ecx
  00162	51		 push	 ecx
  00163	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00168	e8 00 00 00 00	 call	 _sqrt
  0016d	59		 pop	 ecx
  0016e	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 144  : 	float fSunVectorMagnitude = sqrtf(afSunPos[0] * afSunPos[0] +

  0016f	d9 5d bc	 fstp	 DWORD PTR _fSunVectorMagnitude$[ebp]

; 145  : 		afSunPos[1] * afSunPos[1] +
; 146  : 		afSunPos[2] * afSunPos[2]);
; 147  : 	float afSunVector[3];
; 148  : 	afSunVector[0] = -afSunPos[0] / fSunVectorMagnitude;

  00172	6a 04		 push	 4
  00174	58		 pop	 eax
  00175	6b c0 00	 imul	 eax, eax, 0
  00178	f3 0f 10 44 05
	f0		 movss	 xmm0, DWORD PTR _afSunPos$[ebp+eax]
  0017e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00185	f3 0f 5e 45 bc	 divss	 xmm0, DWORD PTR _fSunVectorMagnitude$[ebp]
  0018a	6a 04		 push	 4
  0018c	58		 pop	 eax
  0018d	6b c0 00	 imul	 eax, eax, 0
  00190	f3 0f 11 44 05
	e4		 movss	 DWORD PTR _afSunVector$[ebp+eax], xmm0

; 149  : 	afSunVector[1] = -afSunPos[1] / fSunVectorMagnitude;

  00196	6a 04		 push	 4
  00198	58		 pop	 eax
  00199	c1 e0 00	 shl	 eax, 0
  0019c	f3 0f 10 44 05
	f0		 movss	 xmm0, DWORD PTR _afSunPos$[ebp+eax]
  001a2	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001a9	f3 0f 5e 45 bc	 divss	 xmm0, DWORD PTR _fSunVectorMagnitude$[ebp]
  001ae	6a 04		 push	 4
  001b0	58		 pop	 eax
  001b1	c1 e0 00	 shl	 eax, 0
  001b4	f3 0f 11 44 05
	e4		 movss	 DWORD PTR _afSunVector$[ebp+eax], xmm0

; 150  : 	afSunVector[2] = -afSunPos[2] / fSunVectorMagnitude;

  001ba	6a 04		 push	 4
  001bc	58		 pop	 eax
  001bd	d1 e0		 shl	 eax, 1
  001bf	f3 0f 10 44 05
	f0		 movss	 xmm0, DWORD PTR _afSunPos$[ebp+eax]
  001c5	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001cc	f3 0f 5e 45 bc	 divss	 xmm0, DWORD PTR _fSunVectorMagnitude$[ebp]
  001d1	6a 04		 push	 4
  001d3	58		 pop	 eax
  001d4	d1 e0		 shl	 eax, 1
  001d6	f3 0f 11 44 05
	e4		 movss	 DWORD PTR _afSunVector$[ebp+eax], xmm0

; 151  : 	
; 152  : 	float afCameraDirection[3];
; 153  : 	afCameraDirection[0] = ms_matView._13;

  001dc	6a 04		 push	 4
  001de	58		 pop	 eax
  001df	6b c0 00	 imul	 eax, eax, 0
  001e2	f3 0f 10 05 08
	00 00 00	 movss	 xmm0, DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A+8
  001ea	f3 0f 11 44 05
	d8		 movss	 DWORD PTR _afCameraDirection$[ebp+eax], xmm0

; 154  : 	afCameraDirection[1] = ms_matView._23;

  001f0	6a 04		 push	 4
  001f2	58		 pop	 eax
  001f3	c1 e0 00	 shl	 eax, 0
  001f6	f3 0f 10 05 18
	00 00 00	 movss	 xmm0, DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A+24
  001fe	f3 0f 11 44 05
	d8		 movss	 DWORD PTR _afCameraDirection$[ebp+eax], xmm0

; 155  : 	afCameraDirection[2] = ms_matView._33;

  00204	6a 04		 push	 4
  00206	58		 pop	 eax
  00207	d1 e0		 shl	 eax, 1
  00209	f3 0f 10 05 28
	00 00 00	 movss	 xmm0, DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A+40
  00211	f3 0f 11 44 05
	d8		 movss	 DWORD PTR _afCameraDirection$[ebp+eax], xmm0

; 156  : 	
; 157  : 
; 158  : 	float fDotProduct = 

  00217	6a 04		 push	 4
  00219	58		 pop	 eax
  0021a	6b c0 00	 imul	 eax, eax, 0
  0021d	6a 04		 push	 4
  0021f	59		 pop	 ecx
  00220	6b c9 00	 imul	 ecx, ecx, 0
  00223	f3 0f 10 44 05
	e4		 movss	 xmm0, DWORD PTR _afSunVector$[ebp+eax]
  00229	f3 0f 59 44 0d
	d8		 mulss	 xmm0, DWORD PTR _afCameraDirection$[ebp+ecx]
  0022f	6a 04		 push	 4
  00231	58		 pop	 eax
  00232	c1 e0 00	 shl	 eax, 0
  00235	6a 04		 push	 4
  00237	59		 pop	 ecx
  00238	c1 e1 00	 shl	 ecx, 0
  0023b	f3 0f 10 4c 05
	e4		 movss	 xmm1, DWORD PTR _afSunVector$[ebp+eax]
  00241	f3 0f 59 4c 0d
	d8		 mulss	 xmm1, DWORD PTR _afCameraDirection$[ebp+ecx]
  00247	f3 0f 58 c1	 addss	 xmm0, xmm1
  0024b	6a 04		 push	 4
  0024d	58		 pop	 eax
  0024e	d1 e0		 shl	 eax, 1
  00250	6a 04		 push	 4
  00252	59		 pop	 ecx
  00253	d1 e1		 shl	 ecx, 1
  00255	f3 0f 10 4c 05
	e4		 movss	 xmm1, DWORD PTR _afSunVector$[ebp+eax]
  0025b	f3 0f 59 4c 0d
	d8		 mulss	 xmm1, DWORD PTR _afCameraDirection$[ebp+ecx]
  00261	f3 0f 58 c1	 addss	 xmm0, xmm1
  00265	f3 0f 11 45 a0	 movss	 DWORD PTR _fDotProduct$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 624  :             return (float)acos(_X);

  0026a	f3 0f 5a 45 a0	 cvtss2sd xmm0, DWORD PTR _fDotProduct$[ebp]
  0026f	51		 push	 ecx
  00270	51		 push	 ecx
  00271	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00276	e8 00 00 00 00	 call	 _acos
  0027b	59		 pop	 ecx
  0027c	59		 pop	 ecx
  0027d	d9 5d 9c	 fstp	 DWORD PTR tv392[ebp]
  00280	d9 45 9c	 fld	 DWORD PTR tv392[ebp]
  00283	d9 5d 98	 fstp	 DWORD PTR tv393[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 163  : 	if (acosf(fDotProduct) < 0.5f * D3DX_PI)

  00286	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3fc90fdb
  0028e	0f 2f 45 98	 comiss	 xmm0, DWORD PTR tv393[ebp]
  00292	76 09		 jbe	 SHORT $LN2@Compute
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.h

; 95   : 	void            SetVisible(bool bState)		{ m_bFlareVisible = bState; }

  00294	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00297	c6 40 1c 01	 mov	 BYTE PTR [eax+28], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 164  : 		SetVisible(true);

  0029b	eb 07		 jmp	 SHORT $LN15@Compute
$LN2@Compute:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.h

; 95   : 	void            SetVisible(bool bState)		{ m_bFlareVisible = bState; }

  0029d	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  002a0	c6 40 1c 00	 mov	 BYTE PTR [eax+28], 0
$LN15@Compute:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 169  : 	fX /= ms_Viewport.Width;

  002a4	a1 08 00 00 00	 mov	 eax, DWORD PTR ?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A+8
  002a9	89 45 b8	 mov	 DWORD PTR tv398[ebp], eax
  002ac	f2 0f 2a 45 b8	 cvtsi2sd xmm0, DWORD PTR tv398[ebp]
  002b1	8b 45 b8	 mov	 eax, DWORD PTR tv398[ebp]
  002b4	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002b7	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  002c0	f2 0f 11 45 84	 movsd	 QWORD PTR tv402[ebp], xmm0
  002c5	f2 0f 5a 45 84	 cvtsd2ss xmm0, QWORD PTR tv402[ebp]
  002ca	f3 0f 10 4d c0	 movss	 xmm1, DWORD PTR _fX$[ebp]
  002cf	f3 0f 5e c8	 divss	 xmm1, xmm0
  002d3	f3 0f 11 4d c0	 movss	 DWORD PTR _fX$[ebp], xmm1

; 170  : 	fY /= ms_Viewport.Height;

  002d8	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A+12
  002dd	89 45 b4	 mov	 DWORD PTR tv408[ebp], eax
  002e0	f2 0f 2a 45 b4	 cvtsi2sd xmm0, DWORD PTR tv408[ebp]
  002e5	8b 45 b4	 mov	 eax, DWORD PTR tv408[ebp]
  002e8	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002eb	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  002f4	f2 0f 11 85 7c
	ff ff ff	 movsd	 QWORD PTR tv412[ebp], xmm0
  002fc	f2 0f 5a 85 7c
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR tv412[ebp]
  00304	f3 0f 10 4d c4	 movss	 xmm1, DWORD PTR _fY$[ebp]
  00309	f3 0f 5e c8	 divss	 xmm1, xmm0
  0030d	f3 0f 11 4d c4	 movss	 DWORD PTR _fY$[ebp], xmm1

; 172  : 	float fDistance = sqrtf(((0.5f - fX) * (0.5f - fX)) + ((0.5f - fY) * (0.5f - fY)));

  00312	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0031a	f3 0f 5c 45 c4	 subss	 xmm0, DWORD PTR _fY$[ebp]
  0031f	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f000000
  00327	f3 0f 5c 4d c4	 subss	 xmm1, DWORD PTR _fY$[ebp]
  0032c	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00330	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00338	f3 0f 5c 45 c0	 subss	 xmm0, DWORD PTR _fX$[ebp]
  0033d	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f000000
  00345	f3 0f 5c 55 c0	 subss	 xmm2, DWORD PTR _fX$[ebp]
  0034a	f3 0f 59 d0	 mulss	 xmm2, xmm0
  0034e	f3 0f 58 d1	 addss	 xmm2, xmm1
  00352	f3 0f 11 55 94	 movss	 DWORD PTR __X$[ebp], xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00357	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0035c	51		 push	 ecx
  0035d	51		 push	 ecx
  0035e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00363	e8 00 00 00 00	 call	 _sqrt
  00368	59		 pop	 ecx
  00369	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 172  : 	float fDistance = sqrtf(((0.5f - fX) * (0.5f - fX)) + ((0.5f - fY) * (0.5f - fY)));

  0036a	d9 5d b0	 fstp	 DWORD PTR _fDistance$[ebp]

; 173  : 	float fBeforeBright = Interpolate(0.0f, c_fHalfMaxBright, 1.0f - (fDistance * c_fDistanceScale));

  0036d	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _fDistance$[ebp]
  00372	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f800000
  0037a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00382	f3 0f 5c c8	 subss	 xmm1, xmm0
  00386	51		 push	 ecx
  00387	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0038c	51		 push	 ecx
  0038d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ee66666
  00395	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0039a	51		 push	 ecx
  0039b	0f 57 c0	 xorps	 xmm0, xmm0
  0039e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a3	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  003a6	e8 00 00 00 00	 call	 ?Interpolate@CLensFlare@@IAEMMMM@Z ; CLensFlare::Interpolate
  003ab	d9 5d 8c	 fstp	 DWORD PTR _fBeforeBright$[ebp]

; 174  : 	float fAfterBright = Interpolate(0.0f, 1.0f, 1.0f - (fDistance * c_fDistanceScale));

  003ae	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _fDistance$[ebp]
  003b3	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f800000
  003bb	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  003c3	f3 0f 5c c8	 subss	 xmm1, xmm0
  003c7	51		 push	 ecx
  003c8	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  003cd	51		 push	 ecx
  003ce	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003db	51		 push	 ecx
  003dc	0f 57 c0	 xorps	 xmm0, xmm0
  003df	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003e4	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  003e7	e8 00 00 00 00	 call	 ?Interpolate@CLensFlare@@IAEMMMM@Z ; CLensFlare::Interpolate
  003ec	d9 5d 90	 fstp	 DWORD PTR _fAfterBright$[ebp]

; 175  : 	
; 176  : 	SetBrightnesses(fBeforeBright, fAfterBright);

  003ef	51		 push	 ecx
  003f0	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _fAfterBright$[ebp]
  003f5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003fa	51		 push	 ecx
  003fb	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _fBeforeBright$[ebp]
  00400	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00405	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00408	e8 00 00 00 00	 call	 ?SetBrightnesses@CLensFlare@@QAEXMM@Z ; CLensFlare::SetBrightnesses

; 177  : }

  0040d	5f		 pop	 edi
  0040e	5e		 pop	 esi
  0040f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00412	33 cd		 xor	 ecx, ebp
  00414	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00419	c9		 leave
  0041a	c2 04 00	 ret	 4
?Compute@CLensFlare@@QAEXABUD3DXVECTOR3@@@Z ENDP	; CLensFlare::Compute
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ??1CLensFlare@@UAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
??1CLensFlare@@UAE@XZ PROC				; CLensFlare::~CLensFlare, COMDAT
; _this$ = ecx

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CLensFlare@@6B@

; 112  :     delete[] m_pControlPixels;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00018	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  0001b	ff 75 f8	 push	 DWORD PTR $T2[ebp]
  0001e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00023	59		 pop	 ecx

; 113  :     delete[] m_pTestPixels;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  0002a	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0002d	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00030	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00035	59		 pop	 ecx

; 114  : }

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 c1 54	 add	 ecx, 84			; 00000054H
  0003c	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	83 c1 24	 add	 ecx, 36			; 00000024H
  00047	e8 00 00 00 00	 call	 ??1CFlare@@UAE@XZ	; CFlare::~CFlare
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  00054	c9		 leave
  00055	c3		 ret	 0
??1CLensFlare@@UAE@XZ ENDP				; CLensFlare::~CLensFlare
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ??0CLensFlare@@QAE@XZ
_TEXT	SEGMENT
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CLensFlare@@QAE@XZ PROC				; CLensFlare::CLensFlare, COMDAT
; _this$ = ecx

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CLensFlare@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CLensFlare@@6B@

; 92   :     m_fBeforeBright(0.0f),

  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	0f 57 c0	 xorps	 xmm0, xmm0
  00043	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 93   :     m_fAfterBright(0.0f),

  00048	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	0f 57 c0	 xorps	 xmm0, xmm0
  0004e	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 94   :     m_bFlareVisible(false),

  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	c6 40 1c 00	 mov	 BYTE PTR [eax+28], 0

; 95   :     m_bDrawFlare(true),

  0005a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c6 40 1d 01	 mov	 BYTE PTR [eax+29], 1

; 96   :     m_bDrawBrightScreen(true),

  00061	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00064	c6 40 1e 01	 mov	 BYTE PTR [eax+30], 1

; 91   :     m_fSunSize(0),

  00068	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	0f 57 c0	 xorps	 xmm0, xmm0
  0006e	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0

; 100  : {

  00073	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 c1 24	 add	 ecx, 36			; 00000024H
  00079	e8 00 00 00 00	 call	 ??0CFlare@@QAE@XZ	; CFlare::CFlare
  0007e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 97   : 	m_bEnabled(true),

  00082	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00085	c6 40 3c 01	 mov	 BYTE PTR [eax+60], 1

; 98   : 	m_bShowMainFlare(true),

  00089	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	c6 40 3d 01	 mov	 BYTE PTR [eax+61], 1

; 99   : 	m_fMaxBrightness(1.0f)

  00090	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00093	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0009b	f3 0f 11 40 40	 movss	 DWORD PTR [eax+64], xmm0

; 100  : {

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	83 c1 54	 add	 ecx, 84			; 00000054H
  000a6	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  000ab	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 101  :     m_pControlPixels = new float[c_nDepthTestDimension * c_nDepthTestDimension];

  000af	68 84 03 00 00	 push	 900			; 00000384H
  000b4	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000b9	59		 pop	 ecx
  000ba	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  000bd	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  000c3	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 102  :     m_pTestPixels = new float[c_nDepthTestDimension * c_nDepthTestDimension];

  000c6	68 84 03 00 00	 push	 900			; 00000384H
  000cb	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000d0	59		 pop	 ecx
  000d1	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  000d4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	8b 4d e8	 mov	 ecx, DWORD PTR $T2[ebp]
  000da	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 103  : 	m_afColor[0] = m_afColor[1] = m_afColor[2] = 1.0f;

  000dd	6a 04		 push	 4
  000df	58		 pop	 eax
  000e0	d1 e0		 shl	 eax, 1
  000e2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000ed	f3 0f 11 44 01
	44		 movss	 DWORD PTR [ecx+eax+68], xmm0
  000f3	6a 04		 push	 4
  000f5	58		 pop	 eax
  000f6	c1 e0 00	 shl	 eax, 0
  000f9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00104	f3 0f 11 44 01
	44		 movss	 DWORD PTR [ecx+eax+68], xmm0
  0010a	6a 04		 push	 4
  0010c	58		 pop	 eax
  0010d	6b c0 00	 imul	 eax, eax, 0
  00110	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00113	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0011b	f3 0f 11 44 01
	44		 movss	 DWORD PTR [ecx+eax+68], xmm0

; 104  : }

  00121	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00125	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00128	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00132	59		 pop	 ecx
  00133	c9		 leave
  00134	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CLensFlare@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
__unwindfunclet$??0CLensFlare@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 24	 add	 ecx, 36			; 00000024H
  0000e	e9 00 00 00 00	 jmp	 ??1CFlare@@UAE@XZ	; CFlare::~CFlare
__unwindfunclet$??0CLensFlare@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 54	 add	 ecx, 84			; 00000054H
  00019	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  0001e	cc		 int	 3
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
__ehhandler$??0CLensFlare@@QAE@XZ:
  00023	90		 npad	 1
  00024	90		 npad	 1
  00025	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00029	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002c	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CLensFlare@@QAE@XZ
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CLensFlare@@QAE@XZ ENDP				; CLensFlare::CLensFlare
; Function compile flags: /Odspy
;	COMDAT ??_GCFlare@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCFlare@@UAEPAXI@Z PROC				; CFlare::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CFlare@@UAE@XZ	; CFlare::~CFlare
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 10		 push	 16			; 00000010H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GCFlare@@UAEPAXI@Z ENDP				; CFlare::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@CAXXZ PROC ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@CAXXZ ENDP ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXXZ PROC ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAXPAPAUSFlarePiece@CFlare@@QAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z ; std::_Destroy_range<std::allocator<CFlare::SFlarePiece *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXXZ ENDP ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXQAPAUSFlarePiece@CFlare@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXQAPAUSFlarePiece@CFlare@@II@Z PROC ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAXPAPAUSFlarePiece@CFlare@@QAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z ; std::_Destroy_range<std::allocator<CFlare::SFlarePiece *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXQAPAUSFlarePiece@CFlare@@II@Z ENDP ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@ABEII@Z PROC ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@ABEII@Z ENDP ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXPAPAUSFlarePiece@CFlare@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXPAPAUSFlarePiece@CFlare@@0@Z PROC ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@YAXPAPAUSFlarePiece@CFlare@@QAPAU12@AAV?$allocator@PAUSFlarePiece@CFlare@@@0@@Z ; std::_Destroy_range<std::allocator<CFlare::SFlarePiece *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXPAPAUSFlarePiece@CFlare@@0@Z ENDP ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAUSFlarePiece@CFlare@@@std@@QAEXQAPAUSFlarePiece@CFlare@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAUSFlarePiece@CFlare@@@std@@QAEXQAPAUSFlarePiece@CFlare@@I@Z PROC ; std::allocator<CFlare::SFlarePiece *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAUSFlarePiece@CFlare@@@std@@QAEXQAPAUSFlarePiece@CFlare@@I@Z ENDP ; std::allocator<CFlare::SFlarePiece *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.h
;	COMDAT ??0SFlarePiece@CFlare@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SFlarePiece@CFlare@@QAE@XZ PROC			; CFlare::SFlarePiece::SFlarePiece, COMDAT
; _this$ = ecx

; 65   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance

; 62   : 	m_fPosition(0.0f),

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	0f 57 c0	 xorps	 xmm0, xmm0
  00015	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0

; 63   : 		m_fWidth(0.0f),

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	0f 57 c0	 xorps	 xmm0, xmm0
  00020	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0

; 64   : 		m_pColor(NULL)

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	83 60 28 00	 and	 DWORD PTR [eax+40], 0

; 66   : 	}

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c9		 leave
  00030	c3		 ret	 0
??0SFlarePiece@CFlare@@QAE@XZ ENDP			; CFlare::SFlarePiece::SFlarePiece
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ??1CFlare@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CFlare@@UAE@XZ PROC					; CFlare::~CFlare, COMDAT
; _this$ = ecx

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CFlare@@6B@

; 503  : }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@AAEXXZ ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 503  : }

  0001b	c9		 leave
  0001c	c3		 ret	 0
??1CFlare@@UAE@XZ ENDP					; CFlare::~CFlare
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ??0CFlare@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$1 = -4						; size = 4
??0CFlare@@QAE@XZ PROC					; CFlare::CFlare, COMDAT
; _this$ = ecx

; 494  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CFlare@@6B@
  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 fc	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$1[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$1[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$1[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 495  : }

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	c9		 leave
  0003f	c3		 ret	 0
??0CFlare@@QAE@XZ ENDP					; CFlare::CFlare
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -144						; size = 4
$T2 = -140						; size = 4
$T3 = -136						; size = 4
tv172 = -132						; size = 4
tv164 = -128						; size = 4
tv170 = -124						; size = 4
tv168 = -120						; size = 4
tv163 = -116						; size = 4
tv175 = -112						; size = 4
_pResource$4 = -108					; size = 4
tv146 = -104						; size = 4
$T5 = -100						; size = 4
_pPiece$6 = -96						; size = 4
_i$ = -92						; size = 4
$T7 = -88						; size = 24
$T8 = -64						; size = 24
$T9 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strPath$ = 8						; size = 24
?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CFlare::Init, COMDAT
; _this$ = ecx

; 510  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00031	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 511  : 	int i = 0;

  00035	83 65 a4 00	 and	 DWORD PTR _i$[ebp], 0
$LN2@Init:

; 512  : 
; 513  : 	while (g_strFiles[i] != "")

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0003e	6b 45 a4 18	 imul	 eax, DWORD PTR _i$[ebp], 24
  00042	05 00 00 00 00	 add	 eax, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
  0004d	59		 pop	 ecx
  0004e	59		 pop	 ecx
  0004f	0f b6 c0	 movzx	 eax, al
  00052	85 c0		 test	 eax, eax
  00054	0f 84 50 01 00
	00		 je	 $LN3@Init

; 515  : 		CResource * pResource = CResourceManager::Instance().GetResourcePointer((strPath + "/" + string(g_strFiles[i])).c_str());

  0005a	6b 45 a4 18	 imul	 eax, DWORD PTR _i$[ebp], 24
  0005e	05 00 00 00 00	 add	 eax, OFFSET ?g_strFiles@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00063	50		 push	 eax
  00064	8d 4d a8	 lea	 ecx, DWORD PTR $T7[ebp]
  00067	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0006c	89 45 90	 mov	 DWORD PTR tv175[ebp], eax
  0006f	8b 45 90	 mov	 eax, DWORD PTR tv175[ebp]
  00072	89 45 88	 mov	 DWORD PTR tv168[ebp], eax
  00075	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1@
  0007e	8d 45 08	 lea	 eax, DWORD PTR _strPath$[ebp]
  00081	50		 push	 eax
  00082	8d 45 c0	 lea	 eax, DWORD PTR $T8[ebp]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008e	89 45 8c	 mov	 DWORD PTR tv163[ebp], eax
  00091	8b 45 8c	 mov	 eax, DWORD PTR tv163[ebp]
  00094	89 45 84	 mov	 DWORD PTR tv170[ebp], eax
  00097	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0009b	ff 75 88	 push	 DWORD PTR tv168[ebp]
  0009e	ff 75 84	 push	 DWORD PTR tv170[ebp]
  000a1	8d 45 d8	 lea	 eax, DWORD PTR $T9[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ad	89 45 80	 mov	 DWORD PTR tv164[ebp], eax
  000b0	8b 45 80	 mov	 eax, DWORD PTR tv164[ebp]
  000b3	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv172[ebp], eax
  000b9	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  000c2	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 515  : 		CResource * pResource = CResourceManager::Instance().GetResourcePointer((strPath + "/" + string(g_strFiles[i])).c_str());

  000c8	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv172[ebp]
  000ce	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000d3	50		 push	 eax
  000d4	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  000da	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  000df	89 45 94	 mov	 DWORD PTR _pResource$4[ebp], eax
  000e2	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000e6	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  000e9	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 515  : 		CResource * pResource = CResourceManager::Instance().GetResourcePointer((strPath + "/" + string(g_strFiles[i])).c_str());

  000ee	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000f2	8d 4d c0	 lea	 ecx, DWORD PTR $T8[ebp]
  000f5	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 515  : 		CResource * pResource = CResourceManager::Instance().GetResourcePointer((strPath + "/" + string(g_strFiles[i])).c_str());

  000fa	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000fe	8d 4d a8	 lea	 ecx, DWORD PTR $T7[ebp]
  00101	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 517  : 		if (!pResource->IsType(CGraphicImage::Type()))

  00106	e8 00 00 00 00	 call	 ?Type@CGraphicImage@@SAKXZ ; CGraphicImage::Type
  0010b	50		 push	 eax
  0010c	8b 4d 94	 mov	 ecx, DWORD PTR _pResource$4[ebp]
  0010f	e8 00 00 00 00	 call	 ?IsType@CResource@@QAE_NK@Z ; CResource::IsType

; 518  : 			assert(false);
; 519  : 
; 520  : 		SFlarePiece * pPiece = new SFlarePiece;

  00114	6a 2c		 push	 44			; 0000002cH
  00116	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0011b	59		 pop	 ecx
  0011c	89 45 9c	 mov	 DWORD PTR $T5[ebp], eax
  0011f	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00123	83 7d 9c 00	 cmp	 DWORD PTR $T5[ebp], 0
  00127	74 0d		 je	 SHORT $LN6@Init
  00129	8b 4d 9c	 mov	 ecx, DWORD PTR $T5[ebp]
  0012c	e8 00 00 00 00	 call	 ??0SFlarePiece@CFlare@@QAE@XZ ; CFlare::SFlarePiece::SFlarePiece
  00131	89 45 98	 mov	 DWORD PTR tv146[ebp], eax
  00134	eb 04		 jmp	 SHORT $LN7@Init
$LN6@Init:
  00136	83 65 98 00	 and	 DWORD PTR tv146[ebp], 0
$LN7@Init:
  0013a	8b 45 98	 mov	 eax, DWORD PTR tv146[ebp]
  0013d	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00143	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00147	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  0014d	89 45 a0	 mov	 DWORD PTR _pPiece$6[ebp], eax

; 521  : 
; 522  : 		pPiece->m_imageInstance.SetImagePointer(static_cast<CGraphicImage *> (pResource));

  00150	ff 75 94	 push	 DWORD PTR _pResource$4[ebp]
  00153	8b 4d a0	 mov	 ecx, DWORD PTR _pPiece$6[ebp]
  00156	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 523  : 		pPiece->m_fPosition = g_fPosition[i];

  0015b	8b 45 a0	 mov	 eax, DWORD PTR _pPiece$6[ebp]
  0015e	8b 4d a4	 mov	 ecx, DWORD PTR _i$[ebp]
  00161	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR ?g_fPosition@@3PAMA[ecx*4]
  00168	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 524  : 		pPiece->m_fWidth = g_fWidth[i];

  0016b	8b 45 a0	 mov	 eax, DWORD PTR _pPiece$6[ebp]
  0016e	8b 4d a4	 mov	 ecx, DWORD PTR _i$[ebp]
  00171	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR ?g_fWidth@@3PAMA[ecx*4]
  00178	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 525  : 		pPiece->m_pColor = g_afColors[i];

  0017b	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  0017e	c1 e0 04	 shl	 eax, 4
  00181	05 00 00 00 00	 add	 eax, OFFSET ?g_afColors@@3PAY03MA
  00186	8b 4d a0	 mov	 ecx, DWORD PTR _pPiece$6[ebp]
  00189	89 41 28	 mov	 DWORD PTR [ecx+40], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0018c	8d 45 a0	 lea	 eax, DWORD PTR _pPiece$6[ebp]
  0018f	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 527  : 		m_vFlares.push_back(pPiece);

  00190	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00196	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00199	e8 00 00 00 00	 call	 ??$emplace_back@ABQAUSFlarePiece@CFlare@@@?$vector@PAUSFlarePiece@CFlare@@V?$allocator@PAUSFlarePiece@CFlare@@@std@@@std@@QAEXABQAUSFlarePiece@CFlare@@@Z ; std::vector<CFlare::SFlarePiece *,std::allocator<CFlare::SFlarePiece *> >::emplace_back<CFlare::SFlarePiece * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 528  : 		i++;

  0019e	8b 45 a4	 mov	 eax, DWORD PTR _i$[ebp]
  001a1	40		 inc	 eax
  001a2	89 45 a4	 mov	 DWORD PTR _i$[ebp], eax

; 529  : 	}

  001a5	e9 8f fe ff ff	 jmp	 $LN2@Init
$LN3@Init:

; 530  : }

  001aa	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  001ae	8d 4d 08	 lea	 ecx, DWORD PTR _strPath$[ebp]
  001b1	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 530  : }

  001b6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c0	59		 pop	 ecx
  001c1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c4	33 cd		 xor	 ecx, ebp
  001c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001cb	c9		 leave
  001cc	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strPath$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
  00008	8d 4d a8	 lea	 ecx, DWORD PTR $T7[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
  00010	8d 4d c0	 lea	 ecx, DWORD PTR $T8[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$3:
  00018	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$4:
  00020	6a 2c		 push	 44			; 0000002cH
  00022	ff 75 9c	 push	 DWORD PTR $T5[ebp]
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	59		 pop	 ecx
  0002b	59		 pop	 ecx
  0002c	c3		 ret	 0
  0002d	cc		 int	 3
  0002e	cc		 int	 3
  0002f	cc		 int	 3
  00030	cc		 int	 3
  00031	cc		 int	 3
__ehhandler$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00032	90		 npad	 1
  00033	90		 npad	 1
  00034	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00038	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003b	8b 8a 78 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-136]
  00041	33 c8		 xor	 ecx, eax
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0004b	33 c8		 xor	 ecx, eax
  0004d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00052	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00057	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Init@CFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CFlare::Init
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp
;	COMDAT ?Draw@CFlare@@QAEXMHHHH@Z
_TEXT	SEGMENT
_dwB$1 = -328						; size = 4
__My_data$2 = -324					; size = 4
_dwB$3 = -320						; size = 4
_dwA$4 = -316						; size = 4
_dwR$5 = -312						; size = 4
_dwG$6 = -308						; size = 4
_dwB$7 = -304						; size = 4
_dwA$8 = -300						; size = 4
_dwR$9 = -296						; size = 4
_dwG$10 = -292						; size = 4
__My_data$11 = -288					; size = 4
_dwA$12 = -284						; size = 4
_dwR$13 = -280						; size = 4
_dwG$14 = -276						; size = 4
_dwB$15 = -272						; size = 4
_dwA$16 = -268						; size = 4
_dwR$17 = -264						; size = 4
_dwG$18 = -260						; size = 4
$T19 = -256						; size = 4
$T20 = -252						; size = 4
$T21 = -248						; size = 4
_fa$ = -244						; size = 4
_fb$ = -240						; size = 4
_fg$ = -236						; size = 4
_fr$ = -232						; size = 4
$T22 = -228						; size = 4
$T23 = -224						; size = 4
$T24 = -220						; size = 4
$T25 = -216						; size = 4
__My_data$26 = -212					; size = 4
__My_data$27 = -208					; size = 4
__My_data$28 = -204					; size = 4
__My_data$29 = -200					; size = 4
$T30 = -196						; size = 4
__My_data$31 = -192					; size = 4
_fDY$ = -188						; size = 4
$T32 = -184						; size = 4
__My_data$33 = -180					; size = 4
_fDX$ = -176						; size = 4
$T34 = -172						; size = 4
tv475 = -168						; size = 4
tv465 = -164						; size = 4
tv574 = -160						; size = 4
tv573 = -156						; size = 4
tv563 = -152						; size = 4
tv562 = -148						; size = 4
tv552 = -144						; size = 4
tv551 = -140						; size = 4
tv541 = -136						; size = 4
tv540 = -132						; size = 4
tv525 = -128						; size = 4
tv524 = -124						; size = 4
tv514 = -120						; size = 4
tv513 = -116						; size = 4
tv503 = -112						; size = 4
tv502 = -108						; size = 4
tv492 = -104						; size = 4
tv491 = -100						; size = 4
tv476 = -96						; size = 4
tv464 = -92						; size = 4
tv454 = -88						; size = 4
tv453 = -84						; size = 4
tv443 = -80						; size = 4
tv442 = -76						; size = 4
tv427 = -72						; size = 4
tv426 = -68						; size = 4
tv416 = -64						; size = 4
tv415 = -60						; size = 4
tv405 = -56						; size = 4
tv404 = -52						; size = 4
tv394 = -48						; size = 4
tv393 = -44						; size = 4
__My_data$35 = -40					; size = 4
_fCenterY$36 = -36					; size = 4
_fCenterX$37 = -32					; size = 4
_fW$38 = -28						; size = 4
_this$ = -24						; size = 4
_i$39 = -20						; size = 4
_d3dColor$40 = -16					; size = 16
_vertices$41 = 0					; size = 96
__$ArrayPad$ = 96					; size = 4
_fBrightScale$ = 108					; size = 4
_nWidth$ = 112						; size = 4
_nHeight$ = 116						; size = 4
_nX$ = 120						; size = 4
_nY$ = 124						; size = 4
?Draw@CFlare@@QAEXMHHHH@Z PROC				; CFlare::Draw, COMDAT
; _this$ = ecx

; 536  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 9c	 lea	 ebp, DWORD PTR [esp-100]
  00005	81 ec ac 01 00
	00		 sub	 esp, 428		; 000001acH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 60	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 537  : 	STATEMANAGER.SaveRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);

  00019	6a 02		 push	 2
  0001b	6a 14		 push	 20			; 00000014H
  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00023	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 538  : 
; 539  : 	float fDX = float(nX) - float(nWidth) / 2.0f;

  00028	f3 0f 2a 45 78	 cvtsi2ss xmm0, DWORD PTR _nX$[ebp]
  0002d	f3 0f 2a 4d 70	 cvtsi2ss xmm1, DWORD PTR _nWidth$[ebp]
  00032	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  0003a	f3 0f 5c c1	 subss	 xmm0, xmm1
  0003e	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _fDX$[ebp], xmm0

; 540  : 	float fDY = float(nY) - float(nHeight) / 2.0f;

  00046	f3 0f 2a 45 7c	 cvtsi2ss xmm0, DWORD PTR _nY$[ebp]
  0004b	f3 0f 2a 4d 74	 cvtsi2ss xmm1, DWORD PTR _nHeight$[ebp]
  00050	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40000000
  00058	f3 0f 5c c1	 subss	 xmm0, xmm1
  0005c	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _fDY$[ebp], xmm0

; 541  : 
; 542  : 	STATEMANAGER.SetTexture(1, NULL);

  00064	6a 00		 push	 0
  00066	6a 01		 push	 1
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0006e	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 543  : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1);

  00073	68 42 01 00 00	 push	 322			; 00000142H
  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0007e	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 544  : 
; 545  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1,	D3DTA_TEXTURE);

  00083	6a 02		 push	 2
  00085	6a 02		 push	 2
  00087	6a 00		 push	 0
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0008f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 546  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2,	D3DTA_DIFFUSE);

  00094	6a 00		 push	 0
  00096	6a 03		 push	 3
  00098	6a 00		 push	 0
  0009a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000a0	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 547  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,	D3DTOP_MODULATE);

  000a5	6a 04		 push	 4
  000a7	6a 01		 push	 1
  000a9	6a 00		 push	 0
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000b1	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 548  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1,	D3DTA_TEXTURE);

  000b6	6a 02		 push	 2
  000b8	6a 05		 push	 5
  000ba	6a 00		 push	 0
  000bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000c2	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 549  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG2,	D3DTA_DIFFUSE);

  000c7	6a 00		 push	 0
  000c9	6a 06		 push	 6
  000cb	6a 00		 push	 0
  000cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000d3	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 550  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,	D3DTOP_MODULATE);

  000d8	6a 04		 push	 4
  000da	6a 04		 push	 4
  000dc	6a 00		 push	 0
  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000e4	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 552  : 	for (unsigned int i = 0; i < m_vFlares.size(); i++)

  000e9	83 65 ec 00	 and	 DWORD PTR _i$39[ebp], 0
  000ed	eb 07		 jmp	 SHORT $LN4@Draw
$LN2@Draw:
  000ef	8b 45 ec	 mov	 eax, DWORD PTR _i$39[ebp]
  000f2	40		 inc	 eax
  000f3	89 45 ec	 mov	 DWORD PTR _i$39[ebp], eax
$LN4@Draw:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  000f6	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	83 c0 04	 add	 eax, 4
  000fc	89 45 d8	 mov	 DWORD PTR __My_data$35[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000ff	8b 45 d8	 mov	 eax, DWORD PTR __My_data$35[ebp]
  00102	8b 4d d8	 mov	 ecx, DWORD PTR __My_data$35[ebp]
  00105	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00108	2b 01		 sub	 eax, DWORD PTR [ecx]
  0010a	c1 f8 02	 sar	 eax, 2
  0010d	89 85 08 ff ff
	ff		 mov	 DWORD PTR $T21[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 552  : 	for (unsigned int i = 0; i < m_vFlares.size(); i++)

  00113	8b 45 ec	 mov	 eax, DWORD PTR _i$39[ebp]
  00116	3b 85 08 ff ff
	ff		 cmp	 eax, DWORD PTR $T21[ebp]
  0011c	0f 83 16 0a 00
	00		 jae	 $LN3@Draw
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00122	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00125	83 c0 04	 add	 eax, 4
  00128	89 85 bc fe ff
	ff		 mov	 DWORD PTR __My_data$2[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0012e	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR __My_data$2[ebp]
  00134	8b 00		 mov	 eax, DWORD PTR [eax]
  00136	8b 4d ec	 mov	 ecx, DWORD PTR _i$39[ebp]
  00139	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0013c	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T34[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 554  : 		float fCenterX = float(nX) - (m_vFlares[i]->m_fPosition + 1.0f) * fDX;

  00142	f3 0f 2a 45 78	 cvtsi2ss xmm0, DWORD PTR _nX$[ebp]
  00147	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR $T34[ebp]
  0014d	8b 00		 mov	 eax, DWORD PTR [eax]
  0014f	f3 0f 10 48 20	 movss	 xmm1, DWORD PTR [eax+32]
  00154	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
  0015c	f3 0f 59 8d 50
	ff ff ff	 mulss	 xmm1, DWORD PTR _fDX$[ebp]
  00164	f3 0f 5c c1	 subss	 xmm0, xmm1
  00168	f3 0f 11 45 e0	 movss	 DWORD PTR _fCenterX$37[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0016d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00170	83 c0 04	 add	 eax, 4
  00173	89 85 4c ff ff
	ff		 mov	 DWORD PTR __My_data$33[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00179	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR __My_data$33[ebp]
  0017f	8b 00		 mov	 eax, DWORD PTR [eax]
  00181	8b 4d ec	 mov	 ecx, DWORD PTR _i$39[ebp]
  00184	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00187	89 85 48 ff ff
	ff		 mov	 DWORD PTR $T32[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 555  : 		float fCenterY = float(nY) - (m_vFlares[i]->m_fPosition + 1.0f) * fDY;

  0018d	f3 0f 2a 45 7c	 cvtsi2ss xmm0, DWORD PTR _nY$[ebp]
  00192	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR $T32[ebp]
  00198	8b 00		 mov	 eax, DWORD PTR [eax]
  0019a	f3 0f 10 48 20	 movss	 xmm1, DWORD PTR [eax+32]
  0019f	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
  001a7	f3 0f 59 8d 44
	ff ff ff	 mulss	 xmm1, DWORD PTR _fDY$[ebp]
  001af	f3 0f 5c c1	 subss	 xmm0, xmm1
  001b3	f3 0f 11 45 dc	 movss	 DWORD PTR _fCenterY$36[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  001b8	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001bb	83 c0 04	 add	 eax, 4
  001be	89 85 40 ff ff
	ff		 mov	 DWORD PTR __My_data$31[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  001c4	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$31[ebp]
  001ca	8b 00		 mov	 eax, DWORD PTR [eax]
  001cc	8b 4d ec	 mov	 ecx, DWORD PTR _i$39[ebp]
  001cf	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  001d2	89 85 3c ff ff
	ff		 mov	 DWORD PTR $T30[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 556  : 		float fW = m_vFlares[i]->m_fWidth;

  001d8	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR $T30[ebp]
  001de	8b 00		 mov	 eax, DWORD PTR [eax]
  001e0	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  001e5	f3 0f 11 45 e4	 movss	 DWORD PTR _fW$38[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  001ea	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001ed	83 c0 04	 add	 eax, 4
  001f0	89 85 38 ff ff
	ff		 mov	 DWORD PTR __My_data$29[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  001f6	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$29[ebp]
  001fc	8b 00		 mov	 eax, DWORD PTR [eax]
  001fe	8b 4d ec	 mov	 ecx, DWORD PTR _i$39[ebp]
  00201	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00204	89 85 1c ff ff
	ff		 mov	 DWORD PTR $T22[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0020a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0020d	83 c0 04	 add	 eax, 4
  00210	89 85 34 ff ff
	ff		 mov	 DWORD PTR __My_data$28[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00216	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$28[ebp]
  0021c	8b 00		 mov	 eax, DWORD PTR [eax]
  0021e	8b 4d ec	 mov	 ecx, DWORD PTR _i$39[ebp]
  00221	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00224	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T23[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0022a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0022d	83 c0 04	 add	 eax, 4
  00230	89 85 30 ff ff
	ff		 mov	 DWORD PTR __My_data$27[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00236	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$27[ebp]
  0023c	8b 00		 mov	 eax, DWORD PTR [eax]
  0023e	8b 4d ec	 mov	 ecx, DWORD PTR _i$39[ebp]
  00241	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00244	89 85 24 ff ff
	ff		 mov	 DWORD PTR $T24[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0024a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0024d	83 c0 04	 add	 eax, 4
  00250	89 85 2c ff ff
	ff		 mov	 DWORD PTR __My_data$26[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00256	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR __My_data$26[ebp]
  0025c	8b 00		 mov	 eax, DWORD PTR [eax]
  0025e	8b 4d ec	 mov	 ecx, DWORD PTR _i$39[ebp]
  00261	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00264	89 85 28 ff ff
	ff		 mov	 DWORD PTR $T25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 558  : 		D3DXCOLOR d3dColor(m_vFlares[i]->m_pColor[0] * fBrightScale,

  0026a	6a 04		 push	 4
  0026c	58		 pop	 eax
  0026d	6b c0 00	 imul	 eax, eax, 0
  00270	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR $T25[ebp]
  00276	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00278	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  0027b	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00280	f3 0f 59 45 6c	 mulss	 xmm0, DWORD PTR _fBrightScale$[ebp]
  00285	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR _fr$[ebp], xmm0
  0028d	6a 04		 push	 4
  0028f	58		 pop	 eax
  00290	c1 e0 00	 shl	 eax, 0
  00293	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR $T24[ebp]
  00299	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0029b	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  0029e	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  002a3	f3 0f 59 45 6c	 mulss	 xmm0, DWORD PTR _fBrightScale$[ebp]
  002a8	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _fg$[ebp], xmm0
  002b0	6a 04		 push	 4
  002b2	58		 pop	 eax
  002b3	d1 e0		 shl	 eax, 1
  002b5	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR $T23[ebp]
  002bb	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002bd	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  002c0	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  002c5	f3 0f 59 45 6c	 mulss	 xmm0, DWORD PTR _fBrightScale$[ebp]
  002ca	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _fb$[ebp], xmm0
  002d2	6a 04		 push	 4
  002d4	58		 pop	 eax
  002d5	6b c0 03	 imul	 eax, eax, 3
  002d8	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp]
  002de	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002e0	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  002e3	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  002e8	f3 0f 59 45 6c	 mulss	 xmm0, DWORD PTR _fBrightScale$[ebp]
  002ed	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR _fa$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 920  :     r = fr;

  002f5	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _fr$[ebp]
  002fd	f3 0f 11 45 f0	 movss	 DWORD PTR _d3dColor$40[ebp], xmm0

; 921  :     g = fg;

  00302	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _fg$[ebp]
  0030a	f3 0f 11 45 f4	 movss	 DWORD PTR _d3dColor$40[ebp+4], xmm0

; 922  :     b = fb;

  0030f	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _fb$[ebp]
  00317	f3 0f 11 45 f8	 movss	 DWORD PTR _d3dColor$40[ebp+8], xmm0

; 923  :     a = fa;

  0031c	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _fa$[ebp]
  00324	f3 0f 11 45 fc	 movss	 DWORD PTR _d3dColor$40[ebp+12], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00329	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0032c	83 c0 04	 add	 eax, 4
  0032f	89 85 e0 fe ff
	ff		 mov	 DWORD PTR __My_data$11[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00335	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$11[ebp]
  0033b	8b 00		 mov	 eax, DWORD PTR [eax]
  0033d	8b 4d ec	 mov	 ecx, DWORD PTR _i$39[ebp]
  00340	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00343	89 85 04 ff ff
	ff		 mov	 DWORD PTR $T20[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00349	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0034e	89 85 00 ff ff
	ff		 mov	 DWORD PTR $T19[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 563  : 		STATEMANAGER.SetTexture(0, m_vFlares[i]->m_imageInstance.GetTexturePointer()->GetD3DTexture());

  00354	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR $T20[ebp]
  0035a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0035c	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  00361	8b c8		 mov	 ecx, eax
  00363	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00368	50		 push	 eax
  00369	6a 00		 push	 0
  0036b	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR $T19[ebp]
  00371	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 564  : 
; 565  : 		TVertex vertices[4];
; 566  : 		
; 567  : 		vertices[0].u = 0.0f;

  00376	6a 18		 push	 24			; 00000018H
  00378	58		 pop	 eax
  00379	6b c0 00	 imul	 eax, eax, 0
  0037c	0f 57 c0	 xorps	 xmm0, xmm0
  0037f	f3 0f 11 44 05
	10		 movss	 DWORD PTR _vertices$41[ebp+eax+16], xmm0

; 568  : 		vertices[0].v = 0.0f;

  00385	6a 18		 push	 24			; 00000018H
  00387	58		 pop	 eax
  00388	6b c0 00	 imul	 eax, eax, 0
  0038b	0f 57 c0	 xorps	 xmm0, xmm0
  0038e	f3 0f 11 44 05
	14		 movss	 DWORD PTR _vertices$41[ebp+eax+20], xmm0

; 569  : 		vertices[0].x = fCenterX - fW;

  00394	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fCenterX$37[ebp]
  00399	f3 0f 5c 45 e4	 subss	 xmm0, DWORD PTR _fW$38[ebp]
  0039e	6a 18		 push	 24			; 00000018H
  003a0	58		 pop	 eax
  003a1	6b c0 00	 imul	 eax, eax, 0
  003a4	f3 0f 11 44 05
	00		 movss	 DWORD PTR _vertices$41[ebp+eax], xmm0

; 570  : 		vertices[0].y = fCenterY - fW;

  003aa	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fCenterY$36[ebp]
  003af	f3 0f 5c 45 e4	 subss	 xmm0, DWORD PTR _fW$38[ebp]
  003b4	6a 18		 push	 24			; 00000018H
  003b6	58		 pop	 eax
  003b7	6b c0 00	 imul	 eax, eax, 0
  003ba	f3 0f 11 44 05
	04		 movss	 DWORD PTR _vertices$41[ebp+eax+4], xmm0

; 571  : 		vertices[0].z = 0.0f;

  003c0	6a 18		 push	 24			; 00000018H
  003c2	58		 pop	 eax
  003c3	6b c0 00	 imul	 eax, eax, 0
  003c6	0f 57 c0	 xorps	 xmm0, xmm0
  003c9	f3 0f 11 44 05
	08		 movss	 DWORD PTR _vertices$41[ebp+eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  003cf	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp]
  003d4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  003db	72 09		 jb	 SHORT $LN59@Draw
  003dd	c7 45 d0 ff 00
	00 00		 mov	 DWORD PTR tv394[ebp], 255 ; 000000ffH
  003e4	eb 32		 jmp	 SHORT $LN60@Draw
$LN59@Draw:
  003e6	0f 57 c0	 xorps	 xmm0, xmm0
  003e9	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp]
  003ed	72 06		 jb	 SHORT $LN57@Draw
  003ef	83 65 d4 00	 and	 DWORD PTR tv393[ebp], 0
  003f3	eb 1d		 jmp	 SHORT $LN58@Draw
$LN57@Draw:
  003f5	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp]
  003fa	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00402	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0040a	e8 00 00 00 00	 call	 __ftoui3
  0040f	89 45 d4	 mov	 DWORD PTR tv393[ebp], eax
$LN58@Draw:
  00412	8b 45 d4	 mov	 eax, DWORD PTR tv393[ebp]
  00415	89 45 d0	 mov	 DWORD PTR tv394[ebp], eax
$LN60@Draw:
  00418	8b 45 d0	 mov	 eax, DWORD PTR tv394[ebp]
  0041b	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _dwR$17[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00421	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+4]
  00426	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0042d	72 09		 jb	 SHORT $LN63@Draw
  0042f	c7 45 c8 ff 00
	00 00		 mov	 DWORD PTR tv405[ebp], 255 ; 000000ffH
  00436	eb 32		 jmp	 SHORT $LN64@Draw
$LN63@Draw:
  00438	0f 57 c0	 xorps	 xmm0, xmm0
  0043b	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp+4]
  0043f	72 06		 jb	 SHORT $LN61@Draw
  00441	83 65 cc 00	 and	 DWORD PTR tv404[ebp], 0
  00445	eb 1d		 jmp	 SHORT $LN62@Draw
$LN61@Draw:
  00447	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+4]
  0044c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00454	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0045c	e8 00 00 00 00	 call	 __ftoui3
  00461	89 45 cc	 mov	 DWORD PTR tv404[ebp], eax
$LN62@Draw:
  00464	8b 45 cc	 mov	 eax, DWORD PTR tv404[ebp]
  00467	89 45 c8	 mov	 DWORD PTR tv405[ebp], eax
$LN64@Draw:
  0046a	8b 45 c8	 mov	 eax, DWORD PTR tv405[ebp]
  0046d	89 85 fc fe ff
	ff		 mov	 DWORD PTR _dwG$18[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00473	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+8]
  00478	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0047f	72 09		 jb	 SHORT $LN67@Draw
  00481	c7 45 c0 ff 00
	00 00		 mov	 DWORD PTR tv416[ebp], 255 ; 000000ffH
  00488	eb 32		 jmp	 SHORT $LN68@Draw
$LN67@Draw:
  0048a	0f 57 c0	 xorps	 xmm0, xmm0
  0048d	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp+8]
  00491	72 06		 jb	 SHORT $LN65@Draw
  00493	83 65 c4 00	 and	 DWORD PTR tv415[ebp], 0
  00497	eb 1d		 jmp	 SHORT $LN66@Draw
$LN65@Draw:
  00499	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+8]
  0049e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  004a6	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  004ae	e8 00 00 00 00	 call	 __ftoui3
  004b3	89 45 c4	 mov	 DWORD PTR tv415[ebp], eax
$LN66@Draw:
  004b6	8b 45 c4	 mov	 eax, DWORD PTR tv415[ebp]
  004b9	89 45 c0	 mov	 DWORD PTR tv416[ebp], eax
$LN68@Draw:
  004bc	8b 45 c0	 mov	 eax, DWORD PTR tv416[ebp]
  004bf	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _dwB$15[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  004c5	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+12]
  004ca	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  004d1	72 09		 jb	 SHORT $LN71@Draw
  004d3	c7 45 b8 ff 00
	00 00		 mov	 DWORD PTR tv427[ebp], 255 ; 000000ffH
  004da	eb 32		 jmp	 SHORT $LN72@Draw
$LN71@Draw:
  004dc	0f 57 c0	 xorps	 xmm0, xmm0
  004df	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp+12]
  004e3	72 06		 jb	 SHORT $LN69@Draw
  004e5	83 65 bc 00	 and	 DWORD PTR tv426[ebp], 0
  004e9	eb 1d		 jmp	 SHORT $LN70@Draw
$LN69@Draw:
  004eb	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+12]
  004f0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  004f8	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00500	e8 00 00 00 00	 call	 __ftoui3
  00505	89 45 bc	 mov	 DWORD PTR tv426[ebp], eax
$LN70@Draw:
  00508	8b 45 bc	 mov	 eax, DWORD PTR tv426[ebp]
  0050b	89 45 b8	 mov	 DWORD PTR tv427[ebp], eax
$LN72@Draw:
  0050e	8b 45 b8	 mov	 eax, DWORD PTR tv427[ebp]
  00511	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _dwA$16[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 572  : 		vertices[0].color = d3dColor;

  00517	6a 18		 push	 24			; 00000018H
  00519	58		 pop	 eax
  0051a	6b c0 00	 imul	 eax, eax, 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0051d	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR _dwG$18[ebp]
  00523	c1 e1 08	 shl	 ecx, 8
  00526	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR _dwR$17[ebp]
  0052c	c1 e2 10	 shl	 edx, 16			; 00000010H
  0052f	8b b5 f4 fe ff
	ff		 mov	 esi, DWORD PTR _dwA$16[ebp]
  00535	c1 e6 18	 shl	 esi, 24			; 00000018H
  00538	0b f2		 or	 esi, edx
  0053a	0b f1		 or	 esi, ecx
  0053c	0b b5 f0 fe ff
	ff		 or	 esi, DWORD PTR _dwB$15[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 572  : 		vertices[0].color = d3dColor;

  00542	89 74 05 0c	 mov	 DWORD PTR _vertices$41[ebp+eax+12], esi

; 573  : 
; 574  : 		vertices[1].u = 0.0f;

  00546	6a 18		 push	 24			; 00000018H
  00548	58		 pop	 eax
  00549	c1 e0 00	 shl	 eax, 0
  0054c	0f 57 c0	 xorps	 xmm0, xmm0
  0054f	f3 0f 11 44 05
	10		 movss	 DWORD PTR _vertices$41[ebp+eax+16], xmm0

; 575  : 		vertices[1].v = 1.0f;

  00555	6a 18		 push	 24			; 00000018H
  00557	58		 pop	 eax
  00558	c1 e0 00	 shl	 eax, 0
  0055b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00563	f3 0f 11 44 05
	14		 movss	 DWORD PTR _vertices$41[ebp+eax+20], xmm0

; 576  : 		vertices[1].x = fCenterX - fW;

  00569	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fCenterX$37[ebp]
  0056e	f3 0f 5c 45 e4	 subss	 xmm0, DWORD PTR _fW$38[ebp]
  00573	6a 18		 push	 24			; 00000018H
  00575	58		 pop	 eax
  00576	c1 e0 00	 shl	 eax, 0
  00579	f3 0f 11 44 05
	00		 movss	 DWORD PTR _vertices$41[ebp+eax], xmm0

; 577  : 		vertices[1].y = fCenterY + fW;

  0057f	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fCenterY$36[ebp]
  00584	f3 0f 58 45 e4	 addss	 xmm0, DWORD PTR _fW$38[ebp]
  00589	6a 18		 push	 24			; 00000018H
  0058b	58		 pop	 eax
  0058c	c1 e0 00	 shl	 eax, 0
  0058f	f3 0f 11 44 05
	04		 movss	 DWORD PTR _vertices$41[ebp+eax+4], xmm0

; 578  : 		vertices[1].z = 0.0f;

  00595	6a 18		 push	 24			; 00000018H
  00597	58		 pop	 eax
  00598	c1 e0 00	 shl	 eax, 0
  0059b	0f 57 c0	 xorps	 xmm0, xmm0
  0059e	f3 0f 11 44 05
	08		 movss	 DWORD PTR _vertices$41[ebp+eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  005a4	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp]
  005a9	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  005b0	72 09		 jb	 SHORT $LN77@Draw
  005b2	c7 45 b0 ff 00
	00 00		 mov	 DWORD PTR tv443[ebp], 255 ; 000000ffH
  005b9	eb 32		 jmp	 SHORT $LN78@Draw
$LN77@Draw:
  005bb	0f 57 c0	 xorps	 xmm0, xmm0
  005be	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp]
  005c2	72 06		 jb	 SHORT $LN75@Draw
  005c4	83 65 b4 00	 and	 DWORD PTR tv442[ebp], 0
  005c8	eb 1d		 jmp	 SHORT $LN76@Draw
$LN75@Draw:
  005ca	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp]
  005cf	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  005d7	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  005df	e8 00 00 00 00	 call	 __ftoui3
  005e4	89 45 b4	 mov	 DWORD PTR tv442[ebp], eax
$LN76@Draw:
  005e7	8b 45 b4	 mov	 eax, DWORD PTR tv442[ebp]
  005ea	89 45 b0	 mov	 DWORD PTR tv443[ebp], eax
$LN78@Draw:
  005ed	8b 45 b0	 mov	 eax, DWORD PTR tv443[ebp]
  005f0	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _dwR$13[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  005f6	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+4]
  005fb	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00602	72 09		 jb	 SHORT $LN81@Draw
  00604	c7 45 a8 ff 00
	00 00		 mov	 DWORD PTR tv454[ebp], 255 ; 000000ffH
  0060b	eb 32		 jmp	 SHORT $LN82@Draw
$LN81@Draw:
  0060d	0f 57 c0	 xorps	 xmm0, xmm0
  00610	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp+4]
  00614	72 06		 jb	 SHORT $LN79@Draw
  00616	83 65 ac 00	 and	 DWORD PTR tv453[ebp], 0
  0061a	eb 1d		 jmp	 SHORT $LN80@Draw
$LN79@Draw:
  0061c	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+4]
  00621	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00629	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00631	e8 00 00 00 00	 call	 __ftoui3
  00636	89 45 ac	 mov	 DWORD PTR tv453[ebp], eax
$LN80@Draw:
  00639	8b 45 ac	 mov	 eax, DWORD PTR tv453[ebp]
  0063c	89 45 a8	 mov	 DWORD PTR tv454[ebp], eax
$LN82@Draw:
  0063f	8b 45 a8	 mov	 eax, DWORD PTR tv454[ebp]
  00642	89 85 ec fe ff
	ff		 mov	 DWORD PTR _dwG$14[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00648	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+8]
  0064d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00654	72 0c		 jb	 SHORT $LN85@Draw
  00656	c7 85 5c ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv465[ebp], 255 ; 000000ffH
  00660	eb 35		 jmp	 SHORT $LN86@Draw
$LN85@Draw:
  00662	0f 57 c0	 xorps	 xmm0, xmm0
  00665	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp+8]
  00669	72 06		 jb	 SHORT $LN83@Draw
  0066b	83 65 a4 00	 and	 DWORD PTR tv464[ebp], 0
  0066f	eb 1d		 jmp	 SHORT $LN84@Draw
$LN83@Draw:
  00671	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+8]
  00676	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0067e	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00686	e8 00 00 00 00	 call	 __ftoui3
  0068b	89 45 a4	 mov	 DWORD PTR tv464[ebp], eax
$LN84@Draw:
  0068e	8b 45 a4	 mov	 eax, DWORD PTR tv464[ebp]
  00691	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv465[ebp], eax
$LN86@Draw:
  00697	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv465[ebp]
  0069d	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _dwB$1[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  006a3	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+12]
  006a8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  006af	72 09		 jb	 SHORT $LN89@Draw
  006b1	c7 45 a0 ff 00
	00 00		 mov	 DWORD PTR tv476[ebp], 255 ; 000000ffH
  006b8	eb 3b		 jmp	 SHORT $LN90@Draw
$LN89@Draw:
  006ba	0f 57 c0	 xorps	 xmm0, xmm0
  006bd	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp+12]
  006c1	72 09		 jb	 SHORT $LN87@Draw
  006c3	83 a5 58 ff ff
	ff 00		 and	 DWORD PTR tv475[ebp], 0
  006ca	eb 20		 jmp	 SHORT $LN88@Draw
$LN87@Draw:
  006cc	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+12]
  006d1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  006d9	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  006e1	e8 00 00 00 00	 call	 __ftoui3
  006e6	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv475[ebp], eax
$LN88@Draw:
  006ec	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv475[ebp]
  006f2	89 45 a0	 mov	 DWORD PTR tv476[ebp], eax
$LN90@Draw:
  006f5	8b 45 a0	 mov	 eax, DWORD PTR tv476[ebp]
  006f8	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _dwA$12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 579  : 		vertices[1].color = d3dColor;

  006fe	6a 18		 push	 24			; 00000018H
  00700	58		 pop	 eax
  00701	c1 e0 00	 shl	 eax, 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00704	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _dwG$14[ebp]
  0070a	c1 e1 08	 shl	 ecx, 8
  0070d	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _dwR$13[ebp]
  00713	c1 e2 10	 shl	 edx, 16			; 00000010H
  00716	8b b5 e4 fe ff
	ff		 mov	 esi, DWORD PTR _dwA$12[ebp]
  0071c	c1 e6 18	 shl	 esi, 24			; 00000018H
  0071f	0b f2		 or	 esi, edx
  00721	0b f1		 or	 esi, ecx
  00723	0b b5 b8 fe ff
	ff		 or	 esi, DWORD PTR _dwB$1[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 579  : 		vertices[1].color = d3dColor;

  00729	89 74 05 0c	 mov	 DWORD PTR _vertices$41[ebp+eax+12], esi

; 580  : 
; 581  : 		vertices[2].u = 1.0f;

  0072d	6a 18		 push	 24			; 00000018H
  0072f	58		 pop	 eax
  00730	d1 e0		 shl	 eax, 1
  00732	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0073a	f3 0f 11 44 05
	10		 movss	 DWORD PTR _vertices$41[ebp+eax+16], xmm0

; 582  : 		vertices[2].v = 0.0f;

  00740	6a 18		 push	 24			; 00000018H
  00742	58		 pop	 eax
  00743	d1 e0		 shl	 eax, 1
  00745	0f 57 c0	 xorps	 xmm0, xmm0
  00748	f3 0f 11 44 05
	14		 movss	 DWORD PTR _vertices$41[ebp+eax+20], xmm0

; 583  : 		vertices[2].x = fCenterX + fW;

  0074e	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fCenterX$37[ebp]
  00753	f3 0f 58 45 e4	 addss	 xmm0, DWORD PTR _fW$38[ebp]
  00758	6a 18		 push	 24			; 00000018H
  0075a	58		 pop	 eax
  0075b	d1 e0		 shl	 eax, 1
  0075d	f3 0f 11 44 05
	00		 movss	 DWORD PTR _vertices$41[ebp+eax], xmm0

; 584  : 		vertices[2].y = fCenterY - fW;

  00763	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fCenterY$36[ebp]
  00768	f3 0f 5c 45 e4	 subss	 xmm0, DWORD PTR _fW$38[ebp]
  0076d	6a 18		 push	 24			; 00000018H
  0076f	58		 pop	 eax
  00770	d1 e0		 shl	 eax, 1
  00772	f3 0f 11 44 05
	04		 movss	 DWORD PTR _vertices$41[ebp+eax+4], xmm0

; 585  : 		vertices[2].z = 0.0f;

  00778	6a 18		 push	 24			; 00000018H
  0077a	58		 pop	 eax
  0077b	d1 e0		 shl	 eax, 1
  0077d	0f 57 c0	 xorps	 xmm0, xmm0
  00780	f3 0f 11 44 05
	08		 movss	 DWORD PTR _vertices$41[ebp+eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00786	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp]
  0078b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00792	72 09		 jb	 SHORT $LN95@Draw
  00794	c7 45 98 ff 00
	00 00		 mov	 DWORD PTR tv492[ebp], 255 ; 000000ffH
  0079b	eb 32		 jmp	 SHORT $LN96@Draw
$LN95@Draw:
  0079d	0f 57 c0	 xorps	 xmm0, xmm0
  007a0	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp]
  007a4	72 06		 jb	 SHORT $LN93@Draw
  007a6	83 65 9c 00	 and	 DWORD PTR tv491[ebp], 0
  007aa	eb 1d		 jmp	 SHORT $LN94@Draw
$LN93@Draw:
  007ac	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp]
  007b1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  007b9	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  007c1	e8 00 00 00 00	 call	 __ftoui3
  007c6	89 45 9c	 mov	 DWORD PTR tv491[ebp], eax
$LN94@Draw:
  007c9	8b 45 9c	 mov	 eax, DWORD PTR tv491[ebp]
  007cc	89 45 98	 mov	 DWORD PTR tv492[ebp], eax
$LN96@Draw:
  007cf	8b 45 98	 mov	 eax, DWORD PTR tv492[ebp]
  007d2	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _dwR$9[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  007d8	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+4]
  007dd	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  007e4	72 09		 jb	 SHORT $LN99@Draw
  007e6	c7 45 90 ff 00
	00 00		 mov	 DWORD PTR tv503[ebp], 255 ; 000000ffH
  007ed	eb 32		 jmp	 SHORT $LN100@Draw
$LN99@Draw:
  007ef	0f 57 c0	 xorps	 xmm0, xmm0
  007f2	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp+4]
  007f6	72 06		 jb	 SHORT $LN97@Draw
  007f8	83 65 94 00	 and	 DWORD PTR tv502[ebp], 0
  007fc	eb 1d		 jmp	 SHORT $LN98@Draw
$LN97@Draw:
  007fe	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+4]
  00803	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0080b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00813	e8 00 00 00 00	 call	 __ftoui3
  00818	89 45 94	 mov	 DWORD PTR tv502[ebp], eax
$LN98@Draw:
  0081b	8b 45 94	 mov	 eax, DWORD PTR tv502[ebp]
  0081e	89 45 90	 mov	 DWORD PTR tv503[ebp], eax
$LN100@Draw:
  00821	8b 45 90	 mov	 eax, DWORD PTR tv503[ebp]
  00824	89 85 dc fe ff
	ff		 mov	 DWORD PTR _dwG$10[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  0082a	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+8]
  0082f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00836	72 09		 jb	 SHORT $LN103@Draw
  00838	c7 45 88 ff 00
	00 00		 mov	 DWORD PTR tv514[ebp], 255 ; 000000ffH
  0083f	eb 32		 jmp	 SHORT $LN104@Draw
$LN103@Draw:
  00841	0f 57 c0	 xorps	 xmm0, xmm0
  00844	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp+8]
  00848	72 06		 jb	 SHORT $LN101@Draw
  0084a	83 65 8c 00	 and	 DWORD PTR tv513[ebp], 0
  0084e	eb 1d		 jmp	 SHORT $LN102@Draw
$LN101@Draw:
  00850	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+8]
  00855	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0085d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00865	e8 00 00 00 00	 call	 __ftoui3
  0086a	89 45 8c	 mov	 DWORD PTR tv513[ebp], eax
$LN102@Draw:
  0086d	8b 45 8c	 mov	 eax, DWORD PTR tv513[ebp]
  00870	89 45 88	 mov	 DWORD PTR tv514[ebp], eax
$LN104@Draw:
  00873	8b 45 88	 mov	 eax, DWORD PTR tv514[ebp]
  00876	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _dwB$7[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  0087c	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+12]
  00881	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00888	72 09		 jb	 SHORT $LN107@Draw
  0088a	c7 45 80 ff 00
	00 00		 mov	 DWORD PTR tv525[ebp], 255 ; 000000ffH
  00891	eb 32		 jmp	 SHORT $LN108@Draw
$LN107@Draw:
  00893	0f 57 c0	 xorps	 xmm0, xmm0
  00896	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp+12]
  0089a	72 06		 jb	 SHORT $LN105@Draw
  0089c	83 65 84 00	 and	 DWORD PTR tv524[ebp], 0
  008a0	eb 1d		 jmp	 SHORT $LN106@Draw
$LN105@Draw:
  008a2	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+12]
  008a7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  008af	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  008b7	e8 00 00 00 00	 call	 __ftoui3
  008bc	89 45 84	 mov	 DWORD PTR tv524[ebp], eax
$LN106@Draw:
  008bf	8b 45 84	 mov	 eax, DWORD PTR tv524[ebp]
  008c2	89 45 80	 mov	 DWORD PTR tv525[ebp], eax
$LN108@Draw:
  008c5	8b 45 80	 mov	 eax, DWORD PTR tv525[ebp]
  008c8	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _dwA$8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 586  : 		vertices[2].color = d3dColor;

  008ce	6a 18		 push	 24			; 00000018H
  008d0	58		 pop	 eax
  008d1	d1 e0		 shl	 eax, 1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  008d3	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _dwG$10[ebp]
  008d9	c1 e1 08	 shl	 ecx, 8
  008dc	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _dwR$9[ebp]
  008e2	c1 e2 10	 shl	 edx, 16			; 00000010H
  008e5	8b b5 d4 fe ff
	ff		 mov	 esi, DWORD PTR _dwA$8[ebp]
  008eb	c1 e6 18	 shl	 esi, 24			; 00000018H
  008ee	0b f2		 or	 esi, edx
  008f0	0b f1		 or	 esi, ecx
  008f2	0b b5 d0 fe ff
	ff		 or	 esi, DWORD PTR _dwB$7[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 586  : 		vertices[2].color = d3dColor;

  008f8	89 74 05 0c	 mov	 DWORD PTR _vertices$41[ebp+eax+12], esi

; 587  : 
; 588  : 		vertices[3].u = 1.0f;

  008fc	6a 18		 push	 24			; 00000018H
  008fe	58		 pop	 eax
  008ff	6b c0 03	 imul	 eax, eax, 3
  00902	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0090a	f3 0f 11 44 05
	10		 movss	 DWORD PTR _vertices$41[ebp+eax+16], xmm0

; 589  : 		vertices[3].v = 1.0f;

  00910	6a 18		 push	 24			; 00000018H
  00912	58		 pop	 eax
  00913	6b c0 03	 imul	 eax, eax, 3
  00916	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0091e	f3 0f 11 44 05
	14		 movss	 DWORD PTR _vertices$41[ebp+eax+20], xmm0

; 590  : 		vertices[3].x = fCenterX + fW;

  00924	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fCenterX$37[ebp]
  00929	f3 0f 58 45 e4	 addss	 xmm0, DWORD PTR _fW$38[ebp]
  0092e	6a 18		 push	 24			; 00000018H
  00930	58		 pop	 eax
  00931	6b c0 03	 imul	 eax, eax, 3
  00934	f3 0f 11 44 05
	00		 movss	 DWORD PTR _vertices$41[ebp+eax], xmm0

; 591  : 		vertices[3].y = fCenterY + fW;

  0093a	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fCenterY$36[ebp]
  0093f	f3 0f 58 45 e4	 addss	 xmm0, DWORD PTR _fW$38[ebp]
  00944	6a 18		 push	 24			; 00000018H
  00946	58		 pop	 eax
  00947	6b c0 03	 imul	 eax, eax, 3
  0094a	f3 0f 11 44 05
	04		 movss	 DWORD PTR _vertices$41[ebp+eax+4], xmm0

; 592  : 		vertices[3].z = 0.0f;

  00950	6a 18		 push	 24			; 00000018H
  00952	58		 pop	 eax
  00953	6b c0 03	 imul	 eax, eax, 3
  00956	0f 57 c0	 xorps	 xmm0, xmm0
  00959	f3 0f 11 44 05
	08		 movss	 DWORD PTR _vertices$41[ebp+eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  0095f	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp]
  00964	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0096b	72 0c		 jb	 SHORT $LN113@Draw
  0096d	c7 85 78 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv541[ebp], 255 ; 000000ffH
  00977	eb 3e		 jmp	 SHORT $LN114@Draw
$LN113@Draw:
  00979	0f 57 c0	 xorps	 xmm0, xmm0
  0097c	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp]
  00980	72 09		 jb	 SHORT $LN111@Draw
  00982	83 a5 7c ff ff
	ff 00		 and	 DWORD PTR tv540[ebp], 0
  00989	eb 20		 jmp	 SHORT $LN112@Draw
$LN111@Draw:
  0098b	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp]
  00990	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00998	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  009a0	e8 00 00 00 00	 call	 __ftoui3
  009a5	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv540[ebp], eax
$LN112@Draw:
  009ab	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv540[ebp]
  009b1	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv541[ebp], eax
$LN114@Draw:
  009b7	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv541[ebp]
  009bd	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _dwR$5[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  009c3	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+4]
  009c8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  009cf	72 0c		 jb	 SHORT $LN117@Draw
  009d1	c7 85 70 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv552[ebp], 255 ; 000000ffH
  009db	eb 3e		 jmp	 SHORT $LN118@Draw
$LN117@Draw:
  009dd	0f 57 c0	 xorps	 xmm0, xmm0
  009e0	0f 2f 45 f4	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp+4]
  009e4	72 09		 jb	 SHORT $LN115@Draw
  009e6	83 a5 74 ff ff
	ff 00		 and	 DWORD PTR tv551[ebp], 0
  009ed	eb 20		 jmp	 SHORT $LN116@Draw
$LN115@Draw:
  009ef	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+4]
  009f4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  009fc	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00a04	e8 00 00 00 00	 call	 __ftoui3
  00a09	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv551[ebp], eax
$LN116@Draw:
  00a0f	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv551[ebp]
  00a15	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv552[ebp], eax
$LN118@Draw:
  00a1b	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv552[ebp]
  00a21	89 85 cc fe ff
	ff		 mov	 DWORD PTR _dwG$6[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00a27	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+8]
  00a2c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00a33	72 0c		 jb	 SHORT $LN121@Draw
  00a35	c7 85 68 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv563[ebp], 255 ; 000000ffH
  00a3f	eb 3e		 jmp	 SHORT $LN122@Draw
$LN121@Draw:
  00a41	0f 57 c0	 xorps	 xmm0, xmm0
  00a44	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp+8]
  00a48	72 09		 jb	 SHORT $LN119@Draw
  00a4a	83 a5 6c ff ff
	ff 00		 and	 DWORD PTR tv562[ebp], 0
  00a51	eb 20		 jmp	 SHORT $LN120@Draw
$LN119@Draw:
  00a53	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+8]
  00a58	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00a60	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00a68	e8 00 00 00 00	 call	 __ftoui3
  00a6d	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv562[ebp], eax
$LN120@Draw:
  00a73	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv562[ebp]
  00a79	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv563[ebp], eax
$LN122@Draw:
  00a7f	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv563[ebp]
  00a85	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _dwB$3[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00a8b	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+12]
  00a90	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00a97	72 0c		 jb	 SHORT $LN125@Draw
  00a99	c7 85 60 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv574[ebp], 255 ; 000000ffH
  00aa3	eb 3e		 jmp	 SHORT $LN126@Draw
$LN125@Draw:
  00aa5	0f 57 c0	 xorps	 xmm0, xmm0
  00aa8	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _d3dColor$40[ebp+12]
  00aac	72 09		 jb	 SHORT $LN123@Draw
  00aae	83 a5 64 ff ff
	ff 00		 and	 DWORD PTR tv573[ebp], 0
  00ab5	eb 20		 jmp	 SHORT $LN124@Draw
$LN123@Draw:
  00ab7	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _d3dColor$40[ebp+12]
  00abc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00ac4	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00acc	e8 00 00 00 00	 call	 __ftoui3
  00ad1	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv573[ebp], eax
$LN124@Draw:
  00ad7	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv573[ebp]
  00add	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv574[ebp], eax
$LN126@Draw:
  00ae3	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv574[ebp]
  00ae9	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _dwA$4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 593  : 		vertices[3].color = d3dColor;

  00aef	6a 18		 push	 24			; 00000018H
  00af1	58		 pop	 eax
  00af2	6b c0 03	 imul	 eax, eax, 3
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00af5	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _dwG$6[ebp]
  00afb	c1 e1 08	 shl	 ecx, 8
  00afe	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR _dwR$5[ebp]
  00b04	c1 e2 10	 shl	 edx, 16			; 00000010H
  00b07	8b b5 c4 fe ff
	ff		 mov	 esi, DWORD PTR _dwA$4[ebp]
  00b0d	c1 e6 18	 shl	 esi, 24			; 00000018H
  00b10	0b f2		 or	 esi, edx
  00b12	0b f1		 or	 esi, ecx
  00b14	0b b5 c0 fe ff
	ff		 or	 esi, DWORD PTR _dwB$3[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\LensFlare.cpp

; 593  : 		vertices[3].color = d3dColor;

  00b1a	89 74 05 0c	 mov	 DWORD PTR _vertices$41[ebp+eax+12], esi

; 594  : 
; 595  : 		STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, vertices, sizeof(TVertex));

  00b1e	6a 18		 push	 24			; 00000018H
  00b20	8d 45 00	 lea	 eax, DWORD PTR _vertices$41[ebp]
  00b23	50		 push	 eax
  00b24	6a 02		 push	 2
  00b26	6a 05		 push	 5
  00b28	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00b2e	e8 00 00 00 00	 call	 ?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z ; CStateManager::DrawPrimitiveUP

; 596  : 	}

  00b33	e9 b7 f5 ff ff	 jmp	 $LN2@Draw
$LN3@Draw:

; 597  : 
; 598  : 	STATEMANAGER.RestoreRenderState(D3DRS_DESTBLEND);

  00b38	6a 14		 push	 20			; 00000014H
  00b3a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00b40	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 599  : }

  00b45	5e		 pop	 esi
  00b46	8b 4d 60	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b49	33 cd		 xor	 ecx, ebp
  00b4b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b50	83 c5 64	 add	 ebp, 100		; 00000064H
  00b53	c9		 leave
  00b54	c2 14 00	 ret	 20			; 00000014H
?Draw@CFlare@@QAEXMHHHH@Z ENDP				; CFlare::Draw
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
__Ptr$ = -32						; size = 4
tv95 = -28						; size = 4
__Left_size$ = -24					; size = 4
_this$ = -20						; size = 4
__Result$4 = -16					; size = 4
tv91 = -12						; size = 4
_this$ = -8						; size = 4
$T5 = -2						; size = 1
$T6 = -1						; size = 1
__Ptr$ = 8						; size = 4
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT
; _this$ = ecx

; 4179 :     bool _Equal(_In_z_ const _Elem* const _Ptr) const noexcept { // compare [0, size()) with _Ptr for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000c	e8 00 00 00 00	 call	 _strlen
  00011	59		 pop	 ecx
  00012	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax

; 4180 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR __Result$4[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00021	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00028	72 09		 jb	 SHORT $LN12@Equal
  0002a	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  00031	eb 04		 jmp	 SHORT $LN13@Equal
$LN12@Equal:
  00033	83 65 f4 00	 and	 DWORD PTR tv91[ebp], 0
$LN13@Equal:
  00037	8a 45 f4	 mov	 al, BYTE PTR tv91[ebp]
  0003a	88 45 ff	 mov	 BYTE PTR $T6[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0003d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T6[ebp]
  00041	85 c0		 test	 eax, eax
  00043	74 0e		 je	 SHORT $LN7@Equal

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004d	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00050	89 45 f0	 mov	 DWORD PTR __Result$4[ebp], eax
$LN7@Equal:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00053	8b 45 f0	 mov	 eax, DWORD PTR __Result$4[ebp]
  00056	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax

; 4180 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00059	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005f	89 45 e8	 mov	 DWORD PTR __Left_size$[ebp], eax

; 561  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00062	8b 45 e8	 mov	 eax, DWORD PTR __Left_size$[ebp]
  00065	3b 45 dc	 cmp	 eax, DWORD PTR $T3[ebp]
  00068	75 23		 jne	 SHORT $LN20@Equal

; 369  :         return _CSTD memcmp(_First1, _First2, _Count);

  0006a	ff 75 e8	 push	 DWORD PTR __Left_size$[ebp]
  0006d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00070	ff 75 d8	 push	 DWORD PTR $T2[ebp]
  00073	e8 00 00 00 00	 call	 _memcmp
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 561  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  0007e	83 7d d4 00	 cmp	 DWORD PTR $T1[ebp], 0
  00082	75 09		 jne	 SHORT $LN20@Equal
  00084	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
  0008b	eb 04		 jmp	 SHORT $LN21@Equal
$LN20@Equal:
  0008d	83 65 e4 00	 and	 DWORD PTR tv95[ebp], 0
$LN21@Equal:
  00091	8a 45 e4	 mov	 al, BYTE PTR tv95[ebp]
  00094	88 45 fe	 mov	 BYTE PTR $T5[ebp], al

; 4180 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00097	8a 45 fe	 mov	 al, BYTE PTR $T5[ebp]

; 4181 :     }

  0009a	c9		 leave
  0009b	c2 04 00	 ret	 4
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Al$ = -72						; size = 4
$T1 = -68						; size = 4
__Ptr$ = -64						; size = 4
$T2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
__First1$ = -48						; size = 4
__New_capacity$ = -44					; size = 4
__Right_ptr$ = -40					; size = 4
__New_array$ = -36					; size = 4
tv138 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
__Right_data$ = -20					; size = 4
_this$ = -16						; size = 4
__Right_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$7 = -1				; size = 1
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2728 :     void _Construct_lv_contents(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2729 :         // assign by copying data stored in _Right
; 2730 :         // pre: this != &_Right
; 2731 :         // pre: *this owns no memory, iterators orphaned (note:
; 2732 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2733 :         auto& _Right_data             = _Right._Mypair._Myval2;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __Right_data$[ebp], eax

; 2734 :         const size_type _Right_size   = _Right_data._Mysize;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax

; 2735 :         const _Elem* const _Right_ptr = _Right_data._Myptr();

  00018	8b 4d ec	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00020	89 45 d8	 mov	 DWORD PTR __Right_ptr$[ebp], eax

; 2736 :         auto& _My_data                = _Mypair._Myval2;

  00023	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2737 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00029	83 7d f4 10	 cmp	 DWORD PTR __Right_size$[ebp], 16 ; 00000010H
  0002d	73 2e		 jae	 SHORT $LN2@Construct_

; 2738 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00032	89 45 d0	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00035	6a 10		 push	 16			; 00000010H
  00037	ff 75 d8	 push	 DWORD PTR __Right_ptr$[ebp]
  0003a	ff 75 d0	 push	 DWORD PTR __First1$[ebp]
  0003d	e8 00 00 00 00	 call	 _memcpy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2739 :             _My_data._Mysize = _Right_size;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  0004b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2740 :             _My_data._Myres  = _BUF_SIZE - 1;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00051	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 2741 :             return;

  00058	e9 9b 00 00 00	 jmp	 $LN1@Construct_
$LN2@Construct_:

; 4409 :         return _Mypair._Get_first();

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00060	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00063	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  00066	89 45 b8	 mov	 DWORD PTR __Al$[ebp], eax

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  00069	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00071	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
  00074	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00077	83 c8 0f	 or	 eax, 15			; 0000000fH
  0007a	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0007d	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  00080	3b 45 e4	 cmp	 eax, DWORD PTR $T5[ebp]
  00083	73 08		 jae	 SHORT $LN52@Construct_
  00085	8d 45 e8	 lea	 eax, DWORD PTR $T6[ebp]
  00088	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
  0008b	eb 06		 jmp	 SHORT $LN53@Construct_
$LN52@Construct_:
  0008d	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  00090	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
$LN53@Construct_:
  00093	8b 45 e0	 mov	 eax, DWORD PTR tv138[ebp]
  00096	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
  00099	8b 45 c8	 mov	 eax, DWORD PTR $T3[ebp]
  0009c	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0009f	8b 45 c4	 mov	 eax, DWORD PTR $T2[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	89 45 d4	 mov	 DWORD PTR __New_capacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000a7	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$7[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000ab	8b 45 d4	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  000ae	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000b5	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000b6	89 45 dc	 mov	 DWORD PTR __New_array$[ebp], eax

; 2747 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  000b9	8d 45 dc	 lea	 eax, DWORD PTR __New_array$[ebp]
  000bc	50		 push	 eax
  000bd	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  000c0	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c5	59		 pop	 ecx
  000c6	59		 pop	 ecx

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000c7	8b 45 dc	 mov	 eax, DWORD PTR __New_array$[ebp]
  000ca	89 45 c0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000cd	8b 45 c0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000d0	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000d3	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  000d6	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d7	50		 push	 eax
  000d8	ff 75 d8	 push	 DWORD PTR __Right_ptr$[ebp]
  000db	ff 75 bc	 push	 DWORD PTR $T1[ebp]
  000de	e8 00 00 00 00	 call	 _memcpy
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2749 :         _My_data._Mysize = _Right_size;

  000e6	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  000ec	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2750 :         _My_data._Myres  = _New_capacity;

  000ef	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000f2	8b 4d d4	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000f5	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN1@Construct_:

; 2751 :     }

  000f8	c9		 leave
  000f9	c2 04 00	 ret	 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__My_data_mem$ = -12					; size = 4
__Right_data_mem$ = -8					; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT
; _this$ = ecx

; 2678 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2679 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2680 :         const auto _My_data_mem =

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR __My_data_mem$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  0000f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	89 45 f8	 mov	 DWORD PTR __Right_data_mem$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00015	6a 18		 push	 24			; 00000018H
  00017	ff 75 f8	 push	 DWORD PTR __Right_data_mem$[ebp]
  0001a	ff 75 f4	 push	 DWORD PTR __My_data_mem$[ebp]
  0001d	e8 00 00 00 00	 call	 _memcpy
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2685 :     }

  00025	c9		 leave
  00026	c2 04 00	 ret	 4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
_TEXT	SEGMENT
$T2 = -156						; size = 4
__Alproxy$ = -152					; size = 4
$T3 = -148						; size = 4
$T4 = -144						; size = 4
$T5 = -140						; size = 4
__First1$ = -136					; size = 4
$T6 = -132						; size = 4
__Ptr$ = -128						; size = 4
$T7 = -124						; size = 4
__Ptr$ = -120						; size = 4
__Ptr$ = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
__Ptr$ = -96						; size = 4
__First1$ = -92						; size = 4
__Ptr$ = -88						; size = 4
__My_data_mem$12 = -84					; size = 4
__Right_data_mem$13 = -80				; size = 4
$T14 = -76						; size = 4
$T15 = -72						; size = 4
__First1$ = -68						; size = 4
$T16 = -64						; size = 4
__Ptr$17 = -60						; size = 4
__Ptr$ = -56						; size = 4
__Ptr$ = -52						; size = 4
_this$ = -48						; size = 4
$T18 = -44						; size = 4
__Ptr$ = -40						; size = 4
__Result$19 = -36					; size = 4
tv391 = -32						; size = 4
__Result$20 = -28					; size = 4
tv349 = -24						; size = 4
__Fancyptr$ = -20					; size = 4
tv338 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T21 = 0						; size = 4
__Result$22 = 4						; size = 4
tv320 = 8						; size = 4
__Right_capacity$ = 12					; size = 4
__Result$23 = 16					; size = 4
tv301 = 20						; size = 4
__Result$24 = 24					; size = 4
tv292 = 28						; size = 4
__Left_capacity$ = 32					; size = 4
__Masked$25 = 36					; size = 4
__Ptr$26 = 40						; size = 4
__Overflow_is_possible$27 = 46				; size = 1
_$S12$ = 47						; size = 1
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
__New_capacity$ = 56					; size = 4
__New_size$ = 60					; size = 4
__Max$ = 64						; size = 4
__Right_size$ = 68					; size = 4
$T28 = 74						; size = 1
$T29 = 75						; size = 1
$T30 = 76						; size = 1
$T31 = 77						; size = 1
__Fits_in_right$ = 78					; size = 1
$T32 = 79						; size = 1
$T33 = 80						; size = 1
$T34 = 81						; size = 1
$T35 = 82						; size = 1
__Fits_in_left$ = 83					; size = 1
_this$ = 84						; size = 4
__Right_data$ = 88					; size = 4
__Left_data$ = 92					; size = 4
__Left_size$ = 96					; size = 4
__My_data$ = 100					; size = 4
tv156 = 106						; size = 1
tv128 = 107						; size = 1
___formal$ = 116					; size = 1
__Left$ = 120						; size = 4
__Right$ = 124						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2547 :         : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {

  00000	55		 push	 ebp
  00001	8d 6c 24 94	 lea	 ebp, DWORD PTR [esp-108]
  00005	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	89 4d 54	 mov	 DWORD PTR _this$[ebp], ecx

; 4409 :         return _Mypair._Get_first();

  00030	8b 45 78	 mov	 eax, DWORD PTR __Left$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00033	89 45 d4	 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00036	8b 45 d4	 mov	 eax, DWORD PTR $T18[ebp]
  00039	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax

; 2547 :         : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {

  0003f	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  00042	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00045	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2547 :         : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {

  0004d	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2548 :         auto& _My_data    = _Mypair._Myval2;

  00051	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  00054	89 45 64	 mov	 DWORD PTR __My_data$[ebp], eax

; 2549 :         auto& _Left_data  = _Left._Mypair._Myval2;

  00057	8b 45 78	 mov	 eax, DWORD PTR __Left$[ebp]
  0005a	89 45 5c	 mov	 DWORD PTR __Left_data$[ebp], eax

; 2550 :         auto& _Right_data = _Right._Mypair._Myval2;

  0005d	8b 45 7c	 mov	 eax, DWORD PTR __Right$[ebp]
  00060	89 45 58	 mov	 DWORD PTR __Right_data$[ebp], eax

; 2551 :         _Left_data._Orphan_all();
; 2552 :         _Right_data._Orphan_all();
; 2553 :         const auto _Left_size  = _Left_data._Mysize;

  00063	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  00066	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00069	89 45 60	 mov	 DWORD PTR __Left_size$[ebp], eax

; 2554 :         const auto _Right_size = _Right_data._Mysize;

  0006c	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  0006f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00072	89 45 44	 mov	 DWORD PTR __Right_size$[ebp], eax

; 2555 : 
; 2556 :         const auto _Left_capacity  = _Left_data._Myres;

  00075	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  00078	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0007b	89 45 20	 mov	 DWORD PTR __Left_capacity$[ebp], eax

; 2557 :         const auto _Right_capacity = _Right_data._Myres;

  0007e	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00081	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00084	89 45 0c	 mov	 DWORD PTR __Right_capacity$[ebp], eax

; 2558 :         // overflow is OK due to max_size() checks:
; 2559 :         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);

  00087	8b 45 60	 mov	 eax, DWORD PTR __Left_size$[ebp]
  0008a	03 45 44	 add	 eax, DWORD PTR __Right_size$[ebp]
  0008d	89 45 3c	 mov	 DWORD PTR __New_size$[ebp], eax

; 2560 :         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;

  00090	8b 45 20	 mov	 eax, DWORD PTR __Left_capacity$[ebp]
  00093	2b 45 60	 sub	 eax, DWORD PTR __Left_size$[ebp]
  00096	39 45 44	 cmp	 DWORD PTR __Right_size$[ebp], eax
  00099	77 06		 ja	 SHORT $LN6@basic_stri
  0009b	c6 45 6b 01	 mov	 BYTE PTR tv128[ebp], 1
  0009f	eb 04		 jmp	 SHORT $LN7@basic_stri
$LN6@basic_stri:
  000a1	c6 45 6b 00	 mov	 BYTE PTR tv128[ebp], 0
$LN7@basic_stri:
  000a5	8a 45 6b	 mov	 al, BYTE PTR tv128[ebp]
  000a8	88 45 53	 mov	 BYTE PTR __Fits_in_left$[ebp], al

; 2561 :         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {

  000ab	0f b6 45 53	 movzx	 eax, BYTE PTR __Fits_in_left$[ebp]
  000af	85 c0		 test	 eax, eax
  000b1	0f 84 d0 00 00
	00		 je	 $LN2@basic_stri
  000b7	8b 45 0c	 mov	 eax, DWORD PTR __Right_capacity$[ebp]
  000ba	3b 45 20	 cmp	 eax, DWORD PTR __Left_capacity$[ebp]
  000bd	0f 87 c4 00 00
	00		 ja	 $LN2@basic_stri

; 2562 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 2563 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2564 :             _Take_contents(_Left, bool_constant<_Can_memcpy_val>{});

  000c3	33 c0		 xor	 eax, eax
  000c5	88 45 52	 mov	 BYTE PTR $T35[ebp], al
  000c8	8a 45 52	 mov	 al, BYTE PTR $T35[ebp]
  000cb	88 45 34	 mov	 BYTE PTR ___formal$[ebp], al

; 2702 :         _Memcpy_val_from(_Right);

  000ce	ff 75 78	 push	 DWORD PTR __Left$[ebp]
  000d1	8b 4d 54	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	e8 00 00 00 00	 call	 ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from

; 2703 :         _Right._Tidy_init();

  000d9	8b 4d 78	 mov	 ecx, DWORD PTR __Left$[ebp]
  000dc	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2209 :         value_type* _Result = _Bx._Buf;

  000e1	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e4	89 45 18	 mov	 DWORD PTR __Result$24[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  000e7	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ea	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  000ee	72 09		 jb	 SHORT $LN41@basic_stri
  000f0	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR tv292[ebp], 1
  000f7	eb 04		 jmp	 SHORT $LN42@basic_stri
$LN41@basic_stri:
  000f9	83 65 1c 00	 and	 DWORD PTR tv292[ebp], 0
$LN42@basic_stri:
  000fd	8a 45 1c	 mov	 al, BYTE PTR tv292[ebp]
  00100	88 45 51	 mov	 BYTE PTR $T34[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00103	0f b6 45 51	 movzx	 eax, BYTE PTR $T34[ebp]
  00107	85 c0		 test	 eax, eax
  00109	74 0e		 je	 SHORT $LN36@basic_stri

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  0010b	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  0010e	8b 00		 mov	 eax, DWORD PTR [eax]
  00110	89 45 cc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00113	8b 45 cc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00116	89 45 18	 mov	 DWORD PTR __Result$24[ebp], eax
$LN36@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00119	8b 45 18	 mov	 eax, DWORD PTR __Result$24[ebp]
  0011c	89 45 c4	 mov	 DWORD PTR __Ptr$17[ebp], eax

; 2209 :         value_type* _Result = _Bx._Buf;

  0011f	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00122	89 45 10	 mov	 DWORD PTR __Result$23[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00125	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00128	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0012c	72 09		 jb	 SHORT $LN53@basic_stri
  0012e	c7 45 14 01 00
	00 00		 mov	 DWORD PTR tv301[ebp], 1
  00135	eb 04		 jmp	 SHORT $LN54@basic_stri
$LN53@basic_stri:
  00137	83 65 14 00	 and	 DWORD PTR tv301[ebp], 0
$LN54@basic_stri:
  0013b	8a 45 14	 mov	 al, BYTE PTR tv301[ebp]
  0013e	88 45 50	 mov	 BYTE PTR $T33[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00141	0f b6 45 50	 movzx	 eax, BYTE PTR $T33[ebp]
  00145	85 c0		 test	 eax, eax
  00147	74 0e		 je	 SHORT $LN48@basic_stri

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00149	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  0014c	8b 00		 mov	 eax, DWORD PTR [eax]
  0014e	89 45 c8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00151	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00154	89 45 10	 mov	 DWORD PTR __Result$23[ebp], eax
$LN48@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00157	8b 45 10	 mov	 eax, DWORD PTR __Result$23[ebp]
  0015a	89 45 c0	 mov	 DWORD PTR $T16[ebp], eax

; 2565 :             const auto _Ptr = _My_data._Myptr();
; 2566 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

  0015d	8b 45 c4	 mov	 eax, DWORD PTR __Ptr$17[ebp]
  00160	03 45 60	 add	 eax, DWORD PTR __Left_size$[ebp]
  00163	89 45 bc	 mov	 DWORD PTR __First1$[ebp], eax
  00166	8b 45 44	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00169	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0016a	50		 push	 eax
  0016b	ff 75 c0	 push	 DWORD PTR $T16[ebp]
  0016e	ff 75 bc	 push	 DWORD PTR __First1$[ebp]
  00171	e8 00 00 00 00	 call	 _memcpy
  00176	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2567 :             _My_data._Mysize = _New_size;

  00179	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  0017c	8b 4d 3c	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0017f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2568 :             return;

  00182	e9 96 02 00 00	 jmp	 $LN1@basic_stri
$LN2@basic_stri:

; 2569 :         }
; 2570 : 
; 2571 :         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;

  00187	8b 45 0c	 mov	 eax, DWORD PTR __Right_capacity$[ebp]
  0018a	2b 45 44	 sub	 eax, DWORD PTR __Right_size$[ebp]
  0018d	39 45 60	 cmp	 DWORD PTR __Left_size$[ebp], eax
  00190	77 06		 ja	 SHORT $LN8@basic_stri
  00192	c6 45 6a 01	 mov	 BYTE PTR tv156[ebp], 1
  00196	eb 04		 jmp	 SHORT $LN9@basic_stri
$LN8@basic_stri:
  00198	c6 45 6a 00	 mov	 BYTE PTR tv156[ebp], 0
$LN9@basic_stri:
  0019c	8a 45 6a	 mov	 al, BYTE PTR tv156[ebp]
  0019f	88 45 4e	 mov	 BYTE PTR __Fits_in_right$[ebp], al

; 4409 :         return _Mypair._Get_first();

  001a2	8b 45 7c	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001a5	89 45 b8	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  001a8	8b 45 b8	 mov	 eax, DWORD PTR $T15[ebp]
  001ab	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  001b1	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001b4	89 45 b4	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  001b7	8b 45 b4	 mov	 eax, DWORD PTR $T14[ebp]
  001ba	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 2039 :         return true;

  001c0	c6 45 4f 01	 mov	 BYTE PTR $T32[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2572 :         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {

  001c4	0f b6 45 4f	 movzx	 eax, BYTE PTR $T32[ebp]
  001c8	85 c0		 test	 eax, eax
  001ca	0f 84 c2 00 00
	00		 je	 $LN3@basic_stri
  001d0	0f b6 45 4e	 movzx	 eax, BYTE PTR __Fits_in_right$[ebp]
  001d4	85 c0		 test	 eax, eax
  001d6	0f 84 b6 00 00
	00		 je	 $LN3@basic_stri

; 2573 :             // take _Right's buffer, max_size() is OK because _Fits_in_right
; 2574 :             // At this point, we have tested:
; 2575 :             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
; 2576 :             // therefore: (by De Morgan's Laws)
; 2577 :             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
; 2578 :             // therefore: (by the distributive property)
; 2579 :             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
; 2580 :             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
; 2581 :             // therefore: _Right must have more than the minimum capacity, so it must be _Large_string_engaged()
; 2582 :             _STL_INTERNAL_CHECK(_Right_data._Large_string_engaged());
; 2583 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2584 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  001dc	33 c0		 xor	 eax, eax
  001de	88 45 4d	 mov	 BYTE PTR $T31[ebp], al
  001e1	8a 45 4d	 mov	 al, BYTE PTR $T31[ebp]
  001e4	88 45 30	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  001e7	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  001ea	89 45 ac	 mov	 DWORD PTR __My_data_mem$12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  001ed	8b 45 7c	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  001f0	89 45 b0	 mov	 DWORD PTR __Right_data_mem$13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  001f3	6a 18		 push	 24			; 00000018H
  001f5	ff 75 b0	 push	 DWORD PTR __Right_data_mem$13[ebp]
  001f8	ff 75 ac	 push	 DWORD PTR __My_data_mem$12[ebp]
  001fb	e8 00 00 00 00	 call	 _memcpy
  00200	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  00203	8b 4d 7c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00206	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2585 :             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);

  0020b	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  0020e	8b 00		 mov	 eax, DWORD PTR [eax]
  00210	89 45 a8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00213	8b 45 a8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00216	89 45 28	 mov	 DWORD PTR __Ptr$26[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2586 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);

  00219	8b 45 28	 mov	 eax, DWORD PTR __Ptr$26[ebp]
  0021c	03 45 60	 add	 eax, DWORD PTR __Left_size$[ebp]
  0021f	89 45 a4	 mov	 DWORD PTR __First1$[ebp], eax
  00222	8b 45 44	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00225	40		 inc	 eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00226	50		 push	 eax
  00227	ff 75 28	 push	 DWORD PTR __Ptr$26[ebp]
  0022a	ff 75 a4	 push	 DWORD PTR __First1$[ebp]
  0022d	e8 00 00 00 00	 call	 _memmove
  00232	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2209 :         value_type* _Result = _Bx._Buf;

  00235	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  00238	89 45 04	 mov	 DWORD PTR __Result$22[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0023b	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  0023e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00242	72 09		 jb	 SHORT $LN104@basic_stri
  00244	c7 45 08 01 00
	00 00		 mov	 DWORD PTR tv320[ebp], 1
  0024b	eb 04		 jmp	 SHORT $LN105@basic_stri
$LN104@basic_stri:
  0024d	83 65 08 00	 and	 DWORD PTR tv320[ebp], 0
$LN105@basic_stri:
  00251	8a 45 08	 mov	 al, BYTE PTR tv320[ebp]
  00254	88 45 4a	 mov	 BYTE PTR $T28[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00257	0f b6 45 4a	 movzx	 eax, BYTE PTR $T28[ebp]
  0025b	85 c0		 test	 eax, eax
  0025d	74 0e		 je	 SHORT $LN99@basic_stri

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  0025f	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  00262	8b 00		 mov	 eax, DWORD PTR [eax]
  00264	89 45 a0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00267	8b 45 a0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0026a	89 45 04	 mov	 DWORD PTR __Result$22[ebp], eax
$LN99@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  0026d	8b 45 04	 mov	 eax, DWORD PTR __Result$22[ebp]
  00270	89 45 9c	 mov	 DWORD PTR $T11[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00273	ff 75 60	 push	 DWORD PTR __Left_size$[ebp]
  00276	ff 75 9c	 push	 DWORD PTR $T11[ebp]
  00279	ff 75 28	 push	 DWORD PTR __Ptr$26[ebp]
  0027c	e8 00 00 00 00	 call	 _memcpy
  00281	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2587 :             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2588 :             _My_data._Mysize = _New_size;

  00284	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  00287	8b 4d 3c	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0028a	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2589 :             return;

  0028d	e9 8b 01 00 00	 jmp	 $LN1@basic_stri
$LN3@basic_stri:

; 2590 :         }
; 2591 : 
; 2592 :         // can't use either buffer, reallocate
; 2593 :         const auto _Max = max_size();

  00292	8b 4d 54	 mov	 ecx, DWORD PTR _this$[ebp]
  00295	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0029a	89 45 40	 mov	 DWORD PTR __Max$[ebp], eax

; 2594 :         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK

  0029d	8b 45 40	 mov	 eax, DWORD PTR __Max$[ebp]
  002a0	2b 45 60	 sub	 eax, DWORD PTR __Left_size$[ebp]
  002a3	3b 45 44	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  002a6	73 05		 jae	 SHORT $LN4@basic_stri

; 2595 :             _Xlen_string();

  002a8	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN4@basic_stri:

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  002ad	8b 45 3c	 mov	 eax, DWORD PTR __New_size$[ebp]
  002b0	83 c8 0f	 or	 eax, 15			; 0000000fH
  002b3	89 45 24	 mov	 DWORD PTR __Masked$25[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  002b6	8b 45 24	 mov	 eax, DWORD PTR __Masked$25[ebp]
  002b9	3b 45 40	 cmp	 eax, DWORD PTR __Max$[ebp]
  002bc	76 08		 jbe	 SHORT $LN139@basic_stri

; 4287 :             return _Max;

  002be	8b 45 40	 mov	 eax, DWORD PTR __Max$[ebp]
  002c1	89 45 38	 mov	 DWORD PTR __New_capacity$[ebp], eax
  002c4	eb 4c		 jmp	 SHORT $LN141@basic_stri
$LN139@basic_stri:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  002c6	6a 0f		 push	 15			; 0000000fH
  002c8	58		 pop	 eax
  002c9	d1 e8		 shr	 eax, 1
  002cb	8b 4d 40	 mov	 ecx, DWORD PTR __Max$[ebp]
  002ce	2b c8		 sub	 ecx, eax
  002d0	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  002d3	73 08		 jae	 SHORT $LN140@basic_stri

; 4291 :             return _Max;

  002d5	8b 45 40	 mov	 eax, DWORD PTR __Max$[ebp]
  002d8	89 45 38	 mov	 DWORD PTR __New_capacity$[ebp], eax
  002db	eb 35		 jmp	 SHORT $LN141@basic_stri
$LN140@basic_stri:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  002dd	6a 0f		 push	 15			; 0000000fH
  002df	58		 pop	 eax
  002e0	d1 e8		 shr	 eax, 1
  002e2	83 c0 0f	 add	 eax, 15			; 0000000fH
  002e5	89 45 00	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  002e8	8b 45 24	 mov	 eax, DWORD PTR __Masked$25[ebp]
  002eb	3b 45 00	 cmp	 eax, DWORD PTR $T21[ebp]
  002ee	73 08		 jae	 SHORT $LN145@basic_stri
  002f0	8d 45 00	 lea	 eax, DWORD PTR $T21[ebp]
  002f3	89 45 f0	 mov	 DWORD PTR tv338[ebp], eax
  002f6	eb 06		 jmp	 SHORT $LN146@basic_stri
$LN145@basic_stri:
  002f8	8d 45 24	 lea	 eax, DWORD PTR __Masked$25[ebp]
  002fb	89 45 f0	 mov	 DWORD PTR tv338[ebp], eax
$LN146@basic_stri:
  002fe	8b 45 f0	 mov	 eax, DWORD PTR tv338[ebp]
  00301	89 45 98	 mov	 DWORD PTR $T10[ebp], eax
  00304	8b 45 98	 mov	 eax, DWORD PTR $T10[ebp]
  00307	89 45 94	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0030a	8b 45 94	 mov	 eax, DWORD PTR $T9[ebp]
  0030d	8b 00		 mov	 eax, DWORD PTR [eax]
  0030f	89 45 38	 mov	 DWORD PTR __New_capacity$[ebp], eax
$LN141@basic_stri:

; 2596 :         }
; 2597 : 
; 2598 :         const auto _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, _Max);
; 2599 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00312	8d 45 2f	 lea	 eax, DWORD PTR _$S12$[ebp]
  00315	89 85 68 ff ff
	ff		 mov	 DWORD PTR __Alproxy$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0031b	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0031e	89 45 90	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00321	8b 45 90	 mov	 eax, DWORD PTR $T8[ebp]
  00324	89 85 64 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0032a	c6 45 2e 00	 mov	 BYTE PTR __Overflow_is_possible$27[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2601 :         const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  0032e	8b 45 38	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00331	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00332	50		 push	 eax
  00333	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00338	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2601 :         const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  00339	89 45 ec	 mov	 DWORD PTR __Fancyptr$[ebp], eax

; 2602 :         // nothrow hereafter
; 2603 :         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  0033c	8d 45 ec	 lea	 eax, DWORD PTR __Fancyptr$[ebp]
  0033f	50		 push	 eax
  00340	ff 75 64	 push	 DWORD PTR __My_data$[ebp]
  00343	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00348	59		 pop	 ecx
  00349	59		 pop	 ecx

; 2604 :         _My_data._Mysize = _New_size;

  0034a	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  0034d	8b 4d 3c	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00350	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2605 :         _My_data._Myres  = _New_capacity;

  00353	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  00356	8b 4d 38	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00359	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 2606 :         const auto _Ptr  = _Unfancy(_Fancyptr);

  0035c	8b 45 ec	 mov	 eax, DWORD PTR __Fancyptr$[ebp]
  0035f	89 45 8c	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00362	8b 45 8c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00365	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2209 :         value_type* _Result = _Bx._Buf;

  00368	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  0036b	89 45 e4	 mov	 DWORD PTR __Result$20[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0036e	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  00371	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00375	72 09		 jb	 SHORT $LN170@basic_stri
  00377	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv349[ebp], 1
  0037e	eb 04		 jmp	 SHORT $LN171@basic_stri
$LN170@basic_stri:
  00380	83 65 e8 00	 and	 DWORD PTR tv349[ebp], 0
$LN171@basic_stri:
  00384	8a 45 e8	 mov	 al, BYTE PTR tv349[ebp]
  00387	88 45 4c	 mov	 BYTE PTR $T30[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0038a	0f b6 45 4c	 movzx	 eax, BYTE PTR $T30[ebp]
  0038e	85 c0		 test	 eax, eax
  00390	74 0e		 je	 SHORT $LN165@basic_stri

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00392	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  00395	8b 00		 mov	 eax, DWORD PTR [eax]
  00397	89 45 88	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0039a	8b 45 88	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0039d	89 45 e4	 mov	 DWORD PTR __Result$20[ebp], eax
$LN165@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  003a0	8b 45 e4	 mov	 eax, DWORD PTR __Result$20[ebp]
  003a3	89 45 84	 mov	 DWORD PTR $T7[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  003a6	ff 75 60	 push	 DWORD PTR __Left_size$[ebp]
  003a9	ff 75 84	 push	 DWORD PTR $T7[ebp]
  003ac	ff 75 d8	 push	 DWORD PTR __Ptr$[ebp]
  003af	e8 00 00 00 00	 call	 _memcpy
  003b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2209 :         value_type* _Result = _Bx._Buf;

  003b7	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  003ba	89 45 dc	 mov	 DWORD PTR __Result$19[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  003bd	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  003c0	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  003c4	72 09		 jb	 SHORT $LN185@basic_stri
  003c6	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv391[ebp], 1
  003cd	eb 04		 jmp	 SHORT $LN186@basic_stri
$LN185@basic_stri:
  003cf	83 65 e0 00	 and	 DWORD PTR tv391[ebp], 0
$LN186@basic_stri:
  003d3	8a 45 e0	 mov	 al, BYTE PTR tv391[ebp]
  003d6	88 45 4b	 mov	 BYTE PTR $T29[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  003d9	0f b6 45 4b	 movzx	 eax, BYTE PTR $T29[ebp]
  003dd	85 c0		 test	 eax, eax
  003df	74 0e		 je	 SHORT $LN180@basic_stri

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  003e1	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  003e4	8b 00		 mov	 eax, DWORD PTR [eax]
  003e6	89 45 80	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  003e9	8b 45 80	 mov	 eax, DWORD PTR __Ptr$[ebp]
  003ec	89 45 dc	 mov	 DWORD PTR __Result$19[ebp], eax
$LN180@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  003ef	8b 45 dc	 mov	 eax, DWORD PTR __Result$19[ebp]
  003f2	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax

; 2607 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2608 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

  003f8	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  003fb	03 45 60	 add	 eax, DWORD PTR __Left_size$[ebp]
  003fe	89 85 78 ff ff
	ff		 mov	 DWORD PTR __First1$[ebp], eax
  00404	8b 45 44	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00407	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00408	50		 push	 eax
  00409	ff b5 7c ff ff
	ff		 push	 DWORD PTR $T6[ebp]
  0040f	ff b5 78 ff ff
	ff		 push	 DWORD PTR __First1$[ebp]
  00415	e8 00 00 00 00	 call	 _memcpy
  0041a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@basic_stri:

; 2609 :         _Proxy._Release();
; 2610 :     }

  0041d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00421	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@basic_stri:
  00424	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00427	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0042e	59		 pop	 ecx
  0042f	83 c5 6c	 add	 ebp, 108		; 0000006cH
  00432	c9		 leave
  00433	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z$0:
  00000	8b 4d 54	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 6c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-148]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
_TEXT	SEGMENT
$T2 = -100						; size = 4
__Alproxy$ = -96					; size = 4
$T3 = -92						; size = 4
__First1$ = -88						; size = 4
__Ptr$ = -84						; size = 4
$T4 = -80						; size = 4
$T5 = -76						; size = 4
$T6 = -72						; size = 4
_this$ = -68						; size = 4
$T7 = -64						; size = 4
__Fancyptr$8 = -60					; size = 4
tv190 = -56						; size = 4
$T9 = -52						; size = 4
_this$ = -48						; size = 4
__Masked$10 = -44					; size = 4
__New_size$ = -40					; size = 4
__Ptr$ = -36						; size = 4
__My_data$ = -32					; size = 4
__Max$ = -28						; size = 4
_this$ = -24						; size = 4
__New_capacity$ = -20					; size = 4
__Overflow_is_possible$11 = -15				; size = 1
_$S13$ = -14						; size = 1
$T12 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
__Source_of_al$ = 12					; size = 4
__Left_ptr$ = 16					; size = 4
__Left_size$ = 20					; size = 4
__Right_ptr$ = 24					; size = 4
__Right_size$ = 28					; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2521 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Source_of_al$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 c0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0002e	8b 45 c0	 mov	 eax, DWORD PTR $T7[ebp]
  00031	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax

; 2199 : 
; 2200 :     // length of internal buffer, [1, 16]:
; 2201 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2202 :     // roundup mask for allocated buffers, [0, 15]:
; 2203 :     static constexpr size_type _ALLOC_MASK =
; 2204 :         sizeof(value_type) <= 1
; 2205 :             ? 15
; 2206 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2207 : 
; 2208 :     value_type* _Myptr() noexcept {
; 2209 :         value_type* _Result = _Bx._Buf;
; 2210 :         if (_Large_string_engaged()) {
; 2211 :             _Result = _Unfancy(_Bx._Ptr);
; 2212 :         }
; 2213 : 
; 2214 :         return _Result;
; 2215 :     }
; 2216 : 
; 2217 :     const value_type* _Myptr() const noexcept {
; 2218 :         const value_type* _Result = _Bx._Buf;
; 2219 :         if (_Large_string_engaged()) {
; 2220 :             _Result = _Unfancy(_Bx._Ptr);
; 2221 :         }
; 2222 : 
; 2223 :         return _Result;
; 2224 :     }
; 2225 : 
; 2226 :     bool _Large_string_engaged() const noexcept {
; 2227 :         return _BUF_SIZE <= _Myres;
; 2228 :     }
; 2229 : 
; 2230 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2231 :         if (_Mysize < _Off) {
; 2232 :             _Xran();
; 2233 :         }
; 2234 :     }
; 2235 : 
; 2236 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2237 :         if (_Mysize <= _Off) {
; 2238 :             _Xran();
; 2239 :         }
; 2240 :     }
; 2241 : 
; 2242 :     [[noreturn]] static void _Xran() {
; 2243 :         _Xout_of_range("invalid string position");
; 2244 :     }
; 2245 : 
; 2246 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2247 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2248 :         return (_STD min)(_Size, _Mysize - _Off);
; 2249 :     }
; 2250 : 
; 2251 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2252 :         _Bxty() noexcept {} // user-provided, for fancy pointers
; 2253 : 
; 2254 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2255 : 
; 2256 :         value_type _Buf[_BUF_SIZE];
; 2257 :         pointer _Ptr;
; 2258 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2259 :     } _Bx;
; 2260 : 
; 2261 :     size_type _Mysize; // current length of string
; 2262 :     size_type _Myres; // current storage reserved for string
; 2263 : };
; 2264 : 
; 2265 : // CLASS TEMPLATE basic_string
; 2266 : template <class _Ty>
; 2267 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2268 : 
; 2269 : struct _String_constructor_concat_tag {
; 2270 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2271 :     explicit _String_constructor_concat_tag() = default;
; 2272 : };
; 2273 : 
; 2274 : [[noreturn]] inline void _Xlen_string() {
; 2275 :     _Xlength_error("string too long");
; 2276 : }
; 2277 : 
; 2278 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2279 : class basic_string { // null-terminated transparent array of elements
; 2280 : private:
; 2281 :     friend _Tidy_deallocate_guard<basic_string>;
; 2282 : 
; 2283 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2284 :     using _Alty_traits = allocator_traits<_Alty>;
; 2285 : 
; 2286 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2287 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2288 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2289 : 
; 2290 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2291 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2292 : 
; 2293 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2294 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2295 :         "char_traits character type match the string's character type.");
; 2296 : 
; 2297 :     static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
; 2298 :         "The character type of basic_string must be a non-array trivial standard-layout type. See N4861 "
; 2299 :         "[strings.general]/1.");
; 2300 : 
; 2301 : public:
; 2302 :     using traits_type    = _Traits;
; 2303 :     using allocator_type = _Alloc;
; 2304 : 
; 2305 :     using value_type      = _Elem;
; 2306 :     using size_type       = typename _Alty_traits::size_type;
; 2307 :     using difference_type = typename _Alty_traits::difference_type;
; 2308 :     using pointer         = typename _Alty_traits::pointer;
; 2309 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2310 :     using reference       = value_type&;
; 2311 :     using const_reference = const value_type&;
; 2312 : 
; 2313 :     using iterator       = _String_iterator<_Scary_val>;
; 2314 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2315 : 
; 2316 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2317 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2318 : 
; 2319 : private:
; 2320 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2321 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2322 : 
; 2323 :     // When doing _String_val operations by memcpy, we are touching:
; 2324 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2325 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2326 :     //   _String_val::_Mysize   (type is size_type)
; 2327 :     //   _String_val::_Myres    (type is size_type)
; 2328 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2329 :     // We need to ask if pointer is safe to memcpy.
; 2330 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2331 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2332 :     //   they can observe traits::assign and similar.
; 2333 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2334 :     // This offset skips over the _Container_base members, if any
; 2335 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2336 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2337 : 
; 2338 :     template <class _Iter>
; 2339 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2340 : 
; 2341 : #if _HAS_CXX17
; 2342 :     template <class _StringViewIsh>
; 2343 :     using _Is_string_view_ish =
; 2344 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2345 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2346 :             int>;
; 2347 : #endif // _HAS_CXX17
; 2348 : 
; 2349 : public:
; 2350 :     basic_string(const basic_string& _Right)
; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);
; 2355 :         _Proxy._Release();
; 2356 :     }
; 2357 : 
; 2358 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2359 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2360 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2361 :         _Construct_lv_contents(_Right);
; 2362 :         _Proxy._Release();
; 2363 :     }
; 2364 : 
; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();
; 2368 :     }
; 2369 : 
; 2370 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2371 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2372 :         _Tidy_init();
; 2373 :     }
; 2374 : 
; 2375 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2376 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, <end>)
; 2377 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2378 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2379 :         _Tidy_init();
; 2380 :         assign(_Right, _Roff, npos);
; 2381 :         _Proxy._Release();
; 2382 :     }
; 2383 : 
; 2384 :     basic_string(
; 2385 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2387 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2388 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2389 :         _Tidy_init();
; 2390 :         assign(_Right, _Roff, _Count);
; 2391 :         _Proxy._Release();
; 2392 :     }
; 2393 : 
; 2394 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2395 :         : _Mypair(_Zero_then_variadic_args_t{}) {
; 2396 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2397 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2398 :         _Tidy_init();
; 2399 :         assign(_Ptr, _Count);
; 2400 :         _Proxy._Release();
; 2401 :     }
; 2402 : 
; 2403 :     basic_string(
; 2404 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2405 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2406 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2407 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2408 :         _Tidy_init();
; 2409 :         assign(_Ptr, _Count);
; 2410 :         _Proxy._Release();
; 2411 :     }
; 2412 : 
; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();
; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }
; 2420 : 
; 2421 : #if _HAS_CXX17
; 2422 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2423 : #endif // _HAS_CXX17
; 2424 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2425 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2426 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2427 :         _Tidy_init();
; 2428 :         assign(_Ptr);
; 2429 :         _Proxy._Release();
; 2430 :     }
; 2431 : 
; 2432 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2433 :         // construct from _Count * _Ch
; 2434 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2435 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2436 :         _Tidy_init();
; 2437 :         assign(_Count, _Ch);
; 2438 :         _Proxy._Release();
; 2439 :     }
; 2440 : 
; 2441 : #if _HAS_CXX17
; 2442 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2443 : #endif // _HAS_CXX17
; 2444 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2445 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Count * _Ch with allocator
; 2446 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2447 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2448 :         _Tidy_init();
; 2449 :         assign(_Count, _Ch);
; 2450 :         _Proxy._Release();
; 2451 :     }
; 2452 : 
; 2453 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2454 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2455 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2456 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2457 :         _Tidy_init();
; 2458 :         _Adl_verify_range(_First, _Last);
; 2459 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 2460 :         _Proxy._Release();
; 2461 :     }
; 2462 : 
; 2463 :     template <class _Iter>
; 2464 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2465 :         // initialize from [_First, _Last), input iterators
; 2466 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2467 :         for (; _First != _Last; ++_First) {
; 2468 :             push_back(*_First);
; 2469 :         }
; 2470 : 
; 2471 :         _Guard._Target = nullptr;
; 2472 :     }
; 2473 : 
; 2474 :     template <class _Iter>
; 2475 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2476 :         // initialize from [_First, _Last), forward iterators
; 2477 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2478 :         reserve(_Count);
; 2479 :         _Construct(_First, _Last, input_iterator_tag{});
; 2480 :     }
; 2481 : 
; 2482 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2483 :         // initialize from [_First, _Last), pointers
; 2484 :         if (_First != _Last) {
; 2485 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2486 :         }
; 2487 :     }
; 2488 : 
; 2489 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2490 :         // initialize from [_First, _Last), const pointers
; 2491 :         if (_First != _Last) {
; 2492 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2493 :         }
; 2494 :     }
; 2495 : 
; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {
; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2499 :     }
; 2500 : 
; 2501 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2502 :         _Alty_traits::is_always_equal::value) // strengthened
; 2503 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2504 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2505 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2506 :         if _CONSTEXPR_IF (!_Alty_traits::is_always_equal::value) {
; 2507 :             if (_Getal() != _Right._Getal()) {
; 2508 :                 _Construct_lv_contents(_Right);
; 2509 :                 _Proxy._Release();
; 2510 :                 return;
; 2511 :             }
; 2512 :         }
; 2513 : 
; 2514 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2515 :         _Proxy._Release();
; 2516 :     }
; 2517 : 
; 2518 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2519 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2520 :         : _Mypair(

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 bc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003a	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00040	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00047	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2199 : 
; 2200 :     // length of internal buffer, [1, 16]:
; 2201 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2202 :     // roundup mask for allocated buffers, [0, 15]:
; 2203 :     static constexpr size_type _ALLOC_MASK =
; 2204 :         sizeof(value_type) <= 1
; 2205 :             ? 15
; 2206 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2207 : 
; 2208 :     value_type* _Myptr() noexcept {
; 2209 :         value_type* _Result = _Bx._Buf;
; 2210 :         if (_Large_string_engaged()) {
; 2211 :             _Result = _Unfancy(_Bx._Ptr);
; 2212 :         }
; 2213 : 
; 2214 :         return _Result;
; 2215 :     }
; 2216 : 
; 2217 :     const value_type* _Myptr() const noexcept {
; 2218 :         const value_type* _Result = _Bx._Buf;
; 2219 :         if (_Large_string_engaged()) {
; 2220 :             _Result = _Unfancy(_Bx._Ptr);
; 2221 :         }
; 2222 : 
; 2223 :         return _Result;
; 2224 :     }
; 2225 : 
; 2226 :     bool _Large_string_engaged() const noexcept {
; 2227 :         return _BUF_SIZE <= _Myres;
; 2228 :     }
; 2229 : 
; 2230 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2231 :         if (_Mysize < _Off) {
; 2232 :             _Xran();
; 2233 :         }
; 2234 :     }
; 2235 : 
; 2236 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2237 :         if (_Mysize <= _Off) {
; 2238 :             _Xran();
; 2239 :         }
; 2240 :     }
; 2241 : 
; 2242 :     [[noreturn]] static void _Xran() {
; 2243 :         _Xout_of_range("invalid string position");
; 2244 :     }
; 2245 : 
; 2246 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2247 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2248 :         return (_STD min)(_Size, _Mysize - _Off);
; 2249 :     }
; 2250 : 
; 2251 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2252 :         _Bxty() noexcept {} // user-provided, for fancy pointers
; 2253 : 
; 2254 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2255 : 
; 2256 :         value_type _Buf[_BUF_SIZE];
; 2257 :         pointer _Ptr;
; 2258 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2259 :     } _Bx;
; 2260 : 
; 2261 :     size_type _Mysize; // current length of string
; 2262 :     size_type _Myres; // current storage reserved for string
; 2263 : };
; 2264 : 
; 2265 : // CLASS TEMPLATE basic_string
; 2266 : template <class _Ty>
; 2267 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2268 : 
; 2269 : struct _String_constructor_concat_tag {
; 2270 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2271 :     explicit _String_constructor_concat_tag() = default;
; 2272 : };
; 2273 : 
; 2274 : [[noreturn]] inline void _Xlen_string() {
; 2275 :     _Xlength_error("string too long");
; 2276 : }
; 2277 : 
; 2278 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2279 : class basic_string { // null-terminated transparent array of elements
; 2280 : private:
; 2281 :     friend _Tidy_deallocate_guard<basic_string>;
; 2282 : 
; 2283 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2284 :     using _Alty_traits = allocator_traits<_Alty>;
; 2285 : 
; 2286 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2287 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2288 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2289 : 
; 2290 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2291 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2292 : 
; 2293 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2294 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2295 :         "char_traits character type match the string's character type.");
; 2296 : 
; 2297 :     static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
; 2298 :         "The character type of basic_string must be a non-array trivial standard-layout type. See N4861 "
; 2299 :         "[strings.general]/1.");
; 2300 : 
; 2301 : public:
; 2302 :     using traits_type    = _Traits;
; 2303 :     using allocator_type = _Alloc;
; 2304 : 
; 2305 :     using value_type      = _Elem;
; 2306 :     using size_type       = typename _Alty_traits::size_type;
; 2307 :     using difference_type = typename _Alty_traits::difference_type;
; 2308 :     using pointer         = typename _Alty_traits::pointer;
; 2309 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2310 :     using reference       = value_type&;
; 2311 :     using const_reference = const value_type&;
; 2312 : 
; 2313 :     using iterator       = _String_iterator<_Scary_val>;
; 2314 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2315 : 
; 2316 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2317 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2318 : 
; 2319 : private:
; 2320 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2321 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2322 : 
; 2323 :     // When doing _String_val operations by memcpy, we are touching:
; 2324 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2325 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2326 :     //   _String_val::_Mysize   (type is size_type)
; 2327 :     //   _String_val::_Myres    (type is size_type)
; 2328 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2329 :     // We need to ask if pointer is safe to memcpy.
; 2330 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2331 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2332 :     //   they can observe traits::assign and similar.
; 2333 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2334 :     // This offset skips over the _Container_base members, if any
; 2335 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2336 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2337 : 
; 2338 :     template <class _Iter>
; 2339 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2340 : 
; 2341 : #if _HAS_CXX17
; 2342 :     template <class _StringViewIsh>
; 2343 :     using _Is_string_view_ish =
; 2344 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2345 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2346 :             int>;
; 2347 : #endif // _HAS_CXX17
; 2348 : 
; 2349 : public:
; 2350 :     basic_string(const basic_string& _Right)
; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);
; 2355 :         _Proxy._Release();
; 2356 :     }
; 2357 : 
; 2358 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2359 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2360 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2361 :         _Construct_lv_contents(_Right);
; 2362 :         _Proxy._Release();
; 2363 :     }
; 2364 : 
; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();
; 2368 :     }
; 2369 : 
; 2370 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2371 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2372 :         _Tidy_init();
; 2373 :     }
; 2374 : 
; 2375 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2376 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, <end>)
; 2377 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2378 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2379 :         _Tidy_init();
; 2380 :         assign(_Right, _Roff, npos);
; 2381 :         _Proxy._Release();
; 2382 :     }
; 2383 : 
; 2384 :     basic_string(
; 2385 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2387 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2388 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2389 :         _Tidy_init();
; 2390 :         assign(_Right, _Roff, _Count);
; 2391 :         _Proxy._Release();
; 2392 :     }
; 2393 : 
; 2394 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2395 :         : _Mypair(_Zero_then_variadic_args_t{}) {
; 2396 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2397 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2398 :         _Tidy_init();
; 2399 :         assign(_Ptr, _Count);
; 2400 :         _Proxy._Release();
; 2401 :     }
; 2402 : 
; 2403 :     basic_string(
; 2404 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2405 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2406 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2407 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2408 :         _Tidy_init();
; 2409 :         assign(_Ptr, _Count);
; 2410 :         _Proxy._Release();
; 2411 :     }
; 2412 : 
; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();
; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }
; 2420 : 
; 2421 : #if _HAS_CXX17
; 2422 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2423 : #endif // _HAS_CXX17
; 2424 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2425 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2426 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2427 :         _Tidy_init();
; 2428 :         assign(_Ptr);
; 2429 :         _Proxy._Release();
; 2430 :     }
; 2431 : 
; 2432 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2433 :         // construct from _Count * _Ch
; 2434 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2435 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2436 :         _Tidy_init();
; 2437 :         assign(_Count, _Ch);
; 2438 :         _Proxy._Release();
; 2439 :     }
; 2440 : 
; 2441 : #if _HAS_CXX17
; 2442 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2443 : #endif // _HAS_CXX17
; 2444 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2445 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Count * _Ch with allocator
; 2446 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2447 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2448 :         _Tidy_init();
; 2449 :         assign(_Count, _Ch);
; 2450 :         _Proxy._Release();
; 2451 :     }
; 2452 : 
; 2453 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2454 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2455 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2456 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2457 :         _Tidy_init();
; 2458 :         _Adl_verify_range(_First, _Last);
; 2459 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 2460 :         _Proxy._Release();
; 2461 :     }
; 2462 : 
; 2463 :     template <class _Iter>
; 2464 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2465 :         // initialize from [_First, _Last), input iterators
; 2466 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2467 :         for (; _First != _Last; ++_First) {
; 2468 :             push_back(*_First);
; 2469 :         }
; 2470 : 
; 2471 :         _Guard._Target = nullptr;
; 2472 :     }
; 2473 : 
; 2474 :     template <class _Iter>
; 2475 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2476 :         // initialize from [_First, _Last), forward iterators
; 2477 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2478 :         reserve(_Count);
; 2479 :         _Construct(_First, _Last, input_iterator_tag{});
; 2480 :     }
; 2481 : 
; 2482 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2483 :         // initialize from [_First, _Last), pointers
; 2484 :         if (_First != _Last) {
; 2485 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2486 :         }
; 2487 :     }
; 2488 : 
; 2489 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2490 :         // initialize from [_First, _Last), const pointers
; 2491 :         if (_First != _Last) {
; 2492 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2493 :         }
; 2494 :     }
; 2495 : 
; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {
; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2499 :     }
; 2500 : 
; 2501 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2502 :         _Alty_traits::is_always_equal::value) // strengthened
; 2503 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2504 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2505 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2506 :         if _CONSTEXPR_IF (!_Alty_traits::is_always_equal::value) {
; 2507 :             if (_Getal() != _Right._Getal()) {
; 2508 :                 _Construct_lv_contents(_Right);
; 2509 :                 _Proxy._Release();
; 2510 :                 return;
; 2511 :             }
; 2512 :         }
; 2513 : 
; 2514 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2515 :         _Proxy._Release();
; 2516 :     }
; 2517 : 
; 2518 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2519 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2520 :         : _Mypair(

  0004e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2522 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2523 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2524 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2525 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

  00052	8b 45 14	 mov	 eax, DWORD PTR __Left_size$[ebp]
  00055	03 45 1c	 add	 eax, DWORD PTR __Right_size$[ebp]
  00058	89 45 d8	 mov	 DWORD PTR __New_size$[ebp], eax

; 2526 :         size_type _New_capacity = _BUF_SIZE - 1;

  0005b	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __New_capacity$[ebp], 15 ; 0000000fH

; 2527 :         auto& _My_data          = _Mypair._Myval2;

  00062	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __My_data$[ebp], eax

; 2528 :         _Elem* _Ptr             = _My_data._Bx._Buf;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0006b	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2529 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0006e	8d 45 f2	 lea	 eax, DWORD PTR _$S13$[ebp]
  00071	89 45 a0	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2530 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2531 :         if (_New_capacity < _New_size) {

  00074	8b 45 ec	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00077	3b 45 d8	 cmp	 eax, DWORD PTR __New_size$[ebp]
  0007a	0f 83 a8 00 00
	00		 jae	 $LN2@basic_stri

; 2532 :             _New_capacity           = _Calculate_growth(_New_size, _BUF_SIZE - 1, max_size());

  00080	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00088	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0008b	8b 45 d8	 mov	 eax, DWORD PTR __New_size$[ebp]
  0008e	83 c8 0f	 or	 eax, 15			; 0000000fH
  00091	89 45 d4	 mov	 DWORD PTR __Masked$10[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00094	8b 45 d4	 mov	 eax, DWORD PTR __Masked$10[ebp]
  00097	3b 45 e4	 cmp	 eax, DWORD PTR __Max$[ebp]
  0009a	76 08		 jbe	 SHORT $LN54@basic_stri

; 4287 :             return _Max;

  0009c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0009f	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax
  000a2	eb 4c		 jmp	 SHORT $LN56@basic_stri
$LN54@basic_stri:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  000a4	6a 0f		 push	 15			; 0000000fH
  000a6	58		 pop	 eax
  000a7	d1 e8		 shr	 eax, 1
  000a9	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  000ac	2b c8		 sub	 ecx, eax
  000ae	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  000b1	73 08		 jae	 SHORT $LN55@basic_stri

; 4291 :             return _Max;

  000b3	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  000b6	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax
  000b9	eb 35		 jmp	 SHORT $LN56@basic_stri
$LN55@basic_stri:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000bb	6a 0f		 push	 15			; 0000000fH
  000bd	58		 pop	 eax
  000be	d1 e8		 shr	 eax, 1
  000c0	83 c0 0f	 add	 eax, 15			; 0000000fH
  000c3	89 45 cc	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  000c6	8b 45 d4	 mov	 eax, DWORD PTR __Masked$10[ebp]
  000c9	3b 45 cc	 cmp	 eax, DWORD PTR $T9[ebp]
  000cc	73 08		 jae	 SHORT $LN60@basic_stri
  000ce	8d 45 cc	 lea	 eax, DWORD PTR $T9[ebp]
  000d1	89 45 c8	 mov	 DWORD PTR tv190[ebp], eax
  000d4	eb 06		 jmp	 SHORT $LN61@basic_stri
$LN60@basic_stri:
  000d6	8d 45 d4	 lea	 eax, DWORD PTR __Masked$10[ebp]
  000d9	89 45 c8	 mov	 DWORD PTR tv190[ebp], eax
$LN61@basic_stri:
  000dc	8b 45 c8	 mov	 eax, DWORD PTR tv190[ebp]
  000df	89 45 b8	 mov	 DWORD PTR $T6[ebp], eax
  000e2	8b 45 b8	 mov	 eax, DWORD PTR $T6[ebp]
  000e5	89 45 b4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000e8	8b 45 b4	 mov	 eax, DWORD PTR $T5[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax
$LN56@basic_stri:

; 4409 :         return _Mypair._Get_first();

  000f0	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000f3	89 45 b0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  000f6	8b 45 b0	 mov	 eax, DWORD PTR $T4[ebp]
  000f9	89 45 9c	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000fc	c6 45 f1 00	 mov	 BYTE PTR __Overflow_is_possible$11[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2533 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  00100	8b 45 ec	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00103	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010a	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2533 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  0010b	89 45 c4	 mov	 DWORD PTR __Fancyptr$8[ebp], eax

; 2534 :             _Ptr                    = _Unfancy(_Fancyptr);

  0010e	8b 45 c4	 mov	 eax, DWORD PTR __Fancyptr$8[ebp]
  00111	89 45 ac	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00114	8b 45 ac	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00117	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2535 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  0011a	8d 45 c4	 lea	 eax, DWORD PTR __Fancyptr$8[ebp]
  0011d	50		 push	 eax
  0011e	ff 75 e0	 push	 DWORD PTR __My_data$[ebp]
  00121	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00126	59		 pop	 ecx
  00127	59		 pop	 ecx
$LN2@basic_stri:

; 2536 :         }
; 2537 : 
; 2538 :         _My_data._Mysize = _New_size;

  00128	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0012b	8b 4d d8	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0012e	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2539 :         _My_data._Myres  = _New_capacity;

  00131	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00134	8b 4d ec	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00137	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0013a	ff 75 14	 push	 DWORD PTR __Left_size$[ebp]
  0013d	ff 75 10	 push	 DWORD PTR __Left_ptr$[ebp]
  00140	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  00143	e8 00 00 00 00	 call	 _memcpy
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2540 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2541 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  0014b	8b 45 dc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0014e	03 45 14	 add	 eax, DWORD PTR __Left_size$[ebp]
  00151	89 45 a8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00154	ff 75 1c	 push	 DWORD PTR __Right_size$[ebp]
  00157	ff 75 18	 push	 DWORD PTR __Right_ptr$[ebp]
  0015a	ff 75 a8	 push	 DWORD PTR __First1$[ebp]
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2542 :         _Traits::assign(_Ptr[_New_size], _Elem());

  00165	c6 45 f3 00	 mov	 BYTE PTR $T12[ebp], 0

; 428  :         _Left = _Right;

  00169	8b 45 dc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0016c	03 45 d8	 add	 eax, DWORD PTR __New_size$[ebp]
  0016f	8a 4d f3	 mov	 cl, BYTE PTR $T12[ebp]
  00172	88 08		 mov	 BYTE PTR [eax], cl

; 2543 :         _Proxy._Release();
; 2544 :     }

  00174	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00178	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0017b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00185	59		 pop	 ecx
  00186	c9		 leave
  00187	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z$0:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S6$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0003b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00046	8d 45 f3	 lea	 eax, DWORD PTR _$S6$[ebp]
  00049	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00054	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	59		 pop	 ecx
  0005d	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00063	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00066	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00069	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }

  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
_this$ = -32						; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S9$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00031	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00034	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003a	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00040	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00047	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  0004e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00052	8d 45 f3	 lea	 eax, DWORD PTR _$S9$[ebp]
  00055	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);

  00058	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents

; 2355 :         _Proxy._Release();
; 2356 :     }

  00063	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	c9		 leave
  00076	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 14 00	 and	 DWORD PTR [eax+20], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c9		 leave
  00019	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
