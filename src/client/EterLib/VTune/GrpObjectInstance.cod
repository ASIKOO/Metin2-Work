; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?DistanceSq@Vector3d@@QBEMABV1@@Z		; Vector3d::DistanceSq
PUBLIC	?NewPos@SpherePack@@QAEXABVVector3d@@@Z		; SpherePack::NewPos
PUBLIC	?NewPosRadius@SpherePack@@QAEXABVVector3d@@M@Z	; SpherePack::NewPosRadius
PUBLIC	?Unlink@SpherePack@@QAEXXZ			; SpherePack::Unlink
PUBLIC	?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z	; SpherePack::ComputeBindingDistance
PUBLIC	??0CGraphicObjectInstance@@QAE@XZ		; CGraphicObjectInstance::CGraphicObjectInstance
PUBLIC	??1CGraphicObjectInstance@@UAE@XZ		; CGraphicObjectInstance::~CGraphicObjectInstance
PUBLIC	?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
PUBLIC	?GetScale@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetScale
PUBLIC	?GetRotation@CGraphicObjectInstance@@QAEMXZ	; CGraphicObjectInstance::GetRotation
PUBLIC	?GetYaw@CGraphicObjectInstance@@QAEMXZ		; CGraphicObjectInstance::GetYaw
PUBLIC	?GetPitch@CGraphicObjectInstance@@QAEMXZ	; CGraphicObjectInstance::GetPitch
PUBLIC	?GetRoll@CGraphicObjectInstance@@QAEMXZ		; CGraphicObjectInstance::GetRoll
PUBLIC	?SetPosition@CGraphicObjectInstance@@QAEXMMM@Z	; CGraphicObjectInstance::SetPosition
PUBLIC	?SetPosition@CGraphicObjectInstance@@QAEXABUD3DXVECTOR3@@@Z ; CGraphicObjectInstance::SetPosition
PUBLIC	?SetScale@CGraphicObjectInstance@@QAEXMMM@Z	; CGraphicObjectInstance::SetScale
PUBLIC	?SetRotation@CGraphicObjectInstance@@QAEXM@Z	; CGraphicObjectInstance::SetRotation
PUBLIC	?SetRotation@CGraphicObjectInstance@@QAEXMMM@Z	; CGraphicObjectInstance::SetRotation
PUBLIC	?SetRotationQuaternion@CGraphicObjectInstance@@QAEXABUD3DXQUATERNION@@@Z ; CGraphicObjectInstance::SetRotationQuaternion
PUBLIC	?SetRotationMatrix@CGraphicObjectInstance@@QAEXABUD3DXMATRIX@@@Z ; CGraphicObjectInstance::SetRotationMatrix
PUBLIC	?Clear@CGraphicObjectInstance@@QAEXXZ		; CGraphicObjectInstance::Clear
PUBLIC	?Update@CGraphicObjectInstance@@QAEXXZ		; CGraphicObjectInstance::Update
PUBLIC	?Render@CGraphicObjectInstance@@QAE_NXZ		; CGraphicObjectInstance::Render
PUBLIC	?BlendRender@CGraphicObjectInstance@@QAEXXZ	; CGraphicObjectInstance::BlendRender
PUBLIC	?RenderToShadowMap@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::RenderToShadowMap
PUBLIC	?RenderShadow@CGraphicObjectInstance@@QAEXXZ	; CGraphicObjectInstance::RenderShadow
PUBLIC	?RenderPCBlocker@CGraphicObjectInstance@@QAEXXZ	; CGraphicObjectInstance::RenderPCBlocker
PUBLIC	?Deform@CGraphicObjectInstance@@QAEXXZ		; CGraphicObjectInstance::Deform
PUBLIC	?Transform@CGraphicObjectInstance@@QAEXXZ	; CGraphicObjectInstance::Transform
PUBLIC	?Show@CGraphicObjectInstance@@QAEXXZ		; CGraphicObjectInstance::Show
PUBLIC	?Hide@CGraphicObjectInstance@@QAEXXZ		; CGraphicObjectInstance::Hide
PUBLIC	?isShow@CGraphicObjectInstance@@QAE_NXZ		; CGraphicObjectInstance::isShow
PUBLIC	?isIntersect@CGraphicObjectInstance@@QAE_NABVCRay@@PAM11@Z ; CGraphicObjectInstance::isIntersect
PUBLIC	?GetWTBBoxVertex@CGraphicObjectInstance@@QAEAAUD3DXVECTOR4@@ABE@Z ; CGraphicObjectInstance::GetWTBBoxVertex
PUBLIC	?GetTransform@CGraphicObjectInstance@@QAEAAUD3DXMATRIX@@XZ ; CGraphicObjectInstance::GetTransform
PUBLIC	?SetPortal@CGraphicObjectInstance@@QAEXKH@Z	; CGraphicObjectInstance::SetPortal
PUBLIC	?GetPortal@CGraphicObjectInstance@@QAEHK@Z	; CGraphicObjectInstance::GetPortal
PUBLIC	?Initialize@CGraphicObjectInstance@@QAEXXZ	; CGraphicObjectInstance::Initialize
PUBLIC	?OnInitialize@CGraphicObjectInstance@@UAEXXZ	; CGraphicObjectInstance::OnInitialize
PUBLIC	?UpdateBoundingSphere@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::UpdateBoundingSphere
PUBLIC	?RegisterBoundingSphere@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::RegisterBoundingSphere
PUBLIC	?OnClear@CGraphicObjectInstance@@UAEXXZ		; CGraphicObjectInstance::OnClear
PUBLIC	?OnUpdate@CGraphicObjectInstance@@UAEXXZ	; CGraphicObjectInstance::OnUpdate
PUBLIC	?OnDeform@CGraphicObjectInstance@@UAEXXZ	; CGraphicObjectInstance::OnDeform
PUBLIC	?AddCollision@CGraphicObjectInstance@@QAEXPBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z ; CGraphicObjectInstance::AddCollision
PUBLIC	?ClearCollision@CGraphicObjectInstance@@QAEXXZ	; CGraphicObjectInstance::ClearCollision
PUBLIC	?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
PUBLIC	?MovementCollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::MovementCollisionDynamicSphere
PUBLIC	?GetCollisionMovementAdjust@CGraphicObjectInstance@@QBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::GetCollisionMovementAdjust
PUBLIC	?UpdateCollisionData@CGraphicObjectInstance@@QAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z ; CGraphicObjectInstance::UpdateCollisionData
PUBLIC	?deallocate@?$allocator@PAVCBaseCollisionInstance@@@std@@QAEXQAPAVCBaseCollisionInstance@@I@Z ; std::allocator<CBaseCollisionInstance *>::deallocate
PUBLIC	??1?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAE@XZ ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::~vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >
PUBLIC	?clear@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXPAPAVCBaseCollisionInstance@@0@Z ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@ABEII@Z ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXQAPAVCBaseCollisionInstance@@II@Z ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Xlength
PUBLIC	?GetCollisionInstanceCount@CGraphicObjectInstance@@QAEKXZ ; CGraphicObjectInstance::GetCollisionInstanceCount
PUBLIC	?GetCollisionInstanceData@CGraphicObjectInstance@@QAEPAVCBaseCollisionInstance@@K@Z ; CGraphicObjectInstance::GetCollisionInstanceData
PUBLIC	?SetHeightInstance@CGraphicObjectInstance@@QAEXPAVCAttributeInstance@@@Z ; CGraphicObjectInstance::SetHeightInstance
PUBLIC	?ClearHeightInstance@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::ClearHeightInstance
PUBLIC	?UpdateHeightInstance@CGraphicObjectInstance@@QAEXPAVCAttributeInstance@@@Z ; CGraphicObjectInstance::UpdateHeightInstance
PUBLIC	?IsObjectHeight@CGraphicObjectInstance@@QAE_NXZ	; CGraphicObjectInstance::IsObjectHeight
PUBLIC	?GetObjectHeight@CGraphicObjectInstance@@QAE_NMMPAM@Z ; CGraphicObjectInstance::GetObjectHeight
PUBLIC	??_GCGraphicObjectInstance@@UAEPAXI@Z		; CGraphicObjectInstance::`scalar deleting destructor'
PUBLIC	??$emplace_back@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEX$$QAPAVCBaseCollisionInstance@@@Z ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::emplace_back<CBaseCollisionInstance *>
PUBLIC	??$_Emplace_back_with_unused_capacity@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEX$$QAPAVCBaseCollisionInstance@@@Z ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Emplace_back_with_unused_capacity<CBaseCollisionInstance *>
PUBLIC	??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Emplace_reallocate<CBaseCollisionInstance *>
PUBLIC	??$_Destroy_range@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAXPAPAVCBaseCollisionInstance@@QAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CBaseCollisionInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAPAPAVCBaseCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CBaseCollisionInstance * *,std::allocator<CBaseCollisionInstance *> >
PUBLIC	??$_Copy_memmove@PAPAVCBaseCollisionInstance@@PAPAV1@@std@@YAPAPAVCBaseCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CBaseCollisionInstance * *,CBaseCollisionInstance * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
PUBLIC	??_7CGraphicObjectInstance@@6B@			; CGraphicObjectInstance::`vftable'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CGraphicObjectInstance@@6B@		; CGraphicObjectInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGraphicObjectInstance@@@8		; CGraphicObjectInstance `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicObjectInstance@@8			; CGraphicObjectInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicObjectInstance@@8			; CGraphicObjectInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicObjectInstance@@8		; CGraphicObjectInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CGraphicCollisionObject@@8	; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicCollisionObject@@@8		; CGraphicCollisionObject `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicBase@@8			; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicBase@@@8			; CGraphicBase `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicBase@@8				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicBase@@8				; CGraphicBase::`RTTI Base Class Array'
PUBLIC	__real@3c8efa35
PUBLIC	__real@3f800000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_D3DXMatrixRotationZ@8:PROC
EXTRN	_D3DXMatrixRotationQuaternion@8:PROC
EXTRN	_D3DXMatrixRotationYawPitchRoll@16:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??0CGraphicCollisionObject@@QAE@XZ:PROC		; CGraphicCollisionObject::CGraphicCollisionObject
EXTRN	??1CGraphicCollisionObject@@UAE@XZ:PROC		; CGraphicCollisionObject::~CGraphicCollisionObject
EXTRN	?IntersectTriangle@CGraphicCollisionObject@@IAE_NABUD3DXVECTOR3@@0000PAM11@Z:PROC ; CGraphicCollisionObject::IntersectTriangle
EXTRN	?LostChild@SpherePack@@QAEXPAV1@@Z:PROC		; SpherePack::LostChild
EXTRN	?AddIntegrate@SpherePackFactory@@QAEXPAVSpherePack@@@Z:PROC ; SpherePackFactory::AddIntegrate
EXTRN	?AddRecompute@SpherePackFactory@@QAEXPAVSpherePack@@@Z:PROC ; SpherePackFactory::AddRecompute
EXTRN	?Register@CCullingManager@@QAEPAVSpherePack@@PAVCGraphicObjectInstance@@@Z:PROC ; CCullingManager::Register
EXTRN	?Unregister@CCullingManager@@QAEXPAVSpherePack@@@Z:PROC ; CCullingManager::Unregister
EXTRN	?Destroy@CBaseCollisionInstance@@QAEXXZ:PROC	; CBaseCollisionInstance::Destroy
EXTRN	?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z:PROC ; CBaseCollisionInstance::BuildCollisionInstance
EXTRN	??_ECGraphicObjectInstance@@UAEPAXI@Z:PROC	; CGraphicObjectInstance::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A DD 01H DUP (?) ; CSingleton<CCullingManager>::ms_singleton
_BSS	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT ??_R2CGraphicBase@@8
rdata$r	SEGMENT
??_R2CGraphicBase@@8 DD FLAT:??_R1A@?0A@EA@CGraphicBase@@8 ; CGraphicBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicBase@@8
rdata$r	SEGMENT
??_R3CGraphicBase@@8 DD 00H				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicBase@@@8
data$rs	SEGMENT
??_R0?AVCGraphicBase@@@8 DD FLAT:??_7type_info@@6B@	; CGraphicBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicBase@@8 DD FLAT:??_R0?AVCGraphicBase@@@8 ; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R2CGraphicCollisionObject@@8 DD FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8 ; CGraphicCollisionObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R3CGraphicCollisionObject@@8 DD 00H			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicCollisionObject@@@8
data$rs	SEGMENT
??_R0?AVCGraphicCollisionObject@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicCollisionObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicCollisionObject@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicCollisionObject@@8 DD FLAT:??_R0?AVCGraphicCollisionObject@@@8 ; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicObjectInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicObjectInstance@@8 DD FLAT:??_R0?AVCGraphicObjectInstance@@@8 ; CGraphicObjectInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicObjectInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicObjectInstance@@8
rdata$r	SEGMENT
??_R2CGraphicObjectInstance@@8 DD FLAT:??_R1A@?0A@EA@CGraphicObjectInstance@@8 ; CGraphicObjectInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CGraphicObjectInstance@@8
rdata$r	SEGMENT
??_R3CGraphicObjectInstance@@8 DD 00H			; CGraphicObjectInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CGraphicObjectInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicObjectInstance@@@8
data$rs	SEGMENT
??_R0?AVCGraphicObjectInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicObjectInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicObjectInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CGraphicObjectInstance@@6B@
rdata$r	SEGMENT
??_R4CGraphicObjectInstance@@6B@ DD 00H			; CGraphicObjectInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGraphicObjectInstance@@@8
	DD	FLAT:??_R3CGraphicObjectInstance@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CGraphicObjectInstance@@6B@
CONST	SEGMENT
??_7CGraphicObjectInstance@@6B@ DD FLAT:??_R4CGraphicObjectInstance@@6B@ ; CGraphicObjectInstance::`vftable'
	DD	FLAT:??_ECGraphicObjectInstance@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?OnInitialize@CGraphicObjectInstance@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?OnClear@CGraphicObjectInstance@@UAEXXZ
	DD	FLAT:?OnUpdate@CGraphicObjectInstance@@UAEXXZ
	DD	FLAT:?OnDeform@CGraphicObjectInstance@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CGraphicObjectInstance@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CGraphicObjectInstance@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CGraphicObjectInstance@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CGraphicObjectInstance@@QAE@XZ$1
__ehfuncinfo$??0CGraphicObjectInstance@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CGraphicObjectInstance@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCBaseCollisionInstance@@PAPAV1@@std@@YAPAPAVCBaseCollisionInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCBaseCollisionInstance@@PAPAV1@@std@@YAPAPAVCBaseCollisionInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CBaseCollisionInstance * *,CBaseCollisionInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCBaseCollisionInstance@@PAPAV1@@std@@YAPAPAVCBaseCollisionInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CBaseCollisionInstance * *,CBaseCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAPAPAVCBaseCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAPAPAVCBaseCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z PROC ; std::_Uninitialized_move<CBaseCollisionInstance * *,std::allocator<CBaseCollisionInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCBaseCollisionInstance@@PAPAV1@@std@@YAPAPAVCBaseCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CBaseCollisionInstance * *,CBaseCollisionInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAPAPAVCBaseCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CBaseCollisionInstance * *,std::allocator<CBaseCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAXPAPAVCBaseCollisionInstance@@QAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAXPAPAVCBaseCollisionInstance@@QAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CBaseCollisionInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAXPAPAVCBaseCollisionInstance@@QAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CBaseCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z PROC ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Emplace_reallocate<CBaseCollisionInstance *>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@ABEII@Z ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAPAPAVCBaseCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CBaseCollisionInstance * *,std::allocator<CBaseCollisionInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAPAPAVCBaseCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CBaseCollisionInstance * *,std::allocator<CBaseCollisionInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAPAPAVCBaseCollisionInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z ; std::_Uninitialized_move<CBaseCollisionInstance * *,std::allocator<CBaseCollisionInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXPAPAVCBaseCollisionInstance@@0@Z ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCBaseCollisionInstance@@@std@@QAEXQAPAVCBaseCollisionInstance@@I@Z ; std::allocator<CBaseCollisionInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXQAPAVCBaseCollisionInstance@@II@Z ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z ENDP ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Emplace_reallocate<CBaseCollisionInstance *>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEX$$QAPAVCBaseCollisionInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEX$$QAPAVCBaseCollisionInstance@@@Z PROC ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Emplace_back_with_unused_capacity<CBaseCollisionInstance *>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEX$$QAPAVCBaseCollisionInstance@@@Z ENDP ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Emplace_back_with_unused_capacity<CBaseCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEX$$QAPAVCBaseCollisionInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEX$$QAPAVCBaseCollisionInstance@@@Z PROC ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::emplace_back<CBaseCollisionInstance *>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEX$$QAPAVCBaseCollisionInstance@@@Z ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Emplace_back_with_unused_capacity<CBaseCollisionInstance *>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEPAPAVCBaseCollisionInstance@@QAPAV2@$$QAPAV2@@Z ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Emplace_reallocate<CBaseCollisionInstance *>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEX$$QAPAVCBaseCollisionInstance@@@Z ENDP ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::emplace_back<CBaseCollisionInstance *>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCGraphicObjectInstance@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCGraphicObjectInstance@@UAEPAXI@Z PROC		; CGraphicObjectInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CGraphicObjectInstance@@UAE@XZ ; CGraphicObjectInstance::~CGraphicObjectInstance
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 7c 01 00 00	 push	 380			; 0000017cH
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCGraphicObjectInstance@@UAEPAXI@Z ENDP		; CGraphicObjectInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetObjectHeight@CGraphicObjectInstance@@QAE_NMMPAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
_pfHeight$ = 16						; size = 4
?GetObjectHeight@CGraphicObjectInstance@@QAE_NMMPAM@Z PROC ; CGraphicObjectInstance::GetObjectHeight, COMDAT
; _this$ = ecx

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 415  : 	if (!m_pHeightAttributeInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 b8 78 01 00
	00 00		 cmp	 DWORD PTR [eax+376], 0
  00011	75 04		 jne	 SHORT $LN2@GetObjectH

; 416  : 		return false;

  00013	32 c0		 xor	 al, al
  00015	eb 24		 jmp	 SHORT $LN1@GetObjectH
$LN2@GetObjectH:

; 417  : 
; 418  : 	return OnGetObjectHeight(fX, fY, pfHeight);

  00017	ff 75 10	 push	 DWORD PTR _pfHeight$[ebp]
  0001a	51		 push	 ecx
  0001b	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00020	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00025	51		 push	 ecx
  00026	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fX$[ebp]
  0002b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	ff 50 38	 call	 DWORD PTR [eax+56]
$LN1@GetObjectH:

; 419  : }

  0003b	c9		 leave
  0003c	c2 0c 00	 ret	 12			; 0000000cH
?GetObjectHeight@CGraphicObjectInstance@@QAE_NMMPAM@Z ENDP ; CGraphicObjectInstance::GetObjectHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?IsObjectHeight@CGraphicObjectInstance@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsObjectHeight@CGraphicObjectInstance@@QAE_NXZ PROC	; CGraphicObjectInstance::IsObjectHeight, COMDAT
; _this$ = ecx

; 406  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 407  : 	if (m_pHeightAttributeInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 b8 78 01 00
	00 00		 cmp	 DWORD PTR [eax+376], 0
  00011	74 04		 je	 SHORT $LN2@IsObjectHe

; 408  : 		return true;

  00013	b0 01		 mov	 al, 1
  00015	eb 02		 jmp	 SHORT $LN1@IsObjectHe
$LN2@IsObjectHe:

; 409  : 
; 410  : 	return false;

  00017	32 c0		 xor	 al, al
$LN1@IsObjectHe:

; 411  : }

  00019	c9		 leave
  0001a	c3		 ret	 0
?IsObjectHeight@CGraphicObjectInstance@@QAE_NXZ ENDP	; CGraphicObjectInstance::IsObjectHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?UpdateHeightInstance@CGraphicObjectInstance@@QAEXPAVCAttributeInstance@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pAttributeInstance$ = 8				; size = 4
?UpdateHeightInstance@CGraphicObjectInstance@@QAEXPAVCAttributeInstance@@@Z PROC ; CGraphicObjectInstance::UpdateHeightInstance, COMDAT
; _this$ = ecx

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 401  : 	ClearHeightInstance();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?ClearHeightInstance@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::ClearHeightInstance

; 402  : 	OnUpdateHeighInstance(pAttributeInstance);

  0000f	ff 75 08	 push	 DWORD PTR _pAttributeInstance$[ebp]
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 00		 mov	 eax, DWORD PTR [eax]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	ff 50 34	 call	 DWORD PTR [eax+52]

; 403  : }

  0001d	c9		 leave
  0001e	c2 04 00	 ret	 4
?UpdateHeightInstance@CGraphicObjectInstance@@QAEXPAVCAttributeInstance@@@Z ENDP ; CGraphicObjectInstance::UpdateHeightInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?ClearHeightInstance@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearHeightInstance@CGraphicObjectInstance@@QAEXXZ PROC ; CGraphicObjectInstance::ClearHeightInstance, COMDAT
; _this$ = ecx

; 395  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 	m_pHeightAttributeInstance = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 a0 78 01 00
	00 00		 and	 DWORD PTR [eax+376], 0

; 397  : }

  00011	c9		 leave
  00012	c3		 ret	 0
?ClearHeightInstance@CGraphicObjectInstance@@QAEXXZ ENDP ; CGraphicObjectInstance::ClearHeightInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?SetHeightInstance@CGraphicObjectInstance@@QAEXPAVCAttributeInstance@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pAttributeInstance$ = 8				; size = 4
?SetHeightInstance@CGraphicObjectInstance@@QAEXPAVCAttributeInstance@@@Z PROC ; CGraphicObjectInstance::SetHeightInstance, COMDAT
; _this$ = ecx

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 391  : 	m_pHeightAttributeInstance = pAttributeInstance;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pAttributeInstance$[ebp]
  0000d	89 88 78 01 00
	00		 mov	 DWORD PTR [eax+376], ecx

; 392  : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?SetHeightInstance@CGraphicObjectInstance@@QAEXPAVCAttributeInstance@@@Z ENDP ; CGraphicObjectInstance::SetHeightInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetCollisionInstanceData@CGraphicObjectInstance@@QAEPAVCBaseCollisionInstance@@K@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__My_data$2 = -16					; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$4 = -4					; size = 4
_dwIndex$ = 8						; size = 4
?GetCollisionInstanceData@CGraphicObjectInstance@@QAEPAVCBaseCollisionInstance@@K@Z PROC ; CGraphicObjectInstance::GetCollisionInstanceData, COMDAT
; _this$ = ecx

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  00011	89 45 fc	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00014	8b 45 fc	 mov	 eax, DWORD PTR __My_data$4[ebp]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$4[ebp]
  0001a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001d	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001f	c1 f8 02	 sar	 eax, 2
  00022	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 379  : 	if (dwIndex>m_StaticCollisionInstanceVector.size())

  00025	8b 45 08	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00028	3b 45 f4	 cmp	 eax, DWORD PTR $T3[ebp]
  0002b	76 04		 jbe	 SHORT $LN2@GetCollisi

; 380  : 	{
; 381  : 		return 0;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 1e		 jmp	 SHORT $LN1@GetCollisi
$LN2@GetCollisi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  00039	89 45 f0	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0003c	8b 45 f0	 mov	 eax, DWORD PTR __My_data$2[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  00044	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00047	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 383  : 	return m_StaticCollisionInstanceVector[dwIndex];

  0004a	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0004d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@GetCollisi:

; 384  : }

  0004f	c9		 leave
  00050	c2 04 00	 ret	 4
?GetCollisionInstanceData@CGraphicObjectInstance@@QAEPAVCBaseCollisionInstance@@K@Z ENDP ; CGraphicObjectInstance::GetCollisionInstanceData
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetCollisionInstanceCount@CGraphicObjectInstance@@QAEKXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$2 = -4					; size = 4
?GetCollisionInstanceCount@CGraphicObjectInstance@@QAEKXZ PROC ; CGraphicObjectInstance::GetCollisionInstanceCount, COMDAT
; _this$ = ecx

; 373  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  00011	89 45 fc	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00014	8b 45 fc	 mov	 eax, DWORD PTR __My_data$2[ebp]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  0001a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001d	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001f	c1 f8 02	 sar	 eax, 2
  00022	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 374  : 	return m_StaticCollisionInstanceVector.size();

  00025	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 375  : }

  00028	c9		 leave
  00029	c3		 ret	 0
?GetCollisionInstanceCount@CGraphicObjectInstance@@QAEKXZ ENDP ; CGraphicObjectInstance::GetCollisionInstanceCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAXPAPAVCBaseCollisionInstance@@QAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CBaseCollisionInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXQAPAVCBaseCollisionInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXQAPAVCBaseCollisionInstance@@II@Z PROC ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAXPAPAVCBaseCollisionInstance@@QAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CBaseCollisionInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXQAPAVCBaseCollisionInstance@@II@Z ENDP ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXPAPAVCBaseCollisionInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXPAPAVCBaseCollisionInstance@@0@Z PROC ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAXPAPAVCBaseCollisionInstance@@QAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CBaseCollisionInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXPAPAVCBaseCollisionInstance@@0@Z ENDP ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@YAXPAPAVCBaseCollisionInstance@@QAPAV1@AAV?$allocator@PAVCBaseCollisionInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CBaseCollisionInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::~vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::~vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCBaseCollisionInstance@@@std@@QAEXQAPAVCBaseCollisionInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCBaseCollisionInstance@@@std@@QAEXQAPAVCBaseCollisionInstance@@I@Z PROC ; std::allocator<CBaseCollisionInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCBaseCollisionInstance@@@std@@QAEXQAPAVCBaseCollisionInstance@@I@Z ENDP ; std::allocator<CBaseCollisionInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?UpdateCollisionData@CGraphicObjectInstance@@QAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pscdVector$ = 8					; size = 4
?UpdateCollisionData@CGraphicObjectInstance@@QAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z PROC ; CGraphicObjectInstance::UpdateCollisionData, COMDAT
; _this$ = ecx

; 367  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 368  : 	ClearCollision();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?ClearCollision@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::ClearCollision

; 369  : 	OnUpdateCollisionData(pscdVector);

  0000f	ff 75 08	 push	 DWORD PTR _pscdVector$[ebp]
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 00		 mov	 eax, DWORD PTR [eax]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	ff 50 30	 call	 DWORD PTR [eax+48]

; 370  : }

  0001d	c9		 leave
  0001e	c2 04 00	 ret	 4
?UpdateCollisionData@CGraphicObjectInstance@@QAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z ENDP ; CGraphicObjectInstance::UpdateCollisionData
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetCollisionMovementAdjust@CGraphicObjectInstance@@QBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 4
__Parg$ = -52						; size = 4
$T7 = -48						; size = 4
$T8 = -44						; size = 4
__Parg$ = -40						; size = 4
_this$ = -36						; size = 4
_this$ = -32						; size = 4
tv170 = -28						; size = 4
tv176 = -24						; size = 4
__My_data$9 = -20					; size = 4
_this$ = -16						; size = 4
__My_data$10 = -12					; size = 4
_it$ = -8						; size = 4
$T11 = -2						; size = 1
$T12 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?GetCollisionMovementAdjust@CGraphicObjectInstance@@QBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CGraphicObjectInstance::GetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00009	83 65 f8 00	 and	 DWORD PTR _it$[ebp], 0

; 1415 :         auto& _My_data = _Mypair._Myval2;

  0000d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00010	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  00015	89 45 f4	 mov	 DWORD PTR __My_data$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00018	8b 45 f4	 mov	 eax, DWORD PTR __My_data$10[ebp]
  0001b	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1416 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 d8	 mov	 DWORD PTR __Parg$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00026	8b 45 d8	 mov	 eax, DWORD PTR __Parg$[ebp]
  00029	89 45 d4	 mov	 DWORD PTR $T8[ebp], eax

; 1416 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0002c	8d 45 d4	 lea	 eax, DWORD PTR $T8[ebp]
  0002f	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 357  : 	for(it = m_StaticCollisionInstanceVector.begin();it!=m_StaticCollisionInstanceVector.end();++it)

  00032	8b 45 d0	 mov	 eax, DWORD PTR $T7[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	89 45 f8	 mov	 DWORD PTR _it$[ebp], eax
  0003a	eb 09		 jmp	 SHORT $LN22@GetCollisi
$LN2@GetCollisi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _it$[ebp]
  0003f	83 c0 04	 add	 eax, 4
  00042	89 45 f8	 mov	 DWORD PTR _it$[ebp], eax
$LN22@GetCollisi:

; 1425 :         auto& _My_data = _Mypair._Myval2;

  00045	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00048	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  0004d	89 45 ec	 mov	 DWORD PTR __My_data$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00050	8b 45 ec	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00053	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1426 :         return const_iterator(_My_data._Mylast, _STD addressof(_My_data));

  00056	8b 45 ec	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	89 45 cc	 mov	 DWORD PTR __Parg$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0005f	8b 45 cc	 mov	 eax, DWORD PTR __Parg$[ebp]
  00062	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax

; 1426 :         return const_iterator(_My_data._Mylast, _STD addressof(_My_data));

  00065	8d 45 c8	 lea	 eax, DWORD PTR $T6[ebp]
  00068	89 45 c4	 mov	 DWORD PTR $T5[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0006b	8b 45 c4	 mov	 eax, DWORD PTR $T5[ebp]
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _it$[ebp]
  00071	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00073	75 09		 jne	 SHORT $LN44@GetCollisi
  00075	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv176[ebp], 1
  0007c	eb 04		 jmp	 SHORT $LN45@GetCollisi
$LN44@GetCollisi:
  0007e	83 65 e8 00	 and	 DWORD PTR tv176[ebp], 0
$LN45@GetCollisi:
  00082	8a 45 e8	 mov	 al, BYTE PTR tv176[ebp]
  00085	88 45 ff	 mov	 BYTE PTR $T12[ebp], al

; 153  :         return !(*this == _Right);

  00088	0f b6 45 ff	 movzx	 eax, BYTE PTR $T12[ebp]
  0008c	85 c0		 test	 eax, eax
  0008e	75 09		 jne	 SHORT $LN39@GetCollisi
  00090	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv170[ebp], 1
  00097	eb 04		 jmp	 SHORT $LN40@GetCollisi
$LN39@GetCollisi:
  00099	83 65 e4 00	 and	 DWORD PTR tv170[ebp], 0
$LN40@GetCollisi:
  0009d	8a 45 e4	 mov	 al, BYTE PTR tv170[ebp]
  000a0	88 45 fe	 mov	 BYTE PTR $T11[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 357  : 	for(it = m_StaticCollisionInstanceVector.begin();it!=m_StaticCollisionInstanceVector.end();++it)

  000a3	0f b6 45 fe	 movzx	 eax, BYTE PTR $T11[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 4c		 je	 SHORT $LN3@GetCollisi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _it$[ebp]
  000ae	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 359  : 		if ((*it)->MovementCollisionDynamicSphere(s))

  000b1	8b 45 c0	 mov	 eax, DWORD PTR $T4[ebp]
  000b4	8b 00		 mov	 eax, DWORD PTR [eax]
  000b6	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.h

; 83   : 			return OnMovementCollisionDynamicSphere(s);

  000b9	ff 75 0c	 push	 DWORD PTR _s$[ebp]
  000bc	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 00		 mov	 eax, DWORD PTR [eax]
  000c1	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	ff 50 08	 call	 DWORD PTR [eax+8]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 359  : 		if ((*it)->MovementCollisionDynamicSphere(s))

  000c7	0f b6 c0	 movzx	 eax, al
  000ca	85 c0		 test	 eax, eax
  000cc	74 24		 je	 SHORT $LN5@GetCollisi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000ce	8b 45 f8	 mov	 eax, DWORD PTR _it$[ebp]
  000d1	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 360  : 			return (*it)->GetCollisionMovementAdjust(s);

  000d4	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]
  000d9	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.h

; 93   : 			return OnGetCollisionMovementAdjust(s);

  000dc	ff 75 0c	 push	 DWORD PTR _s$[ebp]
  000df	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  000e2	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	8b 00		 mov	 eax, DWORD PTR [eax]
  000e7	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	ff 50 04	 call	 DWORD PTR [eax+4]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 360  : 			return (*it)->GetCollisionMovementAdjust(s);

  000ed	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000f0	eb 28		 jmp	 SHORT $LN1@GetCollisi
$LN5@GetCollisi:

; 361  : 	}

  000f2	e9 45 ff ff ff	 jmp	 $LN2@GetCollisi
$LN3@GetCollisi:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  000f7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000fa	0f 57 c0	 xorps	 xmm0, xmm0
  000fd	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 181  :     y = fy;

  00101	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00104	0f 57 c0	 xorps	 xmm0, xmm0
  00107	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 182  :     z = fz;

  0010c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0010f	0f 57 c0	 xorps	 xmm0, xmm0
  00112	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 363  : 	return D3DXVECTOR3(0.0f,0.0f,0.0f);

  00117	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@GetCollisi:

; 364  : }

  0011a	c9		 leave
  0011b	c2 08 00	 ret	 8
?GetCollisionMovementAdjust@CGraphicObjectInstance@@QBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CGraphicObjectInstance::GetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?MovementCollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
__Parg$ = -48						; size = 4
$T6 = -44						; size = 4
$T7 = -40						; size = 4
__Parg$ = -36						; size = 4
_this$ = -32						; size = 4
tv161 = -28						; size = 4
tv167 = -24						; size = 4
__My_data$8 = -20					; size = 4
_this$ = -16						; size = 4
__My_data$9 = -12					; size = 4
_it$ = -8						; size = 4
$T10 = -2						; size = 1
$T11 = -1						; size = 1
_s$ = 8							; size = 4
?MovementCollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z PROC ; CGraphicObjectInstance::MovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 344  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00009	83 65 f8 00	 and	 DWORD PTR _it$[ebp], 0

; 1415 :         auto& _My_data = _Mypair._Myval2;

  0000d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00010	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  00015	89 45 f4	 mov	 DWORD PTR __My_data$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00018	8b 45 f4	 mov	 eax, DWORD PTR __My_data$9[ebp]
  0001b	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1416 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 dc	 mov	 DWORD PTR __Parg$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00026	8b 45 dc	 mov	 eax, DWORD PTR __Parg$[ebp]
  00029	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax

; 1416 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0002c	8d 45 d8	 lea	 eax, DWORD PTR $T7[ebp]
  0002f	89 45 d4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 346  : 	for(it = m_StaticCollisionInstanceVector.begin();it!=m_StaticCollisionInstanceVector.end();++it)

  00032	8b 45 d4	 mov	 eax, DWORD PTR $T6[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	89 45 f8	 mov	 DWORD PTR _it$[ebp], eax
  0003a	eb 09		 jmp	 SHORT $LN4@MovementCo
$LN2@MovementCo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _it$[ebp]
  0003f	83 c0 04	 add	 eax, 4
  00042	89 45 f8	 mov	 DWORD PTR _it$[ebp], eax
$LN4@MovementCo:

; 1425 :         auto& _My_data = _Mypair._Myval2;

  00045	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00048	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  0004d	89 45 ec	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00050	8b 45 ec	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00053	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1426 :         return const_iterator(_My_data._Mylast, _STD addressof(_My_data));

  00056	8b 45 ec	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	89 45 d0	 mov	 DWORD PTR __Parg$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0005f	8b 45 d0	 mov	 eax, DWORD PTR __Parg$[ebp]
  00062	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax

; 1426 :         return const_iterator(_My_data._Mylast, _STD addressof(_My_data));

  00065	8d 45 cc	 lea	 eax, DWORD PTR $T5[ebp]
  00068	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0006b	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _it$[ebp]
  00071	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00073	75 09		 jne	 SHORT $LN44@MovementCo
  00075	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv167[ebp], 1
  0007c	eb 04		 jmp	 SHORT $LN45@MovementCo
$LN44@MovementCo:
  0007e	83 65 e8 00	 and	 DWORD PTR tv167[ebp], 0
$LN45@MovementCo:
  00082	8a 45 e8	 mov	 al, BYTE PTR tv167[ebp]
  00085	88 45 ff	 mov	 BYTE PTR $T11[ebp], al

; 153  :         return !(*this == _Right);

  00088	0f b6 45 ff	 movzx	 eax, BYTE PTR $T11[ebp]
  0008c	85 c0		 test	 eax, eax
  0008e	75 09		 jne	 SHORT $LN39@MovementCo
  00090	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv161[ebp], 1
  00097	eb 04		 jmp	 SHORT $LN40@MovementCo
$LN39@MovementCo:
  00099	83 65 e4 00	 and	 DWORD PTR tv161[ebp], 0
$LN40@MovementCo:
  0009d	8a 45 e4	 mov	 al, BYTE PTR tv161[ebp]
  000a0	88 45 fe	 mov	 BYTE PTR $T10[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 346  : 	for(it = m_StaticCollisionInstanceVector.begin();it!=m_StaticCollisionInstanceVector.end();++it)

  000a3	0f b6 45 fe	 movzx	 eax, BYTE PTR $T10[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 2c		 je	 SHORT $LN3@MovementCo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _it$[ebp]
  000ae	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 348  : 		if ((*it)->MovementCollisionDynamicSphere(s))

  000b1	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000b4	8b 00		 mov	 eax, DWORD PTR [eax]
  000b6	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.h

; 83   : 			return OnMovementCollisionDynamicSphere(s);

  000b9	ff 75 08	 push	 DWORD PTR _s$[ebp]
  000bc	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 00		 mov	 eax, DWORD PTR [eax]
  000c1	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	ff 50 08	 call	 DWORD PTR [eax+8]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 348  : 		if ((*it)->MovementCollisionDynamicSphere(s))

  000c7	0f b6 c0	 movzx	 eax, al
  000ca	85 c0		 test	 eax, eax
  000cc	74 04		 je	 SHORT $LN5@MovementCo

; 349  : 			return true;

  000ce	b0 01		 mov	 al, 1
  000d0	eb 07		 jmp	 SHORT $LN1@MovementCo
$LN5@MovementCo:

; 350  : 	}

  000d2	e9 65 ff ff ff	 jmp	 $LN2@MovementCo
$LN3@MovementCo:

; 351  : 	return false;

  000d7	32 c0		 xor	 al, al
$LN1@MovementCo:

; 352  : }

  000d9	c9		 leave
  000da	c2 04 00	 ret	 4
?MovementCollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ENDP ; CGraphicObjectInstance::MovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
__Parg$ = -48						; size = 4
$T6 = -44						; size = 4
$T7 = -40						; size = 4
__Parg$ = -36						; size = 4
_this$ = -32						; size = 4
tv161 = -28						; size = 4
tv167 = -24						; size = 4
__My_data$8 = -20					; size = 4
_this$ = -16						; size = 4
__My_data$9 = -12					; size = 4
_it$ = -8						; size = 4
$T10 = -2						; size = 1
$T11 = -1						; size = 1
_s$ = 8							; size = 4
?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z PROC ; CGraphicObjectInstance::CollisionDynamicSphere, COMDAT
; _this$ = ecx

; 333  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00009	83 65 f8 00	 and	 DWORD PTR _it$[ebp], 0

; 1415 :         auto& _My_data = _Mypair._Myval2;

  0000d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00010	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  00015	89 45 f4	 mov	 DWORD PTR __My_data$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00018	8b 45 f4	 mov	 eax, DWORD PTR __My_data$9[ebp]
  0001b	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1416 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 dc	 mov	 DWORD PTR __Parg$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00026	8b 45 dc	 mov	 eax, DWORD PTR __Parg$[ebp]
  00029	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax

; 1416 :         return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0002c	8d 45 d8	 lea	 eax, DWORD PTR $T7[ebp]
  0002f	89 45 d4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 335  : 	for(it = m_StaticCollisionInstanceVector.begin();it!=m_StaticCollisionInstanceVector.end();++it)

  00032	8b 45 d4	 mov	 eax, DWORD PTR $T6[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	89 45 f8	 mov	 DWORD PTR _it$[ebp], eax
  0003a	eb 09		 jmp	 SHORT $LN4@CollisionD
$LN2@CollisionD:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _it$[ebp]
  0003f	83 c0 04	 add	 eax, 4
  00042	89 45 f8	 mov	 DWORD PTR _it$[ebp], eax
$LN4@CollisionD:

; 1425 :         auto& _My_data = _Mypair._Myval2;

  00045	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00048	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  0004d	89 45 ec	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00050	8b 45 ec	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00053	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1426 :         return const_iterator(_My_data._Mylast, _STD addressof(_My_data));

  00056	8b 45 ec	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	89 45 d0	 mov	 DWORD PTR __Parg$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0005f	8b 45 d0	 mov	 eax, DWORD PTR __Parg$[ebp]
  00062	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax

; 1426 :         return const_iterator(_My_data._Mylast, _STD addressof(_My_data));

  00065	8d 45 cc	 lea	 eax, DWORD PTR $T5[ebp]
  00068	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0006b	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _it$[ebp]
  00071	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00073	75 09		 jne	 SHORT $LN44@CollisionD
  00075	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv167[ebp], 1
  0007c	eb 04		 jmp	 SHORT $LN45@CollisionD
$LN44@CollisionD:
  0007e	83 65 e8 00	 and	 DWORD PTR tv167[ebp], 0
$LN45@CollisionD:
  00082	8a 45 e8	 mov	 al, BYTE PTR tv167[ebp]
  00085	88 45 ff	 mov	 BYTE PTR $T11[ebp], al

; 153  :         return !(*this == _Right);

  00088	0f b6 45 ff	 movzx	 eax, BYTE PTR $T11[ebp]
  0008c	85 c0		 test	 eax, eax
  0008e	75 09		 jne	 SHORT $LN39@CollisionD
  00090	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv161[ebp], 1
  00097	eb 04		 jmp	 SHORT $LN40@CollisionD
$LN39@CollisionD:
  00099	83 65 e4 00	 and	 DWORD PTR tv161[ebp], 0
$LN40@CollisionD:
  0009d	8a 45 e4	 mov	 al, BYTE PTR tv161[ebp]
  000a0	88 45 fe	 mov	 BYTE PTR $T10[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 335  : 	for(it = m_StaticCollisionInstanceVector.begin();it!=m_StaticCollisionInstanceVector.end();++it)

  000a3	0f b6 45 fe	 movzx	 eax, BYTE PTR $T10[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 2c		 je	 SHORT $LN3@CollisionD
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _it$[ebp]
  000ae	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 337  : 		if ((*it)->CollisionDynamicSphere(s))

  000b1	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000b4	8b 00		 mov	 eax, DWORD PTR [eax]
  000b6	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\CollisionData.h

; 87   : 			return OnCollisionDynamicSphere(s);

  000b9	ff 75 08	 push	 DWORD PTR _s$[ebp]
  000bc	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 00		 mov	 eax, DWORD PTR [eax]
  000c1	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	ff 50 0c	 call	 DWORD PTR [eax+12]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 337  : 		if ((*it)->CollisionDynamicSphere(s))

  000c7	0f b6 c0	 movzx	 eax, al
  000ca	85 c0		 test	 eax, eax
  000cc	74 04		 je	 SHORT $LN5@CollisionD

; 338  : 			return true;

  000ce	b0 01		 mov	 al, 1
  000d0	eb 07		 jmp	 SHORT $LN1@CollisionD
$LN5@CollisionD:

; 339  : 	}

  000d2	e9 65 ff ff ff	 jmp	 $LN2@CollisionD
$LN3@CollisionD:

; 340  : 	return false;

  000d7	32 c0		 xor	 al, al
$LN1@CollisionD:

; 341  : }

  000d9	c9		 leave
  000da	c2 04 00	 ret	 4
?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ENDP ; CGraphicObjectInstance::CollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?ClearCollision@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
___param0$ = -44					; size = 4
$T7 = -40						; size = 4
$T8 = -36						; size = 4
___param0$ = -32					; size = 4
tv175 = -28						; size = 4
tv189 = -24						; size = 4
__My_data$9 = -20					; size = 4
__My_data$10 = -16					; size = 4
_this$ = -12						; size = 4
_it$ = -8						; size = 4
$T11 = -2						; size = 1
$T12 = -1						; size = 1
?ClearCollision@CGraphicObjectInstance@@QAEXXZ PROC	; CGraphicObjectInstance::ClearCollision, COMDAT
; _this$ = ecx

; 323  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00009	83 65 f8 00	 and	 DWORD PTR _it$[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00010	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  00015	89 45 f0	 mov	 DWORD PTR __My_data$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __My_data$10[ebp]
  0001b	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001e	8b 45 f0	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00026	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00029	89 45 dc	 mov	 DWORD PTR $T8[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0002c	8d 45 dc	 lea	 eax, DWORD PTR $T8[ebp]
  0002f	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 325  : 	for(it = m_StaticCollisionInstanceVector.begin();it!=m_StaticCollisionInstanceVector.end();++it)

  00032	8b 45 d8	 mov	 eax, DWORD PTR $T7[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	89 45 f8	 mov	 DWORD PTR _it$[ebp], eax
  0003a	eb 09		 jmp	 SHORT $LN4@ClearColli
$LN2@ClearColli:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _it$[ebp]
  0003f	83 c0 04	 add	 eax, 4
  00042	89 45 f8	 mov	 DWORD PTR _it$[ebp], eax
$LN4@ClearColli:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00048	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  0004d	89 45 ec	 mov	 DWORD PTR __My_data$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00050	8b 45 ec	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00053	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00056	8b 45 ec	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0005f	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00065	8d 45 d0	 lea	 eax, DWORD PTR $T6[ebp]
  00068	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0006b	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _it$[ebp]
  00071	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00073	75 09		 jne	 SHORT $LN55@ClearColli
  00075	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv189[ebp], 1
  0007c	eb 04		 jmp	 SHORT $LN56@ClearColli
$LN55@ClearColli:
  0007e	83 65 e8 00	 and	 DWORD PTR tv189[ebp], 0
$LN56@ClearColli:
  00082	8a 45 e8	 mov	 al, BYTE PTR tv189[ebp]
  00085	88 45 ff	 mov	 BYTE PTR $T12[ebp], al

; 153  :         return !(*this == _Right);

  00088	0f b6 45 ff	 movzx	 eax, BYTE PTR $T12[ebp]
  0008c	85 c0		 test	 eax, eax
  0008e	75 09		 jne	 SHORT $LN50@ClearColli
  00090	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv175[ebp], 1
  00097	eb 04		 jmp	 SHORT $LN51@ClearColli
$LN50@ClearColli:
  00099	83 65 e4 00	 and	 DWORD PTR tv175[ebp], 0
$LN51@ClearColli:
  0009d	8a 45 e4	 mov	 al, BYTE PTR tv175[ebp]
  000a0	88 45 fe	 mov	 BYTE PTR $T11[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 325  : 	for(it = m_StaticCollisionInstanceVector.begin();it!=m_StaticCollisionInstanceVector.end();++it)

  000a3	0f b6 45 fe	 movzx	 eax, BYTE PTR $T11[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 1b		 je	 SHORT $LN3@ClearColli
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _it$[ebp]
  000ae	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000b1	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
  000b4	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 327  : 		(*it)->Destroy();

  000b7	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000ba	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bc	e8 00 00 00 00	 call	 ?Destroy@CBaseCollisionInstance@@QAEXXZ ; CBaseCollisionInstance::Destroy

; 328  : 	}

  000c1	e9 76 ff ff ff	 jmp	 $LN2@ClearColli
$LN3@ClearColli:

; 329  : 	m_StaticCollisionInstanceVector.clear();

  000c6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	81 c1 6c 01 00
	00		 add	 ecx, 364		; 0000016cH
  000cf	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEXXZ ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::clear

; 330  : }

  000d4	c9		 leave
  000d5	c3		 ret	 0
?ClearCollision@CGraphicObjectInstance@@QAEXXZ ENDP	; CGraphicObjectInstance::ClearCollision
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?AddCollision@CGraphicObjectInstance@@QAEXPBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
_pscd$ = 8						; size = 4
_pMat$ = 12						; size = 4
?AddCollision@CGraphicObjectInstance@@QAEXPBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z PROC ; CGraphicObjectInstance::AddCollision, COMDAT
; _this$ = ecx

; 318  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 319  : 	m_StaticCollisionInstanceVector.push_back(CBaseCollisionInstance::BuildCollisionInstance(pscd, pMat));

  00009	ff 75 0c	 push	 DWORD PTR _pMat$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR _pscd$[ebp]
  0000f	e8 00 00 00 00	 call	 ?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z ; CBaseCollisionInstance::BuildCollisionInstance
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx
  00016	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00019	8d 45 fc	 lea	 eax, DWORD PTR $T2[ebp]
  0001c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 721  :         emplace_back(_STD move(_Val));

  0001f	ff 75 f8	 push	 DWORD PTR $T1[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 319  : 	m_StaticCollisionInstanceVector.push_back(CBaseCollisionInstance::BuildCollisionInstance(pscd, pMat));

  00022	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	81 c1 6c 01 00
	00		 add	 ecx, 364		; 0000016cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 721  :         emplace_back(_STD move(_Val));

  0002b	e8 00 00 00 00	 call	 ??$emplace_back@PAVCBaseCollisionInstance@@@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAEX$$QAPAVCBaseCollisionInstance@@@Z ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::emplace_back<CBaseCollisionInstance *>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 320  : }

  00030	c9		 leave
  00031	c2 08 00	 ret	 8
?AddCollision@CGraphicObjectInstance@@QAEXPBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z ENDP ; CGraphicObjectInstance::AddCollision
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.h
;	COMDAT ?OnDeform@CGraphicObjectInstance@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnDeform@CGraphicObjectInstance@@UAEXXZ PROC		; CGraphicObjectInstance::OnDeform, COMDAT
; _this$ = ecx

; 99   : 		virtual void			OnDeform(){}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?OnDeform@CGraphicObjectInstance@@UAEXXZ ENDP		; CGraphicObjectInstance::OnDeform
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.h
;	COMDAT ?OnUpdate@CGraphicObjectInstance@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnUpdate@CGraphicObjectInstance@@UAEXXZ PROC		; CGraphicObjectInstance::OnUpdate, COMDAT
; _this$ = ecx

; 98   : 		virtual void			OnUpdate(){}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?OnUpdate@CGraphicObjectInstance@@UAEXXZ ENDP		; CGraphicObjectInstance::OnUpdate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.h
;	COMDAT ?OnClear@CGraphicObjectInstance@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnClear@CGraphicObjectInstance@@UAEXXZ PROC		; CGraphicObjectInstance::OnClear, COMDAT
; _this$ = ecx

; 97   : 		virtual void			OnClear(){}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?OnClear@CGraphicObjectInstance@@UAEXXZ ENDP		; CGraphicObjectInstance::OnClear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?RegisterBoundingSphere@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?RegisterBoundingSphere@CGraphicObjectInstance@@QAEXXZ PROC ; CGraphicObjectInstance::RegisterBoundingSphere, COMDAT
; _this$ = ecx

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 311  : 	if (m_CullingHandle)

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 b8 68 01 00
	00 00		 cmp	 DWORD PTR [eax+360], 0
  00012	74 14		 je	 SHORT $LN2@RegisterBo

; 312  : 		CCullingManager::Instance().Unregister(m_CullingHandle);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	ff b0 68 01 00
	00		 push	 DWORD PTR [eax+360]
  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  00023	e8 00 00 00 00	 call	 ?Unregister@CCullingManager@@QAEXPAVSpherePack@@@Z ; CCullingManager::Unregister
$LN2@RegisterBo:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  0002d	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 314  : 	m_CullingHandle = CCullingManager::Instance().Register(this);

  00030	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00036	e8 00 00 00 00	 call	 ?Register@CCullingManager@@QAEPAVSpherePack@@PAVCGraphicObjectInstance@@@Z ; CCullingManager::Register
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 81 68 01 00
	00		 mov	 DWORD PTR [ecx+360], eax

; 315  : }

  00044	c9		 leave
  00045	c3		 ret	 0
?RegisterBoundingSphere@CGraphicObjectInstance@@QAEXXZ ENDP ; CGraphicObjectInstance::RegisterBoundingSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\sphere.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?UpdateBoundingSphere@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
_radius$2 = -24						; size = 4
_this$ = -20						; size = 4
_center$3 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?UpdateBoundingSphere@CGraphicObjectInstance@@QAEXXZ PROC ; CGraphicObjectInstance::UpdateBoundingSphere, COMDAT
; _this$ = ecx

; 296  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 297  : 	if (m_CullingHandle)

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 b8 68 01 00
	00 00		 cmp	 DWORD PTR [eax+360], 0
  0001d	74 66		 je	 SHORT $LN4@UpdateBoun

; 298  : 	{
; 299  : 		Vector3d center;
; 300  : 		float radius;
; 301  : 		GetBoundingSphere(center,radius);

  0001f	8d 45 e8	 lea	 eax, DWORD PTR _radius$2[ebp]
  00022	50		 push	 eax
  00023	8d 45 f0	 lea	 eax, DWORD PTR _center$3[ebp]
  00026	50		 push	 eax
  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	ff 50 0c	 call	 DWORD PTR [eax+12]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\sphere.h

; 45   : 	float GetRadius(void) const { return mRadius; };

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 80 68 01 00
	00		 mov	 eax, DWORD PTR [eax+360]
  0003b	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00040	f3 0f 11 45 e4	 movss	 DWORD PTR $T1[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 302  : 		if (radius != m_CullingHandle->GetRadius())

  00045	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _radius$2[ebp]
  0004a	0f 2e 45 e4	 ucomiss xmm0, DWORD PTR $T1[ebp]
  0004e	9f		 lahf
  0004f	f6 c4 44	 test	 ah, 68			; 00000044H
  00052	7b 1f		 jnp	 SHORT $LN3@UpdateBoun

; 303  : 			m_CullingHandle->NewPosRadius(center,radius);

  00054	51		 push	 ecx
  00055	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _radius$2[ebp]
  0005a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005f	8d 45 f0	 lea	 eax, DWORD PTR _center$3[ebp]
  00062	50		 push	 eax
  00063	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 88 68 01 00
	00		 mov	 ecx, DWORD PTR [eax+360]
  0006c	e8 00 00 00 00	 call	 ?NewPosRadius@SpherePack@@QAEXABVVector3d@@M@Z ; SpherePack::NewPosRadius
  00071	eb 12		 jmp	 SHORT $LN4@UpdateBoun
$LN3@UpdateBoun:

; 304  : 		else
; 305  : 			m_CullingHandle->NewPos(center);

  00073	8d 45 f0	 lea	 eax, DWORD PTR _center$3[ebp]
  00076	50		 push	 eax
  00077	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 88 68 01 00
	00		 mov	 ecx, DWORD PTR [eax+360]
  00080	e8 00 00 00 00	 call	 ?NewPos@SpherePack@@QAEXABVVector3d@@@Z ; SpherePack::NewPos
$LN4@UpdateBoun:

; 306  : 	}
; 307  : }

  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	33 cd		 xor	 ecx, ebp
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	c9		 leave
  00090	c3		 ret	 0
?UpdateBoundingSphere@CGraphicObjectInstance@@QAEXXZ ENDP ; CGraphicObjectInstance::UpdateBoundingSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?OnInitialize@CGraphicObjectInstance@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnInitialize@CGraphicObjectInstance@@UAEXXZ PROC	; CGraphicObjectInstance::OnInitialize, COMDAT
; _this$ = ecx

; 6    : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 7    : 	ZeroMemory(m_abyPortalID, sizeof(m_abyPortalID));

  00007	6a 08		 push	 8
  00009	6a 00		 push	 0
  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	05 60 01 00 00	 add	 eax, 352		; 00000160H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _memset
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8    : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?OnInitialize@CGraphicObjectInstance@@UAEXXZ ENDP	; CGraphicObjectInstance::OnInitialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?Initialize@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
_pOut$ = -12						; size = 4
_pOut$ = -8						; size = 4
_this$ = -4						; size = 4
?Initialize@CGraphicObjectInstance@@QAEXXZ PROC		; CGraphicObjectInstance::Initialize, COMDAT
; _this$ = ecx

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 270  : 	if (m_CullingHandle)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 b8 68 01 00
	00 00		 cmp	 DWORD PTR [eax+360], 0
  00013	74 14		 je	 SHORT $LN2@Initialize

; 271  : 		CCullingManager::Instance().Unregister(m_CullingHandle);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	ff b0 68 01 00
	00		 push	 DWORD PTR [eax+360]
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  00024	e8 00 00 00 00	 call	 ?Unregister@CCullingManager@@QAEXPAVSpherePack@@@Z ; CCullingManager::Unregister
$LN2@Initialize:

; 272  : 	m_CullingHandle = 0;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 a0 68 01 00
	00 00		 and	 DWORD PTR [eax+360], 0

; 273  : 
; 274  : 	m_pHeightAttributeInstance = NULL;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	83 a0 78 01 00
	00 00		 and	 DWORD PTR [eax+376], 0

; 275  : 	
; 276  : 	m_isVisible = TRUE;	

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c6 40 68 01	 mov	 BYTE PTR [eax+104], 1

; 277  : 
; 278  : 	m_BlockCamera = false;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	c6 80 ac 00 00
	00 00		 mov	 BYTE PTR [eax+172], 0

; 279  : 	
; 280  : 	m_v3Position.x = m_v3Position.y = m_v3Position.z = 0.0f;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	0f 57 c0	 xorps	 xmm0, xmm0
  00054	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	0f 57 c0	 xorps	 xmm0, xmm0
  0005f	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	0f 57 c0	 xorps	 xmm0, xmm0
  0006a	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 281  : 	m_v3Scale.x = m_v3Scale.y = m_v3Scale.z = 0.0f;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	0f 57 c0	 xorps	 xmm0, xmm0
  00075	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	0f 57 c0	 xorps	 xmm0, xmm0
  00080	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0
  00085	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00088	0f 57 c0	 xorps	 xmm0, xmm0
  0008b	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 282  : 	m_fYaw = m_fPitch = m_fRoll = 0.0f;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00093	0f 57 c0	 xorps	 xmm0, xmm0
  00096	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0
  0009b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	0f 57 c0	 xorps	 xmm0, xmm0
  000a1	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0
  000a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	0f 57 c0	 xorps	 xmm0, xmm0
  000ac	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 283  : 
; 284  : 	D3DXMatrixIdentity(&m_worldMatrix);

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	83 c0 6c	 add	 eax, 108		; 0000006cH
  000b7	89 45 f8	 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  000ba	6a 10		 push	 16			; 00000010H
  000bc	58		 pop	 eax
  000bd	6b c0 03	 imul	 eax, eax, 3
  000c0	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  000c3	6a 04		 push	 4
  000c5	59		 pop	 ecx
  000c6	d1 e1		 shl	 ecx, 1
  000c8	0f 57 c0	 xorps	 xmm0, xmm0
  000cb	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000d0	6a 10		 push	 16			; 00000010H
  000d2	58		 pop	 eax
  000d3	6b c0 03	 imul	 eax, eax, 3
  000d6	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  000d9	6a 04		 push	 4
  000db	59		 pop	 ecx
  000dc	c1 e1 00	 shl	 ecx, 0
  000df	0f 57 c0	 xorps	 xmm0, xmm0
  000e2	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000e7	6a 10		 push	 16			; 00000010H
  000e9	58		 pop	 eax
  000ea	6b c0 03	 imul	 eax, eax, 3
  000ed	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  000f0	6a 04		 push	 4
  000f2	59		 pop	 ecx
  000f3	6b c9 00	 imul	 ecx, ecx, 0
  000f6	0f 57 c0	 xorps	 xmm0, xmm0
  000f9	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000fe	6a 10		 push	 16			; 00000010H
  00100	58		 pop	 eax
  00101	d1 e0		 shl	 eax, 1
  00103	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00106	6a 04		 push	 4
  00108	59		 pop	 ecx
  00109	6b c9 03	 imul	 ecx, ecx, 3
  0010c	0f 57 c0	 xorps	 xmm0, xmm0
  0010f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00114	6a 10		 push	 16			; 00000010H
  00116	58		 pop	 eax
  00117	d1 e0		 shl	 eax, 1
  00119	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  0011c	6a 04		 push	 4
  0011e	59		 pop	 ecx
  0011f	c1 e1 00	 shl	 ecx, 0
  00122	0f 57 c0	 xorps	 xmm0, xmm0
  00125	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0012a	6a 10		 push	 16			; 00000010H
  0012c	58		 pop	 eax
  0012d	d1 e0		 shl	 eax, 1
  0012f	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00132	6a 04		 push	 4
  00134	59		 pop	 ecx
  00135	6b c9 00	 imul	 ecx, ecx, 0
  00138	0f 57 c0	 xorps	 xmm0, xmm0
  0013b	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00140	6a 10		 push	 16			; 00000010H
  00142	58		 pop	 eax
  00143	c1 e0 00	 shl	 eax, 0
  00146	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00149	6a 04		 push	 4
  0014b	59		 pop	 ecx
  0014c	6b c9 03	 imul	 ecx, ecx, 3
  0014f	0f 57 c0	 xorps	 xmm0, xmm0
  00152	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00157	6a 10		 push	 16			; 00000010H
  00159	58		 pop	 eax
  0015a	c1 e0 00	 shl	 eax, 0
  0015d	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00160	6a 04		 push	 4
  00162	59		 pop	 ecx
  00163	d1 e1		 shl	 ecx, 1
  00165	0f 57 c0	 xorps	 xmm0, xmm0
  00168	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0016d	6a 10		 push	 16			; 00000010H
  0016f	58		 pop	 eax
  00170	c1 e0 00	 shl	 eax, 0
  00173	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00176	6a 04		 push	 4
  00178	59		 pop	 ecx
  00179	6b c9 00	 imul	 ecx, ecx, 0
  0017c	0f 57 c0	 xorps	 xmm0, xmm0
  0017f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00184	6a 10		 push	 16			; 00000010H
  00186	58		 pop	 eax
  00187	6b c0 00	 imul	 eax, eax, 0
  0018a	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  0018d	6a 04		 push	 4
  0018f	59		 pop	 ecx
  00190	6b c9 03	 imul	 ecx, ecx, 3
  00193	0f 57 c0	 xorps	 xmm0, xmm0
  00196	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0019b	6a 10		 push	 16			; 00000010H
  0019d	58		 pop	 eax
  0019e	6b c0 00	 imul	 eax, eax, 0
  001a1	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  001a4	6a 04		 push	 4
  001a6	59		 pop	 ecx
  001a7	d1 e1		 shl	 ecx, 1
  001a9	0f 57 c0	 xorps	 xmm0, xmm0
  001ac	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001b1	6a 10		 push	 16			; 00000010H
  001b3	58		 pop	 eax
  001b4	6b c0 00	 imul	 eax, eax, 0
  001b7	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  001ba	6a 04		 push	 4
  001bc	59		 pop	 ecx
  001bd	c1 e1 00	 shl	 ecx, 0
  001c0	0f 57 c0	 xorps	 xmm0, xmm0
  001c3	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  001c8	6a 10		 push	 16			; 00000010H
  001ca	58		 pop	 eax
  001cb	6b c0 03	 imul	 eax, eax, 3
  001ce	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  001d1	6a 04		 push	 4
  001d3	59		 pop	 ecx
  001d4	6b c9 03	 imul	 ecx, ecx, 3
  001d7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001df	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001e4	6a 10		 push	 16			; 00000010H
  001e6	58		 pop	 eax
  001e7	d1 e0		 shl	 eax, 1
  001e9	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  001ec	6a 04		 push	 4
  001ee	59		 pop	 ecx
  001ef	d1 e1		 shl	 ecx, 1
  001f1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001f9	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001fe	6a 10		 push	 16			; 00000010H
  00200	58		 pop	 eax
  00201	c1 e0 00	 shl	 eax, 0
  00204	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00207	6a 04		 push	 4
  00209	59		 pop	 ecx
  0020a	c1 e1 00	 shl	 ecx, 0
  0020d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00215	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0021a	6a 10		 push	 16			; 00000010H
  0021c	58		 pop	 eax
  0021d	6b c0 00	 imul	 eax, eax, 0
  00220	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00223	6a 04		 push	 4
  00225	59		 pop	 ecx
  00226	6b c9 00	 imul	 ecx, ecx, 0
  00229	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00231	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 285  : 	D3DXMatrixIdentity(&m_mRotation);

  00236	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00239	83 c0 28	 add	 eax, 40			; 00000028H
  0023c	89 45 f4	 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  0023f	6a 10		 push	 16			; 00000010H
  00241	58		 pop	 eax
  00242	6b c0 03	 imul	 eax, eax, 3
  00245	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00248	6a 04		 push	 4
  0024a	59		 pop	 ecx
  0024b	d1 e1		 shl	 ecx, 1
  0024d	0f 57 c0	 xorps	 xmm0, xmm0
  00250	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00255	6a 10		 push	 16			; 00000010H
  00257	58		 pop	 eax
  00258	6b c0 03	 imul	 eax, eax, 3
  0025b	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  0025e	6a 04		 push	 4
  00260	59		 pop	 ecx
  00261	c1 e1 00	 shl	 ecx, 0
  00264	0f 57 c0	 xorps	 xmm0, xmm0
  00267	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0026c	6a 10		 push	 16			; 00000010H
  0026e	58		 pop	 eax
  0026f	6b c0 03	 imul	 eax, eax, 3
  00272	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00275	6a 04		 push	 4
  00277	59		 pop	 ecx
  00278	6b c9 00	 imul	 ecx, ecx, 0
  0027b	0f 57 c0	 xorps	 xmm0, xmm0
  0027e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00283	6a 10		 push	 16			; 00000010H
  00285	58		 pop	 eax
  00286	d1 e0		 shl	 eax, 1
  00288	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  0028b	6a 04		 push	 4
  0028d	59		 pop	 ecx
  0028e	6b c9 03	 imul	 ecx, ecx, 3
  00291	0f 57 c0	 xorps	 xmm0, xmm0
  00294	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00299	6a 10		 push	 16			; 00000010H
  0029b	58		 pop	 eax
  0029c	d1 e0		 shl	 eax, 1
  0029e	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002a1	6a 04		 push	 4
  002a3	59		 pop	 ecx
  002a4	c1 e1 00	 shl	 ecx, 0
  002a7	0f 57 c0	 xorps	 xmm0, xmm0
  002aa	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002af	6a 10		 push	 16			; 00000010H
  002b1	58		 pop	 eax
  002b2	d1 e0		 shl	 eax, 1
  002b4	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002b7	6a 04		 push	 4
  002b9	59		 pop	 ecx
  002ba	6b c9 00	 imul	 ecx, ecx, 0
  002bd	0f 57 c0	 xorps	 xmm0, xmm0
  002c0	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002c5	6a 10		 push	 16			; 00000010H
  002c7	58		 pop	 eax
  002c8	c1 e0 00	 shl	 eax, 0
  002cb	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002ce	6a 04		 push	 4
  002d0	59		 pop	 ecx
  002d1	6b c9 03	 imul	 ecx, ecx, 3
  002d4	0f 57 c0	 xorps	 xmm0, xmm0
  002d7	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002dc	6a 10		 push	 16			; 00000010H
  002de	58		 pop	 eax
  002df	c1 e0 00	 shl	 eax, 0
  002e2	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002e5	6a 04		 push	 4
  002e7	59		 pop	 ecx
  002e8	d1 e1		 shl	 ecx, 1
  002ea	0f 57 c0	 xorps	 xmm0, xmm0
  002ed	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002f2	6a 10		 push	 16			; 00000010H
  002f4	58		 pop	 eax
  002f5	c1 e0 00	 shl	 eax, 0
  002f8	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002fb	6a 04		 push	 4
  002fd	59		 pop	 ecx
  002fe	6b c9 00	 imul	 ecx, ecx, 0
  00301	0f 57 c0	 xorps	 xmm0, xmm0
  00304	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00309	6a 10		 push	 16			; 00000010H
  0030b	58		 pop	 eax
  0030c	6b c0 00	 imul	 eax, eax, 0
  0030f	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00312	6a 04		 push	 4
  00314	59		 pop	 ecx
  00315	6b c9 03	 imul	 ecx, ecx, 3
  00318	0f 57 c0	 xorps	 xmm0, xmm0
  0031b	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00320	6a 10		 push	 16			; 00000010H
  00322	58		 pop	 eax
  00323	6b c0 00	 imul	 eax, eax, 0
  00326	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00329	6a 04		 push	 4
  0032b	59		 pop	 ecx
  0032c	d1 e1		 shl	 ecx, 1
  0032e	0f 57 c0	 xorps	 xmm0, xmm0
  00331	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00336	6a 10		 push	 16			; 00000010H
  00338	58		 pop	 eax
  00339	6b c0 00	 imul	 eax, eax, 0
  0033c	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  0033f	6a 04		 push	 4
  00341	59		 pop	 ecx
  00342	c1 e1 00	 shl	 ecx, 0
  00345	0f 57 c0	 xorps	 xmm0, xmm0
  00348	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  0034d	6a 10		 push	 16			; 00000010H
  0034f	58		 pop	 eax
  00350	6b c0 03	 imul	 eax, eax, 3
  00353	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00356	6a 04		 push	 4
  00358	59		 pop	 ecx
  00359	6b c9 03	 imul	 ecx, ecx, 3
  0035c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00364	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00369	6a 10		 push	 16			; 00000010H
  0036b	58		 pop	 eax
  0036c	d1 e0		 shl	 eax, 1
  0036e	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00371	6a 04		 push	 4
  00373	59		 pop	 ecx
  00374	d1 e1		 shl	 ecx, 1
  00376	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0037e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00383	6a 10		 push	 16			; 00000010H
  00385	58		 pop	 eax
  00386	c1 e0 00	 shl	 eax, 0
  00389	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  0038c	6a 04		 push	 4
  0038e	59		 pop	 ecx
  0038f	c1 e1 00	 shl	 ecx, 0
  00392	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0039a	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0039f	6a 10		 push	 16			; 00000010H
  003a1	58		 pop	 eax
  003a2	6b c0 00	 imul	 eax, eax, 0
  003a5	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  003a8	6a 04		 push	 4
  003aa	59		 pop	 ecx
  003ab	6b c9 00	 imul	 ecx, ecx, 0
  003ae	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003b6	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 287  : 	OnInitialize();

  003bb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003be	8b 00		 mov	 eax, DWORD PTR [eax]
  003c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003c3	ff 50 08	 call	 DWORD PTR [eax+8]

; 288  : }

  003c6	c9		 leave
  003c7	c3		 ret	 0
?Initialize@CGraphicObjectInstance@@QAEXXZ ENDP		; CGraphicObjectInstance::Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetPortal@CGraphicObjectInstance@@QAEHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?GetPortal@CGraphicObjectInstance@@QAEHK@Z PROC		; CGraphicObjectInstance::GetPortal, COMDAT
; _this$ = ecx

; 433  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 434  : 	if (dwIndex >= PORTAL_ID_MAX_NUM)

  00007	83 7d 08 08	 cmp	 DWORD PTR _dwIndex$[ebp], 8
  0000b	72 04		 jb	 SHORT $LN2@GetPortal

; 435  : 	{
; 436  : 		assert(dwIndex < PORTAL_ID_MAX_NUM);
; 437  : 		return 0;

  0000d	33 c0		 xor	 eax, eax
  0000f	eb 0d		 jmp	 SHORT $LN1@GetPortal
$LN2@GetPortal:

; 438  : 	}
; 439  : 
; 440  : 	return m_abyPortalID[dwIndex];

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	03 45 08	 add	 eax, DWORD PTR _dwIndex$[ebp]
  00017	0f b6 80 60 01
	00 00		 movzx	 eax, BYTE PTR [eax+352]
$LN1@GetPortal:

; 441  : }

  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
?GetPortal@CGraphicObjectInstance@@QAEHK@Z ENDP		; CGraphicObjectInstance::GetPortal
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?SetPortal@CGraphicObjectInstance@@QAEXKH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
_iID$ = 12						; size = 4
?SetPortal@CGraphicObjectInstance@@QAEXKH@Z PROC	; CGraphicObjectInstance::SetPortal, COMDAT
; _this$ = ecx

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 423  : 	if (dwIndex >= PORTAL_ID_MAX_NUM)

  00007	83 7d 08 08	 cmp	 DWORD PTR _dwIndex$[ebp], 8
  0000b	72 02		 jb	 SHORT $LN2@SetPortal

; 424  : 	{
; 425  : 		assert(dwIndex < PORTAL_ID_MAX_NUM);
; 426  : 		return;

  0000d	eb 0f		 jmp	 SHORT $LN1@SetPortal
$LN2@SetPortal:

; 427  : 	}
; 428  : 
; 429  : 	m_abyPortalID[dwIndex] = iID;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	03 45 08	 add	 eax, DWORD PTR _dwIndex$[ebp]
  00015	8a 4d 0c	 mov	 cl, BYTE PTR _iID$[ebp]
  00018	88 88 60 01 00
	00		 mov	 BYTE PTR [eax+352], cl
$LN1@SetPortal:

; 430  : }

  0001e	c9		 leave
  0001f	c2 08 00	 ret	 8
?SetPortal@CGraphicObjectInstance@@QAEXKH@Z ENDP	; CGraphicObjectInstance::SetPortal
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetTransform@CGraphicObjectInstance@@QAEAAUD3DXMATRIX@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTransform@CGraphicObjectInstance@@QAEAAUD3DXMATRIX@@XZ PROC ; CGraphicObjectInstance::GetTransform, COMDAT
; _this$ = ecx

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 143  : 	return m_worldMatrix;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 6c	 add	 eax, 108		; 0000006cH

; 144  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetTransform@CGraphicObjectInstance@@QAEAAUD3DXMATRIX@@XZ ENDP ; CGraphicObjectInstance::GetTransform
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetWTBBoxVertex@CGraphicObjectInstance@@QAEAAUD3DXVECTOR4@@ABE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_rucNumTBBoxVertex$ = 8				; size = 4
?GetWTBBoxVertex@CGraphicObjectInstance@@QAEAAUD3DXVECTOR4@@ABE@Z PROC ; CGraphicObjectInstance::GetWTBBoxVertex, COMDAT
; _this$ = ecx

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 214  : 	return m_v4TBBox[c_rucNumTBBoxVertex];

  00007	8b 45 08	 mov	 eax, DWORD PTR _c_rucNumTBBoxVertex$[ebp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0000d	c1 e0 04	 shl	 eax, 4
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8d 84 01 b0 00
	00 00		 lea	 eax, DWORD PTR [ecx+eax+176]

; 215  : }

  0001a	c9		 leave
  0001b	c2 04 00	 ret	 4
?GetWTBBoxVertex@CGraphicObjectInstance@@QAEAAUD3DXVECTOR4@@ABE@Z ENDP ; CGraphicObjectInstance::GetWTBBoxVertex
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ray.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?isIntersect@CGraphicObjectInstance@@QAE_NABVCRay@@PAM11@Z
_TEXT	SEGMENT
_fRayRange$ = -316					; size = 4
_fy$ = -312						; size = 4
_fx$ = -308						; size = 4
_fz$ = -304						; size = 4
_fy$ = -300						; size = 4
_fx$ = -296						; size = 4
_fy$ = -292						; size = 4
_fz$ = -288						; size = 4
_fy$ = -284						; size = 4
_fx$ = -280						; size = 4
_fz$ = -276						; size = 4
_fy$ = -272						; size = 4
_fx$ = -268						; size = 4
tv317 = -264						; size = 4
_fz$ = -260						; size = 4
_fy$ = -256						; size = 4
_fx$ = -252						; size = 4
_fz$ = -248						; size = 4
_fy$ = -244						; size = 4
_fx$ = -240						; size = 4
_fz$ = -236						; size = 4
tv68 = -232						; size = 4
_fx$ = -228						; size = 4
_fz$ = -224						; size = 4
_fy$ = -220						; size = 4
_fx$ = -216						; size = 4
_fz$ = -212						; size = 4
___t$ = -208						; size = 4
_triCount$ = -204					; size = 4
___n$ = -200						; size = 4
_pcurIdx$ = -196					; size = 4
_this$ = -192						; size = 4
_v3Start$ = -188					; size = 12
_v3Dir$ = -176						; size = 12
$T1 = -164						; size = 12
$T2 = -152						; size = 12
$T3 = -140						; size = 12
$T4 = -128						; size = 12
$T5 = -116						; size = 12
$T6 = -104						; size = 12
$T7 = -92						; size = 12
$T8 = -80						; size = 12
_posVertices$ = -68					; size = 96
_Indices$ = 28						; size = 72
__$ArrayPad$ = 100					; size = 4
_c_rRay$ = 112						; size = 4
_pu$ = 116						; size = 4
_pv$ = 120						; size = 4
_pt$ = 124						; size = 4
?isIntersect@CGraphicObjectInstance@@QAE_NABVCRay@@PAM11@Z PROC ; CGraphicObjectInstance::isIntersect, COMDAT
; _this$ = ecx

; 218  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 98	 lea	 ebp, DWORD PTR [esp-104]
  00005	81 ec a4 01 00
	00		 sub	 esp, 420		; 000001a4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 64	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ray.h

; 36   : 			*pv3Start = m_v3Start;

  0001d	8b 75 70	 mov	 esi, DWORD PTR _c_rRay$[ebp]
  00020	8d bd 44 ff ff
	ff		 lea	 edi, DWORD PTR _v3Start$[ebp]
  00026	a5		 movsd
  00027	a5		 movsd
  00028	a5		 movsd

; 41   : 			*pv3Dir = m_v3Direction;

  00029	8b 75 70	 mov	 esi, DWORD PTR _c_rRay$[ebp]
  0002c	83 c6 18	 add	 esi, 24			; 00000018H
  0002f	8d bd 50 ff ff
	ff		 lea	 edi, DWORD PTR _v3Dir$[ebp]
  00035	a5		 movsd
  00036	a5		 movsd
  00037	a5		 movsd

; 42   : 			*pfRayRange = m_fRayRange;

  00038	8b 45 70	 mov	 eax, DWORD PTR _c_rRay$[ebp]
  0003b	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00040	f3 0f 11 85 c4
	fe ff ff	 movss	 DWORD PTR _fRayRange$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 224  : 	TPosition posVertices[8];

  00048	c7 85 38 ff ff
	ff 08 00 00 00	 mov	 DWORD PTR ___n$[ebp], 8
  00052	8d 45 bc	 lea	 eax, DWORD PTR _posVertices$[ebp]
  00055	89 85 30 ff ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
$LN15@isIntersec:
  0005b	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  00061	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  00067	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  0006d	48		 dec	 eax
  0006e	89 85 38 ff ff
	ff		 mov	 DWORD PTR ___n$[ebp], eax
  00074	83 bd 18 ff ff
	ff 00		 cmp	 DWORD PTR tv68[ebp], 0
  0007b	76 11		 jbe	 SHORT $LN16@isIntersec
  0007d	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR ___t$[ebp]
  00083	83 c0 0c	 add	 eax, 12			; 0000000cH
  00086	89 85 30 ff ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
  0008c	eb cd		 jmp	 SHORT $LN15@isIntersec
$LN16@isIntersec:

; 226  : 	posVertices[0] = TPosition(m_v3TBBoxMin.x, m_v3TBBoxMin.y, m_v3TBBoxMin.z);

  0008e	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00094	f3 0f 10 80 30
	01 00 00	 movss	 xmm0, DWORD PTR [eax+304]
  0009c	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  000a4	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000aa	f3 0f 10 80 34
	01 00 00	 movss	 xmm0, DWORD PTR [eax+308]
  000b2	f3 0f 11 85 f0
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  000ba	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000c0	f3 0f 10 80 38
	01 00 00	 movss	 xmm0, DWORD PTR [eax+312]
  000c8	f3 0f 11 85 ec
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  000d0	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000d8	f3 0f 11 45 a4	 movss	 DWORD PTR $T7[ebp], xmm0

; 181  :     y = fy;

  000dd	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  000e5	f3 0f 11 45 a8	 movss	 DWORD PTR $T7[ebp+4], xmm0

; 182  :     z = fz;

  000ea	f3 0f 10 85 ec
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  000f2	f3 0f 11 45 ac	 movss	 DWORD PTR $T7[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 226  : 	posVertices[0] = TPosition(m_v3TBBoxMin.x, m_v3TBBoxMin.y, m_v3TBBoxMin.z);

  000f7	6a 0c		 push	 12			; 0000000cH
  000f9	58		 pop	 eax
  000fa	6b c0 00	 imul	 eax, eax, 0
  000fd	8d 7c 05 bc	 lea	 edi, DWORD PTR _posVertices$[ebp+eax]
  00101	8d 75 a4	 lea	 esi, DWORD PTR $T7[ebp]
  00104	a5		 movsd
  00105	a5		 movsd
  00106	a5		 movsd

; 227  : 	posVertices[1] = TPosition(m_v3TBBoxMax.x, m_v3TBBoxMin.y, m_v3TBBoxMin.z);

  00107	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0010d	f3 0f 10 80 3c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+316]
  00115	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0011d	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00123	f3 0f 10 80 34
	01 00 00	 movss	 xmm0, DWORD PTR [eax+308]
  0012b	f3 0f 11 85 e4
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00133	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00139	f3 0f 10 80 38
	01 00 00	 movss	 xmm0, DWORD PTR [eax+312]
  00141	f3 0f 11 85 e0
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  00149	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00151	f3 0f 11 45 b0	 movss	 DWORD PTR $T8[ebp], xmm0

; 181  :     y = fy;

  00156	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0015e	f3 0f 11 45 b4	 movss	 DWORD PTR $T8[ebp+4], xmm0

; 182  :     z = fz;

  00163	f3 0f 10 85 e0
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0016b	f3 0f 11 45 b8	 movss	 DWORD PTR $T8[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 227  : 	posVertices[1] = TPosition(m_v3TBBoxMax.x, m_v3TBBoxMin.y, m_v3TBBoxMin.z);

  00170	6a 0c		 push	 12			; 0000000cH
  00172	58		 pop	 eax
  00173	c1 e0 00	 shl	 eax, 0
  00176	8d 7c 05 bc	 lea	 edi, DWORD PTR _posVertices$[ebp+eax]
  0017a	8d 75 b0	 lea	 esi, DWORD PTR $T8[ebp]
  0017d	a5		 movsd
  0017e	a5		 movsd
  0017f	a5		 movsd

; 228  : 	posVertices[2] = TPosition(m_v3TBBoxMin.x, m_v3TBBoxMax.y, m_v3TBBoxMin.z);

  00180	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00186	f3 0f 10 80 30
	01 00 00	 movss	 xmm0, DWORD PTR [eax+304]
  0018e	f3 0f 11 85 d8
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00196	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0019c	f3 0f 10 80 40
	01 00 00	 movss	 xmm0, DWORD PTR [eax+320]
  001a4	f3 0f 11 85 d4
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  001ac	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001b2	f3 0f 10 80 38
	01 00 00	 movss	 xmm0, DWORD PTR [eax+312]
  001ba	f3 0f 11 85 d0
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  001c2	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  001ca	f3 0f 11 45 98	 movss	 DWORD PTR $T6[ebp], xmm0

; 181  :     y = fy;

  001cf	f3 0f 10 85 d4
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  001d7	f3 0f 11 45 9c	 movss	 DWORD PTR $T6[ebp+4], xmm0

; 182  :     z = fz;

  001dc	f3 0f 10 85 d0
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  001e4	f3 0f 11 45 a0	 movss	 DWORD PTR $T6[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 228  : 	posVertices[2] = TPosition(m_v3TBBoxMin.x, m_v3TBBoxMax.y, m_v3TBBoxMin.z);

  001e9	6a 0c		 push	 12			; 0000000cH
  001eb	58		 pop	 eax
  001ec	d1 e0		 shl	 eax, 1
  001ee	8d 7c 05 bc	 lea	 edi, DWORD PTR _posVertices$[ebp+eax]
  001f2	8d 75 98	 lea	 esi, DWORD PTR $T6[ebp]
  001f5	a5		 movsd
  001f6	a5		 movsd
  001f7	a5		 movsd

; 229  : 	posVertices[3] = TPosition(m_v3TBBoxMax.x, m_v3TBBoxMax.y, m_v3TBBoxMin.z);

  001f8	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001fe	f3 0f 10 80 3c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+316]
  00206	f3 0f 11 85 cc
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0020e	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00214	f3 0f 10 80 40
	01 00 00	 movss	 xmm0, DWORD PTR [eax+320]
  0021c	f3 0f 11 85 c8
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00224	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0022a	f3 0f 10 80 38
	01 00 00	 movss	 xmm0, DWORD PTR [eax+312]
  00232	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  0023a	f3 0f 10 85 cc
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00242	f3 0f 11 45 8c	 movss	 DWORD PTR $T5[ebp], xmm0

; 181  :     y = fy;

  00247	f3 0f 10 85 c8
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0024f	f3 0f 11 45 90	 movss	 DWORD PTR $T5[ebp+4], xmm0

; 182  :     z = fz;

  00254	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0025c	f3 0f 11 45 94	 movss	 DWORD PTR $T5[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 229  : 	posVertices[3] = TPosition(m_v3TBBoxMax.x, m_v3TBBoxMax.y, m_v3TBBoxMin.z);

  00261	6a 0c		 push	 12			; 0000000cH
  00263	58		 pop	 eax
  00264	6b c0 03	 imul	 eax, eax, 3
  00267	8d 7c 05 bc	 lea	 edi, DWORD PTR _posVertices$[ebp+eax]
  0026b	8d 75 8c	 lea	 esi, DWORD PTR $T5[ebp]
  0026e	a5		 movsd
  0026f	a5		 movsd
  00270	a5		 movsd

; 230  : 	posVertices[4] = TPosition(m_v3TBBoxMin.x, m_v3TBBoxMin.y, m_v3TBBoxMax.z);

  00271	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00277	f3 0f 10 80 30
	01 00 00	 movss	 xmm0, DWORD PTR [eax+304]
  0027f	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00287	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0028d	f3 0f 10 80 34
	01 00 00	 movss	 xmm0, DWORD PTR [eax+308]
  00295	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0029d	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002a3	f3 0f 10 80 44
	01 00 00	 movss	 xmm0, DWORD PTR [eax+324]
  002ab	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  002b3	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002bb	f3 0f 11 45 80	 movss	 DWORD PTR $T4[ebp], xmm0

; 181  :     y = fy;

  002c0	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002c8	f3 0f 11 45 84	 movss	 DWORD PTR $T4[ebp+4], xmm0

; 182  :     z = fz;

  002cd	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002d5	f3 0f 11 45 88	 movss	 DWORD PTR $T4[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 230  : 	posVertices[4] = TPosition(m_v3TBBoxMin.x, m_v3TBBoxMin.y, m_v3TBBoxMax.z);

  002da	6a 0c		 push	 12			; 0000000cH
  002dc	58		 pop	 eax
  002dd	c1 e0 02	 shl	 eax, 2
  002e0	8d 7c 05 bc	 lea	 edi, DWORD PTR _posVertices$[ebp+eax]
  002e4	8d 75 80	 lea	 esi, DWORD PTR $T4[ebp]
  002e7	a5		 movsd
  002e8	a5		 movsd
  002e9	a5		 movsd

; 231  : 	posVertices[5] = TPosition(m_v3TBBoxMax.x, m_v3TBBoxMin.y, m_v3TBBoxMax.z);

  002ea	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002f0	f3 0f 10 80 3c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+316]
  002f8	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00300	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00306	f3 0f 10 80 34
	01 00 00	 movss	 xmm0, DWORD PTR [eax+308]
  0030e	f3 0f 11 85 dc
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00316	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0031c	f3 0f 10 80 44
	01 00 00	 movss	 xmm0, DWORD PTR [eax+324]
  00324	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  0032c	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00334	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR $T3[ebp], xmm0

; 181  :     y = fy;

  0033c	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00344	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 182  :     z = fz;

  0034c	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00354	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR $T3[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 231  : 	posVertices[5] = TPosition(m_v3TBBoxMax.x, m_v3TBBoxMin.y, m_v3TBBoxMax.z);

  0035c	6a 0c		 push	 12			; 0000000cH
  0035e	58		 pop	 eax
  0035f	6b c0 05	 imul	 eax, eax, 5
  00362	8d 7c 05 bc	 lea	 edi, DWORD PTR _posVertices$[ebp+eax]
  00366	8d b5 74 ff ff
	ff		 lea	 esi, DWORD PTR $T3[ebp]
  0036c	a5		 movsd
  0036d	a5		 movsd
  0036e	a5		 movsd

; 232  : 	posVertices[6] = TPosition(m_v3TBBoxMin.x, m_v3TBBoxMax.y, m_v3TBBoxMax.z);

  0036f	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00375	f3 0f 10 80 30
	01 00 00	 movss	 xmm0, DWORD PTR [eax+304]
  0037d	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00385	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0038b	f3 0f 10 80 40
	01 00 00	 movss	 xmm0, DWORD PTR [eax+320]
  00393	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0039b	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003a1	f3 0f 10 80 44
	01 00 00	 movss	 xmm0, DWORD PTR [eax+324]
  003a9	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  003b1	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  003b9	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR $T1[ebp], xmm0

; 181  :     y = fy;

  003c1	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  003c9	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 182  :     z = fz;

  003d1	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  003d9	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR $T1[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 232  : 	posVertices[6] = TPosition(m_v3TBBoxMin.x, m_v3TBBoxMax.y, m_v3TBBoxMax.z);

  003e1	6a 0c		 push	 12			; 0000000cH
  003e3	58		 pop	 eax
  003e4	6b c0 06	 imul	 eax, eax, 6
  003e7	8d 7c 05 bc	 lea	 edi, DWORD PTR _posVertices$[ebp+eax]
  003eb	8d b5 5c ff ff
	ff		 lea	 esi, DWORD PTR $T1[ebp]
  003f1	a5		 movsd
  003f2	a5		 movsd
  003f3	a5		 movsd

; 233  : 	posVertices[7] = TPosition(m_v3TBBoxMax.x, m_v3TBBoxMax.y, m_v3TBBoxMax.z);

  003f4	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003fa	f3 0f 10 80 3c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+316]
  00402	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0040a	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00410	f3 0f 10 80 40
	01 00 00	 movss	 xmm0, DWORD PTR [eax+320]
  00418	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00420	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00426	f3 0f 10 80 44
	01 00 00	 movss	 xmm0, DWORD PTR [eax+324]
  0042e	f3 0f 11 85 fc
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  00436	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0043e	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR $T2[ebp], xmm0

; 181  :     y = fy;

  00446	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0044e	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 182  :     z = fz;

  00456	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0045e	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR $T2[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 233  : 	posVertices[7] = TPosition(m_v3TBBoxMax.x, m_v3TBBoxMax.y, m_v3TBBoxMax.z);

  00466	6a 0c		 push	 12			; 0000000cH
  00468	58		 pop	 eax
  00469	6b c0 07	 imul	 eax, eax, 7
  0046c	8d 7c 05 bc	 lea	 edi, DWORD PTR _posVertices$[ebp+eax]
  00470	8d b5 68 ff ff
	ff		 lea	 esi, DWORD PTR $T2[ebp]
  00476	a5		 movsd
  00477	a5		 movsd
  00478	a5		 movsd

; 234  : 
; 235  : 	TIndex Indices[36] = {0, 1, 2, 1, 3, 2,

  00479	33 c0		 xor	 eax, eax
  0047b	66 89 45 1c	 mov	 WORD PTR _Indices$[ebp], ax
  0047f	33 c0		 xor	 eax, eax
  00481	40		 inc	 eax
  00482	66 89 45 1e	 mov	 WORD PTR _Indices$[ebp+2], ax
  00486	6a 02		 push	 2
  00488	58		 pop	 eax
  00489	66 89 45 20	 mov	 WORD PTR _Indices$[ebp+4], ax
  0048d	33 c0		 xor	 eax, eax
  0048f	40		 inc	 eax
  00490	66 89 45 22	 mov	 WORD PTR _Indices$[ebp+6], ax
  00494	6a 03		 push	 3
  00496	58		 pop	 eax
  00497	66 89 45 24	 mov	 WORD PTR _Indices$[ebp+8], ax
  0049b	6a 02		 push	 2
  0049d	58		 pop	 eax
  0049e	66 89 45 26	 mov	 WORD PTR _Indices$[ebp+10], ax

; 236  : 						  2, 0, 6, 0, 4, 6, 

  004a2	6a 02		 push	 2
  004a4	58		 pop	 eax
  004a5	66 89 45 28	 mov	 WORD PTR _Indices$[ebp+12], ax
  004a9	33 c0		 xor	 eax, eax
  004ab	66 89 45 2a	 mov	 WORD PTR _Indices$[ebp+14], ax
  004af	6a 06		 push	 6
  004b1	58		 pop	 eax
  004b2	66 89 45 2c	 mov	 WORD PTR _Indices$[ebp+16], ax
  004b6	33 c0		 xor	 eax, eax
  004b8	66 89 45 2e	 mov	 WORD PTR _Indices$[ebp+18], ax
  004bc	6a 04		 push	 4
  004be	58		 pop	 eax
  004bf	66 89 45 30	 mov	 WORD PTR _Indices$[ebp+20], ax
  004c3	6a 06		 push	 6
  004c5	58		 pop	 eax
  004c6	66 89 45 32	 mov	 WORD PTR _Indices$[ebp+22], ax

; 237  : 						  0, 1, 4, 1, 5, 4,

  004ca	33 c0		 xor	 eax, eax
  004cc	66 89 45 34	 mov	 WORD PTR _Indices$[ebp+24], ax
  004d0	33 c0		 xor	 eax, eax
  004d2	40		 inc	 eax
  004d3	66 89 45 36	 mov	 WORD PTR _Indices$[ebp+26], ax
  004d7	6a 04		 push	 4
  004d9	58		 pop	 eax
  004da	66 89 45 38	 mov	 WORD PTR _Indices$[ebp+28], ax
  004de	33 c0		 xor	 eax, eax
  004e0	40		 inc	 eax
  004e1	66 89 45 3a	 mov	 WORD PTR _Indices$[ebp+30], ax
  004e5	6a 05		 push	 5
  004e7	58		 pop	 eax
  004e8	66 89 45 3c	 mov	 WORD PTR _Indices$[ebp+32], ax
  004ec	6a 04		 push	 4
  004ee	58		 pop	 eax
  004ef	66 89 45 3e	 mov	 WORD PTR _Indices$[ebp+34], ax

; 238  : 						  1, 3, 5, 3, 7, 5,

  004f3	33 c0		 xor	 eax, eax
  004f5	40		 inc	 eax
  004f6	66 89 45 40	 mov	 WORD PTR _Indices$[ebp+36], ax
  004fa	6a 03		 push	 3
  004fc	58		 pop	 eax
  004fd	66 89 45 42	 mov	 WORD PTR _Indices$[ebp+38], ax
  00501	6a 05		 push	 5
  00503	58		 pop	 eax
  00504	66 89 45 44	 mov	 WORD PTR _Indices$[ebp+40], ax
  00508	6a 03		 push	 3
  0050a	58		 pop	 eax
  0050b	66 89 45 46	 mov	 WORD PTR _Indices$[ebp+42], ax
  0050f	6a 07		 push	 7
  00511	58		 pop	 eax
  00512	66 89 45 48	 mov	 WORD PTR _Indices$[ebp+44], ax
  00516	6a 05		 push	 5
  00518	58		 pop	 eax
  00519	66 89 45 4a	 mov	 WORD PTR _Indices$[ebp+46], ax

; 239  : 						  3, 2, 7, 2, 6, 7,

  0051d	6a 03		 push	 3
  0051f	58		 pop	 eax
  00520	66 89 45 4c	 mov	 WORD PTR _Indices$[ebp+48], ax
  00524	6a 02		 push	 2
  00526	58		 pop	 eax
  00527	66 89 45 4e	 mov	 WORD PTR _Indices$[ebp+50], ax
  0052b	6a 07		 push	 7
  0052d	58		 pop	 eax
  0052e	66 89 45 50	 mov	 WORD PTR _Indices$[ebp+52], ax
  00532	6a 02		 push	 2
  00534	58		 pop	 eax
  00535	66 89 45 52	 mov	 WORD PTR _Indices$[ebp+54], ax
  00539	6a 06		 push	 6
  0053b	58		 pop	 eax
  0053c	66 89 45 54	 mov	 WORD PTR _Indices$[ebp+56], ax
  00540	6a 07		 push	 7
  00542	58		 pop	 eax
  00543	66 89 45 56	 mov	 WORD PTR _Indices$[ebp+58], ax

; 240  : 						  4, 5, 6, 5, 7, 6};

  00547	6a 04		 push	 4
  00549	58		 pop	 eax
  0054a	66 89 45 58	 mov	 WORD PTR _Indices$[ebp+60], ax
  0054e	6a 05		 push	 5
  00550	58		 pop	 eax
  00551	66 89 45 5a	 mov	 WORD PTR _Indices$[ebp+62], ax
  00555	6a 06		 push	 6
  00557	58		 pop	 eax
  00558	66 89 45 5c	 mov	 WORD PTR _Indices$[ebp+64], ax
  0055c	6a 05		 push	 5
  0055e	58		 pop	 eax
  0055f	66 89 45 5e	 mov	 WORD PTR _Indices$[ebp+66], ax
  00563	6a 07		 push	 7
  00565	58		 pop	 eax
  00566	66 89 45 60	 mov	 WORD PTR _Indices$[ebp+68], ax
  0056a	6a 06		 push	 6
  0056c	58		 pop	 eax
  0056d	66 89 45 62	 mov	 WORD PTR _Indices$[ebp+70], ax

; 241  : 
; 242  : 	int triCount = 12;

  00571	c7 85 34 ff ff
	ff 0c 00 00 00	 mov	 DWORD PTR _triCount$[ebp], 12 ; 0000000cH

; 243  : 	WORD* pcurIdx = (WORD*)Indices;

  0057b	8d 45 1c	 lea	 eax, DWORD PTR _Indices$[ebp]
  0057e	89 85 3c ff ff
	ff		 mov	 DWORD PTR _pcurIdx$[ebp], eax
$LN2@isIntersec:

; 244  : 
; 245  : 	while (triCount--)

  00584	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _triCount$[ebp]
  0058a	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv317[ebp], eax
  00590	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _triCount$[ebp]
  00596	48		 dec	 eax
  00597	89 85 34 ff ff
	ff		 mov	 DWORD PTR _triCount$[ebp], eax
  0059d	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR tv317[ebp], 0
  005a4	0f 84 88 00 00
	00		 je	 $LN3@isIntersec

; 246  : 	{
; 247  : 		if (IntersectTriangle(v3Start, v3Dir, 

  005aa	ff 75 7c	 push	 DWORD PTR _pt$[ebp]
  005ad	ff 75 78	 push	 DWORD PTR _pv$[ebp]
  005b0	ff 75 74	 push	 DWORD PTR _pu$[ebp]
  005b3	6a 02		 push	 2
  005b5	58		 pop	 eax
  005b6	d1 e0		 shl	 eax, 1
  005b8	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _pcurIdx$[ebp]
  005be	0f b7 04 01	 movzx	 eax, WORD PTR [ecx+eax]
  005c2	6b c0 0c	 imul	 eax, eax, 12
  005c5	8d 44 05 bc	 lea	 eax, DWORD PTR _posVertices$[ebp+eax]
  005c9	50		 push	 eax
  005ca	6a 02		 push	 2
  005cc	58		 pop	 eax
  005cd	c1 e0 00	 shl	 eax, 0
  005d0	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _pcurIdx$[ebp]
  005d6	0f b7 04 01	 movzx	 eax, WORD PTR [ecx+eax]
  005da	6b c0 0c	 imul	 eax, eax, 12
  005dd	8d 44 05 bc	 lea	 eax, DWORD PTR _posVertices$[ebp+eax]
  005e1	50		 push	 eax
  005e2	6a 02		 push	 2
  005e4	58		 pop	 eax
  005e5	6b c0 00	 imul	 eax, eax, 0
  005e8	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _pcurIdx$[ebp]
  005ee	0f b7 04 01	 movzx	 eax, WORD PTR [ecx+eax]
  005f2	6b c0 0c	 imul	 eax, eax, 12
  005f5	8d 44 05 bc	 lea	 eax, DWORD PTR _posVertices$[ebp+eax]
  005f9	50		 push	 eax
  005fa	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _v3Dir$[ebp]
  00600	50		 push	 eax
  00601	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _v3Start$[ebp]
  00607	50		 push	 eax
  00608	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0060e	e8 00 00 00 00	 call	 ?IntersectTriangle@CGraphicCollisionObject@@IAE_NABUD3DXVECTOR3@@0000PAM11@Z ; CGraphicCollisionObject::IntersectTriangle
  00613	0f b6 c0	 movzx	 eax, al
  00616	85 c0		 test	 eax, eax
  00618	74 04		 je	 SHORT $LN4@isIntersec

; 248  : 			posVertices[pcurIdx[0]],
; 249  : 			posVertices[pcurIdx[1]],
; 250  : 			posVertices[pcurIdx[2]],
; 251  : 			pu, pv, pt))
; 252  : 		{
; 253  : 			return true;

  0061a	b0 01		 mov	 al, 1
  0061c	eb 16		 jmp	 SHORT $LN1@isIntersec
$LN4@isIntersec:

; 254  : 		}
; 255  : 		
; 256  : 		pcurIdx += 3;

  0061e	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _pcurIdx$[ebp]
  00624	83 c0 06	 add	 eax, 6
  00627	89 85 3c ff ff
	ff		 mov	 DWORD PTR _pcurIdx$[ebp], eax

; 257  : 	}

  0062d	e9 52 ff ff ff	 jmp	 $LN2@isIntersec
$LN3@isIntersec:

; 258  : 	
; 259  : 	return false;

  00632	32 c0		 xor	 al, al
$LN1@isIntersec:

; 260  : }

  00634	5f		 pop	 edi
  00635	5e		 pop	 esi
  00636	8b 4d 64	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00639	33 cd		 xor	 ecx, ebp
  0063b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00640	83 c5 68	 add	 ebp, 104		; 00000068H
  00643	c9		 leave
  00644	c2 10 00	 ret	 16			; 00000010H
?isIntersect@CGraphicObjectInstance@@QAE_NABVCRay@@PAM11@Z ENDP ; CGraphicObjectInstance::isIntersect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?isShow@CGraphicObjectInstance@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isShow@CGraphicObjectInstance@@QAE_NXZ PROC		; CGraphicObjectInstance::isShow, COMDAT
; _this$ = ecx

; 204  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 205  : 	return m_isVisible;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 68	 mov	 al, BYTE PTR [eax+104]

; 206  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?isShow@CGraphicObjectInstance@@QAE_NXZ ENDP		; CGraphicObjectInstance::isShow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?Hide@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Hide@CGraphicObjectInstance@@QAEXXZ PROC		; CGraphicObjectInstance::Hide, COMDAT
; _this$ = ecx

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 201  : 	m_isVisible = false;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 68 00	 mov	 BYTE PTR [eax+104], 0

; 202  : }

  0000e	c9		 leave
  0000f	c3		 ret	 0
?Hide@CGraphicObjectInstance@@QAEXXZ ENDP		; CGraphicObjectInstance::Hide
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?Show@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Show@CGraphicObjectInstance@@QAEXXZ PROC		; CGraphicObjectInstance::Show, COMDAT
; _this$ = ecx

; 195  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 196  : 	m_isVisible = true;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 68 01	 mov	 BYTE PTR [eax+104], 1

; 197  : }

  0000e	c9		 leave
  0000f	c3		 ret	 0
?Show@CGraphicObjectInstance@@QAEXXZ ENDP		; CGraphicObjectInstance::Show
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?Transform@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Transform@CGraphicObjectInstance@@QAEXXZ PROC		; CGraphicObjectInstance::Transform, COMDAT
; _this$ = ecx

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 104  : 	m_worldMatrix = m_mRotation;

  00009	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0000c	83 c6 28	 add	 esi, 40			; 00000028H
  0000f	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  00012	83 c7 6c	 add	 edi, 108		; 0000006cH
  00015	6a 10		 push	 16			; 00000010H
  00017	59		 pop	 ecx
  00018	f3 a5		 rep movsd

; 105  : 
; 106  : 	m_worldMatrix._41	+= m_v3Position.x;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	f3 0f 10 80 9c
	00 00 00	 movss	 xmm0, DWORD PTR [eax+156]
  00028	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 11 80 9c
	00 00 00	 movss	 DWORD PTR [eax+156], xmm0

; 107  : 	m_worldMatrix._42	+= m_v3Position.y;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	f3 0f 10 80 a0
	00 00 00	 movss	 xmm0, DWORD PTR [eax+160]
  00046	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	f3 0f 11 80 a0
	00 00 00	 movss	 DWORD PTR [eax+160], xmm0

; 108  : 	m_worldMatrix._43	+= m_v3Position.z;	

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	f3 0f 10 80 a4
	00 00 00	 movss	 xmm0, DWORD PTR [eax+164]
  00064	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [ecx+12]
  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	f3 0f 11 80 a4
	00 00 00	 movss	 DWORD PTR [eax+164], xmm0

; 109  : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	c9		 leave
  00077	c3		 ret	 0
?Transform@CGraphicObjectInstance@@QAEXXZ ENDP		; CGraphicObjectInstance::Transform
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?Deform@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Deform@CGraphicObjectInstance@@QAEXXZ PROC		; CGraphicObjectInstance::Deform, COMDAT
; _this$ = ecx

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   : 	if (!isShow())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	75 02		 jne	 SHORT $LN2@Deform

; 96   : 		return;

  00016	eb 0b		 jmp	 SHORT $LN1@Deform
$LN2@Deform:

; 97   : 
; 98   : 	OnDeform();

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	ff 50 2c	 call	 DWORD PTR [eax+44]
$LN1@Deform:

; 99   : }

  00023	c9		 leave
  00024	c3		 ret	 0
?Deform@CGraphicObjectInstance@@QAEXXZ ENDP		; CGraphicObjectInstance::Deform
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?RenderPCBlocker@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderPCBlocker@CGraphicObjectInstance@@QAEXXZ PROC	; CGraphicObjectInstance::RenderPCBlocker, COMDAT
; _this$ = ecx

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 	if (!isShow())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	75 02		 jne	 SHORT $LN2@RenderPCBl

; 81   : 		return;

  00016	eb 0b		 jmp	 SHORT $LN1@RenderPCBl
$LN2@RenderPCBl:

; 82   : 
; 83   : 	OnRenderPCBlocker();

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	ff 50 20	 call	 DWORD PTR [eax+32]
$LN1@RenderPCBl:

; 84   : }

  00023	c9		 leave
  00024	c3		 ret	 0
?RenderPCBlocker@CGraphicObjectInstance@@QAEXXZ ENDP	; CGraphicObjectInstance::RenderPCBlocker
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?RenderShadow@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderShadow@CGraphicObjectInstance@@QAEXXZ PROC	; CGraphicObjectInstance::RenderShadow, COMDAT
; _this$ = ecx

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 72   : 	if (!isShow())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	75 02		 jne	 SHORT $LN2@RenderShad

; 73   : 		return;

  00016	eb 0b		 jmp	 SHORT $LN1@RenderShad
$LN2@RenderShad:

; 74   : 
; 75   : 	OnRenderShadow();

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN1@RenderShad:

; 76   : }

  00023	c9		 leave
  00024	c3		 ret	 0
?RenderShadow@CGraphicObjectInstance@@QAEXXZ ENDP	; CGraphicObjectInstance::RenderShadow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?RenderToShadowMap@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderToShadowMap@CGraphicObjectInstance@@QAEXXZ PROC	; CGraphicObjectInstance::RenderToShadowMap, COMDAT
; _this$ = ecx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 64   : 	if (!isShow())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	75 02		 jne	 SHORT $LN2@RenderToSh

; 65   : 		return;

  00016	eb 0b		 jmp	 SHORT $LN1@RenderToSh
$LN2@RenderToSh:

; 66   : 
; 67   : 	OnRenderToShadowMap();

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	ff 50 18	 call	 DWORD PTR [eax+24]
$LN1@RenderToSh:

; 68   : }

  00023	c9		 leave
  00024	c3		 ret	 0
?RenderToShadowMap@CGraphicObjectInstance@@QAEXXZ ENDP	; CGraphicObjectInstance::RenderToShadowMap
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?BlendRender@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BlendRender@CGraphicObjectInstance@@QAEXXZ PROC	; CGraphicObjectInstance::BlendRender, COMDAT
; _this$ = ecx

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 56   : 	if (!isShow())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	75 02		 jne	 SHORT $LN2@BlendRende

; 57   : 		return;

  00016	eb 0b		 jmp	 SHORT $LN1@BlendRende
$LN2@BlendRende:

; 58   : 
; 59   : 	OnBlendRender();

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	ff 50 14	 call	 DWORD PTR [eax+20]
$LN1@BlendRende:

; 60   : }

  00023	c9		 leave
  00024	c3		 ret	 0
?BlendRender@CGraphicObjectInstance@@QAEXXZ ENDP	; CGraphicObjectInstance::BlendRender
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?Render@CGraphicObjectInstance@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Render@CGraphicObjectInstance@@QAE_NXZ PROC		; CGraphicObjectInstance::Render, COMDAT
; _this$ = ecx

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 	/*
; 36   : 	if (m_CullingHandle)
; 37   : 	{
; 38   : 		SpherePack * ps = m_CullingHandle->GetParent();
; 39   : 		CScreen s;
; 40   : 		s.SetColorOperation();
; 41   : 		//s.SetDiffuseColor(1,isShow()?1:0,0);
; 42   : 		//s.RenderCircle2d(m_CullingHandle->GetCenter().x,m_CullingHandle->GetCenter().y,m_CullingHandle->GetCenter().z,m_CullingHandle->GetRadius());
; 43   : 		s.SetDiffuseColor(1,isShow()?1:0,ps->HasSpherePackFlag(SPF_PARTIAL)?1:0);
; 44   : 		s.RenderCircle2d(ps->GetCenter().x,ps->GetCenter().y,ps->GetCenter().z,ps->GetRadius());
; 45   : 	}
; 46   : 	//*/
; 47   : 	if (!isShow())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	75 04		 jne	 SHORT $LN2@Render

; 48   : 		return false;

  00016	32 c0		 xor	 al, al
  00018	eb 0d		 jmp	 SHORT $LN1@Render
$LN2@Render:

; 49   : 
; 50   : 	OnRender();

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	ff 50 10	 call	 DWORD PTR [eax+16]

; 51   : 	return true;

  00025	b0 01		 mov	 al, 1
$LN1@Render:

; 52   : }

  00027	c9		 leave
  00028	c3		 ret	 0
?Render@CGraphicObjectInstance@@QAE_NXZ ENDP		; CGraphicObjectInstance::Render
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?Update@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Update@CGraphicObjectInstance@@QAEXXZ PROC		; CGraphicObjectInstance::Update, COMDAT
; _this$ = ecx

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 88   : 	OnUpdate();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 50 28	 call	 DWORD PTR [eax+40]

; 89   : 
; 90   : 	UpdateBoundingSphere();

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?UpdateBoundingSphere@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::UpdateBoundingSphere

; 91   : }

  0001a	c9		 leave
  0001b	c3		 ret	 0
?Update@CGraphicObjectInstance@@QAEXXZ ENDP		; CGraphicObjectInstance::Update
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?Clear@CGraphicObjectInstance@@QAEXXZ
_TEXT	SEGMENT
_pOut$ = -8						; size = 4
_this$ = -4						; size = 4
?Clear@CGraphicObjectInstance@@QAEXXZ PROC		; CGraphicObjectInstance::Clear, COMDAT
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 	if (m_CullingHandle)

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 b8 68 01 00
	00 00		 cmp	 DWORD PTR [eax+360], 0
  00012	74 1e		 je	 SHORT $LN2@Clear

; 13   : 	{
; 14   : 		CCullingManager::Instance().Unregister(m_CullingHandle);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	ff b0 68 01 00
	00		 push	 DWORD PTR [eax+360]
  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  00023	e8 00 00 00 00	 call	 ?Unregister@CCullingManager@@QAEXPAVSpherePack@@@Z ; CCullingManager::Unregister

; 15   : 		m_CullingHandle = NULL;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 a0 68 01 00
	00 00		 and	 DWORD PTR [eax+360], 0
$LN2@Clear:

; 16   : 	}
; 17   : 
; 18   : 	ClearHeightInstance();

  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?ClearHeightInstance@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::ClearHeightInstance

; 19   : 
; 20   : 	m_isVisible = TRUE;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	c6 40 68 01	 mov	 BYTE PTR [eax+104], 1

; 21   : 
; 22   : 	m_v3Position.x = m_v3Position.y = m_v3Position.z = 0.0f;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	0f 57 c0	 xorps	 xmm0, xmm0
  00047	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	0f 57 c0	 xorps	 xmm0, xmm0
  00052	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	0f 57 c0	 xorps	 xmm0, xmm0
  0005d	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 23   : 	m_v3Scale.x = m_v3Scale.y = m_v3Scale.z = 0.0f;

  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	0f 57 c0	 xorps	 xmm0, xmm0
  00073	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0
  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	0f 57 c0	 xorps	 xmm0, xmm0
  0007e	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 24   : 	//m_fRotation = 0.0f;
; 25   : 	m_fYaw = m_fPitch = m_fRoll = 0.0f;

  00083	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00086	0f 57 c0	 xorps	 xmm0, xmm0
  00089	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0
  0008e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00091	0f 57 c0	 xorps	 xmm0, xmm0
  00094	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0
  00099	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	0f 57 c0	 xorps	 xmm0, xmm0
  0009f	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 26   : 	D3DXMatrixIdentity(&m_worldMatrix);

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	83 c0 6c	 add	 eax, 108		; 0000006cH
  000aa	89 45 f8	 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  000ad	6a 10		 push	 16			; 00000010H
  000af	58		 pop	 eax
  000b0	6b c0 03	 imul	 eax, eax, 3
  000b3	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  000b6	6a 04		 push	 4
  000b8	59		 pop	 ecx
  000b9	d1 e1		 shl	 ecx, 1
  000bb	0f 57 c0	 xorps	 xmm0, xmm0
  000be	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000c3	6a 10		 push	 16			; 00000010H
  000c5	58		 pop	 eax
  000c6	6b c0 03	 imul	 eax, eax, 3
  000c9	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  000cc	6a 04		 push	 4
  000ce	59		 pop	 ecx
  000cf	c1 e1 00	 shl	 ecx, 0
  000d2	0f 57 c0	 xorps	 xmm0, xmm0
  000d5	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000da	6a 10		 push	 16			; 00000010H
  000dc	58		 pop	 eax
  000dd	6b c0 03	 imul	 eax, eax, 3
  000e0	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  000e3	6a 04		 push	 4
  000e5	59		 pop	 ecx
  000e6	6b c9 00	 imul	 ecx, ecx, 0
  000e9	0f 57 c0	 xorps	 xmm0, xmm0
  000ec	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000f1	6a 10		 push	 16			; 00000010H
  000f3	58		 pop	 eax
  000f4	d1 e0		 shl	 eax, 1
  000f6	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  000f9	6a 04		 push	 4
  000fb	59		 pop	 ecx
  000fc	6b c9 03	 imul	 ecx, ecx, 3
  000ff	0f 57 c0	 xorps	 xmm0, xmm0
  00102	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00107	6a 10		 push	 16			; 00000010H
  00109	58		 pop	 eax
  0010a	d1 e0		 shl	 eax, 1
  0010c	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  0010f	6a 04		 push	 4
  00111	59		 pop	 ecx
  00112	c1 e1 00	 shl	 ecx, 0
  00115	0f 57 c0	 xorps	 xmm0, xmm0
  00118	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0011d	6a 10		 push	 16			; 00000010H
  0011f	58		 pop	 eax
  00120	d1 e0		 shl	 eax, 1
  00122	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00125	6a 04		 push	 4
  00127	59		 pop	 ecx
  00128	6b c9 00	 imul	 ecx, ecx, 0
  0012b	0f 57 c0	 xorps	 xmm0, xmm0
  0012e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00133	6a 10		 push	 16			; 00000010H
  00135	58		 pop	 eax
  00136	c1 e0 00	 shl	 eax, 0
  00139	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  0013c	6a 04		 push	 4
  0013e	59		 pop	 ecx
  0013f	6b c9 03	 imul	 ecx, ecx, 3
  00142	0f 57 c0	 xorps	 xmm0, xmm0
  00145	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0014a	6a 10		 push	 16			; 00000010H
  0014c	58		 pop	 eax
  0014d	c1 e0 00	 shl	 eax, 0
  00150	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00153	6a 04		 push	 4
  00155	59		 pop	 ecx
  00156	d1 e1		 shl	 ecx, 1
  00158	0f 57 c0	 xorps	 xmm0, xmm0
  0015b	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00160	6a 10		 push	 16			; 00000010H
  00162	58		 pop	 eax
  00163	c1 e0 00	 shl	 eax, 0
  00166	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00169	6a 04		 push	 4
  0016b	59		 pop	 ecx
  0016c	6b c9 00	 imul	 ecx, ecx, 0
  0016f	0f 57 c0	 xorps	 xmm0, xmm0
  00172	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00177	6a 10		 push	 16			; 00000010H
  00179	58		 pop	 eax
  0017a	6b c0 00	 imul	 eax, eax, 0
  0017d	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00180	6a 04		 push	 4
  00182	59		 pop	 ecx
  00183	6b c9 03	 imul	 ecx, ecx, 3
  00186	0f 57 c0	 xorps	 xmm0, xmm0
  00189	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0018e	6a 10		 push	 16			; 00000010H
  00190	58		 pop	 eax
  00191	6b c0 00	 imul	 eax, eax, 0
  00194	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00197	6a 04		 push	 4
  00199	59		 pop	 ecx
  0019a	d1 e1		 shl	 ecx, 1
  0019c	0f 57 c0	 xorps	 xmm0, xmm0
  0019f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001a4	6a 10		 push	 16			; 00000010H
  001a6	58		 pop	 eax
  001a7	6b c0 00	 imul	 eax, eax, 0
  001aa	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  001ad	6a 04		 push	 4
  001af	59		 pop	 ecx
  001b0	c1 e1 00	 shl	 ecx, 0
  001b3	0f 57 c0	 xorps	 xmm0, xmm0
  001b6	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  001bb	6a 10		 push	 16			; 00000010H
  001bd	58		 pop	 eax
  001be	6b c0 03	 imul	 eax, eax, 3
  001c1	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  001c4	6a 04		 push	 4
  001c6	59		 pop	 ecx
  001c7	6b c9 03	 imul	 ecx, ecx, 3
  001ca	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001d2	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001d7	6a 10		 push	 16			; 00000010H
  001d9	58		 pop	 eax
  001da	d1 e0		 shl	 eax, 1
  001dc	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  001df	6a 04		 push	 4
  001e1	59		 pop	 ecx
  001e2	d1 e1		 shl	 ecx, 1
  001e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001ec	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001f1	6a 10		 push	 16			; 00000010H
  001f3	58		 pop	 eax
  001f4	c1 e0 00	 shl	 eax, 0
  001f7	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  001fa	6a 04		 push	 4
  001fc	59		 pop	 ecx
  001fd	c1 e1 00	 shl	 ecx, 0
  00200	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00208	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0020d	6a 10		 push	 16			; 00000010H
  0020f	58		 pop	 eax
  00210	6b c0 00	 imul	 eax, eax, 0
  00213	03 45 f8	 add	 eax, DWORD PTR _pOut$[ebp]
  00216	6a 04		 push	 4
  00218	59		 pop	 ecx
  00219	6b c9 00	 imul	 ecx, ecx, 0
  0021c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00224	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 28   : 	ZeroMemory(m_abyPortalID, sizeof(m_abyPortalID));

  00229	6a 08		 push	 8
  0022b	6a 00		 push	 0
  0022d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00230	05 60 01 00 00	 add	 eax, 352		; 00000160H
  00235	50		 push	 eax
  00236	e8 00 00 00 00	 call	 _memset
  0023b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 29   : 
; 30   : 	OnClear();

  0023e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00241	8b 00		 mov	 eax, DWORD PTR [eax]
  00243	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00246	ff 50 24	 call	 DWORD PTR [eax+36]

; 31   : }

  00249	c9		 leave
  0024a	c3		 ret	 0
?Clear@CGraphicObjectInstance@@QAEXXZ ENDP		; CGraphicObjectInstance::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?SetRotationMatrix@CGraphicObjectInstance@@QAEXABUD3DXMATRIX@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_m$ = 8							; size = 4
?SetRotationMatrix@CGraphicObjectInstance@@QAEXABUD3DXMATRIX@@@Z PROC ; CGraphicObjectInstance::SetRotationMatrix, COMDAT
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 	m_mRotation = m;

  00009	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  0000c	83 c7 28	 add	 edi, 40			; 00000028H
  0000f	6a 10		 push	 16			; 00000010H
  00011	59		 pop	 ecx
  00012	8b 75 08	 mov	 esi, DWORD PTR _m$[ebp]
  00015	f3 a5		 rep movsd

; 154  : }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	c9		 leave
  0001a	c2 04 00	 ret	 4
?SetRotationMatrix@CGraphicObjectInstance@@QAEXABUD3DXMATRIX@@@Z ENDP ; CGraphicObjectInstance::SetRotationMatrix
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?SetRotationQuaternion@CGraphicObjectInstance@@QAEXABUD3DXQUATERNION@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_q$ = 8							; size = 4
?SetRotationQuaternion@CGraphicObjectInstance@@QAEXABUD3DXQUATERNION@@@Z PROC ; CGraphicObjectInstance::SetRotationQuaternion, COMDAT
; _this$ = ecx

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 148  : 	D3DXMatrixRotationQuaternion(&m_mRotation, &q);

  00007	ff 75 08	 push	 DWORD PTR _q$[ebp]
  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	83 c0 28	 add	 eax, 40			; 00000028H
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _D3DXMatrixRotationQuaternion@8

; 149  : }

  00016	c9		 leave
  00017	c2 04 00	 ret	 4
?SetRotationQuaternion@CGraphicObjectInstance@@QAEXABUD3DXQUATERNION@@@Z ENDP ; CGraphicObjectInstance::SetRotationQuaternion
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?SetRotation@CGraphicObjectInstance@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fYaw$ = 8						; size = 4
_fPitch$ = 12						; size = 4
_fRoll$ = 16						; size = 4
?SetRotation@CGraphicObjectInstance@@QAEXMMM@Z PROC	; CGraphicObjectInstance::SetRotation, COMDAT
; _this$ = ecx

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 167  : 	//m_fRotation = fRotation;
; 168  : 	m_fYaw = fYaw;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fYaw$[ebp]
  0000f	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 169  : 	m_fPitch = fPitch;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fPitch$[ebp]
  0001c	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0

; 170  : 	m_fRoll = fRoll;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fRoll$[ebp]
  00029	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0

; 171  : 
; 172  : 	D3DXMatrixRotationYawPitchRoll(&m_mRotation, D3DXToRadian(fYaw), D3DXToRadian(fPitch), D3DXToRadian(fRoll));

  0002e	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fRoll$[ebp]
  00033	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  0003b	51		 push	 ecx
  0003c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00041	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fPitch$[ebp]
  00046	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  0004e	51		 push	 ecx
  0004f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00054	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fYaw$[ebp]
  00059	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  00061	51		 push	 ecx
  00062	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	83 c0 28	 add	 eax, 40			; 00000028H
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 _D3DXMatrixRotationYawPitchRoll@16

; 173  : }

  00073	c9		 leave
  00074	c2 0c 00	 ret	 12			; 0000000cH
?SetRotation@CGraphicObjectInstance@@QAEXMMM@Z ENDP	; CGraphicObjectInstance::SetRotation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?SetRotation@CGraphicObjectInstance@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fRotation$ = 8						; size = 4
?SetRotation@CGraphicObjectInstance@@QAEXM@Z PROC	; CGraphicObjectInstance::SetRotation, COMDAT
; _this$ = ecx

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 158  : 	m_fYaw = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 159  : 	m_fPitch = 0;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	0f 57 c0	 xorps	 xmm0, xmm0
  00018	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0

; 160  : 	m_fRoll = fRotation;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fRotation$[ebp]
  00025	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0

; 161  : 
; 162  : 	D3DXMatrixRotationZ(&m_mRotation, D3DXToRadian(fRotation));

  0002a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fRotation$[ebp]
  0002f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  00037	51		 push	 ecx
  00038	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 c0 28	 add	 eax, 40			; 00000028H
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 _D3DXMatrixRotationZ@8

; 163  : }

  00049	c9		 leave
  0004a	c2 04 00	 ret	 4
?SetRotation@CGraphicObjectInstance@@QAEXM@Z ENDP	; CGraphicObjectInstance::SetRotation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?SetScale@CGraphicObjectInstance@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetScale@CGraphicObjectInstance@@QAEXMMM@Z PROC	; CGraphicObjectInstance::SetScale, COMDAT
; _this$ = ecx

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 189  : 	m_v3Scale.x = x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0000f	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 190  : 	m_v3Scale.y = y;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  0001c	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 191  : 	m_v3Scale.z = z;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  00029	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 192  : }

  0002e	c9		 leave
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?SetScale@CGraphicObjectInstance@@QAEXMMM@Z ENDP	; CGraphicObjectInstance::SetScale
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?SetPosition@CGraphicObjectInstance@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newposition$ = 8					; size = 4
?SetPosition@CGraphicObjectInstance@@QAEXABUD3DXVECTOR3@@@Z PROC ; CGraphicObjectInstance::SetPosition, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 	m_v3Position = newposition;

  00009	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  0000c	83 c7 04	 add	 edi, 4
  0000f	8b 75 08	 mov	 esi, DWORD PTR _newposition$[ebp]
  00012	a5		 movsd
  00013	a5		 movsd
  00014	a5		 movsd

; 185  : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	c9		 leave
  00018	c2 04 00	 ret	 4
?SetPosition@CGraphicObjectInstance@@QAEXABUD3DXVECTOR3@@@Z ENDP ; CGraphicObjectInstance::SetPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?SetPosition@CGraphicObjectInstance@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetPosition@CGraphicObjectInstance@@QAEXMMM@Z PROC	; CGraphicObjectInstance::SetPosition, COMDAT
; _this$ = ecx

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 177  : 	m_v3Position.x = x;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0000f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 178  : 	m_v3Position.y = y;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  0001c	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 179  : 	m_v3Position.z = z;	

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  00029	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 180  : }

  0002e	c9		 leave
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?SetPosition@CGraphicObjectInstance@@QAEXMMM@Z ENDP	; CGraphicObjectInstance::SetPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetRoll@CGraphicObjectInstance@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRoll@CGraphicObjectInstance@@QAEMXZ PROC		; CGraphicObjectInstance::GetRoll, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 138  : 	return m_fRoll;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	d9 40 24	 fld	 DWORD PTR [eax+36]

; 139  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetRoll@CGraphicObjectInstance@@QAEMXZ ENDP		; CGraphicObjectInstance::GetRoll
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetPitch@CGraphicObjectInstance@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPitch@CGraphicObjectInstance@@QAEMXZ PROC		; CGraphicObjectInstance::GetPitch, COMDAT
; _this$ = ecx

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 133  : 	return m_fPitch;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	d9 40 20	 fld	 DWORD PTR [eax+32]

; 134  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetPitch@CGraphicObjectInstance@@QAEMXZ ENDP		; CGraphicObjectInstance::GetPitch
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetYaw@CGraphicObjectInstance@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetYaw@CGraphicObjectInstance@@QAEMXZ PROC		; CGraphicObjectInstance::GetYaw, COMDAT
; _this$ = ecx

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 128  : 	return m_fYaw;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	d9 40 1c	 fld	 DWORD PTR [eax+28]

; 129  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetYaw@CGraphicObjectInstance@@QAEMXZ ENDP		; CGraphicObjectInstance::GetYaw
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetRotation@CGraphicObjectInstance@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRotation@CGraphicObjectInstance@@QAEMXZ PROC	; CGraphicObjectInstance::GetRotation, COMDAT
; _this$ = ecx

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 123  : 	return GetRoll();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetRoll@CGraphicObjectInstance@@QAEMXZ ; CGraphicObjectInstance::GetRoll

; 124  : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?GetRotation@CGraphicObjectInstance@@QAEMXZ ENDP	; CGraphicObjectInstance::GetRotation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetScale@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetScale@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ PROC ; CGraphicObjectInstance::GetScale, COMDAT
; _this$ = ecx

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	return m_v3Scale;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 10	 add	 eax, 16			; 00000010H

; 119  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetScale@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ENDP ; CGraphicObjectInstance::GetScale
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ PROC ; CGraphicObjectInstance::GetPosition, COMDAT
; _this$ = ecx

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 	return m_v3Position;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 114  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ENDP ; CGraphicObjectInstance::GetPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ??1CGraphicObjectInstance@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CGraphicObjectInstance@@UAE@XZ PROC			; CGraphicObjectInstance::~CGraphicObjectInstance, COMDAT
; _this$ = ecx

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGraphicObjectInstance@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGraphicObjectInstance@@6B@

; 292  : 	Initialize();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Initialize@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Initialize

; 293  : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 6c 01 00
	00		 add	 ecx, 364		; 0000016cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00040	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@AAEXXZ ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 293  : }

  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ??1CGraphicCollisionObject@@UAE@XZ ; CGraphicCollisionObject::~CGraphicCollisionObject
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CGraphicObjectInstance@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CGraphicObjectInstance@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CGraphicObjectInstance@@UAE@XZ ENDP			; CGraphicObjectInstance::~CGraphicObjectInstance
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp
;	COMDAT ??0CGraphicObjectInstance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
_this$ = -36						; size = 4
tv153 = -32						; size = 4
___t$ = -28						; size = 4
_this$2 = -24						; size = 4
___n$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CGraphicObjectInstance@@QAE@XZ PROC			; CGraphicObjectInstance::CGraphicObjectInstance, COMDAT
; _this$ = ecx

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CGraphicObjectInstance@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0CGraphicCollisionObject@@QAE@XZ ; CGraphicCollisionObject::CGraphicCollisionObject
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGraphicObjectInstance@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.h

; 115  : 		bool					m_BlockCamera;

  0003d	c7 45 ec 08 00
	00 00		 mov	 DWORD PTR ___n$[ebp], 8
  00044	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00047	05 b0 00 00 00	 add	 eax, 176		; 000000b0H
  0004c	89 45 e4	 mov	 DWORD PTR ___t$[ebp], eax
$LN14@CGraphicOb:
  0004f	8b 45 ec	 mov	 eax, DWORD PTR ___n$[ebp]
  00052	89 45 e0	 mov	 DWORD PTR tv153[ebp], eax
  00055	8b 45 ec	 mov	 eax, DWORD PTR ___n$[ebp]
  00058	48		 dec	 eax
  00059	89 45 ec	 mov	 DWORD PTR ___n$[ebp], eax
  0005c	83 7d e0 00	 cmp	 DWORD PTR tv153[ebp], 0
  00060	76 0b		 jbe	 SHORT $LN25@CGraphicOb
  00062	8b 45 e4	 mov	 eax, DWORD PTR ___t$[ebp]
  00065	83 c0 10	 add	 eax, 16			; 00000010H
  00068	89 45 e4	 mov	 DWORD PTR ___t$[ebp], eax
  0006b	eb e2		 jmp	 SHORT $LN14@CGraphicOb
$LN25@CGraphicOb:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 263  : {

  0006d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00070	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  00075	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00078	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	89 45 d8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0007e	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00081	89 45 e8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00084	8b 45 e8	 mov	 eax, DWORD PTR _this$2[ebp]
  00087	83 20 00	 and	 DWORD PTR [eax], 0
  0008a	8b 45 e8	 mov	 eax, DWORD PTR _this$2[ebp]
  0008d	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00091	8b 45 e8	 mov	 eax, DWORD PTR _this$2[ebp]
  00094	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpObjectInstance.cpp

; 263  : {

  00098	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 264  : 	m_CullingHandle = 0;

  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	83 a0 68 01 00
	00 00		 and	 DWORD PTR [eax+360], 0

; 265  : 	Initialize();

  000a6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?Initialize@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Initialize

; 266  : }

  000ae	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000b2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bf	59		 pop	 ecx
  000c0	c9		 leave
  000c1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CGraphicObjectInstance@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CGraphicCollisionObject@@UAE@XZ ; CGraphicCollisionObject::~CGraphicCollisionObject
__unwindfunclet$??0CGraphicObjectInstance@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 6c 01 00
	00		 add	 ecx, 364		; 0000016cH
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCBaseCollisionInstance@@V?$allocator@PAVCBaseCollisionInstance@@@std@@@std@@QAE@XZ ; std::vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >::~vector<CBaseCollisionInstance *,std::allocator<CBaseCollisionInstance *> >
  00016	cc		 int	 3
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
__ehhandler$??0CGraphicObjectInstance@@QAE@XZ:
  0001b	90		 npad	 1
  0001c	90		 npad	 1
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00021	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00024	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CGraphicObjectInstance@@QAE@XZ
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CGraphicObjectInstance@@QAE@XZ ENDP			; CGraphicObjectInstance::CGraphicObjectInstance
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\sphere.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
_parent$ = 8						; size = 4
?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z PROC	; SpherePack::ComputeBindingDistance, COMDAT
; _this$ = ecx

; 241  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\sphere.h

; 45   : 	float GetRadius(void) const { return mRadius; };

  00009	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
  0000c	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00011	f3 0f 11 45 f8	 movss	 DWORD PTR $T2[ebp], xmm0
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0001e	f3 0f 11 45 f4	 movss	 DWORD PTR $T1[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 242  : 		mBindingDistance = parent->GetRadius() - GetRadius();

  00023	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR $T2[ebp]
  00028	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR $T1[ebp]
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 11 40 40	 movss	 DWORD PTR [eax+64], xmm0

; 243  : 		if ( mBindingDistance <= 0 )

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	0f 57 c0	 xorps	 xmm0, xmm0
  0003b	0f 2f 40 40	 comiss	 xmm0, DWORD PTR [eax+64]
  0003f	72 0d		 jb	 SHORT $LN2@ComputeBin

; 244  : 			mBindingDistance = 0;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	0f 57 c0	 xorps	 xmm0, xmm0
  00047	f3 0f 11 40 40	 movss	 DWORD PTR [eax+64], xmm0
  0004c	eb 18		 jmp	 SHORT $LN3@ComputeBin
$LN2@ComputeBin:

; 245  : 		else
; 246  : 			mBindingDistance*=mBindingDistance;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	f3 0f 10 40 40	 movss	 xmm0, DWORD PTR [eax+64]
  00059	f3 0f 59 41 40	 mulss	 xmm0, DWORD PTR [ecx+64]
  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	f3 0f 11 40 40	 movss	 DWORD PTR [eax+64], xmm0
$LN3@ComputeBin:

; 247  : 	}

  00066	c9		 leave
  00067	c2 04 00	 ret	 4
?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z ENDP	; SpherePack::ComputeBindingDistance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ?Unlink@SpherePack@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Unlink@SpherePack@@QAEXXZ PROC				; SpherePack::Unlink, COMDAT
; _this$ = ecx

; 147  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 148  : 		if ( mFifo1 ) // if we belong to fifo1, null us out

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  0000e	74 10		 je	 SHORT $LN2@Unlink

; 149  : 		{
; 150  : 			*mFifo1 = 0;

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  00016	83 20 00	 and	 DWORD PTR [eax], 0

; 151  : 			mFifo1 = 0;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 60 30 00	 and	 DWORD PTR [eax+48], 0
$LN2@Unlink:

; 152  : 		}
; 153  : 		
; 154  : 		if ( mFifo2 ) // if we belong to fifo2, null us out

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00027	74 10		 je	 SHORT $LN3@Unlink

; 155  : 		{
; 156  : 			*mFifo2 = 0;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0002f	83 20 00	 and	 DWORD PTR [eax], 0

; 157  : 			mFifo2 = 0;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 60 34 00	 and	 DWORD PTR [eax+52], 0
$LN3@Unlink:

; 158  : 		}
; 159  : 		
; 160  : 		if ( mParent ) mParent->LostChild(this);

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00040	74 0e		 je	 SHORT $LN4@Unlink
  00042	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0004b	e8 00 00 00 00	 call	 ?LostChild@SpherePack@@QAEXPAV1@@Z ; SpherePack::LostChild
$LN4@Unlink:

; 161  : 		
; 162  : 		assert( !mChildren ); // can't unlink guys with children!
; 163  : 		
; 164  : 		mParent = 0; // got no father anymore

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 165  : 	}

  00057	c9		 leave
  00058	c3		 ret	 0
?Unlink@SpherePack@@QAEXXZ ENDP				; SpherePack::Unlink
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\sphere.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\sphere.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ?NewPosRadius@SpherePack@@QAEXABVVector3d@@M@Z
_TEXT	SEGMENT
_dist$1 = -24						; size = 4
_pack$ = -20						; size = 4
$T2 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
_pos$ = 8						; size = 4
_radius$ = 12						; size = 4
?NewPosRadius@SpherePack@@QAEXABVVector3d@@M@Z PROC	; SpherePack::NewPosRadius, COMDAT
; _this$ = ecx

; 471  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 472  : 	// New position and, possibly, a new radius.
; 473  : 	mCenter = pos;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  00012	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _pos$[ebp]
  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001a	89 08		 mov	 DWORD PTR [eax], ecx
  0001c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _pos$[ebp]
  00022	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00025	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00028	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _pos$[ebp]
  0002e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00031	89 48 08	 mov	 DWORD PTR [eax+8], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 475  : 	if (mParent && !HasSpherePackFlag(SPF_INTEGRATE))

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0003b	0f 84 bd 00 00
	00		 je	 $LN4@NewPosRadi

; 133  : 		if ( mFlags & flag ) return true;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00047	83 e0 20	 and	 eax, 32			; 00000020H
  0004a	74 06		 je	 SHORT $LN9@NewPosRadi
  0004c	c6 45 ff 01	 mov	 BYTE PTR $T3[ebp], 1
  00050	eb 04		 jmp	 SHORT $LN8@NewPosRadi
$LN9@NewPosRadi:

; 134  : 		return false;

  00052	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
$LN8@NewPosRadi:

; 475  : 	if (mParent && !HasSpherePackFlag(SPF_INTEGRATE))

  00056	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	0f 85 9c 00 00
	00		 jne	 $LN4@NewPosRadi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\sphere.h

; 45   : 	float GetRadius(void) const { return mRadius; };

  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  0006a	f3 0f 11 45 f0	 movss	 DWORD PTR $T2[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 477  : 		if (radius != GetRadius())

  0006f	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00074	0f 2e 45 f0	 ucomiss xmm0, DWORD PTR $T2[ebp]
  00078	9f		 lahf
  00079	f6 c4 44	 test	 ah, 68			; 00000044H
  0007c	7b 2d		 jnp	 SHORT $LN3@NewPosRadi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\sphere.h

; 67   : 		mRadius = radius;

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00081	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00086	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 68   : 		mRadius2 = radius*radius;

  0008b	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00090	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _radius$[ebp]
  00095	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00098	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 480  : 			ComputeBindingDistance(mParent);

  0009d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	ff 70 20	 push	 DWORD PTR [eax+32]
  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?ComputeBindingDistance@SpherePack@@QAEXPAV1@@Z ; SpherePack::ComputeBindingDistance
$LN3@NewPosRadi:

; 481  : 		}
; 482  : 		
; 483  : 		mFactory->AddRecompute(mParent);

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	ff 70 20	 push	 DWORD PTR [eax+32]
  000b1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  000b7	e8 00 00 00 00	 call	 ?AddRecompute@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::AddRecompute

; 484  : 
; 485  : 		float dist = DistanceSquared(mParent);

  000bc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000c2	89 45 ec	 mov	 DWORD PTR _pack$[ebp], eax

; 212  : 	float DistanceSquared(const SpherePack *pack) const { return mCenter.DistanceSq( pack->mCenter );  };

  000c5	8b 45 ec	 mov	 eax, DWORD PTR _pack$[ebp]
  000c8	83 c0 04	 add	 eax, 4
  000cb	50		 push	 eax
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	83 c1 04	 add	 ecx, 4
  000d2	e8 00 00 00 00	 call	 ?DistanceSq@Vector3d@@QBEMABV1@@Z ; Vector3d::DistanceSq

; 484  : 
; 485  : 		float dist = DistanceSquared(mParent);

  000d7	d9 5d e8	 fstp	 DWORD PTR _dist$1[ebp]

; 486  : 	
; 487  : 		if (dist >= mBindingDistance)

  000da	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _dist$1[ebp]
  000e2	0f 2f 40 40	 comiss	 xmm0, DWORD PTR [eax+64]
  000e6	72 16		 jb	 SHORT $LN4@NewPosRadi

; 488  : 		{
; 489  : 			Unlink();

  000e8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	e8 00 00 00 00	 call	 ?Unlink@SpherePack@@QAEXXZ ; SpherePack::Unlink

; 490  : 			mFactory->AddIntegrate(this);

  000f0	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000f3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  000f9	e8 00 00 00 00	 call	 ?AddIntegrate@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::AddIntegrate
$LN4@NewPosRadi:

; 491  : 		}
; 492  : 	}
; 493  : }

  000fe	c9		 leave
  000ff	c2 08 00	 ret	 8
?NewPosRadius@SpherePack@@QAEXABVVector3d@@M@Z ENDP	; SpherePack::NewPosRadius
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ?NewPos@SpherePack@@QAEXABVVector3d@@@Z
_TEXT	SEGMENT
_dist$1 = -20						; size = 4
_pack$ = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -1						; size = 1
_pos$ = 8						; size = 4
?NewPos@SpherePack@@QAEXABVVector3d@@@Z PROC		; SpherePack::NewPos, COMDAT
; _this$ = ecx

; 449  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 450  : 	mCenter = pos;    // set our new center position.

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 57   : 	{ x=A.x; y=A.y; z=A.z;

  00012	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _pos$[ebp]
  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001a	89 08		 mov	 DWORD PTR [eax], ecx
  0001c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _pos$[ebp]
  00022	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00025	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00028	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _pos$[ebp]
  0002e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00031	89 48 08	 mov	 DWORD PTR [eax+8], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 453  : 	if (mParent && !HasSpherePackFlag(SPF_INTEGRATE))

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0003b	74 70		 je	 SHORT $LN3@NewPos

; 133  : 		if ( mFlags & flag ) return true;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00043	83 e0 20	 and	 eax, 32			; 00000020H
  00046	74 06		 je	 SHORT $LN8@NewPos
  00048	c6 45 ff 01	 mov	 BYTE PTR $T2[ebp], 1
  0004c	eb 04		 jmp	 SHORT $LN7@NewPos
$LN8@NewPos:

; 134  : 		return false;

  0004e	c6 45 ff 00	 mov	 BYTE PTR $T2[ebp], 0
$LN7@NewPos:

; 453  : 	if (mParent && !HasSpherePackFlag(SPF_INTEGRATE))

  00052	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]
  00056	85 c0		 test	 eax, eax
  00058	75 53		 jne	 SHORT $LN3@NewPos

; 454  : 	{	
; 455  : 		float dist = DistanceSquared(mParent);  // compute squared distance to our parent.

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00060	89 45 f0	 mov	 DWORD PTR _pack$[ebp], eax

; 212  : 	float DistanceSquared(const SpherePack *pack) const { return mCenter.DistanceSq( pack->mCenter );  };

  00063	8b 45 f0	 mov	 eax, DWORD PTR _pack$[ebp]
  00066	83 c0 04	 add	 eax, 4
  00069	50		 push	 eax
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	83 c1 04	 add	 ecx, 4
  00070	e8 00 00 00 00	 call	 ?DistanceSq@Vector3d@@QBEMABV1@@Z ; Vector3d::DistanceSq

; 454  : 	{	
; 455  : 		float dist = DistanceSquared(mParent);  // compute squared distance to our parent.

  00075	d9 5d ec	 fstp	 DWORD PTR _dist$1[ebp]

; 456  : 		
; 457  : 		if (dist >= mBindingDistance) // if that exceeds our binding distance...

  00078	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _dist$1[ebp]
  00080	0f 2f 40 40	 comiss	 xmm0, DWORD PTR [eax+64]
  00084	72 27		 jb	 SHORT $LN3@NewPos

; 458  : 		{
; 459  : 			// If our parent, is not already marked to be recomputed (rebalance the sphere), then add him to the recomputation fifo.
; 460  : 			mFactory->AddRecompute(mParent);

  00086	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00089	ff 70 20	 push	 DWORD PTR [eax+32]
  0008c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00092	e8 00 00 00 00	 call	 ?AddRecompute@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::AddRecompute

; 461  : 
; 462  : 			// Unlink ourselves from the parent sphere and place ourselves into the root node.
; 463  : 			Unlink();

  00097	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?Unlink@SpherePack@@QAEXXZ ; SpherePack::Unlink

; 464  : 			mFactory->AddIntegrate(this); // add ourselves to the re-integration fifo.

  0009f	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000a2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  000a8	e8 00 00 00 00	 call	 ?AddIntegrate@SpherePackFactory@@QAEXPAVSpherePack@@@Z ; SpherePackFactory::AddIntegrate
$LN3@NewPos:

; 465  : 		}
; 466  : 	}
; 467  : 	
; 468  : }

  000ad	c9		 leave
  000ae	c2 04 00	 ret	 4
?NewPos@SpherePack@@QAEXABVVector3d@@@Z ENDP		; SpherePack::NewPos
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
;	COMDAT ?DistanceSq@Vector3d@@QBEMABV1@@Z
_TEXT	SEGMENT
tv147 = -20						; size = 4
_dz$ = -16						; size = 4
_dy$ = -12						; size = 4
_dx$ = -8						; size = 4
_this$ = -4						; size = 4
_a$ = 8							; size = 4
?DistanceSq@Vector3d@@QBEMABV1@@Z PROC			; Vector3d::DistanceSq, COMDAT
; _this$ = ecx

; 169  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 170  : 		float dx = a.x - x;

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00013	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00017	f3 0f 11 45 f8	 movss	 DWORD PTR _dx$[ebp], xmm0

; 171  : 		float dy = a.y - y;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00027	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0002c	f3 0f 11 45 f4	 movss	 DWORD PTR _dy$[ebp], xmm0

; 172  : 		float dz = a.z - z;

  00031	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0003c	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00041	f3 0f 11 45 f0	 movss	 DWORD PTR _dz$[ebp], xmm0

; 173  : 		return dx*dx + dy*dy + dz*dz;

  00046	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _dx$[ebp]
  0004b	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _dx$[ebp]
  00050	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _dy$[ebp]
  00055	f3 0f 59 4d f4	 mulss	 xmm1, DWORD PTR _dy$[ebp]
  0005a	f3 0f 58 c1	 addss	 xmm0, xmm1
  0005e	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _dz$[ebp]
  00063	f3 0f 59 4d f0	 mulss	 xmm1, DWORD PTR _dz$[ebp]
  00068	f3 0f 58 c1	 addss	 xmm0, xmm1
  0006c	f3 0f 11 45 ec	 movss	 DWORD PTR tv147[ebp], xmm0
  00071	d9 45 ec	 fld	 DWORD PTR tv147[ebp]

; 174  : 	};

  00074	c9		 leave
  00075	c2 04 00	 ret	 4
?DistanceSq@Vector3d@@QBEMABV1@@Z ENDP			; Vector3d::DistanceSq
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
