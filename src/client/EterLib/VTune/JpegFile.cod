; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	?jpeg_save@@YAHPAEHHHPBD@Z			; jpeg_save
PUBLIC	?jpeg_save_to_file@@YAHPAEHHHPAU_iobuf@@@Z	; jpeg_save_to_file
PUBLIC	?jpeg_save_to_mem@@YAHPAEHHH0H@Z		; jpeg_save_to_mem
PUBLIC	?jpeg_load@@YAHPBDPAPAEPAH2@Z			; jpeg_load
PUBLIC	?jpeg_load_from_mem@@YAHPAEH0HH@Z		; jpeg_load_from_mem
PUBLIC	?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z ; mem_init_source
PUBLIC	?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z ; mem_fill_input_buffer
PUBLIC	?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z ; mem_skip_input_data
PUBLIC	?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z ; mem_resync_to_restart
PUBLIC	?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z ; mem_term_source
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_06GLDDLHNF@malloc@			; `string'
PUBLIC	??_C@_0BA@BLONFKFG@Out?5of?5memory?$CB?6@	; `string'
PUBLIC	??_C@_0BE@CJGMBEKG@jpeg?5mem?5overflow?$CB?6@	; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_08CJBHLKCB@fill?5?$CFd?6@			; `string'
PUBLIC	??_C@_0N@KMFLAFCK@skip?5?$CFd?5?$CL?$CFd?6@	; `string'
PUBLIC	??_C@_0L@MJDMKOIM@resync?5?$CFd?6@		; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BH@FLHCPHLC@Couldn?8t?5open?5file?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0CD@HHOHJMLB@Error?3?5Can?8t?5convert?5YCCK?5to?5RG@ ; `string'
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_exit:PROC
EXTRN	_perror:PROC
EXTRN	_memset:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fwrite:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	_jpeg_std_error:PROC
EXTRN	_jpeg_CreateCompress:PROC
EXTRN	_jpeg_CreateDecompress:PROC
EXTRN	_jpeg_destroy_compress:PROC
EXTRN	_jpeg_destroy_decompress:PROC
EXTRN	_jpeg_stdio_src:PROC
EXTRN	_jpeg_set_defaults:PROC
EXTRN	_jpeg_set_quality:PROC
EXTRN	_jpeg_start_compress:PROC
EXTRN	_jpeg_write_scanlines:PROC
EXTRN	_jpeg_finish_compress:PROC
EXTRN	_jpeg_read_header:PROC
EXTRN	_jpeg_start_decompress:PROC
EXTRN	_jpeg_read_scanlines:PROC
EXTRN	_jpeg_finish_decompress:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?fi@@3PAU_iobuf@@A DD 01H DUP (?)			; fi
?buffer@@3PAEA DD 01H DUP (?)				; buffer
?dest@@3PAEA DD	01H DUP (?)				; dest
?len@@3HA DD	01H DUP (?)				; len
?destlen@@3HA DD 01H DUP (?)				; destlen
?dataX@@3PAEA DD 01H DUP (?)				; dataX
?sizeX@@3HA DD	01H DUP (?)				; sizeX
_BSS	ENDS
;	COMDAT ??_C@_0CD@HHOHJMLB@Error?3?5Can?8t?5convert?5YCCK?5to?5RG@
CONST	SEGMENT
??_C@_0CD@HHOHJMLB@Error?3?5Can?8t?5convert?5YCCK?5to?5RG@ DB 'Error: Can'
	DB	'''t convert YCCK to RGB.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FLHCPHLC@Couldn?8t?5open?5file?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@FLHCPHLC@Couldn?8t?5open?5file?5?$CFs?6@ DB 'Couldn''t open fil'
	DB	'e %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MJDMKOIM@resync?5?$CFd?6@
CONST	SEGMENT
??_C@_0L@MJDMKOIM@resync?5?$CFd?6@ DB 'resync %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KMFLAFCK@skip?5?$CFd?5?$CL?$CFd?6@
CONST	SEGMENT
??_C@_0N@KMFLAFCK@skip?5?$CFd?5?$CL?$CFd?6@ DB 'skip %d +%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CJBHLKCB@fill?5?$CFd?6@
CONST	SEGMENT
??_C@_08CJBHLKCB@fill?5?$CFd?6@ DB 'fill %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CJGMBEKG@jpeg?5mem?5overflow?$CB?6@
CONST	SEGMENT
??_C@_0BE@CJGMBEKG@jpeg?5mem?5overflow?$CB?6@ DB 'jpeg mem overflow!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BLONFKFG@Out?5of?5memory?$CB?6@
CONST	SEGMENT
??_C@_0BA@BLONFKFG@Out?5of?5memory?$CB?6@ DB 'Out of memory!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLDDLHNF@malloc@
CONST	SEGMENT
??_C@_06GLDDLHNF@malloc@ DB 'malloc', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z
_TEXT	SEGMENT
_mgr$ = -4						; size = 4
_cinfo$ = 8						; size = 4
?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z PROC	; mem_term_source, COMDAT

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 251  :     struct jpeg_source_mgr* mgr = cinfo->src;

  00004	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	89 45 fc	 mov	 DWORD PTR _mgr$[ebp], eax

; 252  :     //printf("term %d\n", size - mgr->bytes_in_buffer);
; 253  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z ENDP	; mem_term_source
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z
_TEXT	SEGMENT
_mgr$ = -4						; size = 4
_cinfo$ = 8						; size = 4
_desired$ = 12						; size = 4
?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z PROC ; mem_resync_to_restart, COMDAT

; 241  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 242  :     struct jpeg_source_mgr* mgr = cinfo->src;

  00004	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	89 45 fc	 mov	 DWORD PTR _mgr$[ebp], eax

; 243  :     printf("resync %d\n", sizeX - mgr->bytes_in_buffer);

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _mgr$[ebp]
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sizeX@@3HA
  00016	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00019	51		 push	 ecx
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MJDMKOIM@resync?5?$CFd?6@
  0001f	e8 00 00 00 00	 call	 _printf
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx

; 244  :     mgr->next_input_byte = dataX;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _mgr$[ebp]
  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dataX@@3PAEA
  0002f	89 08		 mov	 DWORD PTR [eax], ecx

; 245  :     mgr->bytes_in_buffer = sizeX;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _mgr$[ebp]
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sizeX@@3HA
  0003a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 246  :     return 1;

  0003d	b0 01		 mov	 al, 1

; 247  : }

  0003f	c9		 leave
  00040	c3		 ret	 0
?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z ENDP ; mem_resync_to_restart
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z
_TEXT	SEGMENT
_mgr$ = -4						; size = 4
_cinfo$ = 8						; size = 4
_num_bytes$ = 12					; size = 4
?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z PROC ; mem_skip_input_data, COMDAT

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 232  :     struct jpeg_source_mgr* mgr = cinfo->src;

  00004	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	89 45 fc	 mov	 DWORD PTR _mgr$[ebp], eax

; 233  :     printf("skip %d +%d\n", sizeX - mgr->bytes_in_buffer, num_bytes);

  0000d	ff 75 0c	 push	 DWORD PTR _num_bytes$[ebp]
  00010	8b 45 fc	 mov	 eax, DWORD PTR _mgr$[ebp]
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sizeX@@3HA
  00019	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  0001c	51		 push	 ecx
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KMFLAFCK@skip?5?$CFd?5?$CL?$CFd?6@
  00022	e8 00 00 00 00	 call	 _printf
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 234  :     if (num_bytes <= 0)

  0002a	83 7d 0c 00	 cmp	 DWORD PTR _num_bytes$[ebp], 0
  0002e	7f 02		 jg	 SHORT $LN2@mem_skip_i

; 235  :         return;

  00030	eb 1c		 jmp	 SHORT $LN1@mem_skip_i
$LN2@mem_skip_i:

; 236  :     mgr->next_input_byte += num_bytes;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _mgr$[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	03 45 0c	 add	 eax, DWORD PTR _num_bytes$[ebp]
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _mgr$[ebp]
  0003d	89 01		 mov	 DWORD PTR [ecx], eax

; 237  :     mgr->bytes_in_buffer -= num_bytes;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _mgr$[ebp]
  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	2b 45 0c	 sub	 eax, DWORD PTR _num_bytes$[ebp]
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _mgr$[ebp]
  0004b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN1@mem_skip_i:

; 238  : }

  0004e	c9		 leave
  0004f	c3		 ret	 0
?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z ENDP ; mem_skip_input_data
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z
_TEXT	SEGMENT
_mgr$ = -4						; size = 4
_cinfo$ = 8						; size = 4
?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z PROC ; mem_fill_input_buffer, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 225  :     struct jpeg_source_mgr* mgr = cinfo->src;

  00004	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	89 45 fc	 mov	 DWORD PTR _mgr$[ebp], eax

; 226  :     printf("fill %d\n", sizeX - mgr->bytes_in_buffer);

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _mgr$[ebp]
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sizeX@@3HA
  00016	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00019	51		 push	 ecx
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_08CJBHLKCB@fill?5?$CFd?6@
  0001f	e8 00 00 00 00	 call	 _printf
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx

; 227  :     return 0;

  00026	32 c0		 xor	 al, al

; 228  : }

  00028	c9		 leave
  00029	c3		 ret	 0
?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z ENDP ; mem_fill_input_buffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z
_TEXT	SEGMENT
_mgr$ = -4						; size = 4
_cinfo$ = 8						; size = 4
?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z PROC	; mem_init_source, COMDAT

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 217  :     struct jpeg_source_mgr* mgr = cinfo->src;

  00004	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	89 45 fc	 mov	 DWORD PTR _mgr$[ebp], eax

; 218  :     mgr->next_input_byte = dataX;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _mgr$[ebp]
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dataX@@3PAEA
  00016	89 08		 mov	 DWORD PTR [eax], ecx

; 219  :     mgr->bytes_in_buffer = sizeX;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _mgr$[ebp]
  0001b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sizeX@@3HA
  00021	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 220  :     //printf("init %d\n", size - mgr->bytes_in_buffer);
; 221  : }

  00024	c9		 leave
  00025	c3		 ret	 0
?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z ENDP	; mem_init_source
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_term_destination@@YAXPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_dmgr$ = -4						; size = 4
_cinfo$ = 8						; size = 4
?mem_term_destination@@YAXPAUjpeg_compress_struct@@@Z PROC ; mem_term_destination, COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 73   :     struct jpeg_destination_mgr* dmgr =

  00004	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	89 45 fc	 mov	 DWORD PTR _dmgr$[ebp], eax

; 74   :         (struct jpeg_destination_mgr*)(cinfo->dest);
; 75   :     len = destlen - dmgr->free_in_buffer;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _dmgr$[ebp]
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?destlen@@3HA
  00016	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00019	89 0d 00 00 00
	00		 mov	 DWORD PTR ?len@@3HA, ecx

; 76   :     dmgr->free_in_buffer = 0;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _dmgr$[ebp]
  00022	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 77   : }

  00026	c9		 leave
  00027	c3		 ret	 0
?mem_term_destination@@YAXPAUjpeg_compress_struct@@@Z ENDP ; mem_term_destination
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_cinfo$ = 8						; size = 4
?mem_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z PROC ; mem_empty_output_buffer, COMDAT

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   :     printf("jpeg mem overflow!\n");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CJGMBEKG@jpeg?5mem?5overflow?$CB?6@
  00008	e8 00 00 00 00	 call	 _printf
  0000d	59		 pop	 ecx

; 68   :     exit(1);

  0000e	6a 01		 push	 1
  00010	e8 00 00 00 00	 call	 _exit
$LN2@mem_empty_:

; 69   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?mem_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ENDP ; mem_empty_output_buffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?mem_init_destination@@YAXPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_dmgr$ = -4						; size = 4
_cinfo$ = 8						; size = 4
?mem_init_destination@@YAXPAUjpeg_compress_struct@@@Z PROC ; mem_init_destination, COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 59   :     struct jpeg_destination_mgr* dmgr =

  00004	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	89 45 fc	 mov	 DWORD PTR _dmgr$[ebp], eax

; 60   :         (struct jpeg_destination_mgr*)(cinfo->dest);
; 61   :     dmgr->next_output_byte = dest;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _dmgr$[ebp]
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dest@@3PAEA
  00016	89 08		 mov	 DWORD PTR [eax], ecx

; 62   :     dmgr->free_in_buffer = destlen;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _dmgr$[ebp]
  0001b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?destlen@@3HA
  00021	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 63   : }

  00024	c9		 leave
  00025	c3		 ret	 0
?mem_init_destination@@YAXPAUjpeg_compress_struct@@@Z ENDP ; mem_init_destination
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_dmgr$ = -4						; size = 4
_cinfo$ = 8						; size = 4
?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z PROC ; file_term_destination, COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 48   :     struct jpeg_destination_mgr* dmgr =

  00004	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	89 45 fc	 mov	 DWORD PTR _dmgr$[ebp], eax

; 49   :         (struct jpeg_destination_mgr*)(cinfo->dest);
; 50   :     if (fi)

  0000d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?fi@@3PAU_iobuf@@A, 0
  00014	74 22		 je	 SHORT $LN2@file_term_

; 51   :         fwrite(buffer, OUTBUFFER_SIZE - dmgr->free_in_buffer, 1, fi);

  00016	ff 35 00 00 00
	00		 push	 DWORD PTR ?fi@@3PAU_iobuf@@A
  0001c	6a 01		 push	 1
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _dmgr$[ebp]
  00021	b9 00 80 00 00	 mov	 ecx, 32768		; 00008000H
  00026	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00029	51		 push	 ecx
  0002a	ff 35 00 00 00
	00		 push	 DWORD PTR ?buffer@@3PAEA
  00030	e8 00 00 00 00	 call	 _fwrite
  00035	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@file_term_:

; 52   :     free(buffer);

  00038	ff 35 00 00 00
	00		 push	 DWORD PTR ?buffer@@3PAEA
  0003e	e8 00 00 00 00	 call	 _free
  00043	59		 pop	 ecx

; 53   :     buffer = 0;

  00044	83 25 00 00 00
	00 00		 and	 DWORD PTR ?buffer@@3PAEA, 0

; 54   :     dmgr->free_in_buffer = 0;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _dmgr$[ebp]
  0004e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 55   : }

  00052	c9		 leave
  00053	c3		 ret	 0
?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z ENDP ; file_term_destination
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_dmgr$ = -4						; size = 4
_cinfo$ = 8						; size = 4
?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z PROC ; file_empty_output_buffer, COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 37   :     struct jpeg_destination_mgr* dmgr =

  00004	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	89 45 fc	 mov	 DWORD PTR _dmgr$[ebp], eax

; 38   :         (struct jpeg_destination_mgr*)(cinfo->dest);
; 39   :     if (fi)

  0000d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?fi@@3PAU_iobuf@@A, 0
  00014	74 1b		 je	 SHORT $LN2@file_empty

; 40   :         fwrite(buffer, OUTBUFFER_SIZE, 1, fi);

  00016	ff 35 00 00 00
	00		 push	 DWORD PTR ?fi@@3PAU_iobuf@@A
  0001c	6a 01		 push	 1
  0001e	68 00 80 00 00	 push	 32768			; 00008000H
  00023	ff 35 00 00 00
	00		 push	 DWORD PTR ?buffer@@3PAEA
  00029	e8 00 00 00 00	 call	 _fwrite
  0002e	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@file_empty:

; 41   :     dmgr->next_output_byte = buffer;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _dmgr$[ebp]
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?buffer@@3PAEA
  0003a	89 08		 mov	 DWORD PTR [eax], ecx

; 42   :     dmgr->free_in_buffer = OUTBUFFER_SIZE;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _dmgr$[ebp]
  0003f	c7 40 04 00 80
	00 00		 mov	 DWORD PTR [eax+4], 32768 ; 00008000H

; 43   :     return 1;

  00046	b0 01		 mov	 al, 1

; 44   : }

  00048	c9		 leave
  00049	c3		 ret	 0
?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ENDP ; file_empty_output_buffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z
_TEXT	SEGMENT
_dmgr$ = -4						; size = 4
_cinfo$ = 8						; size = 4
?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z PROC ; file_init_destination, COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 23   :     struct jpeg_destination_mgr* dmgr =

  00004	8b 45 08	 mov	 eax, DWORD PTR _cinfo$[ebp]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	89 45 fc	 mov	 DWORD PTR _dmgr$[ebp], eax

; 24   :         (struct jpeg_destination_mgr*)(cinfo->dest);
; 25   :     buffer = (JOCTET*)malloc(OUTBUFFER_SIZE);

  0000d	68 00 80 00 00	 push	 32768			; 00008000H
  00012	e8 00 00 00 00	 call	 _malloc
  00017	59		 pop	 ecx
  00018	a3 00 00 00 00	 mov	 DWORD PTR ?buffer@@3PAEA, eax

; 26   :     if (!buffer) {

  0001d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?buffer@@3PAEA, 0
  00024	75 1d		 jne	 SHORT $LN2@file_init_

; 27   :         perror("malloc");

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_06GLDDLHNF@malloc@
  0002b	e8 00 00 00 00	 call	 _perror
  00030	59		 pop	 ecx

; 28   :         printf("Out of memory!\n");

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BLONFKFG@Out?5of?5memory?$CB?6@
  00036	e8 00 00 00 00	 call	 _printf
  0003b	59		 pop	 ecx

; 29   :         exit(1);

  0003c	6a 01		 push	 1
  0003e	e8 00 00 00 00	 call	 _exit
$LN2@file_init_:

; 30   :     }
; 31   :     dmgr->next_output_byte = buffer;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _dmgr$[ebp]
  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?buffer@@3PAEA
  0004c	89 08		 mov	 DWORD PTR [eax], ecx

; 32   :     dmgr->free_in_buffer = OUTBUFFER_SIZE;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _dmgr$[ebp]
  00051	c7 40 04 00 80
	00 00		 mov	 DWORD PTR [eax+4], 32768 ; 00008000H
$LN3@file_init_:

; 33   : }

  00058	c9		 leave
  00059	c3		 ret	 0
?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z ENDP ; file_init_destination
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?jpeg_load_from_mem@@YAHPAEH0HH@Z
_TEXT	SEGMENT
_mgr$ = -128						; size = 28
_j$1 = -100						; size = 4
_y$ = -96						; size = 4
_cinfo$ = -92						; size = 456
_jerr$ = 364						; size = 132
__$ArrayPad$ = 496					; size = 4
__data$ = 508						; size = 4
__size$ = 512						; size = 4
_dest$ = 516						; size = 4
_width$ = 520						; size = 4
_height$ = 524						; size = 4
?jpeg_load_from_mem@@YAHPAEH0HH@Z PROC			; jpeg_load_from_mem, COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8d ac 24 0c fe
	ff ff		 lea	 ebp, DWORD PTR [esp-500]
  00008	81 ec 74 02 00
	00		 sub	 esp, 628		; 00000274H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 f0 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 257  :     struct jpeg_decompress_struct cinfo;
; 258  :     struct jpeg_error_mgr jerr;
; 259  :     struct jpeg_source_mgr mgr;
; 260  :     int y;
; 261  :     //int x;
; 262  : 
; 263  :     dataX = _data;

  0001b	8b 85 fc 01 00
	00		 mov	 eax, DWORD PTR __data$[ebp]
  00021	a3 00 00 00 00	 mov	 DWORD PTR ?dataX@@3PAEA, eax

; 264  :     sizeX = _size;

  00026	8b 85 00 02 00
	00		 mov	 eax, DWORD PTR __size$[ebp]
  0002c	a3 00 00 00 00	 mov	 DWORD PTR ?sizeX@@3HA, eax

; 265  : 
; 266  :     jpeg_create_decompress(&cinfo);

  00031	68 c8 01 00 00	 push	 456			; 000001c8H
  00036	6a 5a		 push	 90			; 0000005aH
  00038	8d 45 a4	 lea	 eax, DWORD PTR _cinfo$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _jpeg_CreateDecompress
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 267  : 
; 268  :     mgr.next_input_byte = dataX;

  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dataX@@3PAEA
  00049	89 45 80	 mov	 DWORD PTR _mgr$[ebp], eax

; 269  :     mgr.bytes_in_buffer = sizeX;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sizeX@@3HA
  00051	89 45 84	 mov	 DWORD PTR _mgr$[ebp+4], eax

; 270  :     mgr.init_source = mem_init_source;

  00054	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _mgr$[ebp+8], OFFSET ?mem_init_source@@YAXPAUjpeg_decompress_struct@@@Z ; mem_init_source

; 271  :     mgr.fill_input_buffer = mem_fill_input_buffer;

  0005b	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _mgr$[ebp+12], OFFSET ?mem_fill_input_buffer@@YAEPAUjpeg_decompress_struct@@@Z ; mem_fill_input_buffer

; 272  :     mgr.skip_input_data = mem_skip_input_data;

  00062	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _mgr$[ebp+16], OFFSET ?mem_skip_input_data@@YAXPAUjpeg_decompress_struct@@J@Z ; mem_skip_input_data

; 273  :     mgr.resync_to_restart = mem_resync_to_restart;

  00069	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _mgr$[ebp+20], OFFSET ?mem_resync_to_restart@@YAEPAUjpeg_decompress_struct@@H@Z ; mem_resync_to_restart

; 274  :     mgr.term_source = mem_term_source;

  00070	c7 45 98 00 00
	00 00		 mov	 DWORD PTR _mgr$[ebp+24], OFFSET ?mem_term_source@@YAXPAUjpeg_decompress_struct@@@Z ; mem_term_source

; 275  : 
; 276  :     cinfo.err = jpeg_std_error(&jerr);

  00077	8d 85 6c 01 00
	00		 lea	 eax, DWORD PTR _jerr$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _jpeg_std_error
  00083	59		 pop	 ecx
  00084	89 45 a4	 mov	 DWORD PTR _cinfo$[ebp], eax

; 277  :     cinfo.src = &mgr;

  00087	8d 45 80	 lea	 eax, DWORD PTR _mgr$[ebp]
  0008a	89 45 bc	 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 278  : 
; 279  :     jpeg_read_header(&cinfo, TRUE);

  0008d	6a 01		 push	 1
  0008f	8d 45 a4	 lea	 eax, DWORD PTR _cinfo$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _jpeg_read_header
  00098	59		 pop	 ecx
  00099	59		 pop	 ecx

; 280  :     jpeg_start_decompress(&cinfo);

  0009a	8d 45 a4	 lea	 eax, DWORD PTR _cinfo$[ebp]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 _jpeg_start_decompress
  000a3	59		 pop	 ecx

; 281  : 
; 282  :     for (y = 0; y < height; y++) {

  000a4	83 65 a0 00	 and	 DWORD PTR _y$[ebp], 0
  000a8	eb 07		 jmp	 SHORT $LN4@jpeg_load_
$LN2@jpeg_load_:
  000aa	8b 45 a0	 mov	 eax, DWORD PTR _y$[ebp]
  000ad	40		 inc	 eax
  000ae	89 45 a0	 mov	 DWORD PTR _y$[ebp], eax
$LN4@jpeg_load_:
  000b1	8b 45 a0	 mov	 eax, DWORD PTR _y$[ebp]
  000b4	3b 85 0c 02 00
	00		 cmp	 eax, DWORD PTR _height$[ebp]
  000ba	7d 2a		 jge	 SHORT $LN3@jpeg_load_

; 283  :         unsigned char* j = &dest[width * y * 3];

  000bc	8b 85 08 02 00
	00		 mov	 eax, DWORD PTR _width$[ebp]
  000c2	0f af 45 a0	 imul	 eax, DWORD PTR _y$[ebp]
  000c6	6b c0 03	 imul	 eax, eax, 3
  000c9	03 85 04 02 00
	00		 add	 eax, DWORD PTR _dest$[ebp]
  000cf	89 45 9c	 mov	 DWORD PTR _j$1[ebp], eax

; 284  :         jpeg_read_scanlines(&cinfo, &j, 1);

  000d2	6a 01		 push	 1
  000d4	8d 45 9c	 lea	 eax, DWORD PTR _j$1[ebp]
  000d7	50		 push	 eax
  000d8	8d 45 a4	 lea	 eax, DWORD PTR _cinfo$[ebp]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _jpeg_read_scanlines
  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 285  :     }

  000e4	eb c4		 jmp	 SHORT $LN2@jpeg_load_
$LN3@jpeg_load_:

; 286  : 
; 287  :     jpeg_finish_decompress(&cinfo);

  000e6	8d 45 a4	 lea	 eax, DWORD PTR _cinfo$[ebp]
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 _jpeg_finish_decompress
  000ef	59		 pop	 ecx

; 288  :     jpeg_destroy_decompress(&cinfo);

  000f0	8d 45 a4	 lea	 eax, DWORD PTR _cinfo$[ebp]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _jpeg_destroy_decompress
  000f9	59		 pop	 ecx

; 289  :     return 1;

  000fa	33 c0		 xor	 eax, eax
  000fc	40		 inc	 eax

; 290  : }

  000fd	8b 8d f0 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00103	33 cd		 xor	 ecx, ebp
  00105	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010a	81 c5 f4 01 00
	00		 add	 ebp, 500		; 000001f4H
  00110	c9		 leave
  00111	c3		 ret	 0
?jpeg_load_from_mem@@YAHPAEH0HH@Z ENDP			; jpeg_load_from_mem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?jpeg_load@@YAHPBDPAPAEPAH2@Z
_TEXT	SEGMENT
_scanline$ = -536					; size = 4
_u$1 = -532						; size = 4
_v$2 = -528						; size = 4
_height$ = -524						; size = 4
_fi$ = -520						; size = 4
_y$3 = -516						; size = 4
_y$ = -512						; size = 4
_white$4 = -508						; size = 4
_width$ = -504						; size = 4
_js$5 = -500						; size = 4
_line$6 = -496						; size = 4
_x$7 = -492						; size = 4
_cinfo$ = -488						; size = 456
_jerr$ = -32						; size = 132
__$ArrayPad$ = 100					; size = 4
_filename$ = 112					; size = 4
_dest$ = 116						; size = 4
__width$ = 120						; size = 4
__height$ = 124						; size = 4
?jpeg_load@@YAHPBDPAPAEPAH2@Z PROC			; jpeg_load, COMDAT

; 299  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 98	 lea	 ebp, DWORD PTR [esp-104]
  00005	81 ec 80 02 00
	00		 sub	 esp, 640		; 00000280H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 64	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi

; 300  :     struct jpeg_decompress_struct cinfo;
; 301  :     struct jpeg_error_mgr jerr;
; 302  :     //struct jpeg_source_mgr mgr;
; 303  : 
; 304  :     FILE* fi = fopen(filename, "rb");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  0001b	ff 75 70	 push	 DWORD PTR _filename$[ebp]
  0001e	e8 00 00 00 00	 call	 _fopen
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _fi$[ebp], eax

; 305  :     if (!fi) {

  0002b	83 bd f8 fd ff
	ff 00		 cmp	 DWORD PTR _fi$[ebp], 0
  00032	75 20		 jne	 SHORT $LN17@jpeg_load

; 306  :         fprintf(stderr, "Couldn't open file %s\n", filename);

  00034	ff 75 70	 push	 DWORD PTR _filename$[ebp]
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FLHCPHLC@Couldn?8t?5open?5file?5?$CFs?6@
  0003c	6a 02		 push	 2
  0003e	e8 00 00 00 00	 call	 ___acrt_iob_func
  00043	59		 pop	 ecx
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _fprintf
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 307  :         return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	e9 00 05 00 00	 jmp	 $LN1@jpeg_load
$LN17@jpeg_load:

; 308  :     }
; 309  : 
; 310  :     cinfo.err = jpeg_std_error(&jerr);

  00054	8d 45 e0	 lea	 eax, DWORD PTR _jerr$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _jpeg_std_error
  0005d	59		 pop	 ecx
  0005e	89 85 18 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax

; 311  :     jpeg_create_decompress(&cinfo);

  00064	68 c8 01 00 00	 push	 456			; 000001c8H
  00069	6a 5a		 push	 90			; 0000005aH
  0006b	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _jpeg_CreateDecompress
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 312  :     jpeg_stdio_src(&cinfo, fi);

  0007a	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _fi$[ebp]
  00080	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _jpeg_stdio_src
  0008c	59		 pop	 ecx
  0008d	59		 pop	 ecx

; 313  :     jpeg_read_header(&cinfo, TRUE);

  0008e	6a 01		 push	 1
  00090	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _jpeg_read_header
  0009c	59		 pop	 ecx
  0009d	59		 pop	 ecx

; 314  :     jpeg_start_decompress(&cinfo);

  0009e	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _jpeg_start_decompress
  000aa	59		 pop	 ecx

; 315  : 
; 316  :     U8* scanline = (U8*)malloc(4 * cinfo.output_width);

  000ab	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+92]
  000b1	c1 e0 02	 shl	 eax, 2
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 _malloc
  000ba	59		 pop	 ecx
  000bb	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _scanline$[ebp], eax

; 317  : 
; 318  :     int width = *_width = cinfo.output_width;

  000c1	8b 45 78	 mov	 eax, DWORD PTR __width$[ebp]
  000c4	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _cinfo$[ebp+92]
  000ca	89 08		 mov	 DWORD PTR [eax], ecx
  000cc	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+92]
  000d2	89 85 08 fe ff
	ff		 mov	 DWORD PTR _width$[ebp], eax

; 319  :     int height = *_height = cinfo.output_height;

  000d8	8b 45 7c	 mov	 eax, DWORD PTR __height$[ebp]
  000db	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _cinfo$[ebp+96]
  000e1	89 08		 mov	 DWORD PTR [eax], ecx
  000e3	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _cinfo$[ebp+96]
  000e9	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _height$[ebp], eax

; 320  :     *dest = (unsigned char*)malloc(width * height * 4);

  000ef	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR _width$[ebp]
  000f5	0f af 85 f4 fd
	ff ff		 imul	 eax, DWORD PTR _height$[ebp]
  000fc	c1 e0 02	 shl	 eax, 2
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _malloc
  00105	59		 pop	 ecx
  00106	8b 4d 74	 mov	 ecx, DWORD PTR _dest$[ebp]
  00109	89 01		 mov	 DWORD PTR [ecx], eax

; 321  : 
; 322  :     int y;
; 323  :     for (y = 0; y < height; y++) {

  0010b	83 a5 00 fe ff
	ff 00		 and	 DWORD PTR _y$[ebp], 0
  00112	eb 0d		 jmp	 SHORT $LN4@jpeg_load
$LN2@jpeg_load:
  00114	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR _y$[ebp]
  0011a	40		 inc	 eax
  0011b	89 85 00 fe ff
	ff		 mov	 DWORD PTR _y$[ebp], eax
$LN4@jpeg_load:
  00121	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR _y$[ebp]
  00127	3b 85 f4 fd ff
	ff		 cmp	 eax, DWORD PTR _height$[ebp]
  0012d	0f 8d ec 03 00
	00		 jge	 $LN3@jpeg_load

; 324  :         int x;
; 325  :         U8* js = scanline;

  00133	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _scanline$[ebp]
  00139	89 85 0c fe ff
	ff		 mov	 DWORD PTR _js$5[ebp], eax

; 326  :         RGBA* line = &((RGBA*)(*dest))[y * width];

  0013f	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR _y$[ebp]
  00145	0f af 85 08 fe
	ff ff		 imul	 eax, DWORD PTR _width$[ebp]
  0014c	8b 4d 74	 mov	 ecx, DWORD PTR _dest$[ebp]
  0014f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00151	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00154	89 85 10 fe ff
	ff		 mov	 DWORD PTR _line$6[ebp], eax

; 327  : 
; 328  :         jpeg_read_scanlines(&cinfo, &js, 1);

  0015a	6a 01		 push	 1
  0015c	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR _js$5[ebp]
  00162	50		 push	 eax
  00163	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 _jpeg_read_scanlines
  0016f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 329  :         if (cinfo.out_color_space == JCS_GRAYSCALE) {

  00172	83 bd 44 fe ff
	ff 01		 cmp	 DWORD PTR _cinfo$[ebp+44], 1
  00179	0f 85 9c 00 00
	00		 jne	 $LN18@jpeg_load

; 330  :             for (x = 0; x < width; x++) {

  0017f	83 a5 14 fe ff
	ff 00		 and	 DWORD PTR _x$7[ebp], 0
  00186	eb 0d		 jmp	 SHORT $LN7@jpeg_load
$LN5@jpeg_load:
  00188	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0018e	40		 inc	 eax
  0018f	89 85 14 fe ff
	ff		 mov	 DWORD PTR _x$7[ebp], eax
$LN7@jpeg_load:
  00195	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0019b	3b 85 08 fe ff
	ff		 cmp	 eax, DWORD PTR _width$[ebp]
  001a1	7d 73		 jge	 SHORT $LN6@jpeg_load

; 331  :                 line[x].a = 255;

  001a3	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  001a9	8b 8d 10 fe ff
	ff		 mov	 ecx, DWORD PTR _line$6[ebp]
  001af	c6 04 81 ff	 mov	 BYTE PTR [ecx+eax*4], 255 ; 000000ffH

; 332  :                 line[x].r = line[x].g = line[x].b = js[x];

  001b3	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _js$5[ebp]
  001b9	03 85 14 fe ff
	ff		 add	 eax, DWORD PTR _x$7[ebp]
  001bf	8b 8d 14 fe ff
	ff		 mov	 ecx, DWORD PTR _x$7[ebp]
  001c5	8b 95 10 fe ff
	ff		 mov	 edx, DWORD PTR _line$6[ebp]
  001cb	8a 00		 mov	 al, BYTE PTR [eax]
  001cd	88 44 8a 03	 mov	 BYTE PTR [edx+ecx*4+3], al
  001d1	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  001d7	8b 8d 10 fe ff
	ff		 mov	 ecx, DWORD PTR _line$6[ebp]
  001dd	8b 95 14 fe ff
	ff		 mov	 edx, DWORD PTR _x$7[ebp]
  001e3	8b b5 10 fe ff
	ff		 mov	 esi, DWORD PTR _line$6[ebp]
  001e9	8a 54 96 03	 mov	 dl, BYTE PTR [esi+edx*4+3]
  001ed	88 54 81 02	 mov	 BYTE PTR [ecx+eax*4+2], dl
  001f1	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  001f7	8b 8d 10 fe ff
	ff		 mov	 ecx, DWORD PTR _line$6[ebp]
  001fd	8b 95 14 fe ff
	ff		 mov	 edx, DWORD PTR _x$7[ebp]
  00203	8b b5 10 fe ff
	ff		 mov	 esi, DWORD PTR _line$6[ebp]
  00209	8a 54 96 02	 mov	 dl, BYTE PTR [esi+edx*4+2]
  0020d	88 54 81 01	 mov	 BYTE PTR [ecx+eax*4+1], dl

; 333  :             }

  00211	e9 72 ff ff ff	 jmp	 $LN5@jpeg_load
$LN6@jpeg_load:

; 334  :         }

  00216	e9 ff 02 00 00	 jmp	 $LN19@jpeg_load
$LN18@jpeg_load:

; 335  :         else if (cinfo.out_color_space == JCS_RGB) {

  0021b	83 bd 44 fe ff
	ff 02		 cmp	 DWORD PTR _cinfo$[ebp+44], 2
  00222	0f 85 a1 00 00
	00		 jne	 $LN20@jpeg_load

; 336  :             for (x = width - 1; x >= 0; x--) {

  00228	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR _width$[ebp]
  0022e	48		 dec	 eax
  0022f	89 85 14 fe ff
	ff		 mov	 DWORD PTR _x$7[ebp], eax
  00235	eb 0d		 jmp	 SHORT $LN10@jpeg_load
$LN8@jpeg_load:
  00237	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0023d	48		 dec	 eax
  0023e	89 85 14 fe ff
	ff		 mov	 DWORD PTR _x$7[ebp], eax
$LN10@jpeg_load:
  00244	83 bd 14 fe ff
	ff 00		 cmp	 DWORD PTR _x$7[ebp], 0
  0024b	7c 77		 jl	 SHORT $LN9@jpeg_load

; 337  :                 line[x].a = 255;

  0024d	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  00253	8b 8d 10 fe ff
	ff		 mov	 ecx, DWORD PTR _line$6[ebp]
  00259	c6 04 81 ff	 mov	 BYTE PTR [ecx+eax*4], 255 ; 000000ffH

; 338  :                 line[x].r = js[x * 3 + 0];

  0025d	6b 85 14 fe ff
	ff 03		 imul	 eax, DWORD PTR _x$7[ebp], 3
  00264	8b 8d 14 fe ff
	ff		 mov	 ecx, DWORD PTR _x$7[ebp]
  0026a	8b 95 10 fe ff
	ff		 mov	 edx, DWORD PTR _line$6[ebp]
  00270	8b b5 0c fe ff
	ff		 mov	 esi, DWORD PTR _js$5[ebp]
  00276	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  00279	88 44 8a 01	 mov	 BYTE PTR [edx+ecx*4+1], al

; 339  :                 line[x].g = js[x * 3 + 1];

  0027d	6b 85 14 fe ff
	ff 03		 imul	 eax, DWORD PTR _x$7[ebp], 3
  00284	8b 8d 14 fe ff
	ff		 mov	 ecx, DWORD PTR _x$7[ebp]
  0028a	8b 95 10 fe ff
	ff		 mov	 edx, DWORD PTR _line$6[ebp]
  00290	8b b5 0c fe ff
	ff		 mov	 esi, DWORD PTR _js$5[ebp]
  00296	8a 44 06 01	 mov	 al, BYTE PTR [esi+eax+1]
  0029a	88 44 8a 02	 mov	 BYTE PTR [edx+ecx*4+2], al

; 340  :                 line[x].b = js[x * 3 + 2];

  0029e	6b 85 14 fe ff
	ff 03		 imul	 eax, DWORD PTR _x$7[ebp], 3
  002a5	8b 8d 14 fe ff
	ff		 mov	 ecx, DWORD PTR _x$7[ebp]
  002ab	8b 95 10 fe ff
	ff		 mov	 edx, DWORD PTR _line$6[ebp]
  002b1	8b b5 0c fe ff
	ff		 mov	 esi, DWORD PTR _js$5[ebp]
  002b7	8a 44 06 02	 mov	 al, BYTE PTR [esi+eax+2]
  002bb	88 44 8a 03	 mov	 BYTE PTR [edx+ecx*4+3], al

; 341  :             }

  002bf	e9 73 ff ff ff	 jmp	 $LN8@jpeg_load
$LN9@jpeg_load:

; 342  :         }

  002c4	e9 51 02 00 00	 jmp	 $LN19@jpeg_load
$LN20@jpeg_load:

; 343  :         else if (cinfo.out_color_space == JCS_YCCK) {

  002c9	83 bd 44 fe ff
	ff 05		 cmp	 DWORD PTR _cinfo$[ebp+44], 5
  002d0	75 21		 jne	 SHORT $LN22@jpeg_load

; 344  :             fprintf(stderr, "Error: Can't convert YCCK to RGB.\n");

  002d2	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@HHOHJMLB@Error?3?5Can?8t?5convert?5YCCK?5to?5RG@
  002d7	6a 02		 push	 2
  002d9	e8 00 00 00 00	 call	 ___acrt_iob_func
  002de	59		 pop	 ecx
  002df	50		 push	 eax
  002e0	e8 00 00 00 00	 call	 _fprintf
  002e5	59		 pop	 ecx
  002e6	59		 pop	 ecx

; 345  :             return 0;

  002e7	33 c0		 xor	 eax, eax
  002e9	e9 66 02 00 00	 jmp	 $LN1@jpeg_load

; 346  :         }

  002ee	e9 27 02 00 00	 jmp	 $LN19@jpeg_load
$LN22@jpeg_load:

; 347  :         else if (cinfo.out_color_space == JCS_YCbCr) {

  002f3	83 bd 44 fe ff
	ff 03		 cmp	 DWORD PTR _cinfo$[ebp+44], 3
  002fa	0f 85 1a 01 00
	00		 jne	 $LN24@jpeg_load

; 348  :             for (x = 0; x < width; x++) {

  00300	83 a5 14 fe ff
	ff 00		 and	 DWORD PTR _x$7[ebp], 0
  00307	eb 0d		 jmp	 SHORT $LN13@jpeg_load
$LN11@jpeg_load:
  00309	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0030f	40		 inc	 eax
  00310	89 85 14 fe ff
	ff		 mov	 DWORD PTR _x$7[ebp], eax
$LN13@jpeg_load:
  00316	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0031c	3b 85 08 fe ff
	ff		 cmp	 eax, DWORD PTR _width$[ebp]
  00322	0f 8d ed 00 00
	00		 jge	 $LN12@jpeg_load

; 349  :                 int y = js[x * 3 + 0];

  00328	6b 85 14 fe ff
	ff 03		 imul	 eax, DWORD PTR _x$7[ebp], 3
  0032f	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR _js$5[ebp]
  00335	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00339	89 85 fc fd ff
	ff		 mov	 DWORD PTR _y$3[ebp], eax

; 350  :                 int u = js[x * 3 + 1];

  0033f	6b 85 14 fe ff
	ff 03		 imul	 eax, DWORD PTR _x$7[ebp], 3
  00346	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR _js$5[ebp]
  0034c	0f b6 44 01 01	 movzx	 eax, BYTE PTR [ecx+eax+1]
  00351	89 85 ec fd ff
	ff		 mov	 DWORD PTR _u$1[ebp], eax

; 351  :                 int v = js[x * 3 + 1];

  00357	6b 85 14 fe ff
	ff 03		 imul	 eax, DWORD PTR _x$7[ebp], 3
  0035e	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR _js$5[ebp]
  00364	0f b6 44 01 01	 movzx	 eax, BYTE PTR [ecx+eax+1]
  00369	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _v$2[ebp], eax

; 352  :                 line[x].a = 255;

  0036f	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  00375	8b 8d 10 fe ff
	ff		 mov	 ecx, DWORD PTR _line$6[ebp]
  0037b	c6 04 81 ff	 mov	 BYTE PTR [ecx+eax*4], 255 ; 000000ffH

; 353  :                 line[x].r = y + ((360 * (v - 128)) >> 8);

  0037f	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _v$2[ebp]
  00385	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  0038a	69 c0 68 01 00
	00		 imul	 eax, eax, 360
  00390	c1 f8 08	 sar	 eax, 8
  00393	03 85 fc fd ff
	ff		 add	 eax, DWORD PTR _y$3[ebp]
  00399	8b 8d 14 fe ff
	ff		 mov	 ecx, DWORD PTR _x$7[ebp]
  0039f	8b 95 10 fe ff
	ff		 mov	 edx, DWORD PTR _line$6[ebp]
  003a5	88 44 8a 01	 mov	 BYTE PTR [edx+ecx*4+1], al

; 354  :                 line[x].g = y - ((88 * (u - 128) + 183 * (v - 128)) >> 8);

  003a9	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _u$1[ebp]
  003af	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  003b4	6b c0 58	 imul	 eax, eax, 88
  003b7	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _v$2[ebp]
  003bd	81 e9 80 00 00
	00		 sub	 ecx, 128		; 00000080H
  003c3	69 c9 b7 00 00
	00		 imul	 ecx, ecx, 183
  003c9	03 c1		 add	 eax, ecx
  003cb	c1 f8 08	 sar	 eax, 8
  003ce	8b 8d fc fd ff
	ff		 mov	 ecx, DWORD PTR _y$3[ebp]
  003d4	2b c8		 sub	 ecx, eax
  003d6	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  003dc	8b 95 10 fe ff
	ff		 mov	 edx, DWORD PTR _line$6[ebp]
  003e2	88 4c 82 02	 mov	 BYTE PTR [edx+eax*4+2], cl

; 355  :                 line[x].b = y + ((455 * (u - 128)) >> 8);

  003e6	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _u$1[ebp]
  003ec	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  003f1	69 c0 c7 01 00
	00		 imul	 eax, eax, 455
  003f7	c1 f8 08	 sar	 eax, 8
  003fa	03 85 fc fd ff
	ff		 add	 eax, DWORD PTR _y$3[ebp]
  00400	8b 8d 14 fe ff
	ff		 mov	 ecx, DWORD PTR _x$7[ebp]
  00406	8b 95 10 fe ff
	ff		 mov	 edx, DWORD PTR _line$6[ebp]
  0040c	88 44 8a 03	 mov	 BYTE PTR [edx+ecx*4+3], al

; 356  :             }

  00410	e9 f4 fe ff ff	 jmp	 $LN11@jpeg_load
$LN12@jpeg_load:

; 357  :         }

  00415	e9 00 01 00 00	 jmp	 $LN19@jpeg_load
$LN24@jpeg_load:

; 358  :         else if (cinfo.out_color_space == JCS_CMYK) {

  0041a	83 bd 44 fe ff
	ff 04		 cmp	 DWORD PTR _cinfo$[ebp+44], 4
  00421	0f 85 f3 00 00
	00		 jne	 $LN19@jpeg_load

; 359  :             for (x = 0; x < width; x++) {

  00427	83 a5 14 fe ff
	ff 00		 and	 DWORD PTR _x$7[ebp], 0
  0042e	eb 0d		 jmp	 SHORT $LN16@jpeg_load
$LN14@jpeg_load:
  00430	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  00436	40		 inc	 eax
  00437	89 85 14 fe ff
	ff		 mov	 DWORD PTR _x$7[ebp], eax
$LN16@jpeg_load:
  0043d	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  00443	3b 85 08 fe ff
	ff		 cmp	 eax, DWORD PTR _width$[ebp]
  00449	0f 8d cb 00 00
	00		 jge	 $LN19@jpeg_load

; 360  :                 int white = 255 - js[x * 4 + 3];

  0044f	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  00455	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR _js$5[ebp]
  0045b	0f b6 44 81 03	 movzx	 eax, BYTE PTR [ecx+eax*4+3]
  00460	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00465	2b c8		 sub	 ecx, eax
  00467	89 8d 04 fe ff
	ff		 mov	 DWORD PTR _white$4[ebp], ecx

; 361  :                 line[x].a = 255;

  0046d	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  00473	8b 8d 10 fe ff
	ff		 mov	 ecx, DWORD PTR _line$6[ebp]
  00479	c6 04 81 ff	 mov	 BYTE PTR [ecx+eax*4], 255 ; 000000ffH

; 362  :                 line[x].r = white - ((js[x * 4] * white) >> 8);

  0047d	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  00483	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR _js$5[ebp]
  00489	0f b6 04 81	 movzx	 eax, BYTE PTR [ecx+eax*4]
  0048d	0f af 85 04 fe
	ff ff		 imul	 eax, DWORD PTR _white$4[ebp]
  00494	c1 f8 08	 sar	 eax, 8
  00497	8b 8d 04 fe ff
	ff		 mov	 ecx, DWORD PTR _white$4[ebp]
  0049d	2b c8		 sub	 ecx, eax
  0049f	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  004a5	8b 95 10 fe ff
	ff		 mov	 edx, DWORD PTR _line$6[ebp]
  004ab	88 4c 82 01	 mov	 BYTE PTR [edx+eax*4+1], cl

; 363  :                 line[x].g = white - ((js[x * 4 + 1] * white) >> 8);

  004af	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  004b5	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR _js$5[ebp]
  004bb	0f b6 44 81 01	 movzx	 eax, BYTE PTR [ecx+eax*4+1]
  004c0	0f af 85 04 fe
	ff ff		 imul	 eax, DWORD PTR _white$4[ebp]
  004c7	c1 f8 08	 sar	 eax, 8
  004ca	8b 8d 04 fe ff
	ff		 mov	 ecx, DWORD PTR _white$4[ebp]
  004d0	2b c8		 sub	 ecx, eax
  004d2	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  004d8	8b 95 10 fe ff
	ff		 mov	 edx, DWORD PTR _line$6[ebp]
  004de	88 4c 82 02	 mov	 BYTE PTR [edx+eax*4+2], cl

; 364  :                 line[x].b = white - ((js[x * 4 + 2] * white) >> 8);

  004e2	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  004e8	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR _js$5[ebp]
  004ee	0f b6 44 81 02	 movzx	 eax, BYTE PTR [ecx+eax*4+2]
  004f3	0f af 85 04 fe
	ff ff		 imul	 eax, DWORD PTR _white$4[ebp]
  004fa	c1 f8 08	 sar	 eax, 8
  004fd	8b 8d 04 fe ff
	ff		 mov	 ecx, DWORD PTR _white$4[ebp]
  00503	2b c8		 sub	 ecx, eax
  00505	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _x$7[ebp]
  0050b	8b 95 10 fe ff
	ff		 mov	 edx, DWORD PTR _line$6[ebp]
  00511	88 4c 82 03	 mov	 BYTE PTR [edx+eax*4+3], cl

; 365  :             }

  00515	e9 16 ff ff ff	 jmp	 $LN14@jpeg_load
$LN19@jpeg_load:

; 366  :         }
; 367  :     }

  0051a	e9 f5 fb ff ff	 jmp	 $LN2@jpeg_load
$LN3@jpeg_load:

; 368  : 
; 369  :     free(scanline);

  0051f	ff b5 e8 fd ff
	ff		 push	 DWORD PTR _scanline$[ebp]
  00525	e8 00 00 00 00	 call	 _free
  0052a	59		 pop	 ecx

; 370  : 
; 371  :     jpeg_finish_decompress(&cinfo);

  0052b	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00531	50		 push	 eax
  00532	e8 00 00 00 00	 call	 _jpeg_finish_decompress
  00537	59		 pop	 ecx

; 372  :     jpeg_destroy_decompress(&cinfo);

  00538	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0053e	50		 push	 eax
  0053f	e8 00 00 00 00	 call	 _jpeg_destroy_decompress
  00544	59		 pop	 ecx

; 373  :     fclose(fi);

  00545	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _fi$[ebp]
  0054b	e8 00 00 00 00	 call	 _fclose
  00550	59		 pop	 ecx

; 374  :     return 1;

  00551	33 c0		 xor	 eax, eax
  00553	40		 inc	 eax
$LN1@jpeg_load:

; 375  : }

  00554	5e		 pop	 esi
  00555	8b 4d 64	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00558	33 cd		 xor	 ecx, ebp
  0055a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0055f	83 c5 68	 add	 ebp, 104		; 00000068H
  00562	c9		 leave
  00563	c3		 ret	 0
?jpeg_load@@YAHPBDPAPAEPAH2@Z ENDP			; jpeg_load
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?jpeg_save_to_mem@@YAHPAEHHH0H@Z
_TEXT	SEGMENT
_mgr$ = -492						; size = 20
_data2$1 = -472						; size = 4
_t$ = -468						; size = 4
_cinfo$ = -464						; size = 424
_jerr$ = -40						; size = 132
__$ArrayPad$ = 92					; size = 4
_data$ = 104						; size = 4
_width$ = 108						; size = 4
_height$ = 112						; size = 4
_quality$ = 116						; size = 4
__dest$ = 120						; size = 4
__destlen$ = 124					; size = 4
?jpeg_save_to_mem@@YAHPAEHHH0H@Z PROC			; jpeg_save_to_mem, COMDAT

; 174  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 a0	 lea	 ebp, DWORD PTR [esp-96]
  00005	81 ec 4c 02 00
	00		 sub	 esp, 588		; 0000024cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 5c	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 175  :     struct jpeg_destination_mgr mgr;
; 176  :     struct jpeg_compress_struct cinfo;
; 177  :     struct jpeg_error_mgr jerr;
; 178  :     int t;
; 179  : 
; 180  :     memset(&cinfo, 0, sizeof(cinfo));

  00015	68 a8 01 00 00	 push	 424			; 000001a8H
  0001a	6a 00		 push	 0
  0001c	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _memset
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 181  :     memset(&jerr, 0, sizeof(jerr));

  0002b	68 84 00 00 00	 push	 132			; 00000084H
  00030	6a 00		 push	 0
  00032	8d 45 d8	 lea	 eax, DWORD PTR _jerr$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _memset
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 182  :     memset(&mgr, 0, sizeof(mgr));

  0003e	6a 14		 push	 20			; 00000014H
  00040	6a 00		 push	 0
  00042	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _memset
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 183  :     cinfo.err = jpeg_std_error(&jerr);

  00051	8d 45 d8	 lea	 eax, DWORD PTR _jerr$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _jpeg_std_error
  0005a	59		 pop	 ecx
  0005b	89 85 30 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax

; 184  :     jpeg_create_compress(&cinfo);

  00061	68 a8 01 00 00	 push	 424			; 000001a8H
  00066	6a 5a		 push	 90			; 0000005aH
  00068	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _jpeg_CreateCompress
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 185  : 
; 186  :     dest = _dest;

  00077	8b 45 78	 mov	 eax, DWORD PTR __dest$[ebp]
  0007a	a3 00 00 00 00	 mov	 DWORD PTR ?dest@@3PAEA, eax

; 187  :     len = 0;

  0007f	83 25 00 00 00
	00 00		 and	 DWORD PTR ?len@@3HA, 0

; 188  :     destlen = _destlen;

  00086	8b 45 7c	 mov	 eax, DWORD PTR __destlen$[ebp]
  00089	a3 00 00 00 00	 mov	 DWORD PTR ?destlen@@3HA, eax

; 189  : 
; 190  :     mgr.init_destination = mem_init_destination;

  0008e	c7 85 1c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+8], OFFSET ?mem_init_destination@@YAXPAUjpeg_compress_struct@@@Z ; mem_init_destination

; 191  :     mgr.empty_output_buffer = mem_empty_output_buffer;

  00098	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+12], OFFSET ?mem_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ; mem_empty_output_buffer

; 192  :     mgr.term_destination = mem_term_destination;

  000a2	c7 85 24 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], OFFSET ?mem_term_destination@@YAXPAUjpeg_compress_struct@@@Z ; mem_term_destination

; 193  :     cinfo.dest = &mgr;

  000ac	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  000b2	89 85 48 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 194  : 
; 195  :     // init compression
; 196  : 
; 197  :     cinfo.image_width = width;

  000b8	8b 45 6c	 mov	 eax, DWORD PTR _width$[ebp]
  000bb	89 85 4c fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+28], eax

; 198  :     cinfo.image_height = height;

  000c1	8b 45 70	 mov	 eax, DWORD PTR _height$[ebp]
  000c4	89 85 50 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+32], eax

; 199  :     cinfo.input_components = 3;

  000ca	c7 85 54 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+36], 3

; 200  :     cinfo.in_color_space = JCS_RGB;

  000d4	c7 85 58 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+40], 2

; 201  :     jpeg_set_defaults(&cinfo);

  000de	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 _jpeg_set_defaults
  000ea	59		 pop	 ecx

; 202  :     cinfo.dct_method = JDCT_IFAST;

  000eb	c7 85 0c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+220], 1

; 203  :     jpeg_set_quality(&cinfo, quality, TRUE);

  000f5	6a 01		 push	 1
  000f7	ff 75 74	 push	 DWORD PTR _quality$[ebp]
  000fa	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 _jpeg_set_quality
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  : 
; 205  :     jpeg_start_compress(&cinfo, FALSE);

  00109	6a 00		 push	 0
  0010b	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _jpeg_start_compress
  00117	59		 pop	 ecx
  00118	59		 pop	 ecx

; 206  :     for (t = 0; t < height; t++) {

  00119	83 a5 2c fe ff
	ff 00		 and	 DWORD PTR _t$[ebp], 0
  00120	eb 0d		 jmp	 SHORT $LN4@jpeg_save_
$LN2@jpeg_save_:
  00122	8b 85 2c fe ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  00128	40		 inc	 eax
  00129	89 85 2c fe ff
	ff		 mov	 DWORD PTR _t$[ebp], eax
$LN4@jpeg_save_:
  0012f	8b 85 2c fe ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  00135	3b 45 70	 cmp	 eax, DWORD PTR _height$[ebp]
  00138	7d 2e		 jge	 SHORT $LN3@jpeg_save_

; 207  :         unsigned char* data2 = &data[width * 3 * t];

  0013a	6b 45 6c 03	 imul	 eax, DWORD PTR _width$[ebp], 3
  0013e	0f af 85 2c fe
	ff ff		 imul	 eax, DWORD PTR _t$[ebp]
  00145	03 45 68	 add	 eax, DWORD PTR _data$[ebp]
  00148	89 85 28 fe ff
	ff		 mov	 DWORD PTR _data2$1[ebp], eax

; 208  :         jpeg_write_scanlines(&cinfo, &data2, 1);

  0014e	6a 01		 push	 1
  00150	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR _data2$1[ebp]
  00156	50		 push	 eax
  00157	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 _jpeg_write_scanlines
  00163	83 c4 0c	 add	 esp, 12			; 0000000cH

; 209  :     }

  00166	eb ba		 jmp	 SHORT $LN2@jpeg_save_
$LN3@jpeg_save_:

; 210  :     jpeg_finish_compress(&cinfo);

  00168	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 _jpeg_finish_compress
  00174	59		 pop	 ecx

; 211  :     jpeg_destroy_compress(&cinfo);

  00175	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 _jpeg_destroy_compress
  00181	59		 pop	 ecx

; 212  :     return len;

  00182	a1 00 00 00 00	 mov	 eax, DWORD PTR ?len@@3HA

; 213  : }

  00187	8b 4d 5c	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018a	33 cd		 xor	 ecx, ebp
  0018c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00191	83 c5 60	 add	 ebp, 96			; 00000060H
  00194	c9		 leave
  00195	c3		 ret	 0
?jpeg_save_to_mem@@YAHPAEHHH0H@Z ENDP			; jpeg_save_to_mem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?jpeg_save_to_file@@YAHPAEHHHPAU_iobuf@@@Z
_TEXT	SEGMENT
_mgr$ = -488						; size = 20
_data2$1 = -468						; size = 4
_t$ = -464						; size = 4
_cinfo$ = -460						; size = 424
_jerr$ = -36						; size = 132
__$ArrayPad$ = 96					; size = 4
_data$ = 108						; size = 4
_width$ = 112						; size = 4
_height$ = 116						; size = 4
_quality$ = 120						; size = 4
__fi$ = 124						; size = 4
?jpeg_save_to_file@@YAHPAEHHHPAU_iobuf@@@Z PROC		; jpeg_save_to_file, COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 9c	 lea	 ebp, DWORD PTR [esp-100]
  00005	81 ec 4c 02 00
	00		 sub	 esp, 588		; 0000024cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 60	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 132  :     struct jpeg_destination_mgr mgr;
; 133  :     struct jpeg_compress_struct cinfo;
; 134  :     struct jpeg_error_mgr jerr;
; 135  :     int t;
; 136  : 
; 137  :     fi = _fi;

  00015	8b 45 7c	 mov	 eax, DWORD PTR __fi$[ebp]
  00018	a3 00 00 00 00	 mov	 DWORD PTR ?fi@@3PAU_iobuf@@A, eax

; 138  : 
; 139  :     memset(&cinfo, 0, sizeof(cinfo));

  0001d	68 a8 01 00 00	 push	 424			; 000001a8H
  00022	6a 00		 push	 0
  00024	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _memset
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 140  :     memset(&jerr, 0, sizeof(jerr));

  00033	68 84 00 00 00	 push	 132			; 00000084H
  00038	6a 00		 push	 0
  0003a	8d 45 dc	 lea	 eax, DWORD PTR _jerr$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _memset
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 141  :     memset(&mgr, 0, sizeof(mgr));

  00046	6a 14		 push	 20			; 00000014H
  00048	6a 00		 push	 0
  0004a	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _memset
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 142  :     cinfo.err = jpeg_std_error(&jerr);

  00059	8d 45 dc	 lea	 eax, DWORD PTR _jerr$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _jpeg_std_error
  00062	59		 pop	 ecx
  00063	89 85 34 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax

; 143  :     jpeg_create_compress(&cinfo);

  00069	68 a8 01 00 00	 push	 424			; 000001a8H
  0006e	6a 5a		 push	 90			; 0000005aH
  00070	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _jpeg_CreateCompress
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 144  : 
; 145  :     mgr.init_destination = file_init_destination;

  0007f	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+8], OFFSET ?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z ; file_init_destination

; 146  :     mgr.empty_output_buffer = file_empty_output_buffer;

  00089	c7 85 24 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+12], OFFSET ?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ; file_empty_output_buffer

; 147  :     mgr.term_destination = file_term_destination;

  00093	c7 85 28 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], OFFSET ?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z ; file_term_destination

; 148  :     cinfo.dest = &mgr;

  0009d	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  000a3	89 85 4c fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 149  : 
; 150  :     // init compression
; 151  : 
; 152  :     cinfo.image_width = width;

  000a9	8b 45 70	 mov	 eax, DWORD PTR _width$[ebp]
  000ac	89 85 50 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+28], eax

; 153  :     cinfo.image_height = height;

  000b2	8b 45 74	 mov	 eax, DWORD PTR _height$[ebp]
  000b5	89 85 54 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+32], eax

; 154  :     cinfo.input_components = 3;

  000bb	c7 85 58 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+36], 3

; 155  :     cinfo.in_color_space = JCS_RGB;

  000c5	c7 85 5c fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+40], 2

; 156  :     jpeg_set_defaults(&cinfo);

  000cf	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _jpeg_set_defaults
  000db	59		 pop	 ecx

; 157  :     cinfo.dct_method = JDCT_IFAST;

  000dc	c7 85 10 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+220], 1

; 158  :     jpeg_set_quality(&cinfo, quality, TRUE);

  000e6	6a 01		 push	 1
  000e8	ff 75 78	 push	 DWORD PTR _quality$[ebp]
  000eb	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _jpeg_set_quality
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 159  : 
; 160  :     //jpeg_write_tables(&cinfo);
; 161  :     //jpeg_suppress_tables(&cinfo, TRUE);
; 162  :     jpeg_start_compress(&cinfo, FALSE);

  000fa	6a 00		 push	 0
  000fc	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 _jpeg_start_compress
  00108	59		 pop	 ecx
  00109	59		 pop	 ecx

; 163  : 
; 164  :     for (t = 0; t < height; t++) {

  0010a	83 a5 30 fe ff
	ff 00		 and	 DWORD PTR _t$[ebp], 0
  00111	eb 0d		 jmp	 SHORT $LN4@jpeg_save_
$LN2@jpeg_save_:
  00113	8b 85 30 fe ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  00119	40		 inc	 eax
  0011a	89 85 30 fe ff
	ff		 mov	 DWORD PTR _t$[ebp], eax
$LN4@jpeg_save_:
  00120	8b 85 30 fe ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  00126	3b 45 74	 cmp	 eax, DWORD PTR _height$[ebp]
  00129	7d 2e		 jge	 SHORT $LN3@jpeg_save_

; 165  :         unsigned char* data2 = &data[width * 3 * t];

  0012b	6b 45 70 03	 imul	 eax, DWORD PTR _width$[ebp], 3
  0012f	0f af 85 30 fe
	ff ff		 imul	 eax, DWORD PTR _t$[ebp]
  00136	03 45 6c	 add	 eax, DWORD PTR _data$[ebp]
  00139	89 85 2c fe ff
	ff		 mov	 DWORD PTR _data2$1[ebp], eax

; 166  :         jpeg_write_scanlines(&cinfo, &data2, 1);

  0013f	6a 01		 push	 1
  00141	8d 85 2c fe ff
	ff		 lea	 eax, DWORD PTR _data2$1[ebp]
  00147	50		 push	 eax
  00148	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 _jpeg_write_scanlines
  00154	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  :     }

  00157	eb ba		 jmp	 SHORT $LN2@jpeg_save_
$LN3@jpeg_save_:

; 168  :     jpeg_finish_compress(&cinfo);

  00159	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _jpeg_finish_compress
  00165	59		 pop	 ecx

; 169  :     jpeg_destroy_compress(&cinfo);

  00166	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 _jpeg_destroy_compress
  00172	59		 pop	 ecx

; 170  :     return 1;

  00173	33 c0		 xor	 eax, eax
  00175	40		 inc	 eax

; 171  : }

  00176	8b 4d 60	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00179	33 cd		 xor	 ecx, ebp
  0017b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00180	83 c5 64	 add	 ebp, 100		; 00000064H
  00183	c9		 leave
  00184	c3		 ret	 0
?jpeg_save_to_file@@YAHPAEHHHPAU_iobuf@@@Z ENDP		; jpeg_save_to_file
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\JpegFile.cpp
;	COMDAT ?jpeg_save@@YAHPAEHHHPBD@Z
_TEXT	SEGMENT
_mgr$ = -488						; size = 20
_data2$1 = -468						; size = 4
_t$ = -464						; size = 4
_cinfo$ = -460						; size = 424
_jerr$ = -36						; size = 132
__$ArrayPad$ = 96					; size = 4
_data$ = 108						; size = 4
_width$ = 112						; size = 4
_height$ = 116						; size = 4
_quality$ = 120						; size = 4
_filename$ = 124					; size = 4
?jpeg_save@@YAHPAEHHHPBD@Z PROC				; jpeg_save, COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 9c	 lea	 ebp, DWORD PTR [esp-100]
  00005	81 ec 4c 02 00
	00		 sub	 esp, 588		; 0000024cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 60	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 81   :     struct jpeg_destination_mgr mgr;
; 82   :     struct jpeg_compress_struct cinfo;
; 83   :     struct jpeg_error_mgr jerr;
; 84   :     int t;
; 85   : 
; 86   :     if (filename) {

  00015	83 7d 7c 00	 cmp	 DWORD PTR _filename$[ebp], 0
  00019	74 26		 je	 SHORT $LN5@jpeg_save

; 87   :         fi = fopen(filename, "wb");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  00020	ff 75 7c	 push	 DWORD PTR _filename$[ebp]
  00023	e8 00 00 00 00	 call	 _fopen
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?fi@@3PAU_iobuf@@A, eax

; 88   :         if (fi == NULL)

  0002f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?fi@@3PAU_iobuf@@A, 0
  00036	75 07		 jne	 SHORT $LN7@jpeg_save

; 89   :             return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 6d 01 00 00	 jmp	 $LN1@jpeg_save
$LN7@jpeg_save:

; 90   :     }

  0003f	eb 07		 jmp	 SHORT $LN6@jpeg_save
$LN5@jpeg_save:

; 91   :     else
; 92   :         fi = NULL;

  00041	83 25 00 00 00
	00 00		 and	 DWORD PTR ?fi@@3PAU_iobuf@@A, 0
$LN6@jpeg_save:

; 93   : 
; 94   :     memset(&cinfo, 0, sizeof(cinfo));

  00048	68 a8 01 00 00	 push	 424			; 000001a8H
  0004d	6a 00		 push	 0
  0004f	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _memset
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 95   :     memset(&jerr, 0, sizeof(jerr));

  0005e	68 84 00 00 00	 push	 132			; 00000084H
  00063	6a 00		 push	 0
  00065	8d 45 dc	 lea	 eax, DWORD PTR _jerr$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _memset
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 96   :     memset(&mgr, 0, sizeof(mgr));

  00071	6a 14		 push	 20			; 00000014H
  00073	6a 00		 push	 0
  00075	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _memset
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 97   :     cinfo.err = jpeg_std_error(&jerr);

  00084	8d 45 dc	 lea	 eax, DWORD PTR _jerr$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _jpeg_std_error
  0008d	59		 pop	 ecx
  0008e	89 85 34 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp], eax

; 98   :     jpeg_create_compress(&cinfo);

  00094	68 a8 01 00 00	 push	 424			; 000001a8H
  00099	6a 5a		 push	 90			; 0000005aH
  0009b	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _jpeg_CreateCompress
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 99   : 
; 100  :     mgr.init_destination = file_init_destination;

  000aa	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+8], OFFSET ?file_init_destination@@YAXPAUjpeg_compress_struct@@@Z ; file_init_destination

; 101  :     mgr.empty_output_buffer = file_empty_output_buffer;

  000b4	c7 85 24 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+12], OFFSET ?file_empty_output_buffer@@YAEPAUjpeg_compress_struct@@@Z ; file_empty_output_buffer

; 102  :     mgr.term_destination = file_term_destination;

  000be	c7 85 28 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _mgr$[ebp+16], OFFSET ?file_term_destination@@YAXPAUjpeg_compress_struct@@@Z ; file_term_destination

; 103  :     cinfo.dest = &mgr;

  000c8	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _mgr$[ebp]
  000ce	89 85 4c fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+24], eax

; 104  : 
; 105  :     // init compression
; 106  : 
; 107  :     cinfo.image_width = width;

  000d4	8b 45 70	 mov	 eax, DWORD PTR _width$[ebp]
  000d7	89 85 50 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+28], eax

; 108  :     cinfo.image_height = height;

  000dd	8b 45 74	 mov	 eax, DWORD PTR _height$[ebp]
  000e0	89 85 54 fe ff
	ff		 mov	 DWORD PTR _cinfo$[ebp+32], eax

; 109  :     cinfo.input_components = 3;

  000e6	c7 85 58 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+36], 3

; 110  :     cinfo.in_color_space = JCS_RGB;

  000f0	c7 85 5c fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _cinfo$[ebp+40], 2

; 111  :     jpeg_set_defaults(&cinfo);

  000fa	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 _jpeg_set_defaults
  00106	59		 pop	 ecx

; 112  :     jpeg_set_quality(&cinfo, quality, TRUE);

  00107	6a 01		 push	 1
  00109	ff 75 78	 push	 DWORD PTR _quality$[ebp]
  0010c	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 _jpeg_set_quality
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH

; 113  : 
; 114  :     //jpeg_write_tables(&cinfo);
; 115  :     //jpeg_suppress_tables(&cinfo, TRUE);
; 116  :     jpeg_start_compress(&cinfo, FALSE);

  0011b	6a 00		 push	 0
  0011d	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _jpeg_start_compress
  00129	59		 pop	 ecx
  0012a	59		 pop	 ecx

; 117  : 
; 118  :     for (t = 0; t < height; t++) {

  0012b	83 a5 30 fe ff
	ff 00		 and	 DWORD PTR _t$[ebp], 0
  00132	eb 0d		 jmp	 SHORT $LN4@jpeg_save
$LN2@jpeg_save:
  00134	8b 85 30 fe ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  0013a	40		 inc	 eax
  0013b	89 85 30 fe ff
	ff		 mov	 DWORD PTR _t$[ebp], eax
$LN4@jpeg_save:
  00141	8b 85 30 fe ff
	ff		 mov	 eax, DWORD PTR _t$[ebp]
  00147	3b 45 74	 cmp	 eax, DWORD PTR _height$[ebp]
  0014a	7d 2e		 jge	 SHORT $LN3@jpeg_save

; 119  :         unsigned char* data2 = &data[width * 3 * t];

  0014c	6b 45 70 03	 imul	 eax, DWORD PTR _width$[ebp], 3
  00150	0f af 85 30 fe
	ff ff		 imul	 eax, DWORD PTR _t$[ebp]
  00157	03 45 6c	 add	 eax, DWORD PTR _data$[ebp]
  0015a	89 85 2c fe ff
	ff		 mov	 DWORD PTR _data2$1[ebp], eax

; 120  :         jpeg_write_scanlines(&cinfo, &data2, 1);

  00160	6a 01		 push	 1
  00162	8d 85 2c fe ff
	ff		 lea	 eax, DWORD PTR _data2$1[ebp]
  00168	50		 push	 eax
  00169	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 _jpeg_write_scanlines
  00175	83 c4 0c	 add	 esp, 12			; 0000000cH

; 121  :     }

  00178	eb ba		 jmp	 SHORT $LN2@jpeg_save
$LN3@jpeg_save:

; 122  :     jpeg_finish_compress(&cinfo);

  0017a	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  00180	50		 push	 eax
  00181	e8 00 00 00 00	 call	 _jpeg_finish_compress
  00186	59		 pop	 ecx

; 123  : 
; 124  :     if (fi)

  00187	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?fi@@3PAU_iobuf@@A, 0
  0018e	74 0c		 je	 SHORT $LN8@jpeg_save

; 125  :         fclose(fi);

  00190	ff 35 00 00 00
	00		 push	 DWORD PTR ?fi@@3PAU_iobuf@@A
  00196	e8 00 00 00 00	 call	 _fclose
  0019b	59		 pop	 ecx
$LN8@jpeg_save:

; 126  :     jpeg_destroy_compress(&cinfo);

  0019c	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR _cinfo$[ebp]
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 _jpeg_destroy_compress
  001a8	59		 pop	 ecx

; 127  :     return 1;

  001a9	33 c0		 xor	 eax, eax
  001ab	40		 inc	 eax
$LN1@jpeg_save:

; 128  : }

  001ac	8b 4d 60	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001af	33 cd		 xor	 ecx, ebp
  001b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b6	83 c5 64	 add	 ebp, 100		; 00000064H
  001b9	c9		 leave
  001ba	c3		 ret	 0
?jpeg_save@@YAHPAEHHHPBD@Z ENDP				; jpeg_save
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Stream$ = -12						; size = 4
__Format$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Format$[ebp], eax
  00012	6a 01		 push	 1
  00014	e8 00 00 00 00	 call	 ___acrt_iob_func
  00019	59		 pop	 ecx
  0001a	89 45 f4	 mov	 DWORD PTR __Stream$[ebp], eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0001d	ff 75 fc	 push	 DWORD PTR __ArgList$[ebp]
  00020	6a 00		 push	 0
  00022	ff 75 f8	 push	 DWORD PTR __Format$[ebp]
  00025	ff 75 f4	 push	 DWORD PTR __Stream$[ebp]
  00028	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0002d	ff 70 04	 push	 DWORD PTR [eax+4]
  00030	ff 30		 push	 DWORD PTR [eax]
  00032	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00037	83 c4 18	 add	 esp, 24			; 00000018H

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0003a	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

  0003d	83 65 fc 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 961  :     }

  00044	c9		 leave
  00045	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Result$ = -12						; size = 4
__Format$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Format$[ebp], eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00012	ff 75 fc	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f8	 push	 DWORD PTR __Format$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	ff 70 04	 push	 DWORD PTR [eax+4]
  00025	ff 30		 push	 DWORD PTR [eax]
  00027	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0002c	83 c4 18	 add	 esp, 24			; 00000018H

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0002f	89 45 f4	 mov	 DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

  00032	83 65 fc 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp]

; 842  :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
