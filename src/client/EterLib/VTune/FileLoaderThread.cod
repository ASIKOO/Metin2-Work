; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??_GSData@CFileLoaderThread@@QAEPAXI@Z		; CFileLoaderThread::SData::`scalar deleting destructor'
PUBLIC	??0CFileLoaderThread@@QAE@XZ			; CFileLoaderThread::CFileLoaderThread
PUBLIC	??1CFileLoaderThread@@QAE@XZ			; CFileLoaderThread::~CFileLoaderThread
PUBLIC	?Create@CFileLoaderThread@@QAEHPAX@Z		; CFileLoaderThread::Create
PUBLIC	?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CFileLoaderThread::Request
PUBLIC	?Fetch@CFileLoaderThread@@QAE_NPAPAUSData@1@@Z	; CFileLoaderThread::Fetch
PUBLIC	?Shutdown@CFileLoaderThread@@QAEXXZ		; CFileLoaderThread::Shutdown
PUBLIC	?EntryPoint@CFileLoaderThread@@KGIPAX@Z		; CFileLoaderThread::EntryPoint
PUBLIC	?Run@CFileLoaderThread@@IAEIPAX@Z		; CFileLoaderThread::Run
PUBLIC	?Setup@CFileLoaderThread@@IAEIXZ		; CFileLoaderThread::Setup
PUBLIC	?Execute@CFileLoaderThread@@IAEIPAX@Z		; CFileLoaderThread::Execute
PUBLIC	?Destroy@CFileLoaderThread@@IAEXXZ		; CFileLoaderThread::Destroy
PUBLIC	?Process@CFileLoaderThread@@IAEXXZ		; CFileLoaderThread::Process
PUBLIC	??0?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >
PUBLIC	??1?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::~deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >
PUBLIC	?begin@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@2@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::begin
PUBLIC	?end@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@2@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::end
PUBLIC	?front@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEAAPAUSData@CFileLoaderThread@@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::front
PUBLIC	?pop_front@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEXXZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::pop_front
PUBLIC	?pop_back@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEXXZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::pop_back
PUBLIC	?_Xlen@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@ABEXXZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Xlen
PUBLIC	?_Growmap@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXI@Z ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Growmap
PUBLIC	?_Tidy@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXXZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Tidy
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> >::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> >
PUBLIC	??$stl_wipe@V?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@@@YAXAAV?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@@Z ; stl_wipe<std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> > >
PUBLIC	??$_Emplace_back_internal@ABQAUSData@CFileLoaderThread@@@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXABQAUSData@CFileLoaderThread@@@Z ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Emplace_back_internal<CFileLoaderThread::SData * const &>
PUBLIC	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@std@@QBEABQAUSData@CFileLoaderThread@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> > >::operator*
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Destroy_in_place@PAPAUSData@CFileLoaderThread@@@std@@YAXAAPAPAUSData@CFileLoaderThread@@@Z ; std::_Destroy_in_place<CFileLoaderThread::SData * *>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@std@@QBEABQAUSData@CFileLoaderThread@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> > >::operator*
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$uninitialized_copy@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0PAPAPAU12@@Z ; std::uninitialized_copy<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>
PUBLIC	??$_Uninitialized_value_construct_n_unchecked1@PAPAPAUSData@CFileLoaderThread@@I@std@@YAPAPAPAUSData@CFileLoaderThread@@PAPAPAU12@I@Z ; std::_Uninitialized_value_construct_n_unchecked1<CFileLoaderThread::SData * * *,unsigned int>
PUBLIC	??$_Destroy_range@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAXPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@@Z ; std::_Destroy_range<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>
PUBLIC	??$_Copy_memmove@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@PAPAPAU12@00@Z ; std::_Copy_memmove<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>
PUBLIC	??$_Zero_range@PAPAPAUSData@CFileLoaderThread@@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0@Z ; std::_Zero_range<CFileLoaderThread::SData * * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
PUBLIC	??_C@_0EP@NDKNAKHH@CFileLoaderThread?3?3Execute?3?5Tim@ ; `string'
PUBLIC	??_C@_0DD@FFGDMIEH@CFileLoaderThread?3?3Request?3?5Rel@ ; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@	; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__ReleaseSemaphore@12:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__SetThreadPriority@8:PROC
EXTRN	__imp__CreateSemaphoreA@16:PROC
EXTRN	__beginthreadex:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z:PROC ; CEterPackManager::Get
EXTRN	??0Mutex@@QAE@XZ:PROC				; Mutex::Mutex
EXTRN	??1Mutex@@QAE@XZ:PROC				; Mutex::~Mutex
EXTRN	?Lock@Mutex@@QAEXXZ:PROC			; Mutex::Lock
EXTRN	?Unlock@Mutex@@QAEXXZ:PROC			; Mutex::Unlock
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?g_iLoadingDelayTime@@3HA:DWORD			; g_iLoadingDelayTime
EXTRN	___security_cookie:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A DD 01H DUP (?) ; CSingleton<CEterPackManager>::ms_singleton
_BSS	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@FFGDMIEH@CFileLoaderThread?3?3Request?3?5Rel@
CONST	SEGMENT
??_C@_0DD@FFGDMIEH@CFileLoaderThread?3?3Request?3?5Rel@ DB 'CFileLoaderTh'
	DB	'read::Request: ReleaseSemaphore error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@NDKNAKHH@CFileLoaderThread?3?3Execute?3?5Tim@
CONST	SEGMENT
??_C@_0EP@NDKNAKHH@CFileLoaderThread?3?3Execute?3?5Tim@ DB 'CFileLoaderTh'
	DB	'read::Execute: Timeout occured while time-out interval is INI'
	DB	'FITE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
__ehfuncinfo$?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CFileLoaderThread@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CFileLoaderThread@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CFileLoaderThread@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CFileLoaderThread@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CFileLoaderThread@@QAE@XZ$2
__ehfuncinfo$??0CFileLoaderThread@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CFileLoaderThread@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Zero_range@PAPAPAUSData@CFileLoaderThread@@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0@Z
_TEXT	SEGMENT
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAPAPAUSData@CFileLoaderThread@@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0@Z PROC ; std::_Zero_range<CFileLoaderThread::SData * * *>, COMDAT

; 1852 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1853 :     char* const _First_ch = reinterpret_cast<char*>(_First);

  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 1854 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 1855 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00011	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00014	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  0001d	e8 00 00 00 00	 call	 _memset
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1856 :     return _Last;

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 1857 : }

  00028	c9		 leave
  00029	c3		 ret	 0
??$_Zero_range@PAPAPAUSData@CFileLoaderThread@@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0@Z ENDP ; std::_Zero_range<CFileLoaderThread::SData * * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@PAPAPAU12@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@PAPAPAU12@00@Z PROC ; std::_Copy_memmove<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@PAPAPAU12@00@Z ENDP ; std::_Copy_memmove<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAXPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Destroy_range@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAXPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@@Z PROC ; std::_Destroy_range<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>, COMDAT

; 974  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 975  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 976  :     if _CONSTEXPR_IF (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 977  :         for (; _First != _Last; ++_First) {
; 978  :             _Destroy_in_place(*_First);
; 979  :         }
; 980  :     }
; 981  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAXPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@@Z ENDP ; std::_Destroy_range<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n_unchecked1@PAPAPAUSData@CFileLoaderThread@@I@std@@YAPAPAPAUSData@CFileLoaderThread@@PAPAPAU12@I@Z
_TEXT	SEGMENT
__UFirst$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Uninitialized_value_construct_n_unchecked1@PAPAPAUSData@CFileLoaderThread@@I@std@@YAPAPAPAUSData@CFileLoaderThread@@PAPAPAU12@I@Z PROC ; std::_Uninitialized_value_construct_n_unchecked1<CFileLoaderThread::SData * * *,unsigned int>, COMDAT

; 1912 : _NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1913 :     // value-initialize all elements in [_UFirst, _UFirst + _Count_raw)
; 1914 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 1915 :     if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
; 1916 :         return _Zero_range(_UFirst, _UFirst + _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00009	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000c	50		 push	 eax
  0000d	ff 75 08	 push	 DWORD PTR __UFirst$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Zero_range@PAPAPAUSData@CFileLoaderThread@@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0@Z ; std::_Zero_range<CFileLoaderThread::SData * * *>
  00015	59		 pop	 ecx
  00016	59		 pop	 ecx

; 1917 :     } else {
; 1918 :         _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
; 1919 :         for (; 0 < _Count; --_Count) {
; 1920 :             _Backout._Emplace_back();
; 1921 :         }
; 1922 : 
; 1923 :         return _Backout._Release();
; 1924 :     }
; 1925 : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Uninitialized_value_construct_n_unchecked1@PAPAPAUSData@CFileLoaderThread@@I@std@@YAPAPAPAUSData@CFileLoaderThread@@PAPAPAU12@I@Z ENDP ; std::_Uninitialized_value_construct_n_unchecked1<CFileLoaderThread::SData * * *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$uninitialized_copy@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0PAPAPAU12@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__UFirst$ = -12						; size = 4
__ULast$ = -8						; size = 4
__UDest$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$uninitialized_copy@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0PAPAPAU12@@Z PROC ; std::uninitialized_copy<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>, COMDAT

; 1629 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1630 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1631 :     _Adl_verify_range(_First, _Last);
; 1632 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1633 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1557 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __ULast$[ebp]
  00015	2b 45 f4	 sub	 eax, DWORD PTR __UFirst$[ebp]
  00018	c1 f8 02	 sar	 eax, 2
  0001b	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1634 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00021	89 45 fc	 mov	 DWORD PTR __UDest$[ebp], eax

; 1635 :     if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial) {
; 1636 :         _UDest = _Copy_memmove(_UFirst, _ULast, _UDest);

  00024	ff 75 fc	 push	 DWORD PTR __UDest$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __ULast$[ebp]
  0002a	ff 75 f4	 push	 DWORD PTR __UFirst$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@PAPAPAU12@00@Z ; std::_Copy_memmove<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	89 45 fc	 mov	 DWORD PTR __UDest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1492 :         _It = static_cast<_UIter&&>(_UIt);

  00038	8b 45 fc	 mov	 eax, DWORD PTR __UDest$[ebp]
  0003b	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1647 :     return _Dest;

  0003e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1648 : }

  00041	c9		 leave
  00042	c3		 ret	 0
??$uninitialized_copy@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0PAPAPAU12@@Z ENDP ; std::uninitialized_copy<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
__Mycont_$ = -16					; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	89 45 f0	 mov	 DWORD PTR __Mycont_$[ebp], eax

; 1089 :     _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_), _Myfirstiter(nullptr) {}

  00020	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00023	8b 4d f0	 mov	 ecx, DWORD PTR __Mycont_$[ebp]
  00026	89 08		 mov	 DWORD PTR [eax], ecx
  00028	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0002b	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  0002f	c9		 leave
  00030	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1003 : void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00003	33 c0		 xor	 eax, eax
  00005	40		 inc	 eax
  00006	c1 e0 03	 shl	 eax, 3
  00009	50		 push	 eax
  0000a	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00012	59		 pop	 ecx
  00013	59		 pop	 ecx

; 1004 :     // deallocate a plain pointer using an allocator
; 1005 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1006 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1007 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);
; 1008 :     } else {
; 1009 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1010 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1011 :     }
; 1012 : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@std@@QBEABQAUSData@CFileLoaderThread@@XZ
_TEXT	SEGMENT
__Off$ = -24						; size = 4
__Block$ = -20						; size = 4
__Off$ = -16						; size = 4
__Mycont$ = -12						; size = 4
tv89 = -8						; size = 4
_this$ = -4						; size = 4
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@std@@QBEABQAUSData@CFileLoaderThread@@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> > >::operator*, COMDAT
; _this$ = ecx

; 260  :     _NODISCARD reference operator*() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1185 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 0c		 je	 SHORT $LN5@operator
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f8	 mov	 DWORD PTR tv89[ebp], eax
  0001b	eb 04		 jmp	 SHORT $LN6@operator
$LN5@operator:
  0001d	83 65 f8 00	 and	 DWORD PTR tv89[ebp], 0
$LN6@operator:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv89[ebp]
  00024	89 45 f4	 mov	 DWORD PTR __Mycont$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 268  :         _Size_type _Block = _Mycont->_Getblock(_Myoff);

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002d	89 45 f0	 mov	 DWORD PTR __Off$[ebp], eax

; 548  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00030	8b 45 f0	 mov	 eax, DWORD PTR __Off$[ebp]
  00033	c1 e8 02	 shr	 eax, 2
  00036	8b 4d f4	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  00039	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0003c	49		 dec	 ecx
  0003d	23 c1		 and	 eax, ecx
  0003f	89 45 ec	 mov	 DWORD PTR __Block$[ebp], eax

; 269  :         _Size_type _Off   = _Myoff % _DEQUESIZ;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00048	33 d2		 xor	 edx, edx
  0004a	6a 04		 push	 4
  0004c	59		 pop	 ecx
  0004d	f7 f1		 div	 ecx
  0004f	89 55 e8	 mov	 DWORD PTR __Off$[ebp], edx

; 270  :         return _Mycont->_Map[_Block][_Off];

  00052	8b 45 f4	 mov	 eax, DWORD PTR __Mycont$[ebp]
  00055	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00058	8b 4d ec	 mov	 ecx, DWORD PTR __Block$[ebp]
  0005b	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0005e	8b 4d e8	 mov	 ecx, DWORD PTR __Off$[ebp]
  00061	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 271  :     }

  00064	c9		 leave
  00065	c3		 ret	 0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@std@@QBEABQAUSData@CFileLoaderThread@@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 885  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 886  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 887  :         _Left = _Right;
; 888  :     }
; 889  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAUSData@CFileLoaderThread@@@std@@YAXAAPAPAUSData@CFileLoaderThread@@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAPAUSData@CFileLoaderThread@@@std@@YAXAAPAPAUSData@CFileLoaderThread@@@Z PROC ; std::_Destroy_in_place<CFileLoaderThread::SData * *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAPAUSData@CFileLoaderThread@@@std@@YAXAAPAPAUSData@CFileLoaderThread@@@Z ENDP ; std::_Destroy_in_place<CFileLoaderThread::SData * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__New_proxy$ = -8					; size = 4
__Overflow_is_possible$5 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1106 :     void _Alloc_proxy(_Alloc&& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 e4 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 60   :         if (_Count > _Max_possible) {

  00014	33 c0		 xor	 eax, eax
  00016	40		 inc	 eax
  00017	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0001c	76 05		 jbe	 SHORT $LN6@Alloc_prox

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Alloc_prox:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	c1 e0 03	 shl	 eax, 3
  00029	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0002c	ff 75 f0	 push	 DWORD PTR $T4[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00034	59		 pop	 ecx
  00035	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00038	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  0003b	89 45 f8	 mov	 DWORD PTR __New_proxy$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1108 :         _Construct_in_place(*_New_proxy, this);

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  00044	8d 45 e8	 lea	 eax, DWORD PTR $T2[ebp]
  00047	50		 push	 eax
  00048	ff 75 f8	 push	 DWORD PTR __New_proxy$[ebp]
  0004b	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00050	59		 pop	 ecx
  00051	59		 pop	 ecx

; 1109 :         _Myproxy            = _New_proxy;

  00052	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 4d f8	 mov	 ecx, DWORD PTR __New_proxy$[ebp]
  00058	89 08		 mov	 DWORD PTR [eax], ecx

; 1110 :         _New_proxy->_Mycont = this;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __New_proxy$[ebp]
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	89 08		 mov	 DWORD PTR [eax], ecx
$LN9@Alloc_prox:

; 1111 :     }

  00062	c9		 leave
  00063	c2 04 00	 ret	 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1031 : void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1032 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1033 :     using _Ty = typename _Alloc::value_type;
; 1034 :     _Ptr->~_Ty();
; 1035 :     _Deallocate_plain(_Al, _Ptr);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 1036 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@std@@QBEABQAUSData@CFileLoaderThread@@XZ
_TEXT	SEGMENT
__Off$ = -20						; size = 4
__Block$ = -16						; size = 4
_this$ = -12						; size = 4
__Off$ = -8						; size = 4
_this$ = -4						; size = 4
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@std@@QBEABQAUSData@CFileLoaderThread@@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> > >::operator*, COMDAT
; _this$ = ecx

; 54   :     _NODISCARD reference operator*() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 55   :         _Size_type _Block = _Mycont->_Getblock(_Myoff);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f8	 mov	 DWORD PTR __Off$[ebp], eax
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 00		 mov	 eax, DWORD PTR [eax]
  00017	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 548  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  0001a	8b 45 f8	 mov	 eax, DWORD PTR __Off$[ebp]
  0001d	c1 e8 02	 shr	 eax, 2
  00020	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00026	49		 dec	 ecx
  00027	23 c1		 and	 eax, ecx
  00029	89 45 f0	 mov	 DWORD PTR __Block$[ebp], eax

; 56   :         _Size_type _Off   = _Myoff % _DEQUESIZ;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	33 d2		 xor	 edx, edx
  00034	6a 04		 push	 4
  00036	59		 pop	 ecx
  00037	f7 f1		 div	 ecx
  00039	89 55 ec	 mov	 DWORD PTR __Off$[ebp], edx

; 57   :         return _Mycont->_Map[_Block][_Off];

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	8b 4d f0	 mov	 ecx, DWORD PTR __Block$[ebp]
  00047	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0004a	8b 4d ec	 mov	 ecx, DWORD PTR __Off$[ebp]
  0004d	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 58   :     }

  00050	c9		 leave
  00051	c3		 ret	 0
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@std@@QBEABQAUSData@CFileLoaderThread@@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??$_Emplace_back_internal@ABQAUSData@CFileLoaderThread@@@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXABQAUSData@CFileLoaderThread@@@Z
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
__Max_possible$3 = -52					; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
$T9 = -28						; size = 4
$T10 = -24						; size = 4
$T11 = -20						; size = 4
__Ptr$ = -16						; size = 4
$T12 = -12						; size = 4
$T13 = -8						; size = 4
$T14 = -4						; size = 4
$T15 = 0						; size = 4
$T16 = 4						; size = 4
$T17 = 8						; size = 4
$T18 = 12						; size = 4
$T19 = 16						; size = 4
$T20 = 20						; size = 4
$T21 = 24						; size = 4
$T22 = 28						; size = 4
$T23 = 32						; size = 4
$T24 = 36						; size = 4
$T25 = 40						; size = 4
$T26 = 44						; size = 4
$T27 = 48						; size = 4
$T28 = 52						; size = 4
$T29 = 56						; size = 4
$T30 = 60						; size = 4
$T31 = 64						; size = 4
$T32 = 68						; size = 4
$T33 = 72						; size = 4
$T34 = 76						; size = 4
$T35 = 80						; size = 4
$T36 = 84						; size = 4
$T37 = 88						; size = 4
__Newoff$ = 92						; size = 4
tv163 = 96						; size = 4
__Block$ = 100						; size = 4
tv86 = 104						; size = 4
__Overflow_is_possible$38 = 111				; size = 1
_this$ = 112						; size = 4
_<_Vals_0>$ = 124					; size = 4
??$_Emplace_back_internal@ABQAUSData@CFileLoaderThread@@@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXABQAUSData@CFileLoaderThread@@@Z PROC ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Emplace_back_internal<CFileLoaderThread::SData * const &>, COMDAT
; _this$ = ecx

; 1114 :     void _Emplace_back_internal(_Tys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  0000b	89 4d 70	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  0000e	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00011	89 45 58	 mov	 DWORD PTR $T37[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  00014	8b 45 58	 mov	 eax, DWORD PTR $T37[ebp]
  00017	83 c0 0c	 add	 eax, 12			; 0000000cH
  0001a	89 45 50	 mov	 DWORD PTR $T35[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0001d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 54	 mov	 DWORD PTR $T36[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  00023	8b 45 54	 mov	 eax, DWORD PTR $T36[ebp]
  00026	83 c0 10	 add	 eax, 16			; 00000010H
  00029	89 45 4c	 mov	 DWORD PTR $T34[ebp], eax

; 1115 :         _PUSH_BACK_BEGIN;

  0002c	8b 45 50	 mov	 eax, DWORD PTR $T35[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	8b 4d 4c	 mov	 ecx, DWORD PTR $T34[ebp]
  00034	03 01		 add	 eax, DWORD PTR [ecx]
  00036	33 d2		 xor	 edx, edx
  00038	6a 04		 push	 4
  0003a	59		 pop	 ecx
  0003b	f7 f1		 div	 ecx
  0003d	85 d2		 test	 edx, edx
  0003f	75 3a		 jne	 SHORT $LN2@Emplace_ba

; 1530 :         return _Mypair._Myval2;

  00041	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00044	89 45 48	 mov	 DWORD PTR $T33[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00047	8b 45 48	 mov	 eax, DWORD PTR $T33[ebp]
  0004a	83 c0 08	 add	 eax, 8
  0004d	89 45 3c	 mov	 DWORD PTR $T30[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00050	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00053	89 45 44	 mov	 DWORD PTR $T32[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  00056	8b 45 44	 mov	 eax, DWORD PTR $T32[ebp]
  00059	83 c0 10	 add	 eax, 16			; 00000010H
  0005c	89 45 40	 mov	 DWORD PTR $T31[ebp], eax

; 1115 :         _PUSH_BACK_BEGIN;

  0005f	8b 45 40	 mov	 eax, DWORD PTR $T31[ebp]
  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	83 c0 04	 add	 eax, 4
  00067	c1 e8 02	 shr	 eax, 2
  0006a	8b 4d 3c	 mov	 ecx, DWORD PTR $T30[ebp]
  0006d	39 01		 cmp	 DWORD PTR [ecx], eax
  0006f	77 0a		 ja	 SHORT $LN2@Emplace_ba
  00071	6a 01		 push	 1
  00073	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Growmap@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXI@Z ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Growmap
$LN2@Emplace_ba:
  0007b	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  0007e	89 45 68	 mov	 DWORD PTR tv86[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00081	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00084	89 45 38	 mov	 DWORD PTR $T29[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  00087	8b 45 38	 mov	 eax, DWORD PTR $T29[ebp]
  0008a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0008d	89 45 68	 mov	 DWORD PTR tv86[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00090	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00093	89 45 34	 mov	 DWORD PTR $T28[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00096	8b 45 34	 mov	 eax, DWORD PTR $T28[ebp]
  00099	83 c0 08	 add	 eax, 8
  0009c	89 45 30	 mov	 DWORD PTR $T27[ebp], eax

; 1115 :         _PUSH_BACK_BEGIN;

  0009f	8b 45 30	 mov	 eax, DWORD PTR $T27[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	8d 04 85 ff ff
	ff ff		 lea	 eax, DWORD PTR [eax*4-1]
  000ab	8b 4d 68	 mov	 ecx, DWORD PTR tv86[ebp]
  000ae	23 01		 and	 eax, DWORD PTR [ecx]
  000b0	8b 4d 68	 mov	 ecx, DWORD PTR tv86[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1530 :         return _Mypair._Myval2;

  000b5	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	89 45 2c	 mov	 DWORD PTR $T26[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  000bb	8b 45 2c	 mov	 eax, DWORD PTR $T26[ebp]
  000be	83 c0 0c	 add	 eax, 12			; 0000000cH
  000c1	89 45 24	 mov	 DWORD PTR $T24[ebp], eax

; 1530 :         return _Mypair._Myval2;

  000c4	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	89 45 28	 mov	 DWORD PTR $T25[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  000ca	8b 45 28	 mov	 eax, DWORD PTR $T25[ebp]
  000cd	83 c0 10	 add	 eax, 16			; 00000010H
  000d0	89 45 20	 mov	 DWORD PTR $T23[ebp], eax

; 1115 :         _PUSH_BACK_BEGIN;

  000d3	8b 45 24	 mov	 eax, DWORD PTR $T24[ebp]
  000d6	8b 00		 mov	 eax, DWORD PTR [eax]
  000d8	8b 4d 20	 mov	 ecx, DWORD PTR $T23[ebp]
  000db	03 01		 add	 eax, DWORD PTR [ecx]
  000dd	89 45 5c	 mov	 DWORD PTR __Newoff$[ebp], eax

; 1534 :         return _Mypair._Myval2;

  000e0	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	89 45 1c	 mov	 DWORD PTR $T22[ebp], eax

; 548  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  000e6	8b 45 5c	 mov	 eax, DWORD PTR __Newoff$[ebp]
  000e9	c1 e8 02	 shr	 eax, 2
  000ec	8b 4d 1c	 mov	 ecx, DWORD PTR $T22[ebp]
  000ef	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000f2	49		 dec	 ecx
  000f3	23 c1		 and	 eax, ecx
  000f5	89 45 18	 mov	 DWORD PTR $T21[ebp], eax

; 1514 :         return _Get_data()._Getblock(_Off);

  000f8	8b 45 18	 mov	 eax, DWORD PTR $T21[ebp]
  000fb	89 45 64	 mov	 DWORD PTR __Block$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  000fe	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00101	89 45 14	 mov	 DWORD PTR $T20[ebp], eax

; 1538 :         return _Get_data()._Map;

  00104	8b 45 14	 mov	 eax, DWORD PTR $T20[ebp]
  00107	83 c0 04	 add	 eax, 4
  0010a	89 45 10	 mov	 DWORD PTR $T19[ebp], eax

; 1115 :         _PUSH_BACK_BEGIN;

  0010d	8b 45 10	 mov	 eax, DWORD PTR $T19[ebp]
  00110	8b 00		 mov	 eax, DWORD PTR [eax]
  00112	8b 4d 64	 mov	 ecx, DWORD PTR __Block$[ebp]
  00115	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00119	75 58		 jne	 SHORT $LN3@Emplace_ba

; 1522 :         return _Mypair._Get_first();

  0011b	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0011e	89 45 0c	 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00121	8b 45 0c	 mov	 eax, DWORD PTR $T18[ebp]
  00124	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00127	c6 45 6f 01	 mov	 BYTE PTR __Overflow_is_possible$38[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0012b	c7 45 cc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$3[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  00132	6a 04		 push	 4
  00134	58		 pop	 eax
  00135	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0013a	76 05		 jbe	 SHORT $LN77@Emplace_ba

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0013c	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN77@Emplace_ba:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00141	6a 04		 push	 4
  00143	58		 pop	 eax
  00144	c1 e0 02	 shl	 eax, 2
  00147	89 45 08	 mov	 DWORD PTR $T17[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0014a	ff 75 08	 push	 DWORD PTR $T17[ebp]
  0014d	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00152	59		 pop	 ecx
  00153	89 45 fc	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00156	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00159	89 45 04	 mov	 DWORD PTR $T16[ebp], eax

; 1538 :         return _Get_data()._Map;

  0015c	8b 45 04	 mov	 eax, DWORD PTR $T16[ebp]
  0015f	83 c0 04	 add	 eax, 4
  00162	89 45 00	 mov	 DWORD PTR $T15[ebp], eax

; 1115 :         _PUSH_BACK_BEGIN;

  00165	8b 45 00	 mov	 eax, DWORD PTR $T15[ebp]
  00168	8b 00		 mov	 eax, DWORD PTR [eax]
  0016a	8b 4d 64	 mov	 ecx, DWORD PTR __Block$[ebp]
  0016d	8b 55 fc	 mov	 edx, DWORD PTR $T14[ebp]
  00170	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN3@Emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00173	8b 45 7c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00176	89 45 e4	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00179	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0017c	89 45 f8	 mov	 DWORD PTR $T13[ebp], eax

; 1538 :         return _Get_data()._Map;

  0017f	8b 45 f8	 mov	 eax, DWORD PTR $T13[ebp]
  00182	83 c0 04	 add	 eax, 4
  00185	89 45 f4	 mov	 DWORD PTR $T12[ebp], eax

; 1116 :         _Alty_traits::construct(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _DEQUESIZ), _STD forward<_Tys>(_Vals)...);

  00188	8b 45 5c	 mov	 eax, DWORD PTR __Newoff$[ebp]
  0018b	33 d2		 xor	 edx, edx
  0018d	6a 04		 push	 4
  0018f	59		 pop	 ecx
  00190	f7 f1		 div	 ecx
  00192	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00195	8b 00		 mov	 eax, DWORD PTR [eax]
  00197	8b 4d 64	 mov	 ecx, DWORD PTR __Block$[ebp]
  0019a	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0019d	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  001a0	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  001a3	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  001a6	89 45 e8	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  001a9	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001ac	89 45 ec	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  001af	8b 45 ec	 mov	 eax, DWORD PTR $T11[ebp]
  001b2	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  001b5	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp]
  001b8	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  001bb	8b 45 e4	 mov	 eax, DWORD PTR $T9[ebp]
  001be	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  001c1	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  001c4	8b 4d dc	 mov	 ecx, DWORD PTR $T7[ebp]
  001c7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001c9	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1117 :         _PUSH_BACK_END;

  001cb	8b 45 c4	 mov	 eax, DWORD PTR $T1[ebp]
  001ce	89 45 60	 mov	 DWORD PTR tv163[ebp], eax

; 1530 :         return _Mypair._Myval2;

  001d1	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001d4	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  001d7	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  001da	83 c0 10	 add	 eax, 16			; 00000010H
  001dd	89 45 60	 mov	 DWORD PTR tv163[ebp], eax

; 1117 :         _PUSH_BACK_END;

  001e0	8b 45 60	 mov	 eax, DWORD PTR tv163[ebp]
  001e3	8b 00		 mov	 eax, DWORD PTR [eax]
  001e5	40		 inc	 eax
  001e6	8b 4d 60	 mov	 ecx, DWORD PTR tv163[ebp]
  001e9	89 01		 mov	 DWORD PTR [ecx], eax
$LN80@Emplace_ba:

; 1118 :     }

  001eb	83 c5 74	 add	 ebp, 116		; 00000074H
  001ee	c9		 leave
  001ef	c2 04 00	 ret	 4
??$_Emplace_back_internal@ABQAUSData@CFileLoaderThread@@@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXABQAUSData@CFileLoaderThread@@@Z ENDP ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Emplace_back_internal<CFileLoaderThread::SData * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h
;	COMDAT ??$stl_wipe@V?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@@@YAXAAV?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = -56						; size = 12
_i$2 = -44						; size = 12
$T3 = -32						; size = 4
tv93 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
tv180 = -12						; size = 4
tv166 = -8						; size = 4
$T7 = -2						; size = 1
$T8 = -1						; size = 1
_container$ = 8						; size = 4
??$stl_wipe@V?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@@@YAXAAV?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@@Z PROC ; stl_wipe<std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> > >, COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H

; 95   : 	for (TContainer::iterator i = container.begin(); i != container.end(); ++i)

  00006	8d 45 d4	 lea	 eax, DWORD PTR _i$2[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _container$[ebp]
  0000d	e8 00 00 00 00	 call	 ?begin@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@2@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::begin
  00012	eb 07		 jmp	 SHORT $LN4@stl_wipe
$LN2@stl_wipe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 284  :         ++_Myoff;

  00014	8b 45 dc	 mov	 eax, DWORD PTR _i$2[ebp+8]
  00017	40		 inc	 eax
  00018	89 45 dc	 mov	 DWORD PTR _i$2[ebp+8], eax
$LN4@stl_wipe:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h

; 95   : 	for (TContainer::iterator i = container.begin(); i != container.end(); ++i)

  0001b	8d 45 c8	 lea	 eax, DWORD PTR $T1[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _container$[ebp]
  00022	e8 00 00 00 00	 call	 ?end@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@2@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::end
  00027	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 351  :         return this->_Myoff == _Right._Myoff;

  0002a	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  0002d	8b 4d dc	 mov	 ecx, DWORD PTR _i$2[ebp+8]
  00030	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00033	75 09		 jne	 SHORT $LN65@stl_wipe
  00035	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv166[ebp], 1
  0003c	eb 04		 jmp	 SHORT $LN66@stl_wipe
$LN65@stl_wipe:
  0003e	83 65 f8 00	 and	 DWORD PTR tv166[ebp], 0
$LN66@stl_wipe:
  00042	8a 45 f8	 mov	 al, BYTE PTR tv166[ebp]
  00045	88 45 ff	 mov	 BYTE PTR $T8[ebp], al

; 355  :         return !(*this == _Right);

  00048	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0004c	85 c0		 test	 eax, eax
  0004e	75 09		 jne	 SHORT $LN60@stl_wipe
  00050	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv180[ebp], 1
  00057	eb 04		 jmp	 SHORT $LN61@stl_wipe
$LN60@stl_wipe:
  00059	83 65 f4 00	 and	 DWORD PTR tv180[ebp], 0
$LN61@stl_wipe:
  0005d	8a 45 f4	 mov	 al, BYTE PTR tv180[ebp]
  00060	88 45 fe	 mov	 BYTE PTR $T7[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h

; 95   : 	for (TContainer::iterator i = container.begin(); i != container.end(); ++i)

  00063	0f b6 45 fe	 movzx	 eax, BYTE PTR $T7[ebp]
  00067	85 c0		 test	 eax, eax
  00069	74 42		 je	 SHORT $LN128@stl_wipe
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 446  :         return const_cast<reference>(_Mybase::operator*());

  0006b	8d 4d d4	 lea	 ecx, DWORD PTR _i$2[ebp]
  0006e	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@std@@QBEABQAUSData@CFileLoaderThread@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> > >::operator*
  00073	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h

; 97   : 		delete *i;

  00076	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00079	8b 00		 mov	 eax, DWORD PTR [eax]
  0007b	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
  0007e	83 7d f0 00	 cmp	 DWORD PTR $T6[ebp], 0
  00082	74 0f		 je	 SHORT $LN6@stl_wipe
  00084	6a 01		 push	 1
  00086	8b 4d f0	 mov	 ecx, DWORD PTR $T6[ebp]
  00089	e8 00 00 00 00	 call	 ??_GSData@CFileLoaderThread@@QAEPAXI@Z
  0008e	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00091	eb 04		 jmp	 SHORT $LN7@stl_wipe
$LN6@stl_wipe:
  00093	83 65 e4 00	 and	 DWORD PTR tv93[ebp], 0
$LN7@stl_wipe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 446  :         return const_cast<reference>(_Mybase::operator*());

  00097	8d 4d d4	 lea	 ecx, DWORD PTR _i$2[ebp]
  0009a	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@std@@QBEABQAUSData@CFileLoaderThread@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> > >::operator*
  0009f	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h

; 98   : 		*i = NULL;

  000a2	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  000a5	83 20 00	 and	 DWORD PTR [eax], 0

; 99   : 	}

  000a8	e9 67 ff ff ff	 jmp	 $LN2@stl_wipe
$LN128@stl_wipe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1330 :         _Tidy();

  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _container$[ebp]
  000b0	e8 00 00 00 00	 call	 ?_Tidy@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXXZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h

; 102  : }

  000b5	c9		 leave
  000b6	c3		 ret	 0
??$stl_wipe@V?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@@@YAXAAV?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@@Z ENDP ; stl_wipe<std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> >::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> >, COMDAT
; _this$ = ecx

; 544  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1097 :     _Container_base12() noexcept : _Myproxy(nullptr) {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 544  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 0c 00	 and	 DWORD PTR [eax+12], 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c9		 leave
  0002d	c3		 ret	 0
??0?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> >::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?_Tidy@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -128						; size = 4
$T2 = -124						; size = 4
$T3 = -120						; size = 4
$T4 = -116						; size = 4
$T5 = -112						; size = 4
$T6 = -108						; size = 4
$T7 = -104						; size = 4
__Ptr$ = -100						; size = 4
__Count$ = -96						; size = 4
$T8 = -92						; size = 4
$T9 = -88						; size = 4
$T10 = -84						; size = 4
$T11 = -80						; size = 4
$T12 = -76						; size = 4
$T13 = -72						; size = 4
$T14 = -68						; size = 4
$T15 = -64						; size = 4
__Ptr$ = -60						; size = 4
$T16 = -56						; size = 4
$T17 = -52						; size = 4
$T18 = -48						; size = 4
$T19 = -44						; size = 4
$T20 = -40						; size = 4
$T21 = -36						; size = 4
$T22 = -32						; size = 4
$T23 = -28						; size = 4
$T24 = -24						; size = 4
$T25 = -20						; size = 4
tv149 = -16						; size = 4
__Block$26 = -12					; size = 4
_this$ = -8						; size = 4
$T27 = -1						; size = 1
?_Tidy@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXXZ PROC ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Tidy, COMDAT
; _this$ = ecx

; 1469 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 88	 mov	 DWORD PTR $T3[ebp], eax

; 1522 :         return _Mypair._Get_first();

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00015	89 45 ec	 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00018	8b 45 ec	 mov	 eax, DWORD PTR $T25[ebp]
  0001b	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
$LN2@Tidy:

; 1534 :         return _Mypair._Myval2;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	89 45 e8	 mov	 DWORD PTR $T24[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  00024	8b 45 e8	 mov	 eax, DWORD PTR $T24[ebp]
  00027	83 c0 10	 add	 eax, 16			; 00000010H
  0002a	89 45 e4	 mov	 DWORD PTR $T23[ebp], eax

; 1010 :         return _Mysize() == 0;

  0002d	8b 45 e4	 mov	 eax, DWORD PTR $T23[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 09		 jne	 SHORT $LN30@Tidy
  00035	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv149[ebp], 1
  0003c	eb 04		 jmp	 SHORT $LN31@Tidy
$LN30@Tidy:
  0003e	83 65 f0 00	 and	 DWORD PTR tv149[ebp], 0
$LN31@Tidy:
  00042	8a 45 f0	 mov	 al, BYTE PTR tv149[ebp]
  00045	88 45 ff	 mov	 BYTE PTR $T27[ebp], al

; 1470 :         _Orphan_all();
; 1471 : 
; 1472 :         _Alpty _Almap(_Getal());
; 1473 :         while (!empty()) {

  00048	0f b6 45 ff	 movzx	 eax, BYTE PTR $T27[ebp]
  0004c	85 c0		 test	 eax, eax
  0004e	75 0a		 jne	 SHORT $LN3@Tidy

; 1474 :             pop_back();

  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?pop_back@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEXXZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::pop_back

; 1475 :         }

  00058	eb c4		 jmp	 SHORT $LN2@Tidy
$LN3@Tidy:

; 1530 :         return _Mypair._Myval2;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	89 45 e0	 mov	 DWORD PTR $T22[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T22[ebp]
  00063	83 c0 08	 add	 eax, 8
  00066	89 45 dc	 mov	 DWORD PTR $T21[ebp], eax

; 1476 : 
; 1477 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  00069	8b 45 dc	 mov	 eax, DWORD PTR $T21[ebp]
  0006c	8b 00		 mov	 eax, DWORD PTR [eax]
  0006e	89 45 f4	 mov	 DWORD PTR __Block$26[ebp], eax
$LN6@Tidy:
  00071	83 7d f4 00	 cmp	 DWORD PTR __Block$26[ebp], 0
  00075	0f 86 84 00 00
	00		 jbe	 $LN5@Tidy

; 1478 :             if (_Map()[--_Block]) { // free block and destroy its pointer

  0007b	8b 45 f4	 mov	 eax, DWORD PTR __Block$26[ebp]
  0007e	48		 dec	 eax
  0007f	89 45 f4	 mov	 DWORD PTR __Block$26[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00082	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00085	89 45 d8	 mov	 DWORD PTR $T20[ebp], eax

; 1538 :         return _Get_data()._Map;

  00088	8b 45 d8	 mov	 eax, DWORD PTR $T20[ebp]
  0008b	83 c0 04	 add	 eax, 4
  0008e	89 45 d4	 mov	 DWORD PTR $T19[ebp], eax

; 1478 :             if (_Map()[--_Block]) { // free block and destroy its pointer

  00091	8b 45 d4	 mov	 eax, DWORD PTR $T19[ebp]
  00094	8b 00		 mov	 eax, DWORD PTR [eax]
  00096	8b 4d f4	 mov	 ecx, DWORD PTR __Block$26[ebp]
  00099	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  0009d	74 5b		 je	 SHORT $LN7@Tidy

; 1530 :         return _Mypair._Myval2;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	89 45 d0	 mov	 DWORD PTR $T18[ebp], eax

; 1538 :         return _Get_data()._Map;

  000a5	8b 45 d0	 mov	 eax, DWORD PTR $T18[ebp]
  000a8	83 c0 04	 add	 eax, 4
  000ab	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax

; 1522 :         return _Mypair._Get_first();

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b1	89 45 cc	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  000b4	8b 45 cc	 mov	 eax, DWORD PTR $T17[ebp]
  000b7	89 45 80	 mov	 DWORD PTR $T1[ebp], eax

; 1479 :                 _Getal().deallocate(_Map()[_Block], _DEQUESIZ);

  000ba	8b 45 c8	 mov	 eax, DWORD PTR $T16[ebp]
  000bd	8b 00		 mov	 eax, DWORD PTR [eax]
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __Block$26[ebp]
  000c2	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  000c5	89 45 c4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c8	6a 04		 push	 4
  000ca	58		 pop	 eax
  000cb	c1 e0 02	 shl	 eax, 2
  000ce	50		 push	 eax
  000cf	ff 75 c4	 push	 DWORD PTR __Ptr$[ebp]
  000d2	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000d7	59		 pop	 ecx
  000d8	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	89 45 c0	 mov	 DWORD PTR $T15[ebp], eax

; 1538 :         return _Get_data()._Map;

  000df	8b 45 c0	 mov	 eax, DWORD PTR $T15[ebp]
  000e2	83 c0 04	 add	 eax, 4
  000e5	89 45 bc	 mov	 DWORD PTR $T14[ebp], eax

; 1480 :                 _Destroy_in_place(_Map()[_Block]);

  000e8	8b 45 bc	 mov	 eax, DWORD PTR $T14[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	8b 4d f4	 mov	 ecx, DWORD PTR __Block$26[ebp]
  000f0	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAPAUSData@CFileLoaderThread@@@std@@YAXAAPAPAUSData@CFileLoaderThread@@@Z ; std::_Destroy_in_place<CFileLoaderThread::SData * *>
  000f9	59		 pop	 ecx
$LN7@Tidy:

; 1481 :             }
; 1482 :         }

  000fa	e9 72 ff ff ff	 jmp	 $LN6@Tidy
$LN5@Tidy:

; 1530 :         return _Mypair._Myval2;

  000ff	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00102	89 45 b8	 mov	 DWORD PTR $T13[ebp], eax

; 1538 :         return _Get_data()._Map;

  00105	8b 45 b8	 mov	 eax, DWORD PTR $T13[ebp]
  00108	83 c0 04	 add	 eax, 4
  0010b	89 45 b4	 mov	 DWORD PTR $T12[ebp], eax

; 1483 : 
; 1484 :         if (_Map() != _Mapptr()) {

  0010e	8b 45 b4	 mov	 eax, DWORD PTR $T12[ebp]
  00111	83 38 00	 cmp	 DWORD PTR [eax], 0
  00114	74 3f		 je	 SHORT $LN8@Tidy

; 1530 :         return _Mypair._Myval2;

  00116	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00119	89 45 b0	 mov	 DWORD PTR $T11[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0011c	8b 45 b0	 mov	 eax, DWORD PTR $T11[ebp]
  0011f	83 c0 08	 add	 eax, 8
  00122	89 45 a8	 mov	 DWORD PTR $T9[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00125	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00128	89 45 ac	 mov	 DWORD PTR $T10[ebp], eax

; 1538 :         return _Get_data()._Map;

  0012b	8b 45 ac	 mov	 eax, DWORD PTR $T10[ebp]
  0012e	83 c0 04	 add	 eax, 4
  00131	89 45 a4	 mov	 DWORD PTR $T8[ebp], eax

; 1485 :             _Almap.deallocate(_Map(), _Mapsize()); // free storage for map

  00134	8b 45 a8	 mov	 eax, DWORD PTR $T9[ebp]
  00137	8b 00		 mov	 eax, DWORD PTR [eax]
  00139	89 45 a0	 mov	 DWORD PTR __Count$[ebp], eax
  0013c	8b 45 a4	 mov	 eax, DWORD PTR $T8[ebp]
  0013f	8b 00		 mov	 eax, DWORD PTR [eax]
  00141	89 45 9c	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00144	8b 45 a0	 mov	 eax, DWORD PTR __Count$[ebp]
  00147	c1 e0 02	 shl	 eax, 2
  0014a	50		 push	 eax
  0014b	ff 75 9c	 push	 DWORD PTR __Ptr$[ebp]
  0014e	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00153	59		 pop	 ecx
  00154	59		 pop	 ecx
$LN8@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00155	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00158	89 45 98	 mov	 DWORD PTR $T7[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0015b	8b 45 98	 mov	 eax, DWORD PTR $T7[ebp]
  0015e	83 c0 08	 add	 eax, 8
  00161	89 45 94	 mov	 DWORD PTR $T6[ebp], eax

; 1486 :         }
; 1487 : 
; 1488 :         _Mapsize() = 0;

  00164	8b 45 94	 mov	 eax, DWORD PTR $T6[ebp]
  00167	83 20 00	 and	 DWORD PTR [eax], 0

; 1530 :         return _Mypair._Myval2;

  0016a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0016d	89 45 90	 mov	 DWORD PTR $T5[ebp], eax

; 1538 :         return _Get_data()._Map;

  00170	8b 45 90	 mov	 eax, DWORD PTR $T5[ebp]
  00173	83 c0 04	 add	 eax, 4
  00176	89 45 8c	 mov	 DWORD PTR $T4[ebp], eax

; 1489 :         _Map()     = _Mapptr();

  00179	8b 45 8c	 mov	 eax, DWORD PTR $T4[ebp]
  0017c	83 20 00	 and	 DWORD PTR [eax], 0

; 1490 :     }

  0017f	c9		 leave
  00180	c3		 ret	 0
?_Tidy@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXXZ ENDP ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?_Growmap@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
$T1 = -164						; size = 4
__Max_possible$2 = -160					; size = 4
$T3 = -156						; size = 4
$T4 = -152						; size = 4
$T5 = -148						; size = 4
$T6 = -144						; size = 4
$T7 = -140						; size = 4
__Ptr$ = -136						; size = 4
__Count$ = -132						; size = 4
$T8 = -128						; size = 4
$T9 = -124						; size = 4
$T10 = -120						; size = 4
$T11 = -116						; size = 4
$T12 = -112						; size = 4
$T13 = -108						; size = 4
$T14 = -104						; size = 4
$T15 = -100						; size = 4
$T16 = -96						; size = 4
$T17 = -92						; size = 4
$T18 = -88						; size = 4
$T19 = -84						; size = 4
$T20 = -80						; size = 4
$T21 = -76						; size = 4
$T22 = -72						; size = 4
$T23 = -68						; size = 4
$T24 = -64						; size = 4
$T25 = -60						; size = 4
$T26 = -56						; size = 4
$T27 = -52						; size = 4
$T28 = -48						; size = 4
$T29 = -44						; size = 4
$T30 = -40						; size = 4
$T31 = -36						; size = 4
$T32 = -32						; size = 4
$T33 = -28						; size = 4
$T34 = -24						; size = 4
$T35 = -20						; size = 4
$T36 = -16						; size = 4
$T37 = -12						; size = 4
$T38 = -8						; size = 4
$T39 = -4						; size = 4
$T40 = 0						; size = 4
$T41 = 4						; size = 4
$T42 = 8						; size = 4
$T43 = 12						; size = 4
$T44 = 16						; size = 4
$T45 = 20						; size = 4
$T46 = 24						; size = 4
$T47 = 28						; size = 4
$T48 = 32						; size = 4
$T49 = 36						; size = 4
$T50 = 40						; size = 4
$T51 = 44						; size = 4
$T52 = 48						; size = 4
$T53 = 52						; size = 4
$T54 = 56						; size = 4
$T55 = 60						; size = 4
$T56 = 64						; size = 4
__Count$ = 68						; size = 4
tv232 = 72						; size = 4
$T57 = 76						; size = 4
$T58 = 80						; size = 4
tv73 = 84						; size = 4
tv214 = 88						; size = 4
__Overflow_is_possible$59 = 95				; size = 1
__Newmap$ = 96						; size = 4
__Newsize$ = 100					; size = 4
__Myboff$ = 104						; size = 4
__Myptr$ = 108						; size = 4
_this$ = 112						; size = 4
__Count$ = 124						; size = 4
?_Growmap@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXI@Z PROC ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Growmap, COMDAT
; _this$ = ecx

; 1430 :     void _Growmap(size_type _Count) { // grow map by at least _Count pointers, _Mapsize() a power of 2

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0000b	89 4d 70	 mov	 DWORD PTR _this$[ebp], ecx

; 1522 :         return _Mypair._Get_first();

  0000e	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00011	89 45 40	 mov	 DWORD PTR $T56[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00014	8b 45 40	 mov	 eax, DWORD PTR $T56[ebp]
  00017	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0001d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 3c	 mov	 DWORD PTR $T55[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00023	8b 45 3c	 mov	 eax, DWORD PTR $T55[ebp]
  00026	83 c0 08	 add	 eax, 8
  00029	89 45 38	 mov	 DWORD PTR $T54[ebp], eax

; 1431 :         static_assert(1 < _DEQUEMAPSIZ, "The _Xlen() test should always be performed.");
; 1432 : 
; 1433 :         _Alpty _Almap(_Getal());
; 1434 :         size_type _Newsize = 0 < _Mapsize() ? _Mapsize() : 1;

  0002c	8b 45 38	 mov	 eax, DWORD PTR $T54[ebp]
  0002f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00032	76 19		 jbe	 SHORT $LN10@Growmap

; 1530 :         return _Mypair._Myval2;

  00034	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 34	 mov	 DWORD PTR $T53[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0003a	8b 45 34	 mov	 eax, DWORD PTR $T53[ebp]
  0003d	83 c0 08	 add	 eax, 8
  00040	89 45 30	 mov	 DWORD PTR $T52[ebp], eax

; 1431 :         static_assert(1 < _DEQUEMAPSIZ, "The _Xlen() test should always be performed.");
; 1432 : 
; 1433 :         _Alpty _Almap(_Getal());
; 1434 :         size_type _Newsize = 0 < _Mapsize() ? _Mapsize() : 1;

  00043	8b 45 30	 mov	 eax, DWORD PTR $T52[ebp]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 45 54	 mov	 DWORD PTR tv73[ebp], eax
  0004b	eb 07		 jmp	 SHORT $LN11@Growmap
$LN10@Growmap:
  0004d	c7 45 54 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN11@Growmap:
  00054	8b 45 54	 mov	 eax, DWORD PTR tv73[ebp]
  00057	89 45 64	 mov	 DWORD PTR __Newsize$[ebp], eax
$LN2@Growmap:

; 1530 :         return _Mypair._Myval2;

  0005a	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	89 45 2c	 mov	 DWORD PTR $T51[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00060	8b 45 2c	 mov	 eax, DWORD PTR $T51[ebp]
  00063	83 c0 08	 add	 eax, 8
  00066	89 45 28	 mov	 DWORD PTR $T50[ebp], eax

; 1435 :         while (_Newsize - _Mapsize() < _Count || _Newsize < _DEQUEMAPSIZ) {

  00069	8b 45 28	 mov	 eax, DWORD PTR $T50[ebp]
  0006c	8b 4d 64	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0006f	2b 08		 sub	 ecx, DWORD PTR [eax]
  00071	3b 4d 7c	 cmp	 ecx, DWORD PTR __Count$[ebp]
  00074	72 06		 jb	 SHORT $LN4@Growmap
  00076	83 7d 64 08	 cmp	 DWORD PTR __Newsize$[ebp], 8
  0007a	73 70		 jae	 SHORT $LN3@Growmap
$LN4@Growmap:

; 1526 :         return _Mypair._Get_first();

  0007c	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007f	89 45 24	 mov	 DWORD PTR $T49[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1526 :         return _Mypair._Get_first();

  00082	8b 45 24	 mov	 eax, DWORD PTR $T49[ebp]
  00085	89 85 64 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0008b	c7 45 50 ff ff
	ff 3f		 mov	 DWORD PTR $T58[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00092	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T48[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1005 :         return (_STD min)(

  00099	8b 45 20	 mov	 eax, DWORD PTR $T48[ebp]
  0009c	89 45 4c	 mov	 DWORD PTR $T57[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009f	8b 45 50	 mov	 eax, DWORD PTR $T58[ebp]
  000a2	3b 45 4c	 cmp	 eax, DWORD PTR $T57[ebp]
  000a5	73 08		 jae	 SHORT $LN56@Growmap
  000a7	8d 45 50	 lea	 eax, DWORD PTR $T58[ebp]
  000aa	89 45 48	 mov	 DWORD PTR tv232[ebp], eax
  000ad	eb 06		 jmp	 SHORT $LN57@Growmap
$LN56@Growmap:
  000af	8d 45 4c	 lea	 eax, DWORD PTR $T57[ebp]
  000b2	89 45 48	 mov	 DWORD PTR tv232[ebp], eax
$LN57@Growmap:
  000b5	8b 45 48	 mov	 eax, DWORD PTR tv232[ebp]
  000b8	89 45 1c	 mov	 DWORD PTR $T47[ebp], eax
  000bb	8b 45 1c	 mov	 eax, DWORD PTR $T47[ebp]
  000be	89 45 18	 mov	 DWORD PTR $T46[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1005 :         return (_STD min)(

  000c1	8b 45 18	 mov	 eax, DWORD PTR $T46[ebp]
  000c4	8b 00		 mov	 eax, DWORD PTR [eax]
  000c6	89 45 14	 mov	 DWORD PTR $T45[ebp], eax

; 1436 :             // scale _Newsize to 2^N >= _Mapsize() + _Count
; 1437 :             if (max_size() / _DEQUESIZ - _Newsize < _Newsize) {

  000c9	8b 45 14	 mov	 eax, DWORD PTR $T45[ebp]
  000cc	c1 e8 02	 shr	 eax, 2
  000cf	2b 45 64	 sub	 eax, DWORD PTR __Newsize$[ebp]
  000d2	3b 45 64	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  000d5	73 08		 jae	 SHORT $LN5@Growmap

; 1438 :                 _Xlen(); // result too long

  000d7	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	e8 00 00 00 00	 call	 ?_Xlen@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@ABEXXZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Xlen
$LN5@Growmap:

; 1439 :             }
; 1440 : 
; 1441 :             _Newsize *= 2;

  000df	8b 45 64	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000e2	d1 e0		 shl	 eax, 1
  000e4	89 45 64	 mov	 DWORD PTR __Newsize$[ebp], eax

; 1442 :         }

  000e7	e9 6e ff ff ff	 jmp	 $LN2@Growmap
$LN3@Growmap:

; 1530 :         return _Mypair._Myval2;

  000ec	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	89 45 10	 mov	 DWORD PTR $T44[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  000f2	8b 45 10	 mov	 eax, DWORD PTR $T44[ebp]
  000f5	83 c0 08	 add	 eax, 8
  000f8	89 45 0c	 mov	 DWORD PTR $T43[ebp], eax

; 1443 :         _Count = _Newsize - _Mapsize();

  000fb	8b 45 0c	 mov	 eax, DWORD PTR $T43[ebp]
  000fe	8b 4d 64	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00101	2b 08		 sub	 ecx, DWORD PTR [eax]
  00103	89 4d 7c	 mov	 DWORD PTR __Count$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00106	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00109	89 45 08	 mov	 DWORD PTR $T42[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0010c	8b 45 08	 mov	 eax, DWORD PTR $T42[ebp]
  0010f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00112	89 45 04	 mov	 DWORD PTR $T41[ebp], eax

; 1444 : 
; 1445 :         size_type _Myboff = _Myoff() / _DEQUESIZ;

  00115	8b 45 04	 mov	 eax, DWORD PTR $T41[ebp]
  00118	8b 00		 mov	 eax, DWORD PTR [eax]
  0011a	c1 e8 02	 shr	 eax, 2
  0011d	89 45 68	 mov	 DWORD PTR __Myboff$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00120	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00123	89 45 00	 mov	 DWORD PTR $T40[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00126	8b 45 00	 mov	 eax, DWORD PTR $T40[ebp]
  00129	83 c0 08	 add	 eax, 8
  0012c	89 45 fc	 mov	 DWORD PTR $T39[ebp], eax

; 1446 :         _Mapptr _Newmap   = _Almap.allocate(_Mapsize() + _Count);

  0012f	8b 45 fc	 mov	 eax, DWORD PTR $T39[ebp]
  00132	8b 00		 mov	 eax, DWORD PTR [eax]
  00134	03 45 7c	 add	 eax, DWORD PTR __Count$[ebp]
  00137	89 45 44	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0013a	c6 45 5f 01	 mov	 BYTE PTR __Overflow_is_possible$59[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0013e	c7 85 60 ff ff
	ff ff ff ff 3f	 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  00148	81 7d 44 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0014f	76 05		 jbe	 SHORT $LN80@Growmap

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00151	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN80@Growmap:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00156	8b 45 44	 mov	 eax, DWORD PTR __Count$[ebp]
  00159	c1 e0 02	 shl	 eax, 2
  0015c	89 45 f8	 mov	 DWORD PTR $T38[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0015f	ff 75 f8	 push	 DWORD PTR $T38[ebp]
  00162	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00167	59		 pop	 ecx
  00168	89 45 60	 mov	 DWORD PTR __Newmap$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1447 :         _Mapptr _Myptr    = _Newmap + _Myboff;

  0016b	8b 45 68	 mov	 eax, DWORD PTR __Myboff$[ebp]
  0016e	8b 4d 60	 mov	 ecx, DWORD PTR __Newmap$[ebp]
  00171	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00174	89 45 6c	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00177	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0017a	89 45 f4	 mov	 DWORD PTR $T37[ebp], eax

; 1538 :         return _Get_data()._Map;

  0017d	8b 45 f4	 mov	 eax, DWORD PTR $T37[ebp]
  00180	83 c0 04	 add	 eax, 4
  00183	89 45 e4	 mov	 DWORD PTR $T33[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00186	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00189	89 45 f0	 mov	 DWORD PTR $T36[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0018c	8b 45 f0	 mov	 eax, DWORD PTR $T36[ebp]
  0018f	83 c0 08	 add	 eax, 8
  00192	89 45 e8	 mov	 DWORD PTR $T34[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00195	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00198	89 45 ec	 mov	 DWORD PTR $T35[ebp], eax

; 1538 :         return _Get_data()._Map;

  0019b	8b 45 ec	 mov	 eax, DWORD PTR $T35[ebp]
  0019e	83 c0 04	 add	 eax, 4
  001a1	89 45 e0	 mov	 DWORD PTR $T32[ebp], eax

; 1448 : 
; 1449 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

  001a4	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  001a7	8b 45 e8	 mov	 eax, DWORD PTR $T34[ebp]
  001aa	8b 00		 mov	 eax, DWORD PTR [eax]
  001ac	8b 4d e4	 mov	 ecx, DWORD PTR $T33[ebp]
  001af	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001b1	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  001b4	50		 push	 eax
  001b5	8b 45 e0	 mov	 eax, DWORD PTR $T32[ebp]
  001b8	8b 00		 mov	 eax, DWORD PTR [eax]
  001ba	8b 4d 68	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  001bd	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0PAPAPAU12@@Z ; std::uninitialized_copy<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>
  001c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c9	89 45 6c	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1450 :         if (_Myboff <= _Count) { // increment greater than offset of initial block

  001cc	8b 45 68	 mov	 eax, DWORD PTR __Myboff$[ebp]
  001cf	3b 45 7c	 cmp	 eax, DWORD PTR __Count$[ebp]
  001d2	77 60		 ja	 SHORT $LN6@Growmap

; 1530 :         return _Mypair._Myval2;

  001d4	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001d7	89 45 dc	 mov	 DWORD PTR $T31[ebp], eax

; 1538 :         return _Get_data()._Map;

  001da	8b 45 dc	 mov	 eax, DWORD PTR $T31[ebp]
  001dd	83 c0 04	 add	 eax, 4
  001e0	89 45 d4	 mov	 DWORD PTR $T29[ebp], eax

; 1530 :         return _Mypair._Myval2;

  001e3	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001e6	89 45 d8	 mov	 DWORD PTR $T30[ebp], eax

; 1538 :         return _Get_data()._Map;

  001e9	8b 45 d8	 mov	 eax, DWORD PTR $T30[ebp]
  001ec	83 c0 04	 add	 eax, 4
  001ef	89 45 d0	 mov	 DWORD PTR $T28[ebp], eax

; 1451 :             _Myptr = _STD uninitialized_copy(_Map(), _Map() + _Myboff, _Myptr); // copy rest of old

  001f2	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  001f5	8b 45 d4	 mov	 eax, DWORD PTR $T29[ebp]
  001f8	8b 00		 mov	 eax, DWORD PTR [eax]
  001fa	8b 4d 68	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  001fd	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00200	50		 push	 eax
  00201	8b 45 d0	 mov	 eax, DWORD PTR $T28[ebp]
  00204	ff 30		 push	 DWORD PTR [eax]
  00206	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0PAPAPAU12@@Z ; std::uninitialized_copy<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>
  0020b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020e	89 45 6c	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1452 :             _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count - _Myboff); // clear suffix of new

  00211	8b 45 7c	 mov	 eax, DWORD PTR __Count$[ebp]
  00214	2b 45 68	 sub	 eax, DWORD PTR __Myboff$[ebp]
  00217	50		 push	 eax
  00218	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  0021b	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n_unchecked1@PAPAPAUSData@CFileLoaderThread@@I@std@@YAPAPAPAUSData@CFileLoaderThread@@PAPAPAU12@I@Z ; std::_Uninitialized_value_construct_n_unchecked1<CFileLoaderThread::SData * * *,unsigned int>
  00220	59		 pop	 ecx
  00221	59		 pop	 ecx

; 1453 :             _Uninitialized_value_construct_n_unchecked1(_Newmap, _Myboff); // clear prefix of new

  00222	ff 75 68	 push	 DWORD PTR __Myboff$[ebp]
  00225	ff 75 60	 push	 DWORD PTR __Newmap$[ebp]
  00228	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n_unchecked1@PAPAPAUSData@CFileLoaderThread@@I@std@@YAPAPAPAUSData@CFileLoaderThread@@PAPAPAU12@I@Z ; std::_Uninitialized_value_construct_n_unchecked1<CFileLoaderThread::SData * * *,unsigned int>
  0022d	59		 pop	 ecx
  0022e	59		 pop	 ecx

; 1454 :         } else { // increment not greater than offset of initial block

  0022f	e9 8b 00 00 00	 jmp	 $LN7@Growmap
$LN6@Growmap:

; 1530 :         return _Mypair._Myval2;

  00234	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00237	89 45 cc	 mov	 DWORD PTR $T27[ebp], eax

; 1538 :         return _Get_data()._Map;

  0023a	8b 45 cc	 mov	 eax, DWORD PTR $T27[ebp]
  0023d	83 c0 04	 add	 eax, 4
  00240	89 45 c4	 mov	 DWORD PTR $T25[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00243	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00246	89 45 c8	 mov	 DWORD PTR $T26[ebp], eax

; 1538 :         return _Get_data()._Map;

  00249	8b 45 c8	 mov	 eax, DWORD PTR $T26[ebp]
  0024c	83 c0 04	 add	 eax, 4
  0024f	89 45 c0	 mov	 DWORD PTR $T24[ebp], eax

; 1455 :             _STD uninitialized_copy(_Map(), _Map() + _Count, _Myptr); // copy more old

  00252	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  00255	8b 45 c4	 mov	 eax, DWORD PTR $T25[ebp]
  00258	8b 00		 mov	 eax, DWORD PTR [eax]
  0025a	8b 4d 7c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0025d	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00260	50		 push	 eax
  00261	8b 45 c0	 mov	 eax, DWORD PTR $T24[ebp]
  00264	ff 30		 push	 DWORD PTR [eax]
  00266	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0PAPAPAU12@@Z ; std::uninitialized_copy<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>
  0026b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1530 :         return _Mypair._Myval2;

  0026e	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00271	89 45 bc	 mov	 DWORD PTR $T23[ebp], eax

; 1538 :         return _Get_data()._Map;

  00274	8b 45 bc	 mov	 eax, DWORD PTR $T23[ebp]
  00277	83 c0 04	 add	 eax, 4
  0027a	89 45 b4	 mov	 DWORD PTR $T21[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0027d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00280	89 45 b8	 mov	 DWORD PTR $T22[ebp], eax

; 1538 :         return _Get_data()._Map;

  00283	8b 45 b8	 mov	 eax, DWORD PTR $T22[ebp]
  00286	83 c0 04	 add	 eax, 4
  00289	89 45 b0	 mov	 DWORD PTR $T20[ebp], eax

; 1456 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

  0028c	ff 75 60	 push	 DWORD PTR __Newmap$[ebp]
  0028f	8b 45 b4	 mov	 eax, DWORD PTR $T21[ebp]
  00292	8b 00		 mov	 eax, DWORD PTR [eax]
  00294	8b 4d 68	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  00297	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0029a	50		 push	 eax
  0029b	8b 45 b0	 mov	 eax, DWORD PTR $T20[ebp]
  0029e	8b 00		 mov	 eax, DWORD PTR [eax]
  002a0	8b 4d 7c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002a3	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  002a6	50		 push	 eax
  002a7	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@0PAPAPAU12@@Z ; std::uninitialized_copy<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>
  002ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  002af	89 45 6c	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1457 :             _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count); // clear rest to initial block

  002b2	ff 75 7c	 push	 DWORD PTR __Count$[ebp]
  002b5	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  002b8	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n_unchecked1@PAPAPAUSData@CFileLoaderThread@@I@std@@YAPAPAPAUSData@CFileLoaderThread@@PAPAPAU12@I@Z ; std::_Uninitialized_value_construct_n_unchecked1<CFileLoaderThread::SData * * *,unsigned int>
  002bd	59		 pop	 ecx
  002be	59		 pop	 ecx
$LN7@Growmap:

; 1530 :         return _Mypair._Myval2;

  002bf	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  002c2	89 45 ac	 mov	 DWORD PTR $T19[ebp], eax

; 1538 :         return _Get_data()._Map;

  002c5	8b 45 ac	 mov	 eax, DWORD PTR $T19[ebp]
  002c8	83 c0 04	 add	 eax, 4
  002cb	89 45 9c	 mov	 DWORD PTR $T15[ebp], eax

; 1530 :         return _Mypair._Myval2;

  002ce	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  002d1	89 45 a8	 mov	 DWORD PTR $T18[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  002d4	8b 45 a8	 mov	 eax, DWORD PTR $T18[ebp]
  002d7	83 c0 08	 add	 eax, 8
  002da	89 45 a0	 mov	 DWORD PTR $T16[ebp], eax

; 1530 :         return _Mypair._Myval2;

  002dd	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  002e0	89 45 a4	 mov	 DWORD PTR $T17[ebp], eax

; 1538 :         return _Get_data()._Map;

  002e3	8b 45 a4	 mov	 eax, DWORD PTR $T17[ebp]
  002e6	83 c0 04	 add	 eax, 4
  002e9	89 45 98	 mov	 DWORD PTR $T14[ebp], eax

; 1458 :         }
; 1459 : 
; 1460 :         _Destroy_range(_Map() + _Myboff, _Map() + _Mapsize());

  002ec	8b 45 a0	 mov	 eax, DWORD PTR $T16[ebp]
  002ef	8b 00		 mov	 eax, DWORD PTR [eax]
  002f1	8b 4d 9c	 mov	 ecx, DWORD PTR $T15[ebp]
  002f4	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002f6	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  002f9	50		 push	 eax
  002fa	8b 45 98	 mov	 eax, DWORD PTR $T14[ebp]
  002fd	8b 00		 mov	 eax, DWORD PTR [eax]
  002ff	8b 4d 68	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  00302	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00305	50		 push	 eax
  00306	e8 00 00 00 00	 call	 ??$_Destroy_range@PAPAPAUSData@CFileLoaderThread@@PAPAPAU12@@std@@YAXPAPAPAUSData@CFileLoaderThread@@QAPAPAU12@@Z ; std::_Destroy_range<CFileLoaderThread::SData * * *,CFileLoaderThread::SData * * *>
  0030b	59		 pop	 ecx
  0030c	59		 pop	 ecx

; 1530 :         return _Mypair._Myval2;

  0030d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00310	89 45 94	 mov	 DWORD PTR $T13[ebp], eax

; 1538 :         return _Get_data()._Map;

  00313	8b 45 94	 mov	 eax, DWORD PTR $T13[ebp]
  00316	83 c0 04	 add	 eax, 4
  00319	89 45 90	 mov	 DWORD PTR $T12[ebp], eax

; 1461 :         if (_Map() != _Mapptr()) {

  0031c	8b 45 90	 mov	 eax, DWORD PTR $T12[ebp]
  0031f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00322	74 4b		 je	 SHORT $LN8@Growmap

; 1530 :         return _Mypair._Myval2;

  00324	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00327	89 45 8c	 mov	 DWORD PTR $T11[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0032a	8b 45 8c	 mov	 eax, DWORD PTR $T11[ebp]
  0032d	83 c0 08	 add	 eax, 8
  00330	89 45 84	 mov	 DWORD PTR $T9[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00333	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00336	89 45 88	 mov	 DWORD PTR $T10[ebp], eax

; 1538 :         return _Get_data()._Map;

  00339	8b 45 88	 mov	 eax, DWORD PTR $T10[ebp]
  0033c	83 c0 04	 add	 eax, 4
  0033f	89 45 80	 mov	 DWORD PTR $T8[ebp], eax

; 1462 :             _Almap.deallocate(_Map(), _Mapsize()); // free storage for old

  00342	8b 45 84	 mov	 eax, DWORD PTR $T9[ebp]
  00345	8b 00		 mov	 eax, DWORD PTR [eax]
  00347	89 85 7c ff ff
	ff		 mov	 DWORD PTR __Count$[ebp], eax
  0034d	8b 45 80	 mov	 eax, DWORD PTR $T8[ebp]
  00350	8b 00		 mov	 eax, DWORD PTR [eax]
  00352	89 85 78 ff ff
	ff		 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00358	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR __Count$[ebp]
  0035e	c1 e0 02	 shl	 eax, 2
  00361	50		 push	 eax
  00362	ff b5 78 ff ff
	ff		 push	 DWORD PTR __Ptr$[ebp]
  00368	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0036d	59		 pop	 ecx
  0036e	59		 pop	 ecx
$LN8@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  0036f	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00372	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax

; 1538 :         return _Get_data()._Map;

  00378	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  0037e	83 c0 04	 add	 eax, 4
  00381	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax

; 1463 :         }
; 1464 : 
; 1465 :         _Map() = _Newmap; // point at new

  00387	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  0038d	8b 4d 60	 mov	 ecx, DWORD PTR __Newmap$[ebp]
  00390	89 08		 mov	 DWORD PTR [eax], ecx

; 1466 :         _Mapsize() += _Count;

  00392	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00398	89 45 58	 mov	 DWORD PTR tv214[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0039b	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0039e	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  003a4	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  003aa	83 c0 08	 add	 eax, 8
  003ad	89 45 58	 mov	 DWORD PTR tv214[ebp], eax

; 1466 :         _Mapsize() += _Count;

  003b0	8b 45 58	 mov	 eax, DWORD PTR tv214[ebp]
  003b3	8b 00		 mov	 eax, DWORD PTR [eax]
  003b5	03 45 7c	 add	 eax, DWORD PTR __Count$[ebp]
  003b8	8b 4d 58	 mov	 ecx, DWORD PTR tv214[ebp]
  003bb	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Growmap:

; 1467 :     }

  003bd	83 c5 74	 add	 ebp, 116		; 00000074H
  003c0	c9		 leave
  003c1	c2 04 00	 ret	 4
?_Growmap@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXI@Z ENDP ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?_Xlen@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@ABEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@ABEXXZ PROC ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Xlen, COMDAT
; _this$ = ecx

; 1422 :     [[noreturn]] void _Xlen() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1423 :         _Xlength_error("deque<T> too long");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
  0000c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1424 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Xlen@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@ABEXXZ ENDP ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?pop_back@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
$T6 = -60						; size = 4
$T7 = -56						; size = 4
__Ptr$ = -52						; size = 4
__Block$ = -48						; size = 4
$T8 = -44						; size = 4
$T9 = -40						; size = 4
$T10 = -36						; size = 4
$T11 = -32						; size = 4
$T12 = -28						; size = 4
$T13 = -24						; size = 4
$T14 = -20						; size = 4
$T15 = -16						; size = 4
__Newoff$ = -12						; size = 4
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?pop_back@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEXXZ PROC ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::pop_back, COMDAT
; _this$ = ecx

; 1126 :     void pop_back() noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T15[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T15[ebp]
  00012	83 c0 0c	 add	 eax, 12			; 0000000cH
  00015	89 45 e8	 mov	 DWORD PTR $T13[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	89 45 ec	 mov	 DWORD PTR $T14[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  0001e	8b 45 ec	 mov	 eax, DWORD PTR $T14[ebp]
  00021	83 c0 10	 add	 eax, 16			; 00000010H
  00024	89 45 e4	 mov	 DWORD PTR $T12[ebp], eax

; 1127 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1128 :         if (empty()) {
; 1129 :             _STL_REPORT_ERROR("deque empty before pop");
; 1130 :         } else { // something to erase, do it
; 1131 :             size_type _Newoff = _Myoff() + _Mysize() - 1;
; 1132 :             _Orphan_off(_Newoff);
; 1133 :             size_type _Block = _Getblock(_Newoff);
; 1134 :             _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1135 :             if (--_Mysize() == 0) {
; 1136 :                 _Myoff() = 0;
; 1137 :             }
; 1138 :         }
; 1139 : 
; 1140 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1141 :         size_type _Newoff = _Myoff() + _Mysize() - 1;

  00027	8b 45 e8	 mov	 eax, DWORD PTR $T13[ebp]
  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	8b 4d e4	 mov	 ecx, DWORD PTR $T12[ebp]
  0002f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00031	8d 44 08 ff	 lea	 eax, DWORD PTR [eax+ecx-1]
  00035	89 45 f4	 mov	 DWORD PTR __Newoff$[ebp], eax

; 1534 :         return _Mypair._Myval2;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T11[ebp], eax

; 548  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  0003e	8b 45 f4	 mov	 eax, DWORD PTR __Newoff$[ebp]
  00041	c1 e8 02	 shr	 eax, 2
  00044	8b 4d e0	 mov	 ecx, DWORD PTR $T11[ebp]
  00047	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0004a	49		 dec	 ecx
  0004b	23 c1		 and	 eax, ecx
  0004d	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax

; 1514 :         return _Get_data()._Getblock(_Off);

  00050	8b 45 dc	 mov	 eax, DWORD PTR $T10[ebp]
  00053	89 45 d0	 mov	 DWORD PTR __Block$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	89 45 d8	 mov	 DWORD PTR $T9[ebp], eax

; 1538 :         return _Get_data()._Map;

  0005c	8b 45 d8	 mov	 eax, DWORD PTR $T9[ebp]
  0005f	83 c0 04	 add	 eax, 4
  00062	89 45 d4	 mov	 DWORD PTR $T8[ebp], eax

; 1142 :         size_type _Block  = _Getblock(_Newoff);
; 1143 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _DEQUESIZ));

  00065	8b 45 f4	 mov	 eax, DWORD PTR __Newoff$[ebp]
  00068	33 d2		 xor	 edx, edx
  0006a	6a 04		 push	 4
  0006c	59		 pop	 ecx
  0006d	f7 f1		 div	 ecx
  0006f	8b 45 d4	 mov	 eax, DWORD PTR $T8[ebp]
  00072	8b 00		 mov	 eax, DWORD PTR [eax]
  00074	8b 4d d0	 mov	 ecx, DWORD PTR __Block$[ebp]
  00077	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0007a	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  0007d	89 45 cc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00080	8b 45 cc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00083	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00089	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  0008c	8b 45 c8	 mov	 eax, DWORD PTR $T7[ebp]
  0008f	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax

; 1144 :         if (--_Mysize() == 0) {

  00092	8b 45 b0	 mov	 eax, DWORD PTR $T1[ebp]
  00095	89 45 f8	 mov	 DWORD PTR tv88[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  0009e	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000a1	83 c0 10	 add	 eax, 16			; 00000010H
  000a4	89 45 f8	 mov	 DWORD PTR tv88[ebp], eax

; 1144 :         if (--_Mysize() == 0) {

  000a7	8b 45 f8	 mov	 eax, DWORD PTR tv88[ebp]
  000aa	8b 00		 mov	 eax, DWORD PTR [eax]
  000ac	48		 dec	 eax
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR tv88[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax
  000b2	8b 45 f8	 mov	 eax, DWORD PTR tv88[ebp]
  000b5	83 38 00	 cmp	 DWORD PTR [eax], 0
  000b8	75 15		 jne	 SHORT $LN3@pop_back

; 1530 :         return _Mypair._Myval2;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  000c0	8b 45 c0	 mov	 eax, DWORD PTR $T5[ebp]
  000c3	83 c0 0c	 add	 eax, 12			; 0000000cH
  000c6	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax

; 1145 :             _Myoff() = 0;

  000c9	8b 45 bc	 mov	 eax, DWORD PTR $T4[ebp]
  000cc	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@pop_back:

; 1146 :         }
; 1147 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1148 :     }

  000cf	c9		 leave
  000d0	c3		 ret	 0
?pop_back@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEXXZ ENDP ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?pop_front@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -92						; size = 4
$T2 = -88						; size = 4
$T3 = -84						; size = 4
$T4 = -80						; size = 4
$T5 = -76						; size = 4
$T6 = -72						; size = 4
$T7 = -68						; size = 4
$T8 = -64						; size = 4
$T9 = -60						; size = 4
__Ptr$ = -56						; size = 4
__Block$ = -52						; size = 4
$T10 = -48						; size = 4
$T11 = -44						; size = 4
$T12 = -40						; size = 4
$T13 = -36						; size = 4
$T14 = -32						; size = 4
$T15 = -28						; size = 4
__Off$ = -24						; size = 4
$T16 = -20						; size = 4
$T17 = -16						; size = 4
tv93 = -12						; size = 4
tv86 = -8						; size = 4
_this$ = -4						; size = 4
?pop_front@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEXXZ PROC ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::pop_front, COMDAT
; _this$ = ecx

; 1086 :     void pop_front() noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T17[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T17[ebp]
  00012	83 c0 0c	 add	 eax, 12			; 0000000cH
  00015	89 45 ec	 mov	 DWORD PTR $T16[ebp], eax

; 1087 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1088 :         if (empty()) {
; 1089 :             _STL_REPORT_ERROR("deque empty before pop");
; 1090 :         } else { // something to erase, do it
; 1091 :             _Orphan_off(_Myoff());
; 1092 :             size_type _Block = _Getblock(_Myoff());
; 1093 :             _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Myoff() % _DEQUESIZ));
; 1094 :             if (--_Mysize() == 0) {
; 1095 :                 _Myoff() = 0;
; 1096 :             } else {
; 1097 :                 ++_Myoff();
; 1098 :             }
; 1099 :         }
; 1100 : 
; 1101 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1102 :         size_type _Block = _Getblock(_Myoff());

  00018	8b 45 ec	 mov	 eax, DWORD PTR $T16[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	89 45 e8	 mov	 DWORD PTR __Off$[ebp], eax

; 1534 :         return _Mypair._Myval2;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 45 e4	 mov	 DWORD PTR $T15[ebp], eax

; 548  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00026	8b 45 e8	 mov	 eax, DWORD PTR __Off$[ebp]
  00029	c1 e8 02	 shr	 eax, 2
  0002c	8b 4d e4	 mov	 ecx, DWORD PTR $T15[ebp]
  0002f	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00032	49		 dec	 ecx
  00033	23 c1		 and	 eax, ecx
  00035	89 45 e0	 mov	 DWORD PTR $T14[ebp], eax

; 1514 :         return _Get_data()._Getblock(_Off);

  00038	8b 45 e0	 mov	 eax, DWORD PTR $T14[ebp]
  0003b	89 45 cc	 mov	 DWORD PTR __Block$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T13[ebp], eax

; 1538 :         return _Get_data()._Map;

  00044	8b 45 dc	 mov	 eax, DWORD PTR $T13[ebp]
  00047	83 c0 04	 add	 eax, 4
  0004a	89 45 d0	 mov	 DWORD PTR $T10[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	89 45 d8	 mov	 DWORD PTR $T12[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  00053	8b 45 d8	 mov	 eax, DWORD PTR $T12[ebp]
  00056	83 c0 0c	 add	 eax, 12			; 0000000cH
  00059	89 45 d4	 mov	 DWORD PTR $T11[ebp], eax

; 1103 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Myoff() % _DEQUESIZ));

  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T11[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	33 d2		 xor	 edx, edx
  00063	6a 04		 push	 4
  00065	59		 pop	 ecx
  00066	f7 f1		 div	 ecx
  00068	8b 45 d0	 mov	 eax, DWORD PTR $T10[ebp]
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	8b 4d cc	 mov	 ecx, DWORD PTR __Block$[ebp]
  00070	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00073	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  00076	89 45 c8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00079	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0007c	89 45 b0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00082	89 45 c4	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00085	8b 45 c4	 mov	 eax, DWORD PTR $T9[ebp]
  00088	89 45 ac	 mov	 DWORD PTR $T3[ebp], eax

; 1104 :         if (--_Mysize() == 0) {

  0008b	8b 45 a8	 mov	 eax, DWORD PTR $T2[ebp]
  0008e	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	89 45 c0	 mov	 DWORD PTR $T8[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  00097	8b 45 c0	 mov	 eax, DWORD PTR $T8[ebp]
  0009a	83 c0 10	 add	 eax, 16			; 00000010H
  0009d	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax

; 1104 :         if (--_Mysize() == 0) {

  000a0	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  000a3	8b 00		 mov	 eax, DWORD PTR [eax]
  000a5	48		 dec	 eax
  000a6	8b 4d f8	 mov	 ecx, DWORD PTR tv86[ebp]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
  000ab	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  000ae	83 38 00	 cmp	 DWORD PTR [eax], 0
  000b1	75 17		 jne	 SHORT $LN2@pop_front

; 1530 :         return _Mypair._Myval2;

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	89 45 bc	 mov	 DWORD PTR $T7[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  000b9	8b 45 bc	 mov	 eax, DWORD PTR $T7[ebp]
  000bc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000bf	89 45 b8	 mov	 DWORD PTR $T6[ebp], eax

; 1105 :             _Myoff() = 0;

  000c2	8b 45 b8	 mov	 eax, DWORD PTR $T6[ebp]
  000c5	83 20 00	 and	 DWORD PTR [eax], 0

; 1106 :         } else {

  000c8	eb 20		 jmp	 SHORT $LN4@pop_front
$LN2@pop_front:

; 1107 :             ++_Myoff();

  000ca	8b 45 a4	 mov	 eax, DWORD PTR $T1[ebp]
  000cd	89 45 f4	 mov	 DWORD PTR tv93[ebp], eax

; 1530 :         return _Mypair._Myval2;

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	89 45 b4	 mov	 DWORD PTR $T5[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  000d6	8b 45 b4	 mov	 eax, DWORD PTR $T5[ebp]
  000d9	83 c0 0c	 add	 eax, 12			; 0000000cH
  000dc	89 45 f4	 mov	 DWORD PTR tv93[ebp], eax

; 1107 :             ++_Myoff();

  000df	8b 45 f4	 mov	 eax, DWORD PTR tv93[ebp]
  000e2	8b 00		 mov	 eax, DWORD PTR [eax]
  000e4	40		 inc	 eax
  000e5	8b 4d f4	 mov	 ecx, DWORD PTR tv93[ebp]
  000e8	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@pop_front:

; 1108 :         }
; 1109 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1110 :     }

  000ea	c9		 leave
  000eb	c3		 ret	 0
?pop_front@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEXXZ ENDP ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::pop_front
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?front@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEAAPAUSData@CFileLoaderThread@@XZ
_TEXT	SEGMENT
$T1 = -40						; size = 8
$T2 = -32						; size = 4
$T3 = -28						; size = 4
___param0$ = -24					; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
$T7 = -8						; size = 4
_this$ = -4						; size = 4
?front@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEAAPAUSData@CFileLoaderThread@@XZ PROC ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::front, COMDAT
; _this$ = ecx

; 1047 :     _NODISCARD reference front() noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0001b	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  0001e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00021	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax

; 914  :         return _Unchecked_iterator(_Myoff(), _STD addressof(_Get_data()));

  00024	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 52   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

  0002c	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  0002f	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
  00032	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00035	89 45 dc	 mov	 DWORD PTR $T1[ebp+4], eax

; 914  :         return _Unchecked_iterator(_Myoff(), _STD addressof(_Get_data()));

  00038	8d 45 d8	 lea	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 171  :         return const_cast<reference>(_Mybase::operator*());

  0003e	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  00041	e8 00 00 00 00	 call	 ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@std@@QBEABQAUSData@CFileLoaderThread@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> > >::operator*
  00046	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax

; 1048 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1049 :         _STL_VERIFY(!empty(), "front() called on empty deque");
; 1050 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1051 : 
; 1052 :         return *_Unchecked_begin();

  00049	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]

; 1053 :     }

  0004c	c9		 leave
  0004d	c3		 ret	 0
?front@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEAAPAUSData@CFileLoaderThread@@XZ ENDP ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::front
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?end@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Parent_proxy$1 = -36					; size = 4
___param0$ = -32					; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
$T7 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@2@XZ PROC ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::end, COMDAT
; _this$ = ecx

; 905  :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  00012	89 45 f8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0001b	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  0001e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00021	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  0002a	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  0002d	83 c0 10	 add	 eax, 16			; 00000010H
  00030	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 906  :         return iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  00033	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  0003b	03 01		 add	 eax, DWORD PTR [ecx]
  0003d	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1126 :     _Iterator_base12() noexcept : _Myproxy(nullptr), _Mynextiter(nullptr) {} // construct orphaned iterator

  00040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00043	83 20 00	 and	 DWORD PTR [eax], 0
  00046	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00049	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 256  :     _Deque_const_iterator(_Size_type _Off, const _Container_base12* _Pdeque) noexcept : _Myoff(_Off) {

  0004d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00050	8b 4d e0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00053	89 48 08	 mov	 DWORD PTR [eax+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1157 :         if (_Parent) {

  00056	83 7d f8 00	 cmp	 DWORD PTR $T7[ebp], 0
  0005a	74 12		 je	 SHORT $LN34@end

; 1158 :             // have a parent, do adoption
; 1159 :             _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  0005c	8b 45 f8	 mov	 eax, DWORD PTR $T7[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	89 45 dc	 mov	 DWORD PTR __Parent_proxy$1[ebp], eax

; 1160 : 
; 1161 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1162 :             if (_Myproxy != _Parent_proxy) { // change parentage
; 1163 :                 _Lockit _Lock(_LOCK_DEBUG);
; 1164 :                 _Orphan_me();
; 1165 :                 _Mynextiter                 = _Parent_proxy->_Myfirstiter;
; 1166 :                 _Parent_proxy->_Myfirstiter = this;
; 1167 :                 _Myproxy                    = _Parent_proxy;
; 1168 :             }
; 1169 : 
; 1170 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1171 :             _Myproxy = _Parent_proxy;

  00064	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00067	8b 4d dc	 mov	 ecx, DWORD PTR __Parent_proxy$1[ebp]
  0006a	89 08		 mov	 DWORD PTR [eax], ecx

; 1172 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1173 :         } else {

  0006c	eb 06		 jmp	 SHORT $LN22@end
$LN34@end:

; 1174 :             // no future parent, just disown current parent
; 1175 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1176 :             _Lockit _Lock(_LOCK_DEBUG);
; 1177 :             _Orphan_me();
; 1178 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1179 :             _Myproxy = nullptr;

  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00071	83 20 00	 and	 DWORD PTR [eax], 0
$LN22@end:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 906  :         return iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  00074	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 907  :     }

  00077	c9		 leave
  00078	c2 04 00	 ret	 4
?end@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@2@XZ ENDP ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::end
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?begin@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Parent_proxy$1 = -28					; size = 4
___param0$ = -24					; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
$T5 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@2@XZ PROC ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::begin, COMDAT
; _this$ = ecx

; 897  :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T4[ebp]
  00012	89 45 f8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0001b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0001e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00021	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax

; 898  :         return iterator(_Myoff(), _STD addressof(_Get_data()));

  00024	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1126 :     _Iterator_base12() noexcept : _Myproxy(nullptr), _Mynextiter(nullptr) {} // construct orphaned iterator

  0002c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002f	83 20 00	 and	 DWORD PTR [eax], 0
  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00035	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 256  :     _Deque_const_iterator(_Size_type _Off, const _Container_base12* _Pdeque) noexcept : _Myoff(_Off) {

  00039	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003c	8b 4d e8	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0003f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1157 :         if (_Parent) {

  00042	83 7d f8 00	 cmp	 DWORD PTR $T5[ebp], 0
  00046	74 12		 je	 SHORT $LN28@begin

; 1158 :             // have a parent, do adoption
; 1159 :             _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  00048	8b 45 f8	 mov	 eax, DWORD PTR $T5[ebp]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	89 45 e4	 mov	 DWORD PTR __Parent_proxy$1[ebp], eax

; 1160 : 
; 1161 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1162 :             if (_Myproxy != _Parent_proxy) { // change parentage
; 1163 :                 _Lockit _Lock(_LOCK_DEBUG);
; 1164 :                 _Orphan_me();
; 1165 :                 _Mynextiter                 = _Parent_proxy->_Myfirstiter;
; 1166 :                 _Parent_proxy->_Myfirstiter = this;
; 1167 :                 _Myproxy                    = _Parent_proxy;
; 1168 :             }
; 1169 : 
; 1170 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1171 :             _Myproxy = _Parent_proxy;

  00050	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00053	8b 4d e4	 mov	 ecx, DWORD PTR __Parent_proxy$1[ebp]
  00056	89 08		 mov	 DWORD PTR [eax], ecx

; 1172 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1173 :         } else {

  00058	eb 06		 jmp	 SHORT $LN16@begin
$LN28@begin:

; 1174 :             // no future parent, just disown current parent
; 1175 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1176 :             _Lockit _Lock(_LOCK_DEBUG);
; 1177 :             _Orphan_me();
; 1178 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1179 :             _Myproxy = nullptr;

  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	83 20 00	 and	 DWORD PTR [eax], 0
$LN16@begin:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 898  :         return iterator(_Myoff(), _STD addressof(_Get_data()));

  00060	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 899  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
?begin@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@@2@XZ ENDP ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??1?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
__Old_val$3 = -24					; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
??1?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ PROC ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::~deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >, COMDAT
; _this$ = ecx

; 869  :     ~deque() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 870  :         _Tidy();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Tidy@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXXZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Tidy

; 1522 :         return _Mypair._Get_first();

  00011	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00014	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00017	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  0001a	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax

; 872  :         _Delete_plain_internal(_Proxy_allocator, _STD exchange(_Get_data()._Myproxy, nullptr));

  0001d	83 65 ec 00	 and	 DWORD PTR $T4[ebp], 0

; 1530 :         return _Mypair._Myval2;

  00021	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00027	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	89 45 e8	 mov	 DWORD PTR __Old_val$3[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  0002f	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  00032	8b 4d ec	 mov	 ecx, DWORD PTR $T4[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  00037	8b 45 e8	 mov	 eax, DWORD PTR __Old_val$3[ebp]
  0003a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 872  :         _Delete_plain_internal(_Proxy_allocator, _STD exchange(_Get_data()._Myproxy, nullptr));

  0003d	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  00040	8d 45 ff	 lea	 eax, DWORD PTR __Proxy_allocator$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00049	59		 pop	 ecx
  0004a	59		 pop	 ecx

; 873  :     }

  0004b	c9		 leave
  0004c	c3		 ret	 0
??1?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ENDP ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::~deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??0?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -1						; size = 1
??0?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ PROC ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >, COMDAT
; _this$ = ecx

; 596  :     deque() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Deque_val@U?$_Deque_simple_types@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> >::_Deque_val<std::_Deque_simple_types<CFileLoaderThread::SData *> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00017	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001a	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  0001d	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00020	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax

; 597  :         _Get_data()._Alloc_proxy(static_cast<_Alproxy_ty>(_Getal()));

  00029	8d 45 ff	 lea	 eax, DWORD PTR $T4[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 598  :     }

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c9		 leave
  00039	c3		 ret	 0
??0?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ENDP ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
;	COMDAT ?Process@CFileLoaderThread@@IAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
_pvBuf$ = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
tv151 = -16						; size = 4
_this$ = -12						; size = 4
_pData$ = -8						; size = 4
$T6 = -1						; size = 1
?Process@CFileLoaderThread@@IAEXXZ PROC			; CFileLoaderThread::Process, COMDAT
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 153  : 	m_RequestMutex.Lock();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 20	 add	 ecx, 32			; 00000020H
  0000f	e8 00 00 00 00	 call	 ?Lock@Mutex@@QAEXXZ	; Mutex::Lock
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1534 :         return _Mypair._Myval2;

  00014	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 c0 0c	 add	 eax, 12			; 0000000cH
  0001a	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  0001d	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00020	83 c0 10	 add	 eax, 16			; 00000010H
  00023	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax

; 1010 :         return _Mysize() == 0;

  00026	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	75 09		 jne	 SHORT $LN7@Process
  0002e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv151[ebp], 1
  00035	eb 04		 jmp	 SHORT $LN8@Process
$LN7@Process:
  00037	83 65 f0 00	 and	 DWORD PTR tv151[ebp], 0
$LN8@Process:
  0003b	8a 45 f0	 mov	 al, BYTE PTR tv151[ebp]
  0003e	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp

; 155  : 	if (m_pRequestDeque.empty())

  00041	0f b6 45 ff	 movzx	 eax, BYTE PTR $T6[ebp]
  00045	85 c0		 test	 eax, eax
  00047	74 10		 je	 SHORT $LN2@Process

; 156  : 	{
; 157  : 		m_RequestMutex.Unlock();

  00049	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	83 c1 20	 add	 ecx, 32			; 00000020H
  0004f	e8 00 00 00 00	 call	 ?Unlock@Mutex@@QAEXXZ	; Mutex::Unlock

; 158  : 		return;

  00054	e9 dd 00 00 00	 jmp	 $LN1@Process
$LN2@Process:

; 159  : 	}
; 160  : 
; 161  : 	TData * pData = m_pRequestDeque.front();

  00059	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0005f	e8 00 00 00 00	 call	 ?front@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEAAPAUSData@CFileLoaderThread@@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::front
  00064	8b 00		 mov	 eax, DWORD PTR [eax]
  00066	89 45 f8	 mov	 DWORD PTR _pData$[ebp], eax

; 162  : 	m_pRequestDeque.pop_front();

  00069	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0006f	e8 00 00 00 00	 call	 ?pop_front@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEXXZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::pop_front

; 163  : 
; 164  : 	m_RequestMutex.Unlock();

  00074	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	83 c1 20	 add	 ecx, 32			; 00000020H
  0007a	e8 00 00 00 00	 call	 ?Unlock@Mutex@@QAEXXZ	; Mutex::Unlock
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00084	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp

; 168  : 	if (CEterPackManager::Instance().Get(pData->File, pData->stFileName.c_str(), &pvBuf))

  00087	8d 45 d8	 lea	 eax, DWORD PTR _pvBuf$[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  0008e	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00093	50		 push	 eax
  00094	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  00097	83 c0 18	 add	 eax, 24			; 00000018H
  0009a	50		 push	 eax
  0009b	8b 4d e0	 mov	 ecx, DWORD PTR $T3[ebp]
  0009e	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get
  000a3	0f b6 c0	 movzx	 eax, al
  000a6	85 c0		 test	 eax, eax
  000a8	74 4f		 je	 SHORT $LN3@Process

; 169  : 	{
; 170  : 		pData->dwSize	= pData->File.Size();

  000aa	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  000ad	83 c1 18	 add	 ecx, 24			; 00000018H
  000b0	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  000b8	89 81 60 01 00
	00		 mov	 DWORD PTR [ecx+352], eax

; 171  : 		pData->pvBuf	= new char [pData->dwSize];

  000be	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  000c1	ff b0 60 01 00
	00		 push	 DWORD PTR [eax+352]
  000c7	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000cc	59		 pop	 ecx
  000cd	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
  000d0	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  000d3	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  000d6	89 88 5c 01 00
	00		 mov	 DWORD PTR [eax+348], ecx

; 172  : 		memcpy(pData->pvBuf, pvBuf, pData->dwSize);

  000dc	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  000df	ff b0 60 01 00
	00		 push	 DWORD PTR [eax+352]
  000e5	ff 75 d8	 push	 DWORD PTR _pvBuf$[ebp]
  000e8	8b 45 f8	 mov	 eax, DWORD PTR _pData$[ebp]
  000eb	ff b0 5c 01 00
	00		 push	 DWORD PTR [eax+348]
  000f1	e8 00 00 00 00	 call	 _memcpy
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@Process:

; 173  : 	}
; 174  : 
; 175  : 	m_CompleteMutex.Lock();

  000f9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	83 c1 4c	 add	 ecx, 76			; 0000004cH
  000ff	e8 00 00 00 00	 call	 ?Lock@Mutex@@QAEXXZ	; Mutex::Lock

; 176  : 	m_pCompleteDeque.push_back(pData);

  00104	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00107	83 c0 38	 add	 eax, 56			; 00000038H
  0010a	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  0010d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00110	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 1123 :         _Emplace_back_internal(_Val);

  00113	8d 45 f8	 lea	 eax, DWORD PTR _pData$[ebp]
  00116	50		 push	 eax
  00117	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	e8 00 00 00 00	 call	 ??$_Emplace_back_internal@ABQAUSData@CFileLoaderThread@@@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXABQAUSData@CFileLoaderThread@@@Z ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Emplace_back_internal<CFileLoaderThread::SData * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp

; 177  : 	m_CompleteMutex.Unlock();

  0011f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00125	e8 00 00 00 00	 call	 ?Unlock@Mutex@@QAEXXZ	; Mutex::Unlock

; 178  : 
; 179  : 	Sleep(g_iLoadingDelayTime);

  0012a	ff 35 00 00 00
	00		 push	 DWORD PTR ?g_iLoadingDelayTime@@3HA ; g_iLoadingDelayTime
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN1@Process:

; 180  : }

  00136	c9		 leave
  00137	c3		 ret	 0
?Process@CFileLoaderThread@@IAEXXZ ENDP			; CFileLoaderThread::Process
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
;	COMDAT ?Destroy@CFileLoaderThread@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Destroy@CFileLoaderThread@@IAEXXZ PROC			; CFileLoaderThread::Destroy, COMDAT
; _this$ = ecx

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 45   : 	if (m_hSemaphore)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  0000e	74 13		 je	 SHORT $LN2@Destroy

; 46   : 	{
; 47   : 		CloseHandle(m_hSemaphore);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	ff 70 64	 push	 DWORD PTR [eax+100]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 48   : 		m_hSemaphore = NULL;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 64 00	 and	 DWORD PTR [eax+100], 0
$LN2@Destroy:

; 49   : 	}
; 50   : 
; 51   : 	stl_wipe(m_pRequestDeque);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c0 0c	 add	 eax, 12			; 0000000cH
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??$stl_wipe@V?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@@@YAXAAV?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@@Z ; stl_wipe<std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> > >
  0002f	59		 pop	 ecx

; 52   : 	stl_wipe(m_pCompleteDeque);

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 c0 38	 add	 eax, 56			; 00000038H
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??$stl_wipe@V?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@@@YAXAAV?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@@Z ; stl_wipe<std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> > >
  0003c	59		 pop	 ecx

; 53   : }

  0003d	c9		 leave
  0003e	c3		 ret	 0
?Destroy@CFileLoaderThread@@IAEXXZ ENDP			; CFileLoaderThread::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
;	COMDAT ?Execute@CFileLoaderThread@@IAEIPAX@Z
_TEXT	SEGMENT
_dwWaitResult$1 = -12					; size = 4
tv74 = -8						; size = 4
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?Execute@CFileLoaderThread@@IAEIPAX@Z PROC		; CFileLoaderThread::Execute, COMDAT
; _this$ = ecx

; 86   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Execute:

; 87   : 	while (!m_bShutdowned)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 40 6c	 movzx	 eax, BYTE PTR [eax+108]
  00010	85 c0		 test	 eax, eax
  00012	75 4c		 jne	 SHORT $LN3@Execute

; 88   : 	{
; 89   : 		DWORD dwWaitResult; 
; 90   : 
; 91   : 		dwWaitResult = WaitForSingleObject(m_hSemaphore, INFINITE);

  00014	6a ff		 push	 -1
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	ff 70 64	 push	 DWORD PTR [eax+100]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  00022	89 45 f4	 mov	 DWORD PTR _dwWaitResult$1[ebp], eax

; 92   : 
; 93   : 		if (m_bShutdowned)

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	0f b6 40 6c	 movzx	 eax, BYTE PTR [eax+108]
  0002c	85 c0		 test	 eax, eax
  0002e	74 02		 je	 SHORT $LN6@Execute

; 94   : 			break;

  00030	eb 2e		 jmp	 SHORT $LN3@Execute
$LN6@Execute:

; 95   : 
; 96   : 		switch (dwWaitResult) 

  00032	8b 45 f4	 mov	 eax, DWORD PTR _dwWaitResult$1[ebp]
  00035	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  00038	83 7d f8 00	 cmp	 DWORD PTR tv74[ebp], 0
  0003c	74 0b		 je	 SHORT $LN7@Execute
  0003e	81 7d f8 02 01
	00 00		 cmp	 DWORD PTR tv74[ebp], 258 ; 00000102H
  00045	74 0c		 je	 SHORT $LN8@Execute
  00047	eb 15		 jmp	 SHORT $LN4@Execute
$LN7@Execute:

; 97   : 		{ 
; 98   : 			case WAIT_OBJECT_0:
; 99   : 				{
; 100  : 					Process();

  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?Process@CFileLoaderThread@@IAEXXZ ; CFileLoaderThread::Process

; 101  : 				}
; 102  : 				break;

  00051	eb 0b		 jmp	 SHORT $LN4@Execute
$LN8@Execute:

; 103  : 
; 104  : 			case WAIT_TIMEOUT:
; 105  : 				TraceError("CFileLoaderThread::Execute: Timeout occured while time-out interval is INIFITE");

  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@NDKNAKHH@CFileLoaderThread?3?3Execute?3?5Tim@
  00058	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0005d	59		 pop	 ecx
$LN4@Execute:

; 106  : 				break;
; 107  : 		}
; 108  : 	}

  0005e	eb a9		 jmp	 SHORT $LN2@Execute
$LN3@Execute:

; 109  : 
; 110  : 	Destroy();

  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?Destroy@CFileLoaderThread@@IAEXXZ ; CFileLoaderThread::Destroy

; 111  : 	return 1;

  00068	33 c0		 xor	 eax, eax
  0006a	40		 inc	 eax

; 112  : }

  0006b	c9		 leave
  0006c	c2 04 00	 ret	 4
?Execute@CFileLoaderThread@@IAEIPAX@Z ENDP		; CFileLoaderThread::Execute
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
;	COMDAT ?Setup@CFileLoaderThread@@IAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Setup@CFileLoaderThread@@IAEIXZ PROC			; CFileLoaderThread::Setup, COMDAT
; _this$ = ecx

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 57   : 	m_hSemaphore = CreateSemaphore(NULL,		// no security attributes

  00007	6a 00		 push	 0
  00009	68 ff ff 00 00	 push	 65535			; 0000ffffH
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSemaphoreA@16
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 58   : 								   0,			// initial count
; 59   : 								   65535,		// maximum count
; 60   : 								   NULL);		// unnamed semaphore
; 61   : 	if (!m_hSemaphore)

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  00025	75 04		 jne	 SHORT $LN2@Setup

; 62   : 		return 0;

  00027	33 c0		 xor	 eax, eax
  00029	eb 03		 jmp	 SHORT $LN1@Setup
$LN2@Setup:

; 63   : 
; 64   : 	return 1;

  0002b	33 c0		 xor	 eax, eax
  0002d	40		 inc	 eax
$LN1@Setup:

; 65   : }

  0002e	c9		 leave
  0002f	c3		 ret	 0
?Setup@CFileLoaderThread@@IAEIXZ ENDP			; CFileLoaderThread::Setup
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
;	COMDAT ?Run@CFileLoaderThread@@IAEIPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_arg$ = 8						; size = 4
?Run@CFileLoaderThread@@IAEIPAX@Z PROC			; CFileLoaderThread::Run, COMDAT
; _this$ = ecx

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 	if (!Setup())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Setup@CFileLoaderThread@@IAEIXZ ; CFileLoaderThread::Setup
  0000f	85 c0		 test	 eax, eax
  00011	75 04		 jne	 SHORT $LN2@Run

; 30   : 		return 0;

  00013	33 c0		 xor	 eax, eax
  00015	eb 0b		 jmp	 SHORT $LN1@Run
$LN2@Run:

; 31   : 
; 32   : 	return (Execute(arg));

  00017	ff 75 08	 push	 DWORD PTR _arg$[ebp]
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?Execute@CFileLoaderThread@@IAEIPAX@Z ; CFileLoaderThread::Execute
$LN1@Run:

; 33   : }

  00022	c9		 leave
  00023	c2 04 00	 ret	 4
?Run@CFileLoaderThread@@IAEIPAX@Z ENDP			; CFileLoaderThread::Run
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
;	COMDAT ?EntryPoint@CFileLoaderThread@@KGIPAX@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_pThread$ = -4						; size = 4
_pThis$ = 8						; size = 4
?EntryPoint@CFileLoaderThread@@KGIPAX@Z PROC		; CFileLoaderThread::EntryPoint, COMDAT

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 38   : 	CFileLoaderThread * pThread = (CFileLoaderThread *) pThis;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pThis$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR _pThread$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.h

; 36   : 		void *					Arg() const		{ return m_pArg; }

  0000b	8b 45 fc	 mov	 eax, DWORD PTR _pThread$[ebp]
  0000e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp

; 39   : 	return pThread->Run(pThread->Arg());

  00014	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _pThread$[ebp]
  0001a	e8 00 00 00 00	 call	 ?Run@CFileLoaderThread@@IAEIPAX@Z ; CFileLoaderThread::Run

; 40   : }

  0001f	c9		 leave
  00020	c2 04 00	 ret	 4
?EntryPoint@CFileLoaderThread@@KGIPAX@Z ENDP		; CFileLoaderThread::EntryPoint
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
;	COMDAT ?Shutdown@CFileLoaderThread@@QAEXXZ
_TEXT	SEGMENT
_bRet$ = -8						; size = 4
_this$ = -4						; size = 4
?Shutdown@CFileLoaderThread@@QAEXXZ PROC		; CFileLoaderThread::Shutdown, COMDAT
; _this$ = ecx

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 69   : 	if (!m_hSemaphore)

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  0000f	75 02		 jne	 SHORT $LN5@Shutdown

; 70   : 		return;

  00011	eb 30		 jmp	 SHORT $LN1@Shutdown
$LN5@Shutdown:

; 71   : 
; 72   : 	BOOL bRet;
; 73   : 	
; 74   : 	m_bShutdowned = true;

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	c6 40 6c 01	 mov	 BYTE PTR [eax+108], 1
$LN4@Shutdown:

; 75   : 
; 76   : 	do
; 77   : 	{
; 78   : 		bRet = ReleaseSemaphore(m_hSemaphore, 1, NULL);

  0001a	6a 00		 push	 0
  0001c	6a 01		 push	 1
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	ff 70 64	 push	 DWORD PTR [eax+100]
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseSemaphore@12
  0002a	89 45 f8	 mov	 DWORD PTR _bRet$[ebp], eax

; 79   : 	}
; 80   : 	while (!bRet);

  0002d	83 7d f8 00	 cmp	 DWORD PTR _bRet$[ebp], 0
  00031	74 e7		 je	 SHORT $LN4@Shutdown

; 81   : 
; 82   : 	WaitForSingleObject(m_hThread, 10000);	//    10 

  00033	68 10 27 00 00	 push	 10000			; 00002710H
  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	ff 30		 push	 DWORD PTR [eax]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$LN1@Shutdown:

; 83   : }

  00043	c9		 leave
  00044	c3		 ret	 0
?Shutdown@CFileLoaderThread@@QAEXXZ ENDP		; CFileLoaderThread::Shutdown
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
;	COMDAT ?Fetch@CFileLoaderThread@@QAE_NPAPAUSData@1@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv83 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
_ppData$ = 8						; size = 4
?Fetch@CFileLoaderThread@@QAE_NPAPAUSData@1@@Z PROC	; CFileLoaderThread::Fetch, COMDAT
; _this$ = ecx

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 136  : 	m_CompleteMutex.Lock();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0000f	e8 00 00 00 00	 call	 ?Lock@Mutex@@QAEXXZ	; Mutex::Lock
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1534 :         return _Mypair._Myval2;

  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 c0 38	 add	 eax, 56			; 00000038H
  0001a	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  0001d	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00020	83 c0 10	 add	 eax, 16			; 00000010H
  00023	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 1010 :         return _Mysize() == 0;

  00026	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	75 09		 jne	 SHORT $LN6@Fetch
  0002e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
  00035	eb 04		 jmp	 SHORT $LN7@Fetch
$LN6@Fetch:
  00037	83 65 f4 00	 and	 DWORD PTR tv83[ebp], 0
$LN7@Fetch:
  0003b	8a 45 f4	 mov	 al, BYTE PTR tv83[ebp]
  0003e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp

; 138  : 	if (m_pCompleteDeque.empty())

  00041	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00045	85 c0		 test	 eax, eax
  00047	74 0f		 je	 SHORT $LN2@Fetch

; 139  : 	{
; 140  : 		m_CompleteMutex.Unlock();

  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0004f	e8 00 00 00 00	 call	 ?Unlock@Mutex@@QAEXXZ	; Mutex::Unlock

; 141  : 		return false;

  00054	32 c0		 xor	 al, al
  00056	eb 2a		 jmp	 SHORT $LN1@Fetch
$LN2@Fetch:

; 142  : 	}
; 143  : 
; 144  : 	*ppData = m_pCompleteDeque.front();

  00058	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	83 c1 38	 add	 ecx, 56			; 00000038H
  0005e	e8 00 00 00 00	 call	 ?front@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEAAPAUSData@CFileLoaderThread@@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::front
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _ppData$[ebp]
  00066	8b 00		 mov	 eax, DWORD PTR [eax]
  00068	89 01		 mov	 DWORD PTR [ecx], eax

; 145  : 	m_pCompleteDeque.pop_front();

  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	83 c1 38	 add	 ecx, 56			; 00000038H
  00070	e8 00 00 00 00	 call	 ?pop_front@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAEXXZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::pop_front

; 146  : 
; 147  : 	m_CompleteMutex.Unlock();

  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0007b	e8 00 00 00 00	 call	 ?Unlock@Mutex@@QAEXXZ	; Mutex::Unlock

; 148  : 	return true;

  00080	b0 01		 mov	 al, 1
$LN1@Fetch:

; 149  : }

  00082	c9		 leave
  00083	c2 04 00	 ret	 4
?Fetch@CFileLoaderThread@@QAE_NPAPAUSData@1@@Z ENDP	; CFileLoaderThread::Fetch
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
;	COMDAT ?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T2 = -52						; size = 4
$T3 = -48						; size = 1
$T4 = -44						; size = 4
$T5 = -40						; size = 4
_this$ = -36						; size = 4
_this$ = -32						; size = 4
tv75 = -28						; size = 4
_pData$ = -24						; size = 4
$T6 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_c_rstFileName$ = 8					; size = 4
?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CFileLoaderThread::Request, COMDAT
; _this$ = ecx

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 	TData * pData = new TData;

  00028	68 64 01 00 00	 push	 356			; 00000164H
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00032	59		 pop	 ecx
  00033	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
  00036	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	83 7d ec 00	 cmp	 DWORD PTR $T6[ebp], 0
  0003e	74 23		 je	 SHORT $LN4@Request
  00040	8b 4d ec	 mov	 ecx, DWORD PTR $T6[ebp]
  00043	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00048	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR $T6[ebp]
  0004f	83 c1 18	 add	 ecx, 24			; 00000018H
  00052	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile
  00057	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0005b	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  0005e	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
  00061	eb 04		 jmp	 SHORT $LN5@Request
$LN4@Request:
  00063	83 65 e4 00	 and	 DWORD PTR tv75[ebp], 0
$LN5@Request:
  00067	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  0006a	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
  0006d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00071	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00074	89 45 e8	 mov	 DWORD PTR _pData$[ebp], eax

; 117  : 
; 118  : 	pData->dwSize = 0;

  00077	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  0007a	83 a0 60 01 00
	00 00		 and	 DWORD PTR [eax+352], 0

; 119  : 	pData->pvBuf = NULL;

  00081	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  00084	83 a0 5c 01 00
	00 00		 and	 DWORD PTR [eax+348], 0

; 120  : 	pData->stFileName = c_rstFileName;

  0008b	8b 45 e8	 mov	 eax, DWORD PTR _pData$[ebp]
  0008e	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00091	8b 45 08	 mov	 eax, DWORD PTR _c_rstFileName$[ebp]
  00094	89 45 d4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  00097	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	3b 45 d4	 cmp	 eax, DWORD PTR $T4[ebp]
  0009d	74 13		 je	 SHORT $LN35@Request

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  0009f	33 c0		 xor	 eax, eax
  000a1	88 45 d0	 mov	 BYTE PTR $T3[ebp], al
  000a4	ff 75 d0	 push	 DWORD PTR $T3[ebp]
  000a7	ff 75 08	 push	 DWORD PTR _c_rstFileName$[ebp]
  000aa	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN35@Request:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp

; 122  : 	m_RequestMutex.Lock();

  000b2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	83 c1 20	 add	 ecx, 32			; 00000020H
  000b8	e8 00 00 00 00	 call	 ?Lock@Mutex@@QAEXXZ	; Mutex::Lock

; 123  : 	m_pRequestDeque.push_back(pData);

  000bd	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	83 c0 0c	 add	 eax, 12			; 0000000cH
  000c3	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  000c6	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 1123 :         _Emplace_back_internal(_Val);

  000cc	8d 45 e8	 lea	 eax, DWORD PTR _pData$[ebp]
  000cf	50		 push	 eax
  000d0	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	e8 00 00 00 00	 call	 ??$_Emplace_back_internal@ABQAUSData@CFileLoaderThread@@@?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@AAEXABQAUSData@CFileLoaderThread@@@Z ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::_Emplace_back_internal<CFileLoaderThread::SData * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp

; 124  : 	m_RequestMutex.Unlock();

  000d8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	83 c1 20	 add	 ecx, 32			; 00000020H
  000de	e8 00 00 00 00	 call	 ?Unlock@Mutex@@QAEXXZ	; Mutex::Unlock

; 125  : 
; 126  : 	++m_iRestSemCount;

  000e3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  000e9	40		 inc	 eax
  000ea	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	89 41 68	 mov	 DWORD PTR [ecx+104], eax

; 127  : 
; 128  : 	if (!ReleaseSemaphore(m_hSemaphore, m_iRestSemCount, NULL))

  000f0	6a 00		 push	 0
  000f2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	ff 70 68	 push	 DWORD PTR [eax+104]
  000f8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000fb	ff 70 64	 push	 DWORD PTR [eax+100]
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseSemaphore@12
  00104	85 c0		 test	 eax, eax
  00106	75 0b		 jne	 SHORT $LN2@Request

; 129  : 		TraceError("CFileLoaderThread::Request: ReleaseSemaphore error");

  00108	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@FFGDMIEH@CFileLoaderThread?3?3Request?3?5Rel@
  0010d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00112	59		 pop	 ecx
$LN2@Request:

; 130  : 
; 131  : 	--m_iRestSemCount;

  00113	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00116	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  00119	48		 dec	 eax
  0011a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	89 41 68	 mov	 DWORD PTR [ecx+104], eax

; 132  : }

  00120	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00123	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012a	59		 pop	 ecx
  0012b	c9		 leave
  0012c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	68 64 01 00 00	 push	 356			; 00000164H
  00005	ff 75 ec	 push	 DWORD PTR $T6[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
__unwindfunclet$?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
  00010	8b 4d ec	 mov	 ecx, DWORD PTR $T6[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Request@CFileLoaderThread@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CFileLoaderThread::Request
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
;	COMDAT ?Create@CFileLoaderThread@@QAEHPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_arg$ = 8						; size = 4
?Create@CFileLoaderThread@@QAEHPAX@Z PROC		; CFileLoaderThread::Create, COMDAT
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.h

; 37   : 		void					Arg(void * arg) { m_pArg = arg; }

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _arg$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp

; 18   : 	m_hThread = (HANDLE) _beginthreadex(NULL, 0, EntryPoint, this, 0, &m_uThreadID);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 08	 add	 eax, 8
  00016	50		 push	 eax
  00017	6a 00		 push	 0
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	68 00 00 00 00	 push	 OFFSET ?EntryPoint@CFileLoaderThread@@KGIPAX@Z ; CFileLoaderThread::EntryPoint
  00021	6a 00		 push	 0
  00023	6a 00		 push	 0
  00025	e8 00 00 00 00	 call	 __beginthreadex
  0002a	83 c4 18	 add	 esp, 24			; 00000018H
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	89 01		 mov	 DWORD PTR [ecx], eax

; 19   : 
; 20   : 	if (!m_hThread)

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 38 00	 cmp	 DWORD PTR [eax], 0
  00038	75 04		 jne	 SHORT $LN2@Create

; 21   : 		return false;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 10		 jmp	 SHORT $LN1@Create
$LN2@Create:

; 22   : 
; 23   : 	SetThreadPriority(m_hThread, THREAD_PRIORITY_NORMAL);

  0003e	6a 00		 push	 0
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	ff 30		 push	 DWORD PTR [eax]
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetThreadPriority@8

; 24   : 	return true;

  0004b	33 c0		 xor	 eax, eax
  0004d	40		 inc	 eax
$LN1@Create:

; 25   : }

  0004e	c9		 leave
  0004f	c2 04 00	 ret	 4
?Create@CFileLoaderThread@@QAEHPAX@Z ENDP		; CFileLoaderThread::Create
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
;	COMDAT ??1CFileLoaderThread@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CFileLoaderThread@@QAE@XZ PROC			; CFileLoaderThread::~CFileLoaderThread, COMDAT
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CFileLoaderThread@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 	Destroy();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?Destroy@CFileLoaderThread@@IAEXXZ ; CFileLoaderThread::Destroy

; 13   : }

  0002e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00034	e8 00 00 00 00	 call	 ??1Mutex@@QAE@XZ	; Mutex::~Mutex
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 38	 add	 ecx, 56			; 00000038H
  0003f	e8 00 00 00 00	 call	 ??1?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::~deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >
  00044	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	83 c1 20	 add	 ecx, 32			; 00000020H
  0004a	e8 00 00 00 00	 call	 ??1Mutex@@QAE@XZ	; Mutex::~Mutex
  0004f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00055	e8 00 00 00 00	 call	 ??1?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::~deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	c9		 leave
  00066	c3		 ret	 0
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CFileLoaderThread@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CFileLoaderThread@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CFileLoaderThread@@QAE@XZ ENDP			; CFileLoaderThread::~CFileLoaderThread
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\FileLoaderThread.cpp
;	COMDAT ??0CFileLoaderThread@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CFileLoaderThread@@QAE@XZ PROC			; CFileLoaderThread::CFileLoaderThread, COMDAT
; _this$ = ecx

; 7    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CFileLoaderThread@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 6    : CFileLoaderThread::CFileLoaderThread() : m_bShutdowned(false), m_pArg(NULL), m_hThread(NULL), m_uThreadID(0)

  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 20 00	 and	 DWORD PTR [eax], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00033	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00036	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 7    : {

  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00040	e8 00 00 00 00	 call	 ??0?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >
  00045	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00049	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	83 c1 20	 add	 ecx, 32			; 00000020H
  0004f	e8 00 00 00 00	 call	 ??0Mutex@@QAE@XZ	; Mutex::Mutex
  00054	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	83 c1 38	 add	 ecx, 56			; 00000038H
  0005e	e8 00 00 00 00	 call	 ??0?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >
  00063	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00067	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0006d	e8 00 00 00 00	 call	 ??0Mutex@@QAE@XZ	; Mutex::Mutex

; 6    : CFileLoaderThread::CFileLoaderThread() : m_bShutdowned(false), m_pArg(NULL), m_hThread(NULL), m_uThreadID(0)

  00072	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c6 40 6c 00	 mov	 BYTE PTR [eax+108], 0

; 8    : }

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	c9		 leave
  0008c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CFileLoaderThread@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::~deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >
__unwindfunclet$??0CFileLoaderThread@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 20	 add	 ecx, 32			; 00000020H
  00011	e9 00 00 00 00	 jmp	 ??1Mutex@@QAE@XZ	; Mutex::~Mutex
__unwindfunclet$??0CFileLoaderThread@@QAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 38	 add	 ecx, 56			; 00000038H
  0001c	e9 00 00 00 00	 jmp	 ??1?$deque@PAUSData@CFileLoaderThread@@V?$allocator@PAUSData@CFileLoaderThread@@@std@@@std@@QAE@XZ ; std::deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >::~deque<CFileLoaderThread::SData *,std::allocator<CFileLoaderThread::SData *> >
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$??0CFileLoaderThread@@QAE@XZ:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CFileLoaderThread@@QAE@XZ
  0003e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CFileLoaderThread@@QAE@XZ ENDP			; CFileLoaderThread::CFileLoaderThread
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??_GSData@CFileLoaderThread@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSData@CFileLoaderThread@@QAEPAXI@Z PROC		; CFileLoaderThread::SData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 18	 add	 ecx, 24			; 00000018H
  0000d	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile

; 2801 :         _Tidy_deallocate();

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001d	83 e0 01	 and	 eax, 1
  00020	74 0f		 je	 SHORT $LN2@scalar
  00022	68 64 01 00 00	 push	 356			; 00000164H
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_GSData@CFileLoaderThread@@QAEPAXI@Z ENDP		; CFileLoaderThread::SData::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
__Ptr$ = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
__Result$6 = -16					; size = 4
tv134 = -12						; size = 4
_this$ = -8						; size = 4
$T7 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign, COMDAT
; _this$ = ecx

; 2826 :     void _Copy_assign(const basic_string& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0001b	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0001e	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2827 :         _Pocca(_Getal(), _Right._Getal());

  00021	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00024	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00041	72 09		 jb	 SHORT $LN21@Copy_assig
  00043	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv134[ebp], 1
  0004a	eb 04		 jmp	 SHORT $LN22@Copy_assig
$LN21@Copy_assig:
  0004c	83 65 f4 00	 and	 DWORD PTR tv134[ebp], 0
$LN22@Copy_assig:
  00050	8a 45 f4	 mov	 al, BYTE PTR tv134[ebp]
  00053	88 45 ff	 mov	 BYTE PTR $T7[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00056	0f b6 45 ff	 movzx	 eax, BYTE PTR $T7[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	74 0e		 je	 SHORT $LN16@Copy_assig

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00066	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00069	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax
$LN16@Copy_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR __Result$6[ebp]
  0006f	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00072	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00075	ff 70 10	 push	 DWORD PTR [eax+16]
  00078	ff 75 d4	 push	 DWORD PTR $T1[ebp]
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2829 :     }

  00083	c9		 leave
  00084	c2 08 00	 ret	 8
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
