; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?c_FillRectIndices@@3QBGB DW 00H			; c_FillRectIndices
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_Copy_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy_assign
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?Hyperlink_UpdateMousePos@CGraphicTextInstance@@SAXHH@Z ; CGraphicTextInstance::Hyperlink_UpdateMousePos
PUBLIC	?Hyperlink_GetText@CGraphicTextInstance@@SAHPADH@Z ; CGraphicTextInstance::Hyperlink_GetText
PUBLIC	??0CGraphicTextInstance@@QAE@XZ			; CGraphicTextInstance::CGraphicTextInstance
PUBLIC	??1CGraphicTextInstance@@UAE@XZ			; CGraphicTextInstance::~CGraphicTextInstance
PUBLIC	?Destroy@CGraphicTextInstance@@QAEXXZ		; CGraphicTextInstance::Destroy
PUBLIC	?Update@CGraphicTextInstance@@QAEXXZ		; CGraphicTextInstance::Update
PUBLIC	?Render@CGraphicTextInstance@@QAEXPAUtagRECT@@@Z ; CGraphicTextInstance::Render
PUBLIC	?ShowCursor@CGraphicTextInstance@@QAEXXZ	; CGraphicTextInstance::ShowCursor
PUBLIC	?HideCursor@CGraphicTextInstance@@QAEXXZ	; CGraphicTextInstance::HideCursor
PUBLIC	?ShowOutLine@CGraphicTextInstance@@QAEXXZ	; CGraphicTextInstance::ShowOutLine
PUBLIC	?HideOutLine@CGraphicTextInstance@@QAEXXZ	; CGraphicTextInstance::HideOutLine
PUBLIC	?SetColor@CGraphicTextInstance@@QAEXK@Z		; CGraphicTextInstance::SetColor
PUBLIC	?SetColor@CGraphicTextInstance@@QAEXMMMM@Z	; CGraphicTextInstance::SetColor
PUBLIC	?SetOutLineColor@CGraphicTextInstance@@QAEXK@Z	; CGraphicTextInstance::SetOutLineColor
PUBLIC	?SetOutLineColor@CGraphicTextInstance@@QAEXMMMM@Z ; CGraphicTextInstance::SetOutLineColor
PUBLIC	?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z ; CGraphicTextInstance::SetHorizonalAlign
PUBLIC	?SetVerticalAlign@CGraphicTextInstance@@QAEXH@Z	; CGraphicTextInstance::SetVerticalAlign
PUBLIC	?SetMax@CGraphicTextInstance@@QAEXH@Z		; CGraphicTextInstance::SetMax
PUBLIC	?SetTextPointer@CGraphicTextInstance@@QAEXPAVCGraphicText@@@Z ; CGraphicTextInstance::SetTextPointer
PUBLIC	?SetValueString@CGraphicTextInstance@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CGraphicTextInstance::SetValueString
PUBLIC	?SetValue@CGraphicTextInstance@@QAEXPBDI@Z	; CGraphicTextInstance::SetValue
PUBLIC	?SetPosition@CGraphicTextInstance@@QAEXMMM@Z	; CGraphicTextInstance::SetPosition
PUBLIC	?SetSecret@CGraphicTextInstance@@QAEX_N@Z	; CGraphicTextInstance::SetSecret
PUBLIC	?SetOutline@CGraphicTextInstance@@QAEX_N@Z	; CGraphicTextInstance::SetOutline
PUBLIC	?SetFeather@CGraphicTextInstance@@QAEX_N@Z	; CGraphicTextInstance::SetFeather
PUBLIC	?SetMultiLine@CGraphicTextInstance@@QAEX_N@Z	; CGraphicTextInstance::SetMultiLine
PUBLIC	?SetLimitWidth@CGraphicTextInstance@@QAEXM@Z	; CGraphicTextInstance::SetLimitWidth
PUBLIC	?GetTextSize@CGraphicTextInstance@@QAEXPAH0@Z	; CGraphicTextInstance::GetTextSize
PUBLIC	?GetValueStringReference@CGraphicTextInstance@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CGraphicTextInstance::GetValueStringReference
PUBLIC	?GetTextLineCount@CGraphicTextInstance@@QAEGXZ	; CGraphicTextInstance::GetTextLineCount
PUBLIC	?PixelPositionToCharacterPosition@CGraphicTextInstance@@QAEHH@Z ; CGraphicTextInstance::PixelPositionToCharacterPosition
PUBLIC	?GetHorizontalAlign@CGraphicTextInstance@@QAEHXZ ; CGraphicTextInstance::GetHorizontalAlign
PUBLIC	?__Initialize@CGraphicTextInstance@@IAEXXZ	; CGraphicTextInstance::__Initialize
PUBLIC	?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter
PUBLIC	?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z	; CGraphicTextInstance::__GetTextPos
PUBLIC	??0SHyperlink@CGraphicTextInstance@@QAE@XZ	; CGraphicTextInstance::SHyperlink::SHyperlink
PUBLIC	??1SHyperlink@CGraphicTextInstance@@QAE@XZ	; CGraphicTextInstance::SHyperlink::~SHyperlink
PUBLIC	??1?$CRef@VCGraphicText@@@@QAE@XZ		; CRef<CGraphicText>::~CRef<CGraphicText>
PUBLIC	?SetPointer@?$CRef@VCGraphicText@@@@QAEXPAVCReferenceObject@@@Z ; CRef<CGraphicText>::SetPointer
PUBLIC	?deallocate@?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@QAEXQAPAUSCharacterInfomation@CGraphicFontTexture@@I@Z ; std::allocator<CGraphicFontTexture::SCharacterInfomation *>::deallocate
PUBLIC	??1?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAE@XZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::~vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
PUBLIC	?clear@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEXXZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::clear
PUBLIC	?_Destroy@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXPAPAUSCharacterInfomation@CGraphicFontTexture@@0@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@ABEII@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXQAPAUSCharacterInfomation@CGraphicFontTexture@@II@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXXZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@CAXXZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Xlength
PUBLIC	?deallocate@?$allocator@K@std@@QAEXQAKI@Z	; std::allocator<unsigned long>::deallocate
PUBLIC	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::clear
PUBLIC	?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Change_array
PUBLIC	?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
PUBLIC	?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
PUBLIC	?deallocate@?$allocator@USHyperlink@CGraphicTextInstance@@@std@@QAEXQAUSHyperlink@CGraphicTextInstance@@I@Z ; std::allocator<CGraphicTextInstance::SHyperlink>::deallocate
PUBLIC	??1?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::~vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >
PUBLIC	?clear@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::clear
PUBLIC	?_Destroy@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXPAUSHyperlink@CGraphicTextInstance@@0@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@ABEII@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXQAUSHyperlink@CGraphicTextInstance@@II@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Change_array
PUBLIC	?_Tidy@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Tidy
PUBLIC	?_Xlength@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Xlength
PUBLIC	?CreateSystem@CGraphicTextInstance@@SAXI@Z	; CGraphicTextInstance::CreateSystem
PUBLIC	?DestroySystem@CGraphicTextInstance@@SAXXZ	; CGraphicTextInstance::DestroySystem
PUBLIC	?New@CGraphicTextInstance@@SAPAV1@XZ		; CGraphicTextInstance::New
PUBLIC	?Delete@CGraphicTextInstance@@SAXPAV1@@Z	; CGraphicTextInstance::Delete
PUBLIC	??_GCGraphicTextInstance@@UAEPAXI@Z		; CGraphicTextInstance::`scalar deleting destructor'
PUBLIC	?FindToken@@YAPBDPBD0@Z				; FindToken
PUBLIC	?ReadToken@@YAHPBD@Z				; ReadToken
PUBLIC	??0?$CDynamicPool@VCGraphicTextInstance@@@@QAE@XZ ; CDynamicPool<CGraphicTextInstance>::CDynamicPool<CGraphicTextInstance>
PUBLIC	??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ ; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ ; CDynamicPool<CGraphicTextInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ ; CDynamicPool<CGraphicTextInstance>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCGraphicTextInstance@@@@KAXPAVCGraphicTextInstance@@@Z ; CDynamicPool<CGraphicTextInstance>::Delete
PUBLIC	?deallocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXQAPAVCGraphicTextInstance@@I@Z ; std::allocator<CGraphicTextInstance *>::deallocate
PUBLIC	?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reallocate_exactly
PUBLIC	?reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::reserve
PUBLIC	?clear@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXPAPAVCGraphicTextInstance@@0@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@ABEII@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXQAPAVCGraphicTextInstance@@II@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlength
PUBLIC	?_Getal@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicTextInstance@@@2@XZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Getal
PUBLIC	??_G?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z ; CDynamicPool<CGraphicTextInstance>::`scalar deleting destructor'
PUBLIC	?isNumberic@@YA_ND@Z				; isNumberic
PUBLIC	?IsValidToken@@YA_NPBD@Z			; IsValidToken
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@P6AXPAVCGraphicTextInstance@@@Z@std@@YAP6AXPAVCGraphicTextInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >,void (__cdecl*)(CGraphicTextInstance *)>
PUBLIC	??$emplace_back@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXABUSHyperlink@CGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::emplace_back<CGraphicTextInstance::SHyperlink const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXABUSHyperlink@CGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_back_with_unused_capacity<CGraphicTextInstance::SHyperlink const &>
PUBLIC	??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_reallocate<CGraphicTextInstance::SHyperlink const &>
PUBLIC	??$emplace_back@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::emplace_back<unsigned long const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_back_with_unused_capacity<unsigned long const &>
PUBLIC	??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long const &>
PUBLIC	??$emplace_back@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEXABQAUSCharacterInfomation@CGraphicFontTexture@@@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::emplace_back<CGraphicFontTexture::SCharacterInfomation * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXABQAUSCharacterInfomation@CGraphicFontTexture@@@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Emplace_back_with_unused_capacity<CGraphicFontTexture::SCharacterInfomation * const &>
PUBLIC	??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Emplace_reallocate<CGraphicFontTexture::SCharacterInfomation * const &>
PUBLIC	??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>
PUBLIC	??$emplace_back@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::emplace_back<CGraphicTextInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXABQAVCGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Emplace_back_with_unused_capacity<CGraphicTextInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Emplace_reallocate<CGraphicTextInstance * const &>
PUBLIC	??$_Destroy_range@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAXPAUSHyperlink@CGraphicTextInstance@@QAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicTextInstance::SHyperlink> >
PUBLIC	??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z ; std::_Destroy_range<std::allocator<unsigned long> >
PUBLIC	??$_Destroy_range@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAXPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
PUBLIC	??$_Pocca@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@ABV10@@Z ; std::_Pocca<std::allocator<wchar_t> >
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@QAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicTextInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAPAPAVCGraphicTextInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance * *,std::allocator<CGraphicTextInstance *> >
PUBLIC	??$_Find_unchecked@PBDD@std@@YAPBDQBD0ABD@Z	; std::_Find_unchecked<char const *,char>
PUBLIC	??$_Copy_memmove@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicTextInstance * *,CGraphicTextInstance * *>
PUBLIC	??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance::SHyperlink *,std::allocator<CGraphicTextInstance::SHyperlink> >
PUBLIC	??$_Uninitialized_move@PAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z ; std::_Uninitialized_move<unsigned long *,std::allocator<unsigned long> >
PUBLIC	??$_Uninitialized_move@PAPAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z ; std::_Uninitialized_move<CGraphicFontTexture::SCharacterInfomation * *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<CGraphicTextInstance::SHyperlink> >::~_Uninitialized_backout_al<std::allocator<CGraphicTextInstance::SHyperlink> >
PUBLIC	??$_Emplace_back@USHyperlink@CGraphicTextInstance@@@?$_Uninitialized_backout_al@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEX$$QAUSHyperlink@CGraphicTextInstance@@@Z ; std::_Uninitialized_backout_al<std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_back<CGraphicTextInstance::SHyperlink>
PUBLIC	??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z	; std::_Copy_memmove<unsigned long *,unsigned long *>
PUBLIC	??$_Copy_memmove@PAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@00@Z ; std::_Copy_memmove<CGraphicFontTexture::SCharacterInfomation * *,CGraphicFontTexture::SCharacterInfomation * *>
PUBLIC	??$_Within_limits@PBDD@std@@YA_NPBDABD@Z	; std::_Within_limits<char const *,char>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A ; CGraphicTextInstance::ms_kPool
PUBLIC	??_7CGraphicTextInstance@@6B@			; CGraphicTextInstance::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@	; CDynamicPool<CGraphicTextInstance>::`vftable'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_0DL@KFHPELNP@CGraphicTextInstance?3?3Update?5?9?5@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CGraphicTextInstance@@6B@			; CGraphicTextInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGraphicTextInstance@@@8		; CGraphicTextInstance `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicTextInstance@@8			; CGraphicTextInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicTextInstance@@8			; CGraphicTextInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicTextInstance@@8		; CGraphicTextInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCGraphicTextInstance@@@@6B@ ; CDynamicPool<CGraphicTextInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8 ; CDynamicPool<CGraphicTextInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8	; CDynamicPool<CGraphicTextInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCGraphicTextInstance@@@@8	; CDynamicPool<CGraphicTextInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCGraphicTextInstance@@@@8 ; CDynamicPool<CGraphicTextInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@437f0000
PUBLIC	__real@44c80000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memchr:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_wcslen:PROC
EXTRN	_strlen:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Tracef@@YAXPBDZZ:PROC				; Tracef
EXTRN	?AddReference@CReferenceObject@@QAEXXZ:PROC	; CReferenceObject::AddReference
EXTRN	?Release@CReferenceObject@@QAEXXZ:PROC		; CReferenceObject::Release
EXTRN	?IsEmpty@CResource@@QBE_NXZ:PROC		; CResource::IsEmpty
EXTRN	?SetDefaultIndexBuffer@CGraphicBase@@SAXI@Z:PROC ; CGraphicBase::SetDefaultIndexBuffer
EXTRN	?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z:PROC ; CGraphicBase::SetPDTStream
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	?SelectTexture@CGraphicFontTexture@@QAEXK@Z:PROC ; CGraphicFontTexture::SelectTexture
EXTRN	?UpdateTexture@CGraphicFontTexture@@QAE_NXZ:PROC ; CGraphicFontTexture::UpdateTexture
EXTRN	?GetCharacterInfomation@CGraphicFontTexture@@QAEPAUSCharacterInfomation@1@G_W@Z:PROC ; CGraphicFontTexture::GetCharacterInfomation
EXTRN	?GetFontTexturePointer@CGraphicText@@QAEPAVCGraphicFontTexture@@XZ:PROC ; CGraphicText::GetFontTexturePointer
EXTRN	??_ECGraphicTextInstance@@UAEPAXI@Z:PROC	; CGraphicTextInstance::`vector deleting destructor'
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z:PROC ; CStateManager::DrawPrimitive
EXTRN	?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z:PROC ; CStateManager::DrawIndexedPrimitive
EXTRN	?DrawIndexedPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIIPBXW4_D3DFORMAT@@1I@Z:PROC ; CStateManager::DrawIndexedPrimitiveUP
EXTRN	?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::GetRenderState
EXTRN	?GetCurPos@CIME@@SAHXZ:PROC			; CIME::GetCurPos
EXTRN	?GetCompLen@CIME@@SAHXZ:PROC			; CIME::GetCompLen
EXTRN	?GetULBegin@CIME@@SAHXZ:PROC			; CIME::GetULBegin
EXTRN	?GetULEnd@CIME@@SAHXZ:PROC			; CIME::GetULEnd
EXTRN	?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z:PROC ; GetTextTag
EXTRN	?Ymir_WideCharToMultiByte@@YAHIKPB_WHPADHPBDPAH@Z:PROC ; Ymir_WideCharToMultiByte
EXTRN	?Ymir_MultiByteToWideChar@@YAHIKPBDHPA_WH@Z:PROC ; Ymir_MultiByteToWideChar
EXTRN	?Arabic_ConvSymbol@@YA_W_W@Z:PROC		; Arabic_ConvSymbol
EXTRN	?Arabic_IsInSymbol@@YA_N_W@Z:PROC		; Arabic_IsInSymbol
EXTRN	?Arabic_IsInPresentation@@YA_N_W@Z:PROC		; Arabic_IsInPresentation
EXTRN	?Arabic_HasPresentation@@YA_NPA_WH@Z:PROC	; Arabic_HasPresentation
EXTRN	?Arabic_MakeShape@@YAIPA_WI0I@Z:PROC		; Arabic_MakeShape
EXTRN	?GetDefaultCodePage@@YAKXZ:PROC			; GetDefaultCodePage
EXTRN	??_E?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CGraphicTextInstance>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	__ftoui3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A DB 024H DUP (?) ; CGraphicTextInstance::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?gs_mx@@3HA DD	01H DUP (?)				; gs_mx
?gs_my@@3HA DD	01H DUP (?)				; gs_my
?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A DB 018H DUP (?) ; gs_hyperlinkText
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CGraphicTextInstance@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CGraphicTextInstance@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __real@44c80000
CONST	SEGMENT
__real@44c80000 DD 044c80000r			; 1600
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCGraphicTextInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8 ; CDynamicPool<CGraphicTextInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCGraphicTextInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCGraphicTextInstance@@@@8 ; CDynamicPool<CGraphicTextInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8 DD 00H	; CDynamicPool<CGraphicTextInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CGraphicTextInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCGraphicTextInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCGraphicTextInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCGraphicTextInstance@@@@6B@ DD 00H	; CDynamicPool<CGraphicTextInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicTextInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicTextInstance@@8 DD FLAT:??_R0?AVCGraphicTextInstance@@@8 ; CGraphicTextInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicTextInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicTextInstance@@8
rdata$r	SEGMENT
??_R2CGraphicTextInstance@@8 DD FLAT:??_R1A@?0A@EA@CGraphicTextInstance@@8 ; CGraphicTextInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicTextInstance@@8
rdata$r	SEGMENT
??_R3CGraphicTextInstance@@8 DD 00H			; CGraphicTextInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicTextInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicTextInstance@@@8
data$rs	SEGMENT
??_R0?AVCGraphicTextInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicTextInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicTextInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CGraphicTextInstance@@6B@
rdata$r	SEGMENT
??_R4CGraphicTextInstance@@6B@ DD 00H			; CGraphicTextInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGraphicTextInstance@@@8
	DD	FLAT:??_R3CGraphicTextInstance@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@KFHPELNP@CGraphicTextInstance?3?3Update?5?9?5@
CONST	SEGMENT
??_C@_0DL@KFHPELNP@CGraphicTextInstance?3?3Update?5?9?5@ DB 'CGraphicText'
	DB	'Instance::Update - ', 0c6H, 0f9H, 0c6H, 0aeH, 0b0H, 0a1H, ' ', 0bcH
	DB	0b3H, 0c1H, 0a4H, 0b5H, 0c7H, 0c1H, 0f6H, ' ', 0beH, 0caH, 0beH
	DB	0d2H, 0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCGraphicTextInstance@@@@6B@ ; CDynamicPool<CGraphicTextInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CGraphicTextInstance@@6B@
CONST	SEGMENT
??_7CGraphicTextInstance@@6B@ DD FLAT:??_R4CGraphicTextInstance@@6B@ ; CGraphicTextInstance::`vftable'
	DD	FLAT:??_ECGraphicTextInstance@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z$0
__unwindtable$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z$38 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z$38
__ehfuncinfo$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z$0
__unwindtable$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z$11
__ehfuncinfo$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CRef@VCGraphicText@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Update@CGraphicTextInstance@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$3
__ehfuncinfo$?Update@CGraphicTextInstance@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Update@CGraphicTextInstance@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CGraphicTextInstance@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1CGraphicTextInstance@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CGraphicTextInstance@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CGraphicTextInstance@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0CGraphicTextInstance@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CGraphicTextInstance@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?gs_hyperlinkText$initializer$@@3P6AXXZA DD FLAT:??__Egs_hyperlinkText@@YAXXZ ; gs_hyperlinkText$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Within_limits@PBDD@std@@YA_NPBDABD@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv92 = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
tv89 = -1						; size = 1
___formal$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Within_limits@PBDD@std@@YA_NPBDABD@Z PROC		; std::_Within_limits<char const *,char>, COMDAT

; 5426 : _NODISCARD constexpr bool _Within_limits(_InIt, const _Ty& _Val) { // check whether _Val is within the limits of _Elem

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 5427 :     using _Elem = remove_pointer_t<_InIt>;
; 5428 :     return _Within_limits(_Val, is_signed<_Elem>{}, is_signed<_Ty>{}, bool_constant<-1 == static_cast<_Ty>(-1)>{});

  00006	33 c0		 xor	 eax, eax
  00008	88 45 fe	 mov	 BYTE PTR $T2[ebp], al
  0000b	8d 45 fd	 lea	 eax, DWORD PTR $T1[ebp]
  0000e	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 5398 :     return SCHAR_MIN <= _Val && _Val <= SCHAR_MAX;

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00014	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00017	83 f8 80	 cmp	 eax, -128		; ffffff80H
  0001a	7c 14		 jl	 SHORT $LN8@Within_lim
  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0001f	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00022	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00025	7f 09		 jg	 SHORT $LN8@Within_lim
  00027	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  0002e	eb 04		 jmp	 SHORT $LN6@Within_lim
$LN8@Within_lim:
  00030	83 65 f8 00	 and	 DWORD PTR tv92[ebp], 0
$LN6@Within_lim:

; 5427 :     using _Elem = remove_pointer_t<_InIt>;
; 5428 :     return _Within_limits(_Val, is_signed<_Elem>{}, is_signed<_Ty>{}, bool_constant<-1 == static_cast<_Ty>(-1)>{});

  00034	8a 45 f8	 mov	 al, BYTE PTR tv92[ebp]
  00037	88 45 ff	 mov	 BYTE PTR tv89[ebp], al
  0003a	8a 45 ff	 mov	 al, BYTE PTR tv89[ebp]

; 5429 : }

  0003d	c9		 leave
  0003e	c3		 ret	 0
??$_Within_limits@PBDD@std@@YA_NPBDABD@Z ENDP		; std::_Within_limits<char const *,char>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@00@Z PROC ; std::_Copy_memmove<CGraphicFontTexture::SCharacterInfomation * *,CGraphicFontTexture::SCharacterInfomation * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@00@Z ENDP ; std::_Copy_memmove<CGraphicFontTexture::SCharacterInfomation * *,CGraphicFontTexture::SCharacterInfomation * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z PROC		; std::_Copy_memmove<unsigned long *,unsigned long *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z ENDP		; std::_Copy_memmove<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@USHyperlink@CGraphicTextInstance@@@?$_Uninitialized_backout_al@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEX$$QAUSHyperlink@CGraphicTextInstance@@@Z
_TEXT	SEGMENT
___formal$ = -28					; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Ptr$ = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@USHyperlink@CGraphicTextInstance@@@?$_Uninitialized_backout_al@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEX$$QAUSHyperlink@CGraphicTextInstance@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_back<CGraphicTextInstance::SHyperlink>, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00024	89 45 e4	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00027	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  0002a	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002d	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  00030	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
  00033	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00036	8b 4d f8	 mov	 ecx, DWORD PTR $T4[ebp]
  00039	66 8b 09	 mov	 cx, WORD PTR [ecx]
  0003c	66 89 08	 mov	 WORD PTR [eax], cx
  0003f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00042	8b 4d f8	 mov	 ecx, DWORD PTR $T4[ebp]
  00045	66 8b 49 02	 mov	 cx, WORD PTR [ecx+2]
  00049	66 89 48 02	 mov	 WORD PTR [eax+2], cx
  0004d	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  00057	83 c1 04	 add	 ecx, 4
  0005a	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1547 :         ++_Last;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00065	83 c0 1c	 add	 eax, 28			; 0000001cH
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  0006e	c9		 leave
  0006f	c2 04 00	 ret	 4
??$_Emplace_back@USHyperlink@CGraphicTextInstance@@@?$_Uninitialized_backout_al@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEX$$QAUSHyperlink@CGraphicTextInstance@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_back<CGraphicTextInstance::SHyperlink>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<CGraphicTextInstance::SHyperlink> >::~_Uninitialized_backout_al<std::allocator<CGraphicTextInstance::SHyperlink> >, COMDAT
; _this$ = ecx

; 1540 :     ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff 70 08	 push	 DWORD PTR [eax+8]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	ff 70 04	 push	 DWORD PTR [eax+4]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	ff 30		 push	 DWORD PTR [eax]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAXPAUSHyperlink@CGraphicTextInstance@@QAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicTextInstance::SHyperlink> >
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1542 :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<CGraphicTextInstance::SHyperlink> >::~_Uninitialized_backout_al<std::allocator<CGraphicTextInstance::SHyperlink> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z PROC ; std::_Uninitialized_move<CGraphicFontTexture::SCharacterInfomation * *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@00@Z ; std::_Copy_memmove<CGraphicFontTexture::SCharacterInfomation * *,CGraphicFontTexture::SCharacterInfomation * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z ENDP ; std::_Uninitialized_move<CGraphicFontTexture::SCharacterInfomation * *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z PROC ; std::_Uninitialized_move<unsigned long *,std::allocator<unsigned long> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z ; std::_Copy_memmove<unsigned long *,unsigned long *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z ENDP ; std::_Uninitialized_move<unsigned long *,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__ULast$ = -20						; size = 4
__UFirst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z PROC ; std::_Uninitialized_move<CGraphicTextInstance::SHyperlink *,std::allocator<CGraphicTextInstance::SHyperlink> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00031	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00034	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax
  00037	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003a	89 45 dc	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  0003d	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00040	89 45 e0	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00043	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00047	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00049	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	83 c0 1c	 add	 eax, 28			; 0000001cH
  0004f	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00052	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00055	3b 45 ec	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00058	74 13		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0005a	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0005d	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));

  00060	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  00063	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Emplace_back@USHyperlink@CGraphicTextInstance@@@?$_Uninitialized_backout_al@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEX$$QAUSHyperlink@CGraphicTextInstance@@@Z ; std::_Uninitialized_backout_al<std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_back<CGraphicTextInstance::SHyperlink>

; 1699 :         }

  0006b	eb dc		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  0006d	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00070	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  00073	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00076	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1700 : 
; 1701 :         return _Backout._Release();

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  0007d	ff 75 e0	 push	 DWORD PTR __Backout$2[ebp+8]
  00080	ff 75 dc	 push	 DWORD PTR __Backout$2[ebp+4]
  00083	ff 75 d8	 push	 DWORD PTR __Backout$2[ebp]
  00086	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAXPAUSHyperlink@CGraphicTextInstance@@QAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicTextInstance::SHyperlink> >
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  0008e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]

; 1702 :     }
; 1703 : }

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009b	59		 pop	 ecx
  0009c	c9		 leave
  0009d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<CGraphicTextInstance::SHyperlink> >::~_Uninitialized_backout_al<std::allocator<CGraphicTextInstance::SHyperlink> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CGraphicTextInstance::SHyperlink *,std::allocator<CGraphicTextInstance::SHyperlink> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CGraphicTextInstance * *,CGraphicTextInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CGraphicTextInstance * *,CGraphicTextInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Find_unchecked@PBDD@std@@YAPBDQBD0ABD@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
tv84 = -16						; size = 4
__First$ = -12						; size = 4
___formal$ = -8						; size = 1
$T2 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find_unchecked@PBDD@std@@YAPBDQBD0ABD@Z PROC	; std::_Find_unchecked<char const *,char>, COMDAT

; 5467 : _NODISCARD _CONSTEXPR20 _InIt _Find_unchecked(const _InIt _First, const _InIt _Last, const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 5468 :     // find first matching _Val; choose optimization
; 5469 :     // activate optimization for pointers to (const) bytes and integral values
; 5470 :     using _Memchr_opt = bool_constant<
; 5471 :         is_integral_v<_Ty> && _Is_any_of_v<_InIt, char*, signed char*, unsigned char*, //
; 5472 :             const char*, const signed char*, const unsigned char*>>;
; 5473 : 
; 5474 :     return _Find_unchecked1(_First, _Last, _Val, _Memchr_opt{});

  00006	33 c0		 xor	 eax, eax
  00008	88 45 ff	 mov	 BYTE PTR $T2[ebp], al
  0000b	8a 45 ff	 mov	 al, BYTE PTR $T2[ebp]
  0000e	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  00011	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00014	89 45 f4	 mov	 DWORD PTR __First$[ebp], eax

; 5451 :     if (!_Within_limits(_First, _Val)) {

  00017	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  0001a	ff 75 f4	 push	 DWORD PTR __First$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$_Within_limits@PBDD@std@@YA_NPBDABD@Z ; std::_Within_limits<char const *,char>
  00022	59		 pop	 ecx
  00023	59		 pop	 ecx
  00024	0f b6 c0	 movzx	 eax, al
  00027	85 c0		 test	 eax, eax
  00029	75 08		 jne	 SHORT $LN4@Find_unche

; 5452 :         return _Last;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
  00031	eb 36		 jmp	 SHORT $LN3@Find_unche
$LN4@Find_unche:

; 5453 :     }
; 5454 : 
; 5455 : #ifdef __cpp_lib_is_constant_evaluated
; 5456 :     if (_STD is_constant_evaluated()) {
; 5457 :         using _Elem = remove_pointer_t<_InIt>;
; 5458 :         return _Find_unchecked1(_First, _Last, static_cast<_Elem>(_Val), false_type{});
; 5459 :     }
; 5460 : #endif // __cpp_lib_is_constant_evaluated
; 5461 :     _First =

  00033	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00036	2b 45 f4	 sub	 eax, DWORD PTR __First$[ebp]
  00039	50		 push	 eax
  0003a	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0003d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00040	50		 push	 eax
  00041	ff 75 f4	 push	 DWORD PTR __First$[ebp]
  00044	e8 00 00 00 00	 call	 _memchr
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	89 45 f4	 mov	 DWORD PTR __First$[ebp], eax

; 5462 :         static_cast<_InIt>(_CSTD memchr(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
; 5463 :     return _First ? _First : _Last;

  0004f	83 7d f4 00	 cmp	 DWORD PTR __First$[ebp], 0
  00053	74 08		 je	 SHORT $LN6@Find_unche
  00055	8b 45 f4	 mov	 eax, DWORD PTR __First$[ebp]
  00058	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  0005b	eb 06		 jmp	 SHORT $LN7@Find_unche
$LN6@Find_unche:
  0005d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00060	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
$LN7@Find_unche:
  00063	8b 45 f0	 mov	 eax, DWORD PTR tv84[ebp]
  00066	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
$LN3@Find_unche:

; 5468 :     // find first matching _Val; choose optimization
; 5469 :     // activate optimization for pointers to (const) bytes and integral values
; 5470 :     using _Memchr_opt = bool_constant<
; 5471 :         is_integral_v<_Ty> && _Is_any_of_v<_InIt, char*, signed char*, unsigned char*, //
; 5472 :             const char*, const signed char*, const unsigned char*>>;
; 5473 : 
; 5474 :     return _Find_unchecked1(_First, _Last, _Val, _Memchr_opt{});

  00069	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]

; 5475 : }

  0006c	c9		 leave
  0006d	c3		 ret	 0
??$_Find_unchecked@PBDD@std@@YAPBDQBD0ABD@Z ENDP	; std::_Find_unchecked<char const *,char>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAPAPAVCGraphicTextInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAPAPAVCGraphicTextInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z PROC ; std::_Uninitialized_move<CGraphicTextInstance * *,std::allocator<CGraphicTextInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicTextInstance * *,CGraphicTextInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAPAPAVCGraphicTextInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CGraphicTextInstance * *,std::allocator<CGraphicTextInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@QAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@QAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CGraphicTextInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@QAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CGraphicTextInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 885  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 886  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 887  :         _Left = _Right;
; 888  :     }
; 889  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<wchar_t> >, COMDAT

; 885  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 886  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 887  :         _Left = _Right;
; 888  :     }
; 889  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAXPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAXPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CGraphicFontTexture::SCharacterInfomation *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAXPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned long> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAXPAUSHyperlink@CGraphicTextInstance@@QAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAXPAUSHyperlink@CGraphicTextInstance@@QAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CGraphicTextInstance::SHyperlink> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {

  00004	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00012	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00015	74 26		 je	 SHORT $LN5@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00023	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  00028	33 c0		 xor	 eax, eax
  0002a	83 e0 01	 and	 eax, 1
  0002d	74 0c		 je	 SHORT $LN9@Destroy_ra
  0002f	6a 1c		 push	 28			; 0000001cH
  00031	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00039	59		 pop	 ecx
  0003a	59		 pop	 ecx
$LN9@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 968  :         }

  0003b	eb c9		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 969  :     }
; 970  : }

  0003d	c9		 leave
  0003e	c3		 ret	 0
??$_Destroy_range@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAXPAUSHyperlink@CGraphicTextInstance@@QAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CGraphicTextInstance::SHyperlink> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Emplace_reallocate<CGraphicTextInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@ABEII@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAPAPAVCGraphicTextInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance * *,std::allocator<CGraphicTextInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAPAPAVCGraphicTextInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance * *,std::allocator<CGraphicTextInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAPAPAVCGraphicTextInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance * *,std::allocator<CGraphicTextInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXPAPAVCGraphicTextInstance@@0@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXQAPAVCGraphicTextInstance@@I@Z ; std::allocator<CGraphicTextInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXQAPAVCGraphicTextInstance@@II@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Emplace_reallocate<CGraphicTextInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXABQAVCGraphicTextInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXABQAVCGraphicTextInstance@@@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Emplace_back_with_unused_capacity<CGraphicTextInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXABQAVCGraphicTextInstance@@@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Emplace_back_with_unused_capacity<CGraphicTextInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::emplace_back<CGraphicTextInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXABQAVCGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Emplace_back_with_unused_capacity<CGraphicTextInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAPAVCGraphicTextInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Emplace_reallocate<CGraphicTextInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::emplace_back<CGraphicTextInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z
_TEXT	SEGMENT
__Max_possible$1 = -100					; size = 4
__Al$ = -96						; size = 4
__First$ = -92						; size = 4
__First$ = -88						; size = 4
$T2 = -84						; size = 4
__Ptr$ = -80						; size = 4
$T3 = -76						; size = 4
$T4 = -72						; size = 4
$T5 = -68						; size = 4
__Old_ptr$6 = -64					; size = 4
__Old_capacity$ = -60					; size = 4
__New_capacity$ = -56					; size = 4
__New_size$ = -52					; size = 4
__Count$ = -48						; size = 4
__New_ptr$ = -44					; size = 4
__Su$7 = -40						; size = 4
__N$8 = -36						; size = 4
__Su$9 = -32						; size = 4
__N$10 = -28						; size = 4
_this$ = -24						; size = 4
__Raw_new$ = -20					; size = 4
__My_data$ = -16					; size = 4
__Old_size$ = -12					; size = 4
$T11 = -6						; size = 2
$T12 = -4						; size = 2
__Overflow_is_possible$13 = -1				; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 2
??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00020	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 cc	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 c4	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00047	50		 push	 eax
  00048	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 cc	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 c8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 bc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 bc	 mov	 eax, DWORD PTR $T5[ebp]
  00065	89 45 a0	 mov	 DWORD PTR __Al$[ebp], eax

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00068	8b 45 c8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006b	40		 inc	 eax
  0006c	89 45 d0	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0006f	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$13[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00073	c7 45 9c ff ff
	ff 7f		 mov	 DWORD PTR __Max_possible$1[ebp], 2147483647 ; 7fffffffH

; 60   :         if (_Count > _Max_possible) {

  0007a	81 7d d0 ff ff
	ff 7f		 cmp	 DWORD PTR __Count$[ebp], 2147483647 ; 7fffffffH
  00081	76 05		 jbe	 SHORT $LN68@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00083	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN68@Reallocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00088	8b 45 d0	 mov	 eax, DWORD PTR __Count$[ebp]
  0008b	d1 e0		 shl	 eax, 1
  0008d	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00090	ff 75 b8	 push	 DWORD PTR $T4[ebp]
  00093	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00098	59		 pop	 ecx
  00099	89 45 b4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0009c	8b 45 b4	 mov	 eax, DWORD PTR $T3[ebp]
  0009f	89 45 d4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  000a2	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a5	8b 4d cc	 mov	 ecx, DWORD PTR __New_size$[ebp]
  000a8	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  000ab	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ae	8b 4d c8	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000b1	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000b4	8b 45 d4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  000b7	89 45 b0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000ba	8b 45 b0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000bd	89 45 ec	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  000c0	83 7d c4 08	 cmp	 DWORD PTR __Old_capacity$[ebp], 8
  000c4	0f 82 90 00 00
	00		 jb	 $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000ca	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  000cd	8b 00		 mov	 eax, DWORD PTR [eax]
  000cf	89 45 c0	 mov	 DWORD PTR __Old_ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000d2	8b 45 c0	 mov	 eax, DWORD PTR __Old_ptr$6[ebp]
  000d5	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d8	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000db	d1 e0		 shl	 eax, 1
  000dd	50		 push	 eax
  000de	ff 75 ac	 push	 DWORD PTR $T2[ebp]
  000e1	ff 75 ec	 push	 DWORD PTR __Raw_new$[ebp]
  000e4	e8 00 00 00 00	 call	 _memcpy
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2976 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  000ec	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000ef	8b 4d ec	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000f2	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000f5	89 45 a8	 mov	 DWORD PTR __First$[ebp], eax

; 277  :         return reinterpret_cast<_Elem*>(_CSTD wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));

  000f8	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  000fb	89 45 e4	 mov	 DWORD PTR __N$10[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 258  :         wchar_t *_Su = _S;

  000fe	8b 45 a8	 mov	 eax, DWORD PTR __First$[ebp]
  00101	89 45 e0	 mov	 DWORD PTR __Su$9[ebp], eax

; 259  :         for (; 0 < _N; ++_Su, --_N)

  00104	eb 0f		 jmp	 SHORT $LN92@Reallocate
$LN90@Reallocate:
  00106	8b 45 e0	 mov	 eax, DWORD PTR __Su$9[ebp]
  00109	40		 inc	 eax
  0010a	40		 inc	 eax
  0010b	89 45 e0	 mov	 DWORD PTR __Su$9[ebp], eax
  0010e	8b 45 e4	 mov	 eax, DWORD PTR __N$10[ebp]
  00111	48		 dec	 eax
  00112	89 45 e4	 mov	 DWORD PTR __N$10[ebp], eax
$LN92@Reallocate:
  00115	83 7d e4 00	 cmp	 DWORD PTR __N$10[ebp], 0
  00119	76 0c		 jbe	 SHORT $LN87@Reallocate

; 260  :         {
; 261  :             *_Su = _C;

  0011b	8b 45 e0	 mov	 eax, DWORD PTR __Su$9[ebp]
  0011e	66 8b 4d 14	 mov	 cx, WORD PTR _<_Args_1>$[ebp]
  00122	66 89 08	 mov	 WORD PTR [eax], cx

; 262  :         }

  00125	eb df		 jmp	 SHORT $LN90@Reallocate
$LN87@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2977 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00127	33 c0		 xor	 eax, eax
  00129	66 89 45 fc	 mov	 WORD PTR $T12[ebp], ax
  0012d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00130	03 45 10	 add	 eax, DWORD PTR _<_Args_0>$[ebp]

; 281  :         _Left = _Right;

  00133	8b 4d ec	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  00136	66 8b 55 fc	 mov	 dx, WORD PTR $T12[ebp]
  0013a	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0013e	8b 45 c4	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  00141	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00145	50		 push	 eax
  00146	ff 75 c0	 push	 DWORD PTR __Old_ptr$6[ebp]
  00149	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0014e	59		 pop	 ecx
  0014f	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  00150	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00153	8b 4d d4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00156	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  00158	eb 74		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0015a	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0015d	d1 e0		 shl	 eax, 1
  0015f	50		 push	 eax
  00160	ff 75 f0	 push	 DWORD PTR __My_data$[ebp]
  00163	ff 75 ec	 push	 DWORD PTR __Raw_new$[ebp]
  00166	e8 00 00 00 00	 call	 _memcpy
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2976 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  0016e	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00171	8b 4d ec	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  00174	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00177	89 45 a4	 mov	 DWORD PTR __First$[ebp], eax

; 277  :         return reinterpret_cast<_Elem*>(_CSTD wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));

  0017a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0017d	89 45 dc	 mov	 DWORD PTR __N$8[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 258  :         wchar_t *_Su = _S;

  00180	8b 45 a4	 mov	 eax, DWORD PTR __First$[ebp]
  00183	89 45 d8	 mov	 DWORD PTR __Su$7[ebp], eax

; 259  :         for (; 0 < _N; ++_Su, --_N)

  00186	eb 0f		 jmp	 SHORT $LN110@Reallocate
$LN108@Reallocate:
  00188	8b 45 d8	 mov	 eax, DWORD PTR __Su$7[ebp]
  0018b	40		 inc	 eax
  0018c	40		 inc	 eax
  0018d	89 45 d8	 mov	 DWORD PTR __Su$7[ebp], eax
  00190	8b 45 dc	 mov	 eax, DWORD PTR __N$8[ebp]
  00193	48		 dec	 eax
  00194	89 45 dc	 mov	 DWORD PTR __N$8[ebp], eax
$LN110@Reallocate:
  00197	83 7d dc 00	 cmp	 DWORD PTR __N$8[ebp], 0
  0019b	76 0c		 jbe	 SHORT $LN105@Reallocate

; 260  :         {
; 261  :             *_Su = _C;

  0019d	8b 45 d8	 mov	 eax, DWORD PTR __Su$7[ebp]
  001a0	66 8b 4d 14	 mov	 cx, WORD PTR _<_Args_1>$[ebp]
  001a4	66 89 08	 mov	 WORD PTR [eax], cx

; 262  :         }

  001a7	eb df		 jmp	 SHORT $LN108@Reallocate
$LN105@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2977 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  001a9	33 c0		 xor	 eax, eax
  001ab	66 89 45 fa	 mov	 WORD PTR $T11[ebp], ax
  001af	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  001b2	03 45 10	 add	 eax, DWORD PTR _<_Args_0>$[ebp]

; 281  :         _Left = _Right;

  001b5	8b 4d ec	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  001b8	66 8b 55 fa	 mov	 dx, WORD PTR $T11[ebp]
  001bc	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  001c0	8d 45 d4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  001c3	50		 push	 eax
  001c4	ff 75 f0	 push	 DWORD PTR __My_data$[ebp]
  001c7	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  001cc	59		 pop	 ecx
  001cd	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  001ce	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
$LN71@Reallocate:

; 4357 :     }

  001d1	c9		 leave
  001d2	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Emplace_reallocate<CGraphicFontTexture::SCharacterInfomation * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@CAXXZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@ABEII@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z ; std::_Uninitialized_move<CGraphicFontTexture::SCharacterInfomation * *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z ; std::_Uninitialized_move<CGraphicFontTexture::SCharacterInfomation * *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z ; std::_Uninitialized_move<CGraphicFontTexture::SCharacterInfomation * *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXPAPAUSCharacterInfomation@CGraphicFontTexture@@0@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@QAEXQAPAUSCharacterInfomation@CGraphicFontTexture@@I@Z ; std::allocator<CGraphicFontTexture::SCharacterInfomation *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXQAPAUSCharacterInfomation@CGraphicFontTexture@@II@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Emplace_reallocate<CGraphicFontTexture::SCharacterInfomation * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXABQAUSCharacterInfomation@CGraphicFontTexture@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXABQAUSCharacterInfomation@CGraphicFontTexture@@@Z PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Emplace_back_with_unused_capacity<CGraphicFontTexture::SCharacterInfomation * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXABQAUSCharacterInfomation@CGraphicFontTexture@@@Z ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Emplace_back_with_unused_capacity<CGraphicFontTexture::SCharacterInfomation * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEXABQAUSCharacterInfomation@CGraphicFontTexture@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEXABQAUSCharacterInfomation@CGraphicFontTexture@@@Z PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::emplace_back<CGraphicFontTexture::SCharacterInfomation * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXABQAUSCharacterInfomation@CGraphicFontTexture@@@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Emplace_back_with_unused_capacity<CGraphicFontTexture::SCharacterInfomation * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Emplace_reallocate<CGraphicFontTexture::SCharacterInfomation * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEXABQAUSCharacterInfomation@CGraphicFontTexture@@@Z ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::emplace_back<CGraphicFontTexture::SCharacterInfomation * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z ; std::_Uninitialized_move<unsigned long *,std::allocator<unsigned long> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z ; std::_Uninitialized_move<unsigned long *,std::allocator<unsigned long> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z ; std::_Uninitialized_move<unsigned long *,std::allocator<unsigned long> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@K@std@@QAEXQAKI@Z ; std::allocator<unsigned long>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEXABK@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEXABK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_back_with_unused_capacity<unsigned long const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEXABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_back_with_unused_capacity<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::emplace_back<unsigned long const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_back_with_unused_capacity<unsigned long const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEPAKQAKABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::emplace_back<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
__Newsize$ = 36						; size = 4
__Constructed_last$ = 40				; size = 4
__Oldsize$ = 44						; size = 4
tv172 = 48						; size = 4
$T19 = 52						; size = 4
$T20 = 56						; size = 4
__My_data$ = 60						; size = 4
__Constructed_first$ = 64				; size = 4
$T21 = 68						; size = 4
$T22 = 72						; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_reallocate<CGraphicTextInstance::SHyperlink const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 20	 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 3c	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 3c	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 3c	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	8b c1		 mov	 eax, ecx
  0005f	99		 cdq
  00060	6a 1c		 push	 28			; 0000001cH
  00062	59		 pop	 ecx
  00063	f7 f9		 idiv	 ecx
  00065	89 45 60	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00068	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 1c		 push	 28			; 0000001cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 2c	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0007b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007e	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00081	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  00084	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00087	c7 45 38 49 92
	24 09		 mov	 DWORD PTR $T20[ebp], 153391689 ; 09249249H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0008e	c7 45 18 ff ff
	ff 7f		 mov	 DWORD PTR $T16[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00095	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  00098	89 45 34	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009b	8b 45 38	 mov	 eax, DWORD PTR $T20[ebp]
  0009e	3b 45 34	 cmp	 eax, DWORD PTR $T19[ebp]
  000a1	73 08		 jae	 SHORT $LN34@Emplace_re
  000a3	8d 45 38	 lea	 eax, DWORD PTR $T20[ebp]
  000a6	89 45 30	 mov	 DWORD PTR tv172[ebp], eax
  000a9	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000ab	8d 45 34	 lea	 eax, DWORD PTR $T19[ebp]
  000ae	89 45 30	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000b1	8b 45 30	 mov	 eax, DWORD PTR tv172[ebp]
  000b4	89 45 14	 mov	 DWORD PTR $T15[ebp], eax
  000b7	8b 45 14	 mov	 eax, DWORD PTR $T15[ebp]
  000ba	89 45 10	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000bd	8b 45 10	 mov	 eax, DWORD PTR $T14[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000c5	8b 45 2c	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c8	3b 45 0c	 cmp	 eax, DWORD PTR $T13[ebp]
  000cb	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000cd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000d2	8b 45 2c	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000d5	40		 inc	 eax
  000d6	89 45 24	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d9	ff 75 24	 push	 DWORD PTR __Newsize$[ebp]
  000dc	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@ABEII@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Calculate_growth
  000e4	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000e7	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000eb	c7 45 bc 49 92
	24 09		 mov	 DWORD PTR __Max_possible$2[ebp], 153391689 ; 09249249H

; 60   :         if (_Count > _Max_possible) {

  000f2	81 7d 54 49 92
	24 09		 cmp	 DWORD PTR __Newcapacity$[ebp], 153391689 ; 09249249H
  000f9	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000fb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00100	6b 45 54 1c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 28
  00104	89 45 08	 mov	 DWORD PTR $T12[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00107	ff 75 08	 push	 DWORD PTR $T12[ebp]
  0010a	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010f	59		 pop	 ecx
  00110	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00113	6b 45 60 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  00117	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0011a	8d 44 01 1c	 lea	 eax, DWORD PTR [ecx+eax+28]
  0011e	89 45 28	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  00121	8b 45 28	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00124	89 45 40	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00127	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0012b	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0012e	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00131	6b 45 60 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  00135	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00138	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0013b	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  0013e	89 45 44	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8b 45 00	 mov	 eax, DWORD PTR $T10[ebp]
  00144	89 45 48	 mov	 DWORD PTR $T22[ebp], eax
  00147	8b 45 44	 mov	 eax, DWORD PTR $T21[ebp]
  0014a	8b 4d 48	 mov	 ecx, DWORD PTR $T22[ebp]
  0014d	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00150	66 89 08	 mov	 WORD PTR [eax], cx
  00153	8b 45 44	 mov	 eax, DWORD PTR $T21[ebp]
  00156	8b 4d 48	 mov	 ecx, DWORD PTR $T22[ebp]
  00159	66 8b 49 02	 mov	 cx, WORD PTR [ecx+2]
  0015d	66 89 48 02	 mov	 WORD PTR [eax+2], cx
  00161	8b 45 48	 mov	 eax, DWORD PTR $T22[ebp]
  00164	83 c0 04	 add	 eax, 4
  00167	50		 push	 eax
  00168	8b 4d 44	 mov	 ecx, DWORD PTR $T21[ebp]
  0016b	83 c1 04	 add	 ecx, 4
  0016e	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00173	6b 45 60 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  00177	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
  0017a	89 45 40	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0017d	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00180	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00183	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00185	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00187	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0018a	8b 00		 mov	 eax, DWORD PTR [eax]
  0018c	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0018f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00192	8b 00		 mov	 eax, DWORD PTR [eax]
  00194	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00197	33 c0		 xor	 eax, eax
  00199	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  0019c	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0019f	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  001a2	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001a5	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001a8	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  001ab	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ae	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  001b1	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b4	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  001b7	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  001ba	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance::SHyperlink *,std::allocator<CGraphicTextInstance::SHyperlink> >
  001bf	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  001c2	eb 5f		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001c4	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001c7	8b 00		 mov	 eax, DWORD PTR [eax]
  001c9	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001cc	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001cf	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001d2	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001d5	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001d8	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001db	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001de	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001e1	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001e4	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance::SHyperlink *,std::allocator<CGraphicTextInstance::SHyperlink> >
  001e9	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001ec	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ef	89 45 40	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001f2	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001f5	8b 00		 mov	 eax, DWORD PTR [eax]
  001f7	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001fa	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001fd	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00200	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  00203	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00206	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00209	6b 45 60 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  0020d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00210	8d 44 01 1c	 lea	 eax, DWORD PTR [ecx+eax+28]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00214	50		 push	 eax
  00215	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  00218	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  0021b	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance::SHyperlink *,std::allocator<CGraphicTextInstance::SHyperlink> >
  00220	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00223	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00225	ff 75 28	 push	 DWORD PTR __Constructed_last$[ebp]
  00228	ff 75 40	 push	 DWORD PTR __Constructed_first$[ebp]
  0022b	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXPAUSHyperlink@CGraphicTextInstance@@0@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00233	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00236	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00239	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  0023c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@USHyperlink@CGraphicTextInstance@@@std@@QAEXQAUSHyperlink@CGraphicTextInstance@@I@Z ; std::allocator<CGraphicTextInstance::SHyperlink>::deallocate

; 762  :         _RERAISE;

  00241	6a 00		 push	 0
  00243	6a 00		 push	 0
  00245	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  0024a	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0024f	c3		 ret	 0
$LN7@Emplace_re:
  00250	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00254	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00256	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  0025a	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0025d	ff 75 24	 push	 DWORD PTR __Newsize$[ebp]
  00260	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00263	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00266	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXQAUSHyperlink@CGraphicTextInstance@@II@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  0026b	6b 45 60 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  0026f	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN70@Emplace_re:

; 767  :     }

  00272	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00275	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0027c	59		 pop	 ecx
  0027d	5f		 pop	 edi
  0027e	5e		 pop	 esi
  0027f	5b		 pop	 ebx
  00280	83 c5 70	 add	 ebp, 112		; 00000070H
  00283	c9		 leave
  00284	c2 08 00	 ret	 8
  00287	cc		 int	 3
  00288	cc		 int	 3
  00289	cc		 int	 3
  0028a	cc		 int	 3
  0028b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_reallocate<CGraphicTextInstance::SHyperlink const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXABUSHyperlink@CGraphicTextInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
__Ptr$ = -24						; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
$T5 = -12						; size = 4
$T6 = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXABUSHyperlink@CGraphicTextInstance@@@Z PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_back_with_unused_capacity<CGraphicTextInstance::SHyperlink const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  0003b	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
  00041	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
  00044	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00047	8b 4d f8	 mov	 ecx, DWORD PTR $T6[ebp]
  0004a	66 8b 09	 mov	 cx, WORD PTR [ecx]
  0004d	66 89 08	 mov	 WORD PTR [eax], cx
  00050	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00053	8b 4d f8	 mov	 ecx, DWORD PTR $T6[ebp]
  00056	66 8b 49 02	 mov	 cx, WORD PTR [ecx+2]
  0005a	66 89 48 02	 mov	 WORD PTR [eax+2], cx
  0005e	8b 45 f8	 mov	 eax, DWORD PTR $T6[ebp]
  00061	83 c0 04	 add	 eax, 4
  00064	50		 push	 eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR $T5[ebp]
  00068	83 c1 04	 add	 ecx, 4
  0006b	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  00070	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00078	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	83 c0 1c	 add	 eax, 28			; 0000001cH
  00080	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00083	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXABUSHyperlink@CGraphicTextInstance@@@Z ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_back_with_unused_capacity<CGraphicTextInstance::SHyperlink const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXABUSHyperlink@CGraphicTextInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXABUSHyperlink@CGraphicTextInstance@@@Z PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::emplace_back<CGraphicTextInstance::SHyperlink const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXABUSHyperlink@CGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_back_with_unused_capacity<CGraphicTextInstance::SHyperlink const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_reallocate<CGraphicTextInstance::SHyperlink const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXABUSHyperlink@CGraphicTextInstance@@@Z ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::emplace_back<CGraphicTextInstance::SHyperlink const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@P6AXPAVCGraphicTextInstance@@@Z@std@@YAP6AXPAVCGraphicTextInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@P6AXPAVCGraphicTextInstance@@@Z@std@@YAP6AXPAVCGraphicTextInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >,void (__cdecl*)(CGraphicTextInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@P6AXPAVCGraphicTextInstance@@@Z@std@@YAP6AXPAVCGraphicTextInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >,void (__cdecl*)(CGraphicTextInstance *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?IsValidToken@@YA_NPBD@Z
_TEXT	SEGMENT
tv92 = -4						; size = 4
_iter$ = 8						; size = 4
?IsValidToken@@YA_NPBD@Z PROC				; IsValidToken, COMDAT

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 88   : 	return	iter[0]=='@' && 

  00004	33 c0		 xor	 eax, eax
  00006	40		 inc	 eax
  00007	6b c0 00	 imul	 eax, eax, 0
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  0000d	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  00011	83 f8 40	 cmp	 eax, 64			; 00000040H
  00014	75 74		 jne	 SHORT $LN3@IsValidTok
  00016	33 c0		 xor	 eax, eax
  00018	40		 inc	 eax
  00019	c1 e0 00	 shl	 eax, 0
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  0001f	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?isNumberic@@YA_ND@Z	; isNumberic
  00029	59		 pop	 ecx
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 59		 je	 SHORT $LN3@IsValidTok
  00031	33 c0		 xor	 eax, eax
  00033	40		 inc	 eax
  00034	d1 e0		 shl	 eax, 1
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00039	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?isNumberic@@YA_ND@Z	; isNumberic
  00043	59		 pop	 ecx
  00044	0f b6 c0	 movzx	 eax, al
  00047	85 c0		 test	 eax, eax
  00049	74 3f		 je	 SHORT $LN3@IsValidTok
  0004b	33 c0		 xor	 eax, eax
  0004d	40		 inc	 eax
  0004e	6b c0 03	 imul	 eax, eax, 3
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00054	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?isNumberic@@YA_ND@Z	; isNumberic
  0005e	59		 pop	 ecx
  0005f	0f b6 c0	 movzx	 eax, al
  00062	85 c0		 test	 eax, eax
  00064	74 24		 je	 SHORT $LN3@IsValidTok
  00066	33 c0		 xor	 eax, eax
  00068	40		 inc	 eax
  00069	c1 e0 02	 shl	 eax, 2
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  0006f	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?isNumberic@@YA_ND@Z	; isNumberic
  00079	59		 pop	 ecx
  0007a	0f b6 c0	 movzx	 eax, al
  0007d	85 c0		 test	 eax, eax
  0007f	74 09		 je	 SHORT $LN3@IsValidTok
  00081	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  00088	eb 04		 jmp	 SHORT $LN4@IsValidTok
$LN3@IsValidTok:
  0008a	83 65 fc 00	 and	 DWORD PTR tv92[ebp], 0
$LN4@IsValidTok:
  0008e	8a 45 fc	 mov	 al, BYTE PTR tv92[ebp]

; 89   : 		isNumberic(iter[1]) && 
; 90   : 		isNumberic(iter[2]) && 
; 91   : 		isNumberic(iter[3]) && 
; 92   : 		isNumberic(iter[4]);
; 93   : }

  00091	c9		 leave
  00092	c3		 ret	 0
?IsValidToken@@YA_NPBD@Z ENDP				; IsValidToken
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?isNumberic@@YA_ND@Z
_TEXT	SEGMENT
_chr$ = 8						; size = 1
?isNumberic@@YA_ND@Z PROC				; isNumberic, COMDAT

; 80   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 81   : 	if (chr >= '0' && chr <= '9')

  00003	0f be 45 08	 movsx	 eax, BYTE PTR _chr$[ebp]
  00007	83 f8 30	 cmp	 eax, 48			; 00000030H
  0000a	7c 0d		 jl	 SHORT $LN2@isNumberic
  0000c	0f be 45 08	 movsx	 eax, BYTE PTR _chr$[ebp]
  00010	83 f8 39	 cmp	 eax, 57			; 00000039H
  00013	7f 04		 jg	 SHORT $LN2@isNumberic

; 82   : 		return true;

  00015	b0 01		 mov	 al, 1
  00017	eb 02		 jmp	 SHORT $LN1@isNumberic
$LN2@isNumberic:

; 83   : 	return false;

  00019	32 c0		 xor	 al, al
$LN1@isNumberic:

; 84   : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?isNumberic@@YA_ND@Z ENDP				; isNumberic
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??__Fgs_hyperlinkText@@YAXXZ
text$yd	SEGMENT
??__Fgs_hyperlinkText@@YAXXZ PROC			; `dynamic atexit destructor for 'gs_hyperlinkText'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2801 :         _Tidy_deallocate();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  00008	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fgs_hyperlinkText@@YAXXZ ENDP			; `dynamic atexit destructor for 'gs_hyperlinkText''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ??__Egs_hyperlinkText@@YAXXZ
text$di	SEGMENT
??__Egs_hyperlinkText@@YAXXZ PROC			; `dynamic initializer for 'gs_hyperlinkText'', COMDAT

; 19   : static std::wstring gs_hyperlinkText;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  00008	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0000d	68 00 00 00 00	 push	 OFFSET ??__Fgs_hyperlinkText@@YAXXZ ; `dynamic atexit destructor for 'gs_hyperlinkText''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Egs_hyperlinkText@@YAXXZ ENDP			; `dynamic initializer for 'gs_hyperlinkText''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CGraphicTextInstance::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A ; CGraphicTextInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ ; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CGraphicTextInstance::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ??__E?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CGraphicTextInstance::ms_kPool'', COMDAT

; 14   : CDynamicPool<CGraphicTextInstance>		CGraphicTextInstance::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A ; CGraphicTextInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCGraphicTextInstance@@@@QAE@XZ ; CDynamicPool<CGraphicTextInstance>::CDynamicPool<CGraphicTextInstance>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CGraphicTextInstance::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CGraphicTextInstance::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CGraphicTextInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ ; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CGraphicTextInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicTextInstance@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicTextInstance@@@2@XZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicTextInstance@@@2@XZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@QAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicTextInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXQAPAVCGraphicTextInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXQAPAVCGraphicTextInstance@@II@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@QAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicTextInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXQAPAVCGraphicTextInstance@@II@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXPAPAVCGraphicTextInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXPAPAVCGraphicTextInstance@@0@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@QAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicTextInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXPAPAVCGraphicTextInstance@@0@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAXPAPAVCGraphicTextInstance@@QAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicTextInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
$T7 = -24						; size = 4
tv81 = -20						; size = 4
$T8 = -16						; size = 4
$T9 = -12						; size = 4
__My_data$10 = -8					; size = 4
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXI@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::reserve, COMDAT
; _this$ = ecx

; 1304 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 e8	 mov	 DWORD PTR $T7[ebp], eax

; 1305 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1306 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00020	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00023	3b 45 e8	 cmp	 eax, DWORD PTR $T7[ebp]
  00026	76 62		 jbe	 SHORT $LN4@reserve

; 1737 :         return _Mypair._Get_first();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T6[ebp]
  00031	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00034	c7 45 f4 ff ff
	ff 3f		 mov	 DWORD PTR $T9[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0003b	c7 45 e0 ff ff
	ff 7f		 mov	 DWORD PTR $T5[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00042	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00045	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00048	8b 45 f4	 mov	 eax, DWORD PTR $T9[ebp]
  0004b	3b 45 f0	 cmp	 eax, DWORD PTR $T8[ebp]
  0004e	73 08		 jae	 SHORT $LN25@reserve
  00050	8d 45 f4	 lea	 eax, DWORD PTR $T9[ebp]
  00053	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
  00056	eb 06		 jmp	 SHORT $LN26@reserve
$LN25@reserve:
  00058	8d 45 f0	 lea	 eax, DWORD PTR $T8[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
$LN26@reserve:
  0005e	8b 45 ec	 mov	 eax, DWORD PTR tv81[ebp]
  00061	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
  00064	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  00067	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0006a	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0006d	8b 00		 mov	 eax, DWORD PTR [eax]
  0006f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 1307 :             if (_Newcapacity > max_size()) {

  00072	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00075	3b 45 d4	 cmp	 eax, DWORD PTR $T2[ebp]
  00078	76 05		 jbe	 SHORT $LN3@reserve

; 1308 :                 _Xlength();

  0007a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlength
$LN3@reserve:

; 1309 :             }
; 1310 : 
; 1311 :             _Reallocate_exactly(_Newcapacity);

  0007f	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reallocate_exactly
$LN4@reserve:

; 1312 :         }
; 1313 :     }

  0008a	c9		 leave
  0008b	c2 04 00	 ret	 4
?reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::reserve
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Max_possible$2 = -80					; size = 4
$T3 = -76						; size = 4
__Size$ = -72						; size = 4
__First$ = -68						; size = 4
__Last$ = -64						; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
$T7 = -48						; size = 4
__Myfirst$ = -44					; size = 4
__Mylast$ = -40						; size = 4
__My_data$ = -36					; size = 4
__Newvec$ = -32						; size = 4
_this$ = -28						; size = 4
___formal$ = -24					; size = 1
__Overflow_is_possible$8 = -18				; size = 1
$T9 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1251 :     void _Reallocate_exactly(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 40	 sub	 esp, 64			; 00000040H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1253 :         auto& _My_data    = _Mypair._Myval2;

  0002f	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00032	89 45 dc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1254 :         pointer& _Myfirst = _My_data._Myfirst;

  00035	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00038	89 45 d4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1255 :         pointer& _Mylast  = _My_data._Mylast;

  0003b	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003e	83 c0 04	 add	 eax, 4
  00041	89 45 d8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1256 : 
; 1257 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  00044	8b 45 d8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00047	8b 4d d4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004e	c1 f8 02	 sar	 eax, 2
  00051	89 45 b8	 mov	 DWORD PTR __Size$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00054	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00057	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0005a	8b 45 d0	 mov	 eax, DWORD PTR $T7[ebp]
  0005d	89 45 b4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00060	c6 45 ee 01	 mov	 BYTE PTR __Overflow_is_possible$8[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00064	c7 45 b0 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  0006b	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  00072	76 05		 jbe	 SHORT $LN17@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00074	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN17@Reallocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00079	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0007c	c1 e0 02	 shl	 eax, 2
  0007f	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00082	ff 75 cc	 push	 DWORD PTR $T6[ebp]
  00085	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0008a	59		 pop	 ecx
  0008b	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1261 :         _TRY_BEGIN

  0008e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1262 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00092	8b 45 d8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00095	8b 00		 mov	 eax, DWORD PTR [eax]
  00097	89 45 c0	 mov	 DWORD PTR __Last$[ebp], eax
  0009a	8b 45 d4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0009d	8b 00		 mov	 eax, DWORD PTR [eax]
  0009f	89 45 bc	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  000a2	33 c0		 xor	 eax, eax
  000a4	88 45 ef	 mov	 BYTE PTR $T9[ebp], al
  000a7	8a 45 ef	 mov	 al, BYTE PTR $T9[ebp]
  000aa	88 45 e8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000ad	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b0	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000b3	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  000b6	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000b9	ff 75 c4	 push	 DWORD PTR $T4[ebp]
  000bc	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  000bf	ff 75 c0	 push	 DWORD PTR __Last$[ebp]
  000c2	ff 75 bc	 push	 DWORD PTR __First$[ebp]
  000c5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@YAPAPAVCGraphicTextInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicTextInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance * *,std::allocator<CGraphicTextInstance *> >
  000ca	83 c4 10	 add	 esp, 16			; 00000010H

; 1262 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  000cd	eb 24		 jmp	 SHORT $LN4@Reallocate
__catch$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z$0:

; 1263 :         _CATCH_ALL
; 1264 :         _Getal().deallocate(_Newvec, _Newcapacity);

  000cf	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  000d2	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  000d5	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicTextInstance@@@2@XZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Getal
  000dd	8b c8		 mov	 ecx, eax
  000df	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXQAPAVCGraphicTextInstance@@I@Z ; std::allocator<CGraphicTextInstance *>::deallocate

; 1265 :         _RERAISE;

  000e4	6a 00		 push	 0
  000e6	6a 00		 push	 0
  000e8	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1266 :         _CATCH_END

  000ed	b8 00 00 00 00	 mov	 eax, $LN7@Reallocate
  000f2	c3		 ret	 0
$LN4@Reallocate:
  000f3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  000f7	eb 04		 jmp	 SHORT __tryend$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z$1
$LN7@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  000f9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1267 : 
; 1268 :         _Change_array(_Newvec, _Size, _Newcapacity);

  000fd	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  00100	ff 75 b8	 push	 DWORD PTR __Size$[ebp]
  00103	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  00106	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXQAPAVCGraphicTextInstance@@II@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Change_array
$LN20@Reallocate:

; 1269 :     }

  0010e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00111	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00118	59		 pop	 ecx
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	c9		 leave
  0011d	c2 04 00	 ret	 4
  00120	cc		 int	 3
  00121	cc		 int	 3
  00122	cc		 int	 3
  00123	cc		 int	 3
  00124	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Reallocate_exactly
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXQAPAVCGraphicTextInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXQAPAVCGraphicTextInstance@@I@Z PROC ; std::allocator<CGraphicTextInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGraphicTextInstance@@@std@@QAEXQAPAVCGraphicTextInstance@@I@Z ENDP ; std::allocator<CGraphicTextInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCGraphicTextInstance@@@@KAXPAVCGraphicTextInstance@@@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCGraphicTextInstance@@@@KAXPAVCGraphicTextInstance@@@Z PROC ; CDynamicPool<CGraphicTextInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 110  : 			delete pkData;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0000f	74 11		 je	 SHORT $LN3@Delete
  00011	6a 01		 push	 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001b	ff 10		 call	 DWORD PTR [eax]
  0001d	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00020	eb 04		 jmp	 SHORT $LN1@Delete
$LN3@Delete:
  00022	83 65 f8 00	 and	 DWORD PTR tv70[ebp], 0
$LN1@Delete:

; 111  : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
?Delete@?$CDynamicPool@VCGraphicTextInstance@@@@KAXPAVCGraphicTextInstance@@@Z ENDP ; CDynamicPool<CGraphicTextInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
$T10 = -36						; size = 4
tv130 = -32						; size = 4
__My_data$11 = -28					; size = 4
__Mylast$12 = -24					; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ PROC ; CDynamicPool<CGraphicTextInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00034	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 e0 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 e0	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 57		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	6a 70		 push	 112			; 00000070H
  0005b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00060	59		 pop	 ecx
  00061	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  00064	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	83 7d dc 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006c	74 0d		 je	 SHORT $LN4@Alloc
  0006e	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  00071	e8 00 00 00 00	 call	 ??0CGraphicTextInstance@@QAE@XZ ; CGraphicTextInstance::CGraphicTextInstance
  00076	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  00079	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0007b	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  0007f	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  00082	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00085	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00089	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0008c	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0008f	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  00092	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00099	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::emplace_back<CGraphicTextInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  0009e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a4	40		 inc	 eax
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000ab	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000ae	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000b0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	83 c0 10	 add	 eax, 16			; 00000010H
  000b6	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000b9	6a 04		 push	 4
  000bb	58		 pop	 eax
  000bc	6b c0 ff	 imul	 eax, eax, -1
  000bf	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000c2	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c5	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000c8	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000cb	8b 00		 mov	 eax, DWORD PTR [eax]
  000cd	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000d0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	83 c0 10	 add	 eax, 16			; 00000010H
  000d6	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000d9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000df	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000e2	83 c0 04	 add	 eax, 4
  000e5	89 45 e8	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000e8	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	83 e8 04	 sub	 eax, 4
  000f0	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f3	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f6	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000f9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000fc	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000ff	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  00102	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00105	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  00108	8b 00		 mov	 eax, DWORD PTR [eax]
  0010a	83 e8 04	 sub	 eax, 4
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  00110	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 73   : 			return pkFreeData;

  00112	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	c9		 leave
  00121	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ$0:
  00000	6a 70		 push	 112			; 00000070H
  00002	ff 75 dc	 push	 DWORD PTR $T10[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ ENDP ; CDynamicPool<CGraphicTextInstance>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ PROC ; CDynamicPool<CGraphicTextInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCGraphicTextInstance@@@@KAXPAVCGraphicTextInstance@@@Z ; CDynamicPool<CGraphicTextInstance>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@std@@P6AXPAVCGraphicTextInstance@@@Z@std@@YAP6AXPAVCGraphicTextInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicTextInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicTextInstance *> > >,void (__cdecl*)(CGraphicTextInstance *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ ENDP ; CDynamicPool<CGraphicTextInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ PROC	; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ ENDP	; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCGraphicTextInstance@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCGraphicTextInstance@@@@QAE@XZ PROC	; CDynamicPool<CGraphicTextInstance>::CDynamicPool<CGraphicTextInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCGraphicTextInstance@@@@QAE@XZ ENDP	; CDynamicPool<CGraphicTextInstance>::CDynamicPool<CGraphicTextInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?ReadToken@@YAHPBD@Z
_TEXT	SEGMENT
_nRet$ = -4						; size = 4
_token$ = 8						; size = 4
?ReadToken@@YAHPBD@Z PROC				; ReadToken, COMDAT

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 116  : 	int nRet = (token[1]-'0')*1000 + (token[2]-'0')*100 + (token[3]-'0')*10 + (token[4]-'0');

  00004	33 c0		 xor	 eax, eax
  00006	40		 inc	 eax
  00007	c1 e0 00	 shl	 eax, 0
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _token$[ebp]
  0000d	0f be 04 01	 movsx	 eax, BYTE PTR [ecx+eax]
  00011	83 e8 30	 sub	 eax, 48			; 00000030H
  00014	69 c0 e8 03 00
	00		 imul	 eax, eax, 1000
  0001a	33 c9		 xor	 ecx, ecx
  0001c	41		 inc	 ecx
  0001d	d1 e1		 shl	 ecx, 1
  0001f	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00022	0f be 0c 0a	 movsx	 ecx, BYTE PTR [edx+ecx]
  00026	83 e9 30	 sub	 ecx, 48			; 00000030H
  00029	6b c9 64	 imul	 ecx, ecx, 100
  0002c	03 c1		 add	 eax, ecx
  0002e	33 c9		 xor	 ecx, ecx
  00030	41		 inc	 ecx
  00031	6b c9 03	 imul	 ecx, ecx, 3
  00034	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00037	0f be 0c 0a	 movsx	 ecx, BYTE PTR [edx+ecx]
  0003b	83 e9 30	 sub	 ecx, 48			; 00000030H
  0003e	6b c9 0a	 imul	 ecx, ecx, 10
  00041	03 c1		 add	 eax, ecx
  00043	33 c9		 xor	 ecx, ecx
  00045	41		 inc	 ecx
  00046	c1 e1 02	 shl	 ecx, 2
  00049	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  0004c	0f be 0c 0a	 movsx	 ecx, BYTE PTR [edx+ecx]
  00050	8d 44 08 d0	 lea	 eax, DWORD PTR [eax+ecx-48]
  00054	89 45 fc	 mov	 DWORD PTR _nRet$[ebp], eax

; 117  : 	if (nRet == 9999)

  00057	81 7d fc 0f 27
	00 00		 cmp	 DWORD PTR _nRet$[ebp], 9999 ; 0000270fH
  0005e	75 07		 jne	 SHORT $LN2@ReadToken

; 118  : 		return CP_UTF8;

  00060	b8 e9 fd 00 00	 mov	 eax, 65001		; 0000fde9H
  00065	eb 03		 jmp	 SHORT $LN1@ReadToken
$LN2@ReadToken:

; 119  : 	return nRet;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _nRet$[ebp]
$LN1@ReadToken:

; 120  : }

  0006a	c9		 leave
  0006b	c3		 ret	 0
?ReadToken@@YAHPBD@Z ENDP				; ReadToken
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?FindToken@@YAPBDPBD0@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
$T4 = -1						; size = 1
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
?FindToken@@YAPBDPBD0@Z PROC				; FindToken, COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
$LN2@FindToken:

; 97   : 	while(begin < end)

  00006	8b 45 08	 mov	 eax, DWORD PTR _begin$[ebp]
  00009	3b 45 0c	 cmp	 eax, DWORD PTR _end$[ebp]
  0000c	73 68		 jae	 SHORT $LN3@FindToken

; 99   : 		begin = find(begin, end, '@');

  0000e	c6 45 ff 40	 mov	 BYTE PTR $T4[ebp], 64	; 00000040H
  00012	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR __Last$[ebp], eax
  00018	8b 45 08	 mov	 eax, DWORD PTR _begin$[ebp]
  0001b	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1303 :         return _It + 0;

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00024	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00027	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax

; 5480 :     _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

  0002a	8d 45 ff	 lea	 eax, DWORD PTR $T4[ebp]
  0002d	50		 push	 eax
  0002e	ff 75 f0	 push	 DWORD PTR $T3[ebp]
  00031	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00034	e8 00 00 00 00	 call	 ??$_Find_unchecked@PBDD@std@@YAPBDQBD0ABD@Z ; std::_Find_unchecked<char const *,char>
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1492 :         _It = static_cast<_UIter&&>(_UIt);

  0003f	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  00042	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 99   : 		begin = find(begin, end, '@');

  00045	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00048	89 45 08	 mov	 DWORD PTR _begin$[ebp], eax

; 100  : 
; 101  : 		if(end-begin>5 && IsValidToken(begin))

  0004b	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
  0004e	2b 45 08	 sub	 eax, DWORD PTR _begin$[ebp]
  00051	83 f8 05	 cmp	 eax, 5
  00054	7e 17		 jle	 SHORT $LN4@FindToken
  00056	ff 75 08	 push	 DWORD PTR _begin$[ebp]
  00059	e8 00 00 00 00	 call	 ?IsValidToken@@YA_NPBD@Z ; IsValidToken
  0005e	59		 pop	 ecx
  0005f	0f b6 c0	 movzx	 eax, al
  00062	85 c0		 test	 eax, eax
  00064	74 07		 je	 SHORT $LN4@FindToken

; 102  : 		{
; 103  : 			return begin;

  00066	8b 45 08	 mov	 eax, DWORD PTR _begin$[ebp]
  00069	eb 0e		 jmp	 SHORT $LN1@FindToken

; 104  : 		}

  0006b	eb 07		 jmp	 SHORT $LN5@FindToken
$LN4@FindToken:

; 105  : 		else
; 106  : 		{
; 107  : 			++begin;

  0006d	8b 45 08	 mov	 eax, DWORD PTR _begin$[ebp]
  00070	40		 inc	 eax
  00071	89 45 08	 mov	 DWORD PTR _begin$[ebp], eax
$LN5@FindToken:

; 108  : 		}
; 109  : 	}

  00074	eb 90		 jmp	 SHORT $LN2@FindToken
$LN3@FindToken:

; 110  : 
; 111  : 	return end;

  00076	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
$LN1@FindToken:

; 112  : }

  00079	c9		 leave
  0007a	c3		 ret	 0
?FindToken@@YAPBDPBD0@Z ENDP				; FindToken
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCGraphicTextInstance@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCGraphicTextInstance@@UAEPAXI@Z PROC		; CGraphicTextInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CGraphicTextInstance@@UAE@XZ ; CGraphicTextInstance::~CGraphicTextInstance
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 70		 push	 112			; 00000070H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GCGraphicTextInstance@@UAEPAXI@Z ENDP		; CGraphicTextInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?Delete@CGraphicTextInstance@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
_pkInst$ = 8						; size = 4
?Delete@CGraphicTextInstance@@SAXPAV1@@Z PROC		; CGraphicTextInstance::Delete, COMDAT

; 917  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 918  : 	pkInst->Destroy();

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  00007	e8 00 00 00 00	 call	 ?Destroy@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Destroy

; 919  : 	ms_kPool.Free(pkInst);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _pkInst$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00012	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
  00015	50		 push	 eax
  00016	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+16
  0001b	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicTextInstance@@@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::emplace_back<CGraphicTextInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 920  : }

  00020	c9		 leave
  00021	c3		 ret	 0
?Delete@CGraphicTextInstance@@SAXPAV1@@Z ENDP		; CGraphicTextInstance::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?New@CGraphicTextInstance@@SAPAV1@XZ
_TEXT	SEGMENT
?New@CGraphicTextInstance@@SAPAV1@XZ PROC		; CGraphicTextInstance::New, COMDAT

; 912  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 913  : 	return ms_kPool.Alloc();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A ; CGraphicTextInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ ; CDynamicPool<CGraphicTextInstance>::Alloc

; 914  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?New@CGraphicTextInstance@@SAPAV1@XZ ENDP		; CGraphicTextInstance::New
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?DestroySystem@CGraphicTextInstance@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CGraphicTextInstance@@SAXXZ PROC		; CGraphicTextInstance::DestroySystem, COMDAT

; 907  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 908  : 	ms_kPool.Destroy();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A ; CGraphicTextInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCGraphicTextInstance@@@@QAEXXZ ; CDynamicPool<CGraphicTextInstance>::Destroy

; 909  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?DestroySystem@CGraphicTextInstance@@SAXXZ ENDP		; CGraphicTextInstance::DestroySystem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?CreateSystem@CGraphicTextInstance@@SAXI@Z
_TEXT	SEGMENT
_uCapacity$ = 8						; size = 4
?CreateSystem@CGraphicTextInstance@@SAXI@Z PROC		; CGraphicTextInstance::CreateSystem, COMDAT

; 902  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 57   : 			m_uInitCapacity=uCapacity;

  00003	8b 45 08	 mov	 eax, DWORD PTR _uCapacity$[ebp]
  00006	a3 1c 00 00 00	 mov	 DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+28, eax

; 58   : 			m_kVct_pkData.reserve(uCapacity);

  0000b	ff 75 08	 push	 DWORD PTR _uCapacity$[ebp]
  0000e	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+4
  00013	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::reserve

; 59   : 			m_kVct_pkFree.reserve(uCapacity);

  00018	ff 75 08	 push	 DWORD PTR _uCapacity$[ebp]
  0001b	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+16
  00020	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::reserve
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 904  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?CreateSystem@CGraphicTextInstance@@SAXI@Z ENDP		; CGraphicTextInstance::CreateSystem
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAXPAUSHyperlink@CGraphicTextInstance@@QAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicTextInstance::SHyperlink> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 1c		 push	 28			; 0000001cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 1c	 imul	 eax, DWORD PTR __Count$[ebp], 28
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXQAUSHyperlink@CGraphicTextInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXQAUSHyperlink@CGraphicTextInstance@@II@Z PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAXPAUSHyperlink@CGraphicTextInstance@@QAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicTextInstance::SHyperlink> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 1c		 push	 28			; 0000001cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 1c	 imul	 eax, DWORD PTR __Count$[ebp], 28
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 1c	 imul	 eax, DWORD PTR __Newsize$[ebp], 28
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 1c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 28
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXQAUSHyperlink@CGraphicTextInstance@@II@Z ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 1c		 push	 28			; 0000001cH
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 49 92
	24 09		 mov	 DWORD PTR $T7[ebp], 153391689 ; 09249249H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXPAUSHyperlink@CGraphicTextInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXPAUSHyperlink@CGraphicTextInstance@@0@Z PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAXPAUSHyperlink@CGraphicTextInstance@@QAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicTextInstance::SHyperlink> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXPAUSHyperlink@CGraphicTextInstance@@0@Z ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAXPAUSHyperlink@CGraphicTextInstance@@QAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicTextInstance::SHyperlink> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::~vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::~vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@USHyperlink@CGraphicTextInstance@@@std@@QAEXQAUSHyperlink@CGraphicTextInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USHyperlink@CGraphicTextInstance@@@std@@QAEXQAUSHyperlink@CGraphicTextInstance@@I@Z PROC ; std::allocator<CGraphicTextInstance::SHyperlink>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 1c	 imul	 eax, DWORD PTR __Count$[ebp], 28
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@USHyperlink@CGraphicTextInstance@@@std@@QAEXQAUSHyperlink@CGraphicTextInstance@@I@Z ENDP ; std::allocator<CGraphicTextInstance::SHyperlink>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z ; std::_Destroy_range<std::allocator<unsigned long> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z ; std::_Destroy_range<std::allocator<unsigned long> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z ; std::_Destroy_range<std::allocator<unsigned long> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z ; std::_Destroy_range<std::allocator<unsigned long> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXQAKI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@K@std@@QAEXQAKI@Z PROC		; std::allocator<unsigned long>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@K@std@@QAEXQAKI@Z ENDP		; std::allocator<unsigned long>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXXZ PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAXPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXXZ ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXQAPAUSCharacterInfomation@CGraphicFontTexture@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXQAPAUSCharacterInfomation@CGraphicFontTexture@@II@Z PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAXPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXQAPAUSCharacterInfomation@CGraphicFontTexture@@II@Z ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@ABEII@Z PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@ABEII@Z ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXPAPAUSCharacterInfomation@CGraphicFontTexture@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXPAPAUSCharacterInfomation@CGraphicFontTexture@@0@Z PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAXPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXPAPAUSCharacterInfomation@CGraphicFontTexture@@0@Z ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@YAXPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU12@AAV?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::~vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXXZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::~vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@QAEXQAPAUSCharacterInfomation@CGraphicFontTexture@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@QAEXQAPAUSCharacterInfomation@CGraphicFontTexture@@I@Z PROC ; std::allocator<CGraphicFontTexture::SCharacterInfomation *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@QAEXQAPAUSCharacterInfomation@CGraphicFontTexture@@I@Z ENDP ; std::allocator<CGraphicFontTexture::SCharacterInfomation *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
;	COMDAT ?SetPointer@?$CRef@VCGraphicText@@@@QAEXPAVCReferenceObject@@@Z
_TEXT	SEGMENT
_pOldObject$ = -8					; size = 4
_this$ = -4						; size = 4
_pObject$ = 8						; size = 4
?SetPointer@?$CRef@VCGraphicText@@@@QAEXPAVCReferenceObject@@@Z PROC ; CRef<CGraphicText>::SetPointer, COMDAT
; _this$ = ecx

; 66   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 67   : 			CReferenceObject* pOldObject = m_pObject;

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 f8	 mov	 DWORD PTR _pOldObject$[ebp], eax

; 68   : 
; 69   : 			m_pObject = pObject;

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pObject$[ebp]
  00016	89 08		 mov	 DWORD PTR [eax], ecx

; 70   : 
; 71   : 			if (m_pObject)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001e	74 0a		 je	 SHORT $LN2@SetPointer

; 72   : 				m_pObject->AddReference();

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference
$LN2@SetPointer:

; 73   : 
; 74   : 			if (pOldObject)

  0002a	83 7d f8 00	 cmp	 DWORD PTR _pOldObject$[ebp], 0
  0002e	74 08		 je	 SHORT $LN1@SetPointer

; 75   : 				pOldObject->Release();

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _pOldObject$[ebp]
  00033	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN1@SetPointer:

; 76   : 		}

  00038	c9		 leave
  00039	c2 04 00	 ret	 4
?SetPointer@?$CRef@VCGraphicText@@@@QAEXPAVCReferenceObject@@@Z ENDP ; CRef<CGraphicText>::SetPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
;	COMDAT ??1?$CRef@VCGraphicText@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CRef@VCGraphicText@@@@QAE@XZ PROC			; CRef<CGraphicText>::~CRef<CGraphicText>, COMDAT
; _this$ = ecx

; 37   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CRef@VCGraphicText@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 53   : 			if (m_pObject)

  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	74 10		 je	 SHORT $LN2@CRef

; 54   : 			{
; 55   : 				m_pObject->Release();

  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	83 20 00	 and	 DWORD PTR [eax], 0
$LN2@CRef:

; 38   : 			Clear();
; 39   : 		}

  0003e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00041	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00048	59		 pop	 ecx
  00049	c9		 leave
  0004a	c3		 ret	 0
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
  0004f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CRef@VCGraphicText@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CRef@VCGraphicText@@@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CRef@VCGraphicText@@@@QAE@XZ ENDP			; CRef<CGraphicText>::~CRef<CGraphicText>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1SHyperlink@CGraphicTextInstance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SHyperlink@CGraphicTextInstance@@QAE@XZ PROC		; CGraphicTextInstance::SHyperlink::~SHyperlink, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4

; 2801 :         _Tidy_deallocate();

  0000d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  00012	c9		 leave
  00013	c3		 ret	 0
??1SHyperlink@CGraphicTextInstance@@QAE@XZ ENDP		; CGraphicTextInstance::SHyperlink::~SHyperlink
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.h
;	COMDAT ??0SHyperlink@CGraphicTextInstance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SHyperlink@CGraphicTextInstance@@QAE@XZ PROC		; CGraphicTextInstance::SHyperlink::SHyperlink, COMDAT
; _this$ = ecx

; 84   : 			SHyperlink() : sx(0), ex(0) { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	66 89 01	 mov	 WORD PTR [ecx], ax
  0000f	33 c0		 xor	 eax, eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	66 89 41 02	 mov	 WORD PTR [ecx+2], ax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 04	 add	 ecx, 4
  0001e	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c3		 ret	 0
??0SHyperlink@CGraphicTextInstance@@QAE@XZ ENDP		; CGraphicTextInstance::SHyperlink::SHyperlink
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
__My_data$3 = -68					; size = 4
$T4 = -64						; size = 4
__My_data$5 = -60					; size = 4
$T6 = -56						; size = 4
__My_data$7 = -52					; size = 4
$T8 = -48						; size = 4
__My_data$9 = -44					; size = 4
$T10 = -40						; size = 4
tv138 = -36						; size = 4
__My_data$11 = -32					; size = 4
__My_data$12 = -28					; size = 4
_sy$ = -24						; size = 4
tv71 = -20						; size = 4
_fFontMaxHeight$ = -16					; size = 4
_sx$ = -12						; size = 4
_i$13 = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z PROC	; CGraphicTextInstance::__GetTextPos, COMDAT
; _this$ = ecx

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 4c	 add	 eax, 76			; 0000004cH
  0000f	89 45 e4	 mov	 DWORD PTR __My_data$12[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00012	8b 45 e4	 mov	 eax, DWORD PTR __My_data$12[ebp]
  00015	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$12[ebp]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	c1 f8 02	 sar	 eax, 2
  00020	89 45 d8	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 57   : 	index = min(index, m_pCharInfoVector.size());

  00023	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00026	3b 45 d8	 cmp	 eax, DWORD PTR $T10[ebp]
  00029	73 08		 jae	 SHORT $LN7@GetTextPos
  0002b	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR tv71[ebp], eax
  00031	eb 20		 jmp	 SHORT $LN14@GetTextPos
$LN7@GetTextPos:
  00033	8b 45 b4	 mov	 eax, DWORD PTR $T1[ebp]
  00036	89 45 ec	 mov	 DWORD PTR tv71[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	83 c0 4c	 add	 eax, 76			; 0000004cH
  0003f	89 45 e0	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00042	8b 45 e0	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00045	8b 4d e0	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00048	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004d	c1 f8 02	 sar	 eax, 2
  00050	89 45 ec	 mov	 DWORD PTR tv71[ebp], eax
$LN14@GetTextPos:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 57   : 	index = min(index, m_pCharInfoVector.size());

  00053	8b 45 ec	 mov	 eax, DWORD PTR tv71[ebp]
  00056	89 45 08	 mov	 DWORD PTR _index$[ebp], eax

; 58   : 
; 59   : 	float sx = 0;

  00059	0f 57 c0	 xorps	 xmm0, xmm0
  0005c	f3 0f 11 45 f4	 movss	 DWORD PTR _sx$[ebp], xmm0

; 60   : 	float sy = 0;

  00061	0f 57 c0	 xorps	 xmm0, xmm0
  00064	f3 0f 11 45 e8	 movss	 DWORD PTR _sy$[ebp], xmm0

; 61   : 	float fFontMaxHeight = 0;

  00069	0f 57 c0	 xorps	 xmm0, xmm0
  0006c	f3 0f 11 45 f0	 movss	 DWORD PTR _fFontMaxHeight$[ebp], xmm0

; 62   : 
; 63   : 	for(DWORD i=0; i<index; ++i)

  00071	83 65 f8 00	 and	 DWORD PTR _i$13[ebp], 0
  00075	eb 07		 jmp	 SHORT $LN4@GetTextPos
$LN2@GetTextPos:
  00077	8b 45 f8	 mov	 eax, DWORD PTR _i$13[ebp]
  0007a	40		 inc	 eax
  0007b	89 45 f8	 mov	 DWORD PTR _i$13[ebp], eax
$LN4@GetTextPos:
  0007e	8b 45 f8	 mov	 eax, DWORD PTR _i$13[ebp]
  00081	3b 45 08	 cmp	 eax, DWORD PTR _index$[ebp]
  00084	0f 83 e2 00 00
	00		 jae	 $LN3@GetTextPos
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	83 c0 4c	 add	 eax, 76			; 0000004cH
  00090	89 45 d4	 mov	 DWORD PTR __My_data$9[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00093	8b 45 d4	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00096	8b 00		 mov	 eax, DWORD PTR [eax]
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _i$13[ebp]
  0009b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0009e	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 65   : 		if (sx+float(m_pCharInfoVector[i]->width) > m_fLimitWidth)

  000a1	8b 45 d0	 mov	 eax, DWORD PTR $T8[ebp]
  000a4	8b 00		 mov	 eax, DWORD PTR [eax]
  000a6	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  000aa	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000ae	f3 0f 58 45 f4	 addss	 xmm0, DWORD PTR _sx$[ebp]
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  000ba	76 17		 jbe	 SHORT $LN5@GetTextPos

; 66   : 		{
; 67   : 			sx = 0;

  000bc	0f 57 c0	 xorps	 xmm0, xmm0
  000bf	f3 0f 11 45 f4	 movss	 DWORD PTR _sx$[ebp], xmm0

; 68   : 			sy += fFontMaxHeight;

  000c4	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _sy$[ebp]
  000c9	f3 0f 58 45 f0	 addss	 xmm0, DWORD PTR _fFontMaxHeight$[ebp]
  000ce	f3 0f 11 45 e8	 movss	 DWORD PTR _sy$[ebp], xmm0
$LN5@GetTextPos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000d3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	83 c0 4c	 add	 eax, 76			; 0000004cH
  000d9	89 45 cc	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  000dc	8b 45 cc	 mov	 eax, DWORD PTR __My_data$7[ebp]
  000df	8b 00		 mov	 eax, DWORD PTR [eax]
  000e1	8b 4d f8	 mov	 ecx, DWORD PTR _i$13[ebp]
  000e4	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000e7	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 71   : 		sx += float(m_pCharInfoVector[i]->advance);

  000ea	8b 45 c8	 mov	 eax, DWORD PTR $T6[ebp]
  000ed	8b 00		 mov	 eax, DWORD PTR [eax]
  000ef	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _sx$[ebp]
  000f4	f3 0f 58 40 18	 addss	 xmm0, DWORD PTR [eax+24]
  000f9	f3 0f 11 45 f4	 movss	 DWORD PTR _sx$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00101	83 c0 4c	 add	 eax, 76			; 0000004cH
  00104	89 45 c4	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00107	8b 45 c4	 mov	 eax, DWORD PTR __My_data$5[ebp]
  0010a	8b 00		 mov	 eax, DWORD PTR [eax]
  0010c	8b 4d f8	 mov	 ecx, DWORD PTR _i$13[ebp]
  0010f	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00112	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 72   : 		fFontMaxHeight = max(float(m_pCharInfoVector[i]->height), fFontMaxHeight);

  00115	8b 45 c0	 mov	 eax, DWORD PTR $T4[ebp]
  00118	8b 00		 mov	 eax, DWORD PTR [eax]
  0011a	0f bf 40 04	 movsx	 eax, WORD PTR [eax+4]
  0011e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00122	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _fFontMaxHeight$[ebp]
  00126	76 2b		 jbe	 SHORT $LN9@GetTextPos
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00128	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0012b	83 c0 4c	 add	 eax, 76			; 0000004cH
  0012e	89 45 bc	 mov	 DWORD PTR __My_data$3[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00131	8b 45 bc	 mov	 eax, DWORD PTR __My_data$3[ebp]
  00134	8b 00		 mov	 eax, DWORD PTR [eax]
  00136	8b 4d f8	 mov	 ecx, DWORD PTR _i$13[ebp]
  00139	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0013c	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 72   : 		fFontMaxHeight = max(float(m_pCharInfoVector[i]->height), fFontMaxHeight);

  0013f	8b 45 b8	 mov	 eax, DWORD PTR $T2[ebp]
  00142	8b 00		 mov	 eax, DWORD PTR [eax]
  00144	0f bf 40 04	 movsx	 eax, WORD PTR [eax+4]
  00148	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0014c	f3 0f 11 45 dc	 movss	 DWORD PTR tv138[ebp], xmm0
  00151	eb 0a		 jmp	 SHORT $LN10@GetTextPos
$LN9@GetTextPos:
  00153	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fFontMaxHeight$[ebp]
  00158	f3 0f 11 45 dc	 movss	 DWORD PTR tv138[ebp], xmm0
$LN10@GetTextPos:
  0015d	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR tv138[ebp]
  00162	f3 0f 11 45 f0	 movss	 DWORD PTR _fFontMaxHeight$[ebp], xmm0

; 73   : 	}

  00167	e9 0b ff ff ff	 jmp	 $LN2@GetTextPos
$LN3@GetTextPos:

; 74   : 
; 75   : 	*x = sx;

  0016c	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  0016f	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _sx$[ebp]
  00174	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 76   : 	*y = sy;

  00178	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0017b	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _sy$[ebp]
  00180	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 77   : }

  00184	c9		 leave
  00185	c2 0c 00	 ret	 12			; 0000000cH
?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z ENDP	; CGraphicTextInstance::__GetTextPos
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z
_TEXT	SEGMENT
tv92 = -12						; size = 4
_pInsCharInfo$ = -8					; size = 4
_this$ = -4						; size = 4
_pFontTexture$ = 8					; size = 4
_codePage$ = 12						; size = 2
_text$ = 16						; size = 2
_dwColor$ = 20						; size = 4
?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z PROC ; CGraphicTextInstance::__DrawCharacter, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 40   : 	CGraphicFontTexture::TCharacterInfomation* pInsCharInfo = pFontTexture->GetCharacterInfomation(codePage, text);

  00009	ff 75 10	 push	 DWORD PTR _text$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR _codePage$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _pFontTexture$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetCharacterInfomation@CGraphicFontTexture@@QAEPAUSCharacterInfomation@1@G_W@Z ; CGraphicFontTexture::GetCharacterInfomation
  00017	89 45 f8	 mov	 DWORD PTR _pInsCharInfo$[ebp], eax

; 41   : 
; 42   : 	if (pInsCharInfo)

  0001a	83 7d f8 00	 cmp	 DWORD PTR _pInsCharInfo$[ebp], 0
  0001e	74 79		 je	 SHORT $LN2@DrawCharac
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00020	8d 45 14	 lea	 eax, DWORD PTR _dwColor$[ebp]
  00023	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 44   : 		m_dwColorInfoVector.push_back(dwColor);

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	83 c1 58	 add	 ecx, 88			; 00000058H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0002a	e8 00 00 00 00	 call	 ??$emplace_back@ABK@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::emplace_back<unsigned long const &>
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _pInsCharInfo$[ebp]
  00032	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 45   : 		m_pCharInfoVector.push_back(pInsCharInfo);

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	83 c1 4c	 add	 ecx, 76			; 0000004cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00039	e8 00 00 00 00	 call	 ??$emplace_back@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEXABQAUSCharacterInfomation@CGraphicFontTexture@@@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::emplace_back<CGraphicFontTexture::SCharacterInfomation * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 47   : 		m_textWidth += pInsCharInfo->advance;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  00045	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00049	8b 45 f8	 mov	 eax, DWORD PTR _pInsCharInfo$[ebp]
  0004c	f3 0f 58 40 18	 addss	 xmm0, DWORD PTR [eax+24]
  00051	f3 0f 2c c0	 cvttss2si eax, xmm0
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 48   : 		m_textHeight = max(pInsCharInfo->height, m_textHeight);

  0005c	8b 45 f8	 mov	 eax, DWORD PTR _pInsCharInfo$[ebp]
  0005f	0f bf 40 04	 movsx	 eax, WORD PTR [eax+4]
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	0f b7 49 0e	 movzx	 ecx, WORD PTR [ecx+14]
  0006a	3b c1		 cmp	 eax, ecx
  0006c	7e 0c		 jle	 SHORT $LN4@DrawCharac
  0006e	8b 45 f8	 mov	 eax, DWORD PTR _pInsCharInfo$[ebp]
  00071	0f bf 40 04	 movsx	 eax, WORD PTR [eax+4]
  00075	89 45 f4	 mov	 DWORD PTR tv92[ebp], eax
  00078	eb 0a		 jmp	 SHORT $LN5@DrawCharac
$LN4@DrawCharac:
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  00081	89 45 f4	 mov	 DWORD PTR tv92[ebp], eax
$LN5@DrawCharac:
  00084	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00087	66 8b 4d f4	 mov	 cx, WORD PTR tv92[ebp]
  0008b	66 89 48 0e	 mov	 WORD PTR [eax+14], cx

; 49   : 		return pInsCharInfo->advance;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR _pInsCharInfo$[ebp]
  00092	f3 0f 2c 40 18	 cvttss2si eax, DWORD PTR [eax+24]
  00097	eb 02		 jmp	 SHORT $LN1@DrawCharac
$LN2@DrawCharac:

; 50   : 	}
; 51   : 	
; 52   : 	return 0;

  00099	33 c0		 xor	 eax, eax
$LN1@DrawCharac:

; 53   : }

  0009b	c9		 leave
  0009c	c2 10 00	 ret	 16			; 00000010H
?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ENDP ; CGraphicTextInstance::__DrawCharacter
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?__Initialize@CGraphicTextInstance@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__Initialize@CGraphicTextInstance@@IAEXXZ PROC		; CGraphicTextInstance::__Initialize, COMDAT
; _this$ = ecx

; 1106 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 43   : 			SetPointer(pObject);

  00007	6a 00		 push	 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1107 : 	m_roText = NULL;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 48	 add	 ecx, 72			; 00000048H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 43   : 			SetPointer(pObject);

  0000f	e8 00 00 00 00	 call	 ?SetPointer@?$CRef@VCGraphicText@@@@QAEXPAVCReferenceObject@@@Z ; CRef<CGraphicText>::SetPointer
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1109 : 	m_hAlign = HORIZONTAL_ALIGN_LEFT;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c6 40 10 01	 mov	 BYTE PTR [eax+16], 1

; 1110 : 	m_vAlign = VERTICAL_ALIGN_TOP;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c6 40 11 10	 mov	 BYTE PTR [eax+17], 16	; 00000010H

; 1111 : 
; 1112 : 	m_iMax = 0;

  00022	33 c0		 xor	 eax, eax
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 1113 : 	m_fLimitWidth = 1600.0f; // NOTE :  .     ? - [levites]

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44c80000
  00036	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 1114 : 
; 1115 : 	m_isCursor = false;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0

; 1116 : 	m_isSecret = false;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	c6 40 19 00	 mov	 BYTE PTR [eax+25], 0

; 1117 : 	m_isMultiLine = false;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	c6 40 1a 00	 mov	 BYTE PTR [eax+26], 0

; 1118 : 
; 1119 : 	m_isOutline = false;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	c6 40 1b 00	 mov	 BYTE PTR [eax+27], 0

; 1120 : 	m_fFontFeather = c_fFontFeather;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00062	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 1121 : 
; 1122 : 	m_isUpdate = false;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	c6 40 44 00	 mov	 BYTE PTR [eax+68], 0

; 1123 : 
; 1124 : 	m_textWidth = 0;

  0006e	33 c0		 xor	 eax, eax
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 1125 : 	m_textHeight = 0;

  00077	33 c0		 xor	 eax, eax
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 1126 : 
; 1127 : 	m_v3Position.x = m_v3Position.y = m_v3Position.z = 0.0f;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	0f 57 c0	 xorps	 xmm0, xmm0
  00086	f3 0f 11 40 40	 movss	 DWORD PTR [eax+64], xmm0
  0008b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	0f 57 c0	 xorps	 xmm0, xmm0
  00091	f3 0f 11 40 3c	 movss	 DWORD PTR [eax+60], xmm0
  00096	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00099	0f 57 c0	 xorps	 xmm0, xmm0
  0009c	f3 0f 11 40 38	 movss	 DWORD PTR [eax+56], xmm0

; 1128 : 
; 1129 : 	m_dwOutLineColor=0xff000000;

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	c7 40 08 00 00
	00 ff		 mov	 DWORD PTR [eax+8], -16777216 ; ff000000H

; 1130 : }

  000ab	c9		 leave
  000ac	c3		 ret	 0
?__Initialize@CGraphicTextInstance@@IAEXXZ ENDP		; CGraphicTextInstance::__Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?GetHorizontalAlign@CGraphicTextInstance@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHorizontalAlign@CGraphicTextInstance@@QAEHXZ PROC	; CGraphicTextInstance::GetHorizontalAlign, COMDAT
; _this$ = ecx

; 1101 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1102 : 	return m_hAlign;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]

; 1103 : }

  0000e	c9		 leave
  0000f	c3		 ret	 0
?GetHorizontalAlign@CGraphicTextInstance@@QAEHXZ ENDP	; CGraphicTextInstance::GetHorizontalAlign
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?PixelPositionToCharacterPosition@CGraphicTextInstance@@QAEHH@Z
_TEXT	SEGMENT
_pCurCharInfo$1 = -32					; size = 4
$T2 = -28						; size = 4
__My_data$3 = -24					; size = 4
$T4 = -20						; size = 4
_this$ = -16						; size = 4
__My_data$5 = -12					; size = 4
_icurPosition$ = -8					; size = 4
_i$6 = -4						; size = 4
_iPixelPosition$ = 8					; size = 4
?PixelPositionToCharacterPosition@CGraphicTextInstance@@QAEHH@Z PROC ; CGraphicTextInstance::PixelPositionToCharacterPosition, COMDAT
; _this$ = ecx

; 1086 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1087 : 	int icurPosition = 0;

  00009	83 65 f8 00	 and	 DWORD PTR _icurPosition$[ebp], 0

; 1088 : 	for (int i = 0; i < (int)m_pCharInfoVector.size(); ++i)

  0000d	83 65 fc 00	 and	 DWORD PTR _i$6[ebp], 0
  00011	eb 07		 jmp	 SHORT $LN4@PixelPosit
$LN2@PixelPosit:
  00013	8b 45 fc	 mov	 eax, DWORD PTR _i$6[ebp]
  00016	40		 inc	 eax
  00017	89 45 fc	 mov	 DWORD PTR _i$6[ebp], eax
$LN4@PixelPosit:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0001a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c0 4c	 add	 eax, 76			; 0000004cH
  00020	89 45 f4	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00023	8b 45 f4	 mov	 eax, DWORD PTR __My_data$5[ebp]
  00026	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$5[ebp]
  00029	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0002e	c1 f8 02	 sar	 eax, 2
  00031	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1088 : 	for (int i = 0; i < (int)m_pCharInfoVector.size(); ++i)

  00034	8b 45 fc	 mov	 eax, DWORD PTR _i$6[ebp]
  00037	3b 45 ec	 cmp	 eax, DWORD PTR $T4[ebp]
  0003a	7d 3b		 jge	 SHORT $LN3@PixelPosit
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	83 c0 4c	 add	 eax, 76			; 0000004cH
  00042	89 45 e8	 mov	 DWORD PTR __My_data$3[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00045	8b 45 e8	 mov	 eax, DWORD PTR __My_data$3[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _i$6[ebp]
  0004d	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00050	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1090 : 		CGraphicFontTexture::TCharacterInfomation* pCurCharInfo = m_pCharInfoVector[i];

  00053	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00056	8b 00		 mov	 eax, DWORD PTR [eax]
  00058	89 45 e0	 mov	 DWORD PTR _pCurCharInfo$1[ebp], eax

; 1091 : 		icurPosition += pCurCharInfo->width;

  0005b	8b 45 e0	 mov	 eax, DWORD PTR _pCurCharInfo$1[ebp]
  0005e	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  00062	03 45 f8	 add	 eax, DWORD PTR _icurPosition$[ebp]
  00065	89 45 f8	 mov	 DWORD PTR _icurPosition$[ebp], eax

; 1092 : 
; 1093 : 		if (iPixelPosition < icurPosition)

  00068	8b 45 08	 mov	 eax, DWORD PTR _iPixelPosition$[ebp]
  0006b	3b 45 f8	 cmp	 eax, DWORD PTR _icurPosition$[ebp]
  0006e	7d 05		 jge	 SHORT $LN5@PixelPosit

; 1094 : 			return i;

  00070	8b 45 fc	 mov	 eax, DWORD PTR _i$6[ebp]
  00073	eb 05		 jmp	 SHORT $LN1@PixelPosit
$LN5@PixelPosit:

; 1095 : 	}

  00075	eb 9c		 jmp	 SHORT $LN2@PixelPosit
$LN3@PixelPosit:

; 1096 : 
; 1097 : 	return -1;

  00077	83 c8 ff	 or	 eax, -1
$LN1@PixelPosit:

; 1098 : }

  0007a	c9		 leave
  0007b	c2 04 00	 ret	 4
?PixelPositionToCharacterPosition@CGraphicTextInstance@@QAEHH@Z ENDP ; CGraphicTextInstance::PixelPositionToCharacterPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?GetTextLineCount@CGraphicTextInstance@@QAEGXZ
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
_fFontAdvance$3 = -80					; size = 4
_fFontWidth$4 = -76					; size = 4
$T5 = -72						; size = 4
$T6 = -68						; size = 4
$T7 = -64						; size = 4
$T8 = -60						; size = 4
___param0$ = -56					; size = 4
$T9 = -52						; size = 4
$T10 = -48						; size = 4
___param0$ = -44					; size = 4
_pCurCharInfo$ = -40					; size = 4
tv181 = -36						; size = 4
tv195 = -32						; size = 4
__My_data$11 = -28					; size = 4
__My_data$12 = -24					; size = 4
_this$ = -20						; size = 4
_fx$ = -16						; size = 4
_itor$ = -12						; size = 4
_wLineCount$ = -8					; size = 2
$T13 = -2						; size = 1
$T14 = -1						; size = 1
?GetTextLineCount@CGraphicTextInstance@@QAEGXZ PROC	; CGraphicTextInstance::GetTextLineCount, COMDAT
; _this$ = ecx

; 1052 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00009	83 65 f4 00	 and	 DWORD PTR _itor$[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1056 : 	float fx = 0.0f;

  0000d	0f 57 c0	 xorps	 xmm0, xmm0
  00010	f3 0f 11 45 f0	 movss	 DWORD PTR _fx$[ebp], xmm0

; 1057 : 	WORD wLineCount = 1;

  00015	33 c0		 xor	 eax, eax
  00017	40		 inc	 eax
  00018	66 89 45 f8	 mov	 WORD PTR _wLineCount$[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0001c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 c0 4c	 add	 eax, 76			; 0000004cH
  00022	89 45 e8	 mov	 DWORD PTR __My_data$12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00025	8b 45 e8	 mov	 eax, DWORD PTR __My_data$12[ebp]
  00028	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0002b	8b 45 e8	 mov	 eax, DWORD PTR __My_data$12[ebp]
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00033	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00036	89 45 d0	 mov	 DWORD PTR $T10[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00039	8d 45 d0	 lea	 eax, DWORD PTR $T10[ebp]
  0003c	89 45 cc	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1058 : 	for (itor=m_pCharInfoVector.begin(); itor!=m_pCharInfoVector.end(); ++itor)

  0003f	8b 45 cc	 mov	 eax, DWORD PTR $T9[ebp]
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	89 45 f4	 mov	 DWORD PTR _itor$[ebp], eax
  00047	eb 09		 jmp	 SHORT $LN28@GetTextLin
$LN2@GetTextLin:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00049	8b 45 f4	 mov	 eax, DWORD PTR _itor$[ebp]
  0004c	83 c0 04	 add	 eax, 4
  0004f	89 45 f4	 mov	 DWORD PTR _itor$[ebp], eax
$LN28@GetTextLin:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00052	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00055	83 c0 4c	 add	 eax, 76			; 0000004cH
  00058	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0005b	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  0005e	89 45 a8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00061	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00064	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00067	89 45 c8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0006a	8b 45 c8	 mov	 eax, DWORD PTR ___param0$[ebp]
  0006d	89 45 c4	 mov	 DWORD PTR $T8[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00070	8d 45 c4	 lea	 eax, DWORD PTR $T8[ebp]
  00073	89 45 c0	 mov	 DWORD PTR $T7[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00076	8b 45 c0	 mov	 eax, DWORD PTR $T7[ebp]
  00079	8b 4d f4	 mov	 ecx, DWORD PTR _itor$[ebp]
  0007c	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0007e	75 09		 jne	 SHORT $LN56@GetTextLin
  00080	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv195[ebp], 1
  00087	eb 04		 jmp	 SHORT $LN57@GetTextLin
$LN56@GetTextLin:
  00089	83 65 e0 00	 and	 DWORD PTR tv195[ebp], 0
$LN57@GetTextLin:
  0008d	8a 45 e0	 mov	 al, BYTE PTR tv195[ebp]
  00090	88 45 ff	 mov	 BYTE PTR $T14[ebp], al

; 153  :         return !(*this == _Right);

  00093	0f b6 45 ff	 movzx	 eax, BYTE PTR $T14[ebp]
  00097	85 c0		 test	 eax, eax
  00099	75 09		 jne	 SHORT $LN51@GetTextLin
  0009b	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv181[ebp], 1
  000a2	eb 04		 jmp	 SHORT $LN52@GetTextLin
$LN51@GetTextLin:
  000a4	83 65 dc 00	 and	 DWORD PTR tv181[ebp], 0
$LN52@GetTextLin:
  000a8	8a 45 dc	 mov	 al, BYTE PTR tv181[ebp]
  000ab	88 45 fe	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1058 : 	for (itor=m_pCharInfoVector.begin(); itor!=m_pCharInfoVector.end(); ++itor)

  000ae	0f b6 45 fe	 movzx	 eax, BYTE PTR $T13[ebp]
  000b2	85 c0		 test	 eax, eax
  000b4	74 6c		 je	 SHORT $LN3@GetTextLin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000b6	8b 45 f4	 mov	 eax, DWORD PTR _itor$[ebp]
  000b9	89 45 bc	 mov	 DWORD PTR $T6[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000bc	8b 45 bc	 mov	 eax, DWORD PTR $T6[ebp]
  000bf	89 45 b8	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1060 : 		pCurCharInfo = *itor;

  000c2	8b 45 b8	 mov	 eax, DWORD PTR $T5[ebp]
  000c5	8b 00		 mov	 eax, DWORD PTR [eax]
  000c7	89 45 d8	 mov	 DWORD PTR _pCurCharInfo$[ebp], eax

; 1061 : 
; 1062 : 		float fFontWidth=float(pCurCharInfo->width);

  000ca	8b 45 d8	 mov	 eax, DWORD PTR _pCurCharInfo$[ebp]
  000cd	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  000d1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000d5	f3 0f 11 45 b4	 movss	 DWORD PTR _fFontWidth$4[ebp], xmm0

; 1063 : 		float fFontAdvance=float(pCurCharInfo->advance);

  000da	8b 45 d8	 mov	 eax, DWORD PTR _pCurCharInfo$[ebp]
  000dd	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  000e2	f3 0f 11 45 b0	 movss	 DWORD PTR _fFontAdvance$3[ebp], xmm0

; 1064 : 		//float fFontHeight=float(pCurCharInfo->height);
; 1065 : 
; 1066 : 		// NOTE :   Width  . - [levites]
; 1067 : 		if (fx+fFontWidth > m_fLimitWidth)

  000e7	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000ec	f3 0f 58 45 b4	 addss	 xmm0, DWORD PTR _fFontWidth$4[ebp]
  000f1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f4	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  000f8	76 14		 jbe	 SHORT $LN5@GetTextLin

; 1068 : 		{
; 1069 : 			fx = 0.0f;

  000fa	0f 57 c0	 xorps	 xmm0, xmm0
  000fd	f3 0f 11 45 f0	 movss	 DWORD PTR _fx$[ebp], xmm0

; 1070 : 			++wLineCount;

  00102	66 8b 45 f8	 mov	 ax, WORD PTR _wLineCount$[ebp]
  00106	66 83 c0 01	 add	 ax, 1
  0010a	66 89 45 f8	 mov	 WORD PTR _wLineCount$[ebp], ax
$LN5@GetTextLin:

; 1071 : 		}
; 1072 : 
; 1073 : 		fx += fFontAdvance;

  0010e	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00113	f3 0f 58 45 b0	 addss	 xmm0, DWORD PTR _fFontAdvance$3[ebp]
  00118	f3 0f 11 45 f0	 movss	 DWORD PTR _fx$[ebp], xmm0

; 1074 : 	}

  0011d	e9 27 ff ff ff	 jmp	 $LN2@GetTextLin
$LN3@GetTextLin:

; 1075 : 
; 1076 : 	return wLineCount;

  00122	66 8b 45 f8	 mov	 ax, WORD PTR _wLineCount$[ebp]

; 1077 : }

  00126	c9		 leave
  00127	c3		 ret	 0
?GetTextLineCount@CGraphicTextInstance@@QAEGXZ ENDP	; CGraphicTextInstance::GetTextLineCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?GetValueStringReference@CGraphicTextInstance@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetValueStringReference@CGraphicTextInstance@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CGraphicTextInstance::GetValueStringReference, COMDAT
; _this$ = ecx

; 1047 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1048 : 	return m_stText;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 20	 add	 eax, 32			; 00000020H

; 1049 : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetValueStringReference@CGraphicTextInstance@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CGraphicTextInstance::GetValueStringReference
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?GetTextSize@CGraphicTextInstance@@QAEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pRetWidth$ = 8						; size = 4
_pRetHeight$ = 12					; size = 4
?GetTextSize@CGraphicTextInstance@@QAEXPAH0@Z PROC	; CGraphicTextInstance::GetTextSize, COMDAT
; _this$ = ecx

; 1080 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1081 : 	*pRetWidth = m_textWidth;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _pRetWidth$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 1082 : 	*pRetHeight = m_textHeight;

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _pRetHeight$[ebp]
  0001d	89 01		 mov	 DWORD PTR [ecx], eax

; 1083 : }

  0001f	c9		 leave
  00020	c2 08 00	 ret	 8
?GetTextSize@CGraphicTextInstance@@QAEXPAH0@Z ENDP	; CGraphicTextInstance::GetTextSize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetLimitWidth@CGraphicTextInstance@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fWidth$ = 8						; size = 4
?SetLimitWidth@CGraphicTextInstance@@QAEXM@Z PROC	; CGraphicTextInstance::SetLimitWidth, COMDAT
; _this$ = ecx

; 1012 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 : 	m_fLimitWidth = fWidth;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fWidth$[ebp]
  0000f	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 1014 : }

  00014	c9		 leave
  00015	c2 04 00	 ret	 4
?SetLimitWidth@CGraphicTextInstance@@QAEXM@Z ENDP	; CGraphicTextInstance::SetLimitWidth
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetMultiLine@CGraphicTextInstance@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Value$ = 8						; size = 1
?SetMultiLine@CGraphicTextInstance@@QAEX_N@Z PROC	; CGraphicTextInstance::SetMultiLine, COMDAT
; _this$ = ecx

; 992  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 993  : 	m_isMultiLine = Value;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 4d 08	 mov	 cl, BYTE PTR _Value$[ebp]
  0000d	88 48 1a	 mov	 BYTE PTR [eax+26], cl

; 994  : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?SetMultiLine@CGraphicTextInstance@@QAEX_N@Z ENDP	; CGraphicTextInstance::SetMultiLine
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetFeather@CGraphicTextInstance@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Value$ = 8						; size = 1
?SetFeather@CGraphicTextInstance@@QAEX_N@Z PROC		; CGraphicTextInstance::SetFeather, COMDAT
; _this$ = ecx

; 980  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 981  : 	if (Value)

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR _Value$[ebp]
  0000b	85 c0		 test	 eax, eax
  0000d	74 12		 je	 SHORT $LN2@SetFeather

; 982  : 	{
; 983  : 		m_fFontFeather = c_fFontFeather;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0001a	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 984  : 	}

  0001f	eb 0b		 jmp	 SHORT $LN3@SetFeather
$LN2@SetFeather:

; 985  : 	else
; 986  : 	{
; 987  : 		m_fFontFeather = 0.0f;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	0f 57 c0	 xorps	 xmm0, xmm0
  00027	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0
$LN3@SetFeather:

; 988  : 	}
; 989  : }

  0002c	c9		 leave
  0002d	c2 04 00	 ret	 4
?SetFeather@CGraphicTextInstance@@QAEX_N@Z ENDP		; CGraphicTextInstance::SetFeather
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetOutline@CGraphicTextInstance@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Value$ = 8						; size = 1
?SetOutline@CGraphicTextInstance@@QAEX_N@Z PROC		; CGraphicTextInstance::SetOutline, COMDAT
; _this$ = ecx

; 975  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 976  : 	m_isOutline = Value;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 4d 08	 mov	 cl, BYTE PTR _Value$[ebp]
  0000d	88 48 1b	 mov	 BYTE PTR [eax+27], cl

; 977  : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?SetOutline@CGraphicTextInstance@@QAEX_N@Z ENDP		; CGraphicTextInstance::SetOutline
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetSecret@CGraphicTextInstance@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Value$ = 8						; size = 1
?SetSecret@CGraphicTextInstance@@QAEX_N@Z PROC		; CGraphicTextInstance::SetSecret, COMDAT
; _this$ = ecx

; 970  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 971  : 	m_isSecret = Value;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 4d 08	 mov	 cl, BYTE PTR _Value$[ebp]
  0000d	88 48 19	 mov	 BYTE PTR [eax+25], cl

; 972  : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?SetSecret@CGraphicTextInstance@@QAEX_N@Z ENDP		; CGraphicTextInstance::SetSecret
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetPosition@CGraphicTextInstance@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
?SetPosition@CGraphicTextInstance@@QAEXMMM@Z PROC	; CGraphicTextInstance::SetPosition, COMDAT
; _this$ = ecx

; 1035 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1036 : 	m_v3Position.x = fx;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0000f	f3 0f 11 40 38	 movss	 DWORD PTR [eax+56], xmm0

; 1037 : 	m_v3Position.y = fy;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0001c	f3 0f 11 40 3c	 movss	 DWORD PTR [eax+60], xmm0

; 1038 : 	m_v3Position.z = fz;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00029	f3 0f 11 40 40	 movss	 DWORD PTR [eax+64], xmm0

; 1039 : }

  0002e	c9		 leave
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?SetPosition@CGraphicTextInstance@@QAEXMMM@Z ENDP	; CGraphicTextInstance::SetPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetValue@CGraphicTextInstance@@QAEXPBDI@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
_c_szText$ = 8						; size = 4
_len$ = 12						; size = 4
?SetValue@CGraphicTextInstance@@QAEXPBDI@Z PROC		; CGraphicTextInstance::SetValue, COMDAT
; _this$ = ecx

; 1026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1027 : 	if (0 == m_stText.compare(c_szText))

  00009	ff 75 08	 push	 DWORD PTR _c_szText$[ebp]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 20	 add	 ecx, 32			; 00000020H
  00012	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@SetValue

; 1028 : 		return;

  0001b	eb 2a		 jmp	 SHORT $LN1@SetValue
$LN2@SetValue:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0001d	ff 75 08	 push	 DWORD PTR _c_szText$[ebp]
  00020	e8 00 00 00 00	 call	 _strlen
  00025	59		 pop	 ecx
  00026	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00029	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0002c	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002f	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00032	ff 75 08	 push	 DWORD PTR _c_szText$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1030 : 	m_stText = c_szText;

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 20	 add	 ecx, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0003b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1031 : 	m_isUpdate = false;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c6 40 44 00	 mov	 BYTE PTR [eax+68], 0
$LN1@SetValue:

; 1032 : }

  00047	c9		 leave
  00048	c2 08 00	 ret	 8
?SetValue@CGraphicTextInstance@@QAEXPBDI@Z ENDP		; CGraphicTextInstance::SetValue
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetValueString@CGraphicTextInstance@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
$T2 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_c_stValue$ = 8						; size = 4
?SetValueString@CGraphicTextInstance@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CGraphicTextInstance::SetValueString, COMDAT
; _this$ = ecx

; 1017 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1018 : 	if (0 == m_stText.compare(c_stValue))

  00009	ff 75 08	 push	 DWORD PTR _c_stValue$[ebp]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 20	 add	 ecx, 32			; 00000020H
  00012	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@SetValueSt

; 1019 : 		return;

  0001b	eb 31		 jmp	 SHORT $LN1@SetValueSt
$LN2@SetValueSt:

; 1020 : 
; 1021 : 	m_stText = c_stValue;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 20	 add	 eax, 32			; 00000020H
  00023	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00026	8b 45 08	 mov	 eax, DWORD PTR _c_stValue$[ebp]
  00029	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	3b 45 f4	 cmp	 eax, DWORD PTR $T2[ebp]
  00032	74 13		 je	 SHORT $LN45@SetValueSt

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00034	33 c0		 xor	 eax, eax
  00036	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00039	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  0003c	ff 75 08	 push	 DWORD PTR _c_stValue$[ebp]
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN45@SetValueSt:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1022 : 	m_isUpdate = false;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c6 40 44 00	 mov	 BYTE PTR [eax+68], 0
$LN1@SetValueSt:

; 1023 : }

  0004e	c9		 leave
  0004f	c2 04 00	 ret	 4
?SetValueString@CGraphicTextInstance@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CGraphicTextInstance::SetValueString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetTextPointer@CGraphicTextInstance@@QAEXPAVCGraphicText@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pText$ = 8						; size = 4
?SetTextPointer@CGraphicTextInstance@@QAEXPAVCGraphicText@@@Z PROC ; CGraphicTextInstance::SetTextPointer, COMDAT
; _this$ = ecx

; 1042 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 43   : 			SetPointer(pObject);

  00007	ff 75 08	 push	 DWORD PTR _pText$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1043 : 	m_roText = pText;

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	83 c1 48	 add	 ecx, 72			; 00000048H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 43   : 			SetPointer(pObject);

  00010	e8 00 00 00 00	 call	 ?SetPointer@?$CRef@VCGraphicText@@@@QAEXPAVCReferenceObject@@@Z ; CRef<CGraphicText>::SetPointer
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1044 : }

  00015	c9		 leave
  00016	c2 04 00	 ret	 4
?SetTextPointer@CGraphicTextInstance@@QAEXPAVCGraphicText@@@Z ENDP ; CGraphicTextInstance::SetTextPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetMax@CGraphicTextInstance@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iMax$ = 8						; size = 4
?SetMax@CGraphicTextInstance@@QAEXH@Z PROC		; CGraphicTextInstance::SetMax, COMDAT
; _this$ = ecx

; 1007 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1008 : 	m_iMax = iMax;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _iMax$[ebp]
  0000e	66 89 48 12	 mov	 WORD PTR [eax+18], cx

; 1009 : }

  00012	c9		 leave
  00013	c2 04 00	 ret	 4
?SetMax@CGraphicTextInstance@@QAEXH@Z ENDP		; CGraphicTextInstance::SetMax
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetVerticalAlign@CGraphicTextInstance@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vAlign$ = 8						; size = 4
?SetVerticalAlign@CGraphicTextInstance@@QAEXH@Z PROC	; CGraphicTextInstance::SetVerticalAlign, COMDAT
; _this$ = ecx

; 1002 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1003 : 	m_vAlign = vAlign;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 4d 08	 mov	 cl, BYTE PTR _vAlign$[ebp]
  0000d	88 48 11	 mov	 BYTE PTR [eax+17], cl

; 1004 : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?SetVerticalAlign@CGraphicTextInstance@@QAEXH@Z ENDP	; CGraphicTextInstance::SetVerticalAlign
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hAlign$ = 8						; size = 4
?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z PROC	; CGraphicTextInstance::SetHorizonalAlign, COMDAT
; _this$ = ecx

; 997  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 998  : 	m_hAlign = hAlign;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 4d 08	 mov	 cl, BYTE PTR _hAlign$[ebp]
  0000d	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 999  : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z ENDP	; CGraphicTextInstance::SetHorizonalAlign
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetOutLineColor@CGraphicTextInstance@@QAEXMMMM@Z
_TEXT	SEGMENT
$T1 = -68						; size = 16
_this$ = -52						; size = 4
_dwB$2 = -48						; size = 4
_dwA$3 = -44						; size = 4
_dwR$4 = -40						; size = 4
_dwG$5 = -36						; size = 4
tv147 = -32						; size = 4
tv146 = -28						; size = 4
tv136 = -24						; size = 4
tv135 = -20						; size = 4
tv93 = -16						; size = 4
tv92 = -12						; size = 4
tv82 = -8						; size = 4
tv81 = -4						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
?SetOutLineColor@CGraphicTextInstance@@QAEXMMMM@Z PROC	; CGraphicTextInstance::SetOutLineColor, COMDAT
; _this$ = ecx

; 965  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 920  :     r = fr;

  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _r$[ebp]
  0000e	f3 0f 11 45 bc	 movss	 DWORD PTR $T1[ebp], xmm0

; 921  :     g = fg;

  00013	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _g$[ebp]
  00018	f3 0f 11 45 c0	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 922  :     b = fb;

  0001d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _b$[ebp]
  00022	f3 0f 11 45 c4	 movss	 DWORD PTR $T1[ebp+8], xmm0

; 923  :     a = fa;

  00027	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _a$[ebp]
  0002c	f3 0f 11 45 c8	 movss	 DWORD PTR $T1[ebp+12], xmm0

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00031	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR $T1[ebp]
  00036	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0003d	72 09		 jb	 SHORT $LN9@SetOutLine
  0003f	c7 45 f8 ff 00
	00 00		 mov	 DWORD PTR tv82[ebp], 255 ; 000000ffH
  00046	eb 32		 jmp	 SHORT $LN10@SetOutLine
$LN9@SetOutLine:
  00048	0f 57 c0	 xorps	 xmm0, xmm0
  0004b	0f 2f 45 bc	 comiss	 xmm0, DWORD PTR $T1[ebp]
  0004f	72 06		 jb	 SHORT $LN7@SetOutLine
  00051	83 65 fc 00	 and	 DWORD PTR tv81[ebp], 0
  00055	eb 1d		 jmp	 SHORT $LN8@SetOutLine
$LN7@SetOutLine:
  00057	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR $T1[ebp]
  0005c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00064	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0006c	e8 00 00 00 00	 call	 __ftoui3
  00071	89 45 fc	 mov	 DWORD PTR tv81[ebp], eax
$LN8@SetOutLine:
  00074	8b 45 fc	 mov	 eax, DWORD PTR tv81[ebp]
  00077	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
$LN10@SetOutLine:
  0007a	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  0007d	89 45 d8	 mov	 DWORD PTR _dwR$4[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00080	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR $T1[ebp+4]
  00085	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0008c	72 09		 jb	 SHORT $LN13@SetOutLine
  0008e	c7 45 f0 ff 00
	00 00		 mov	 DWORD PTR tv93[ebp], 255 ; 000000ffH
  00095	eb 32		 jmp	 SHORT $LN14@SetOutLine
$LN13@SetOutLine:
  00097	0f 57 c0	 xorps	 xmm0, xmm0
  0009a	0f 2f 45 c0	 comiss	 xmm0, DWORD PTR $T1[ebp+4]
  0009e	72 06		 jb	 SHORT $LN11@SetOutLine
  000a0	83 65 f4 00	 and	 DWORD PTR tv92[ebp], 0
  000a4	eb 1d		 jmp	 SHORT $LN12@SetOutLine
$LN11@SetOutLine:
  000a6	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR $T1[ebp+4]
  000ab	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000b3	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000bb	e8 00 00 00 00	 call	 __ftoui3
  000c0	89 45 f4	 mov	 DWORD PTR tv92[ebp], eax
$LN12@SetOutLine:
  000c3	8b 45 f4	 mov	 eax, DWORD PTR tv92[ebp]
  000c6	89 45 f0	 mov	 DWORD PTR tv93[ebp], eax
$LN14@SetOutLine:
  000c9	8b 45 f0	 mov	 eax, DWORD PTR tv93[ebp]
  000cc	89 45 dc	 mov	 DWORD PTR _dwG$5[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  000cf	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR $T1[ebp+8]
  000d4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000db	72 09		 jb	 SHORT $LN17@SetOutLine
  000dd	c7 45 e8 ff 00
	00 00		 mov	 DWORD PTR tv136[ebp], 255 ; 000000ffH
  000e4	eb 32		 jmp	 SHORT $LN18@SetOutLine
$LN17@SetOutLine:
  000e6	0f 57 c0	 xorps	 xmm0, xmm0
  000e9	0f 2f 45 c4	 comiss	 xmm0, DWORD PTR $T1[ebp+8]
  000ed	72 06		 jb	 SHORT $LN15@SetOutLine
  000ef	83 65 ec 00	 and	 DWORD PTR tv135[ebp], 0
  000f3	eb 1d		 jmp	 SHORT $LN16@SetOutLine
$LN15@SetOutLine:
  000f5	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR $T1[ebp+8]
  000fa	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00102	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0010a	e8 00 00 00 00	 call	 __ftoui3
  0010f	89 45 ec	 mov	 DWORD PTR tv135[ebp], eax
$LN16@SetOutLine:
  00112	8b 45 ec	 mov	 eax, DWORD PTR tv135[ebp]
  00115	89 45 e8	 mov	 DWORD PTR tv136[ebp], eax
$LN18@SetOutLine:
  00118	8b 45 e8	 mov	 eax, DWORD PTR tv136[ebp]
  0011b	89 45 d0	 mov	 DWORD PTR _dwB$2[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  0011e	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR $T1[ebp+12]
  00123	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0012a	72 09		 jb	 SHORT $LN21@SetOutLine
  0012c	c7 45 e0 ff 00
	00 00		 mov	 DWORD PTR tv147[ebp], 255 ; 000000ffH
  00133	eb 32		 jmp	 SHORT $LN22@SetOutLine
$LN21@SetOutLine:
  00135	0f 57 c0	 xorps	 xmm0, xmm0
  00138	0f 2f 45 c8	 comiss	 xmm0, DWORD PTR $T1[ebp+12]
  0013c	72 06		 jb	 SHORT $LN19@SetOutLine
  0013e	83 65 e4 00	 and	 DWORD PTR tv146[ebp], 0
  00142	eb 1d		 jmp	 SHORT $LN20@SetOutLine
$LN19@SetOutLine:
  00144	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR $T1[ebp+12]
  00149	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00151	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00159	e8 00 00 00 00	 call	 __ftoui3
  0015e	89 45 e4	 mov	 DWORD PTR tv146[ebp], eax
$LN20@SetOutLine:
  00161	8b 45 e4	 mov	 eax, DWORD PTR tv146[ebp]
  00164	89 45 e0	 mov	 DWORD PTR tv147[ebp], eax
$LN22@SetOutLine:
  00167	8b 45 e0	 mov	 eax, DWORD PTR tv147[ebp]
  0016a	89 45 d4	 mov	 DWORD PTR _dwA$3[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0016d	8b 45 dc	 mov	 eax, DWORD PTR _dwG$5[ebp]
  00170	c1 e0 08	 shl	 eax, 8
  00173	8b 4d d8	 mov	 ecx, DWORD PTR _dwR$4[ebp]
  00176	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00179	8b 55 d4	 mov	 edx, DWORD PTR _dwA$3[ebp]
  0017c	c1 e2 18	 shl	 edx, 24			; 00000018H
  0017f	0b d1		 or	 edx, ecx
  00181	0b d0		 or	 edx, eax
  00183	0b 55 d0	 or	 edx, DWORD PTR _dwB$2[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 966  : 	m_dwOutLineColor=D3DXCOLOR(r, g, b, a);

  00186	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00189	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 967  : }

  0018c	c9		 leave
  0018d	c2 10 00	 ret	 16			; 00000010H
?SetOutLineColor@CGraphicTextInstance@@QAEXMMMM@Z ENDP	; CGraphicTextInstance::SetOutLineColor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetOutLineColor@CGraphicTextInstance@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_color$ = 8						; size = 4
?SetOutLineColor@CGraphicTextInstance@@QAEXK@Z PROC	; CGraphicTextInstance::SetOutLineColor, COMDAT
; _this$ = ecx

; 960  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 961  : 	m_dwOutLineColor=color;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _color$[ebp]
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 962  : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?SetOutLineColor@CGraphicTextInstance@@QAEXK@Z ENDP	; CGraphicTextInstance::SetOutLineColor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetColor@CGraphicTextInstance@@QAEXMMMM@Z
_TEXT	SEGMENT
$T1 = -68						; size = 16
_this$ = -52						; size = 4
_dwB$2 = -48						; size = 4
_dwA$3 = -44						; size = 4
_dwR$4 = -40						; size = 4
_dwG$5 = -36						; size = 4
tv148 = -32						; size = 4
tv147 = -28						; size = 4
tv137 = -24						; size = 4
tv136 = -20						; size = 4
tv94 = -16						; size = 4
tv93 = -12						; size = 4
tv83 = -8						; size = 4
tv82 = -4						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
?SetColor@CGraphicTextInstance@@QAEXMMMM@Z PROC		; CGraphicTextInstance::SetColor, COMDAT
; _this$ = ecx

; 955  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 920  :     r = fr;

  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _r$[ebp]
  0000e	f3 0f 11 45 bc	 movss	 DWORD PTR $T1[ebp], xmm0

; 921  :     g = fg;

  00013	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _g$[ebp]
  00018	f3 0f 11 45 c0	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 922  :     b = fb;

  0001d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _b$[ebp]
  00022	f3 0f 11 45 c4	 movss	 DWORD PTR $T1[ebp+8], xmm0

; 923  :     a = fa;

  00027	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _a$[ebp]
  0002c	f3 0f 11 45 c8	 movss	 DWORD PTR $T1[ebp+12], xmm0

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00031	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR $T1[ebp]
  00036	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0003d	72 09		 jb	 SHORT $LN9@SetColor
  0003f	c7 45 f8 ff 00
	00 00		 mov	 DWORD PTR tv83[ebp], 255 ; 000000ffH
  00046	eb 32		 jmp	 SHORT $LN10@SetColor
$LN9@SetColor:
  00048	0f 57 c0	 xorps	 xmm0, xmm0
  0004b	0f 2f 45 bc	 comiss	 xmm0, DWORD PTR $T1[ebp]
  0004f	72 06		 jb	 SHORT $LN7@SetColor
  00051	83 65 fc 00	 and	 DWORD PTR tv82[ebp], 0
  00055	eb 1d		 jmp	 SHORT $LN8@SetColor
$LN7@SetColor:
  00057	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR $T1[ebp]
  0005c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00064	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0006c	e8 00 00 00 00	 call	 __ftoui3
  00071	89 45 fc	 mov	 DWORD PTR tv82[ebp], eax
$LN8@SetColor:
  00074	8b 45 fc	 mov	 eax, DWORD PTR tv82[ebp]
  00077	89 45 f8	 mov	 DWORD PTR tv83[ebp], eax
$LN10@SetColor:
  0007a	8b 45 f8	 mov	 eax, DWORD PTR tv83[ebp]
  0007d	89 45 d8	 mov	 DWORD PTR _dwR$4[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00080	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR $T1[ebp+4]
  00085	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0008c	72 09		 jb	 SHORT $LN13@SetColor
  0008e	c7 45 f0 ff 00
	00 00		 mov	 DWORD PTR tv94[ebp], 255 ; 000000ffH
  00095	eb 32		 jmp	 SHORT $LN14@SetColor
$LN13@SetColor:
  00097	0f 57 c0	 xorps	 xmm0, xmm0
  0009a	0f 2f 45 c0	 comiss	 xmm0, DWORD PTR $T1[ebp+4]
  0009e	72 06		 jb	 SHORT $LN11@SetColor
  000a0	83 65 f4 00	 and	 DWORD PTR tv93[ebp], 0
  000a4	eb 1d		 jmp	 SHORT $LN12@SetColor
$LN11@SetColor:
  000a6	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR $T1[ebp+4]
  000ab	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000b3	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000bb	e8 00 00 00 00	 call	 __ftoui3
  000c0	89 45 f4	 mov	 DWORD PTR tv93[ebp], eax
$LN12@SetColor:
  000c3	8b 45 f4	 mov	 eax, DWORD PTR tv93[ebp]
  000c6	89 45 f0	 mov	 DWORD PTR tv94[ebp], eax
$LN14@SetColor:
  000c9	8b 45 f0	 mov	 eax, DWORD PTR tv94[ebp]
  000cc	89 45 dc	 mov	 DWORD PTR _dwG$5[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  000cf	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR $T1[ebp+8]
  000d4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000db	72 09		 jb	 SHORT $LN17@SetColor
  000dd	c7 45 e8 ff 00
	00 00		 mov	 DWORD PTR tv137[ebp], 255 ; 000000ffH
  000e4	eb 32		 jmp	 SHORT $LN18@SetColor
$LN17@SetColor:
  000e6	0f 57 c0	 xorps	 xmm0, xmm0
  000e9	0f 2f 45 c4	 comiss	 xmm0, DWORD PTR $T1[ebp+8]
  000ed	72 06		 jb	 SHORT $LN15@SetColor
  000ef	83 65 ec 00	 and	 DWORD PTR tv136[ebp], 0
  000f3	eb 1d		 jmp	 SHORT $LN16@SetColor
$LN15@SetColor:
  000f5	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR $T1[ebp+8]
  000fa	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00102	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0010a	e8 00 00 00 00	 call	 __ftoui3
  0010f	89 45 ec	 mov	 DWORD PTR tv136[ebp], eax
$LN16@SetColor:
  00112	8b 45 ec	 mov	 eax, DWORD PTR tv136[ebp]
  00115	89 45 e8	 mov	 DWORD PTR tv137[ebp], eax
$LN18@SetColor:
  00118	8b 45 e8	 mov	 eax, DWORD PTR tv137[ebp]
  0011b	89 45 d0	 mov	 DWORD PTR _dwB$2[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  0011e	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR $T1[ebp+12]
  00123	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0012a	72 09		 jb	 SHORT $LN21@SetColor
  0012c	c7 45 e0 ff 00
	00 00		 mov	 DWORD PTR tv148[ebp], 255 ; 000000ffH
  00133	eb 32		 jmp	 SHORT $LN22@SetColor
$LN21@SetColor:
  00135	0f 57 c0	 xorps	 xmm0, xmm0
  00138	0f 2f 45 c8	 comiss	 xmm0, DWORD PTR $T1[ebp+12]
  0013c	72 06		 jb	 SHORT $LN19@SetColor
  0013e	83 65 e4 00	 and	 DWORD PTR tv147[ebp], 0
  00142	eb 1d		 jmp	 SHORT $LN20@SetColor
$LN19@SetColor:
  00144	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR $T1[ebp+12]
  00149	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00151	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00159	e8 00 00 00 00	 call	 __ftoui3
  0015e	89 45 e4	 mov	 DWORD PTR tv147[ebp], eax
$LN20@SetColor:
  00161	8b 45 e4	 mov	 eax, DWORD PTR tv147[ebp]
  00164	89 45 e0	 mov	 DWORD PTR tv148[ebp], eax
$LN22@SetColor:
  00167	8b 45 e0	 mov	 eax, DWORD PTR tv148[ebp]
  0016a	89 45 d4	 mov	 DWORD PTR _dwA$3[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0016d	8b 45 dc	 mov	 eax, DWORD PTR _dwG$5[ebp]
  00170	c1 e0 08	 shl	 eax, 8
  00173	8b 4d d8	 mov	 ecx, DWORD PTR _dwR$4[ebp]
  00176	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00179	8b 55 d4	 mov	 edx, DWORD PTR _dwA$3[ebp]
  0017c	c1 e2 18	 shl	 edx, 24			; 00000018H
  0017f	0b d1		 or	 edx, ecx
  00181	0b d0		 or	 edx, eax
  00183	0b 55 d0	 or	 edx, DWORD PTR _dwB$2[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 956  : 	SetColor(D3DXCOLOR(r, g, b, a));

  00186	52		 push	 edx
  00187	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0018a	e8 00 00 00 00	 call	 ?SetColor@CGraphicTextInstance@@QAEXK@Z ; CGraphicTextInstance::SetColor

; 957  : }

  0018f	c9		 leave
  00190	c2 10 00	 ret	 16			; 00000010H
?SetColor@CGraphicTextInstance@@QAEXMMMM@Z ENDP		; CGraphicTextInstance::SetColor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetColor@CGraphicTextInstance@@QAEXK@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
__My_data$2 = -28					; size = 4
$T3 = -24						; size = 4
__My_data$4 = -20					; size = 4
$T5 = -16						; size = 4
__My_data$6 = -12					; size = 4
_i$7 = -8						; size = 4
_this$ = -4						; size = 4
_color$ = 8						; size = 4
?SetColor@CGraphicTextInstance@@QAEXK@Z PROC		; CGraphicTextInstance::SetColor, COMDAT
; _this$ = ecx

; 943  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 944  : 	if (m_dwTextColor != color)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	3b 45 08	 cmp	 eax, DWORD PTR _color$[ebp]
  00012	74 7d		 je	 SHORT $LN1@SetColor

; 946  : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  00014	83 65 f8 00	 and	 DWORD PTR _i$7[ebp], 0
  00018	eb 07		 jmp	 SHORT $LN4@SetColor
$LN2@SetColor:
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _i$7[ebp]
  0001d	40		 inc	 eax
  0001e	89 45 f8	 mov	 DWORD PTR _i$7[ebp], eax
$LN4@SetColor:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c0 4c	 add	 eax, 76			; 0000004cH
  00027	89 45 f4	 mov	 DWORD PTR __My_data$6[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0002a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$6[ebp]
  0002d	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$6[ebp]
  00030	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00033	2b 01		 sub	 eax, DWORD PTR [ecx]
  00035	c1 f8 02	 sar	 eax, 2
  00038	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 946  : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _i$7[ebp]
  0003e	3b 45 f0	 cmp	 eax, DWORD PTR $T5[ebp]
  00041	73 45		 jae	 SHORT $LN3@SetColor
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 58	 add	 eax, 88			; 00000058H
  00049	89 45 ec	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0004c	8b 45 ec	 mov	 eax, DWORD PTR __My_data$4[ebp]
  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _i$7[ebp]
  00054	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00057	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 947  : 			if (m_dwColorInfoVector[i] == m_dwTextColor)

  0005a	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00065	75 1f		 jne	 SHORT $LN6@SetColor
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	83 c0 58	 add	 eax, 88			; 00000058H
  0006d	89 45 e4	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00070	8b 45 e4	 mov	 eax, DWORD PTR __My_data$2[ebp]
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _i$7[ebp]
  00078	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0007b	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 948  : 				m_dwColorInfoVector[i] = color;

  0007e	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp]
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _color$[ebp]
  00084	89 08		 mov	 DWORD PTR [eax], ecx
$LN6@SetColor:
  00086	eb 92		 jmp	 SHORT $LN2@SetColor
$LN3@SetColor:

; 949  : 
; 950  : 		m_dwTextColor = color;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	8b 4d 08	 mov	 ecx, DWORD PTR _color$[ebp]
  0008e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@SetColor:

; 951  : 	}
; 952  : }

  00091	c9		 leave
  00092	c2 04 00	 ret	 4
?SetColor@CGraphicTextInstance@@QAEXK@Z ENDP		; CGraphicTextInstance::SetColor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?HideOutLine@CGraphicTextInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HideOutLine@CGraphicTextInstance@@QAEXXZ PROC		; CGraphicTextInstance::HideOutLine, COMDAT
; _this$ = ecx

; 938  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 939  : 	m_isOutline = false;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 1b 00	 mov	 BYTE PTR [eax+27], 0

; 940  : }

  0000e	c9		 leave
  0000f	c3		 ret	 0
?HideOutLine@CGraphicTextInstance@@QAEXXZ ENDP		; CGraphicTextInstance::HideOutLine
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?ShowOutLine@CGraphicTextInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShowOutLine@CGraphicTextInstance@@QAEXXZ PROC		; CGraphicTextInstance::ShowOutLine, COMDAT
; _this$ = ecx

; 933  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 934  : 	m_isOutline = true;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 1b 01	 mov	 BYTE PTR [eax+27], 1

; 935  : }

  0000e	c9		 leave
  0000f	c3		 ret	 0
?ShowOutLine@CGraphicTextInstance@@QAEXXZ ENDP		; CGraphicTextInstance::ShowOutLine
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?HideCursor@CGraphicTextInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HideCursor@CGraphicTextInstance@@QAEXXZ PROC		; CGraphicTextInstance::HideCursor, COMDAT
; _this$ = ecx

; 928  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 929  : 	m_isCursor = false;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 18 00	 mov	 BYTE PTR [eax+24], 0

; 930  : }

  0000e	c9		 leave
  0000f	c3		 ret	 0
?HideCursor@CGraphicTextInstance@@QAEXXZ ENDP		; CGraphicTextInstance::HideCursor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?ShowCursor@CGraphicTextInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShowCursor@CGraphicTextInstance@@QAEXXZ PROC		; CGraphicTextInstance::ShowCursor, COMDAT
; _this$ = ecx

; 923  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 924  : 	m_isCursor = true;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 18 01	 mov	 BYTE PTR [eax+24], 1

; 925  : }

  0000e	c9		 leave
  0000f	c3		 ret	 0
?ShowCursor@CGraphicTextInstance@@QAEXXZ ENDP		; CGraphicTextInstance::ShowCursor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?Render@CGraphicTextInstance@@QAEXPAUtagRECT@@@Z
_TEXT	SEGMENT
_fFontHalfWeight$1 = -576				; size = 4
$T2 = -572						; size = 4
$T3 = -568						; size = 4
$T4 = -564						; size = 4
$T5 = -560						; size = 4
$T6 = -556						; size = 4
$T7 = -552						; size = 4
$T8 = -548						; size = 4
$T9 = -544						; size = 4
___param0$ = -540					; size = 4
$T10 = -536						; size = 4
$T11 = -532						; size = 4
___param0$ = -528					; size = 4
$T12 = -524						; size = 4
_fx$ = -520						; size = 4
$T13 = -516						; size = 1
$T14 = -512						; size = 4
$T15 = -508						; size = 4
$T16 = -504						; size = 4
$T17 = -500						; size = 4
__Tmp$18 = -496						; size = 4
$T19 = -492						; size = 4
$T20 = -488						; size = 4
___param0$ = -484					; size = 4
___param0$ = -480					; size = 4
$T21 = -476						; size = 4
_dwLighting$ = -472					; size = 4
_dwFogEnable$ = -468					; size = 4
$T22 = -464						; size = 4
_fx$ = -460						; size = 4
_fy$ = -456						; size = 4
_fx$ = -452						; size = 4
_fy$ = -448						; size = 4
_fx$ = -444						; size = 4
_fx$ = -440						; size = 4
_fx$ = -436						; size = 4
_fy$ = -432						; size = 4
_fx$ = -428						; size = 4
_fy$ = -424						; size = 4
_fx$ = -420						; size = 4
tv1191 = -416						; size = 4
$T23 = -412						; size = 4
__My_data$24 = -408					; size = 4
$T25 = -404						; size = 4
$T26 = -400						; size = 4
__My_data$27 = -396					; size = 4
$T28 = -392						; size = 4
$T29 = -388						; size = 4
_ulend$30 = -384					; size = 4
tv568 = -380						; size = 4
__My_data$31 = -376					; size = 4
tv1163 = -372						; size = 4
tv1177 = -368						; size = 4
__Right$ = -364						; size = 4
__My_data$32 = -360					; size = 4
__My_data$33 = -356					; size = 4
tv155 = -352						; size = 4
tv139 = -348						; size = 4
tv91 = -344						; size = 4
tv1386 = -340						; size = 4
tv1400 = -336						; size = 4
__My_data$34 = -332					; size = 4
__My_data$35 = -328					; size = 4
__My_data$36 = -324					; size = 4
_pkText$ = -320						; size = 4
_ulbegin$37 = -316					; size = 4
___t$ = -312						; size = 4
tv812 = -308						; size = 4
_defCodePage$ = -304					; size = 4
_compend$38 = -300					; size = 4
_link$39 = -296						; size = 4
___n$ = -292						; size = 4
_fFontMaxHeight$40 = -288				; size = 4
_ly$41 = -284						; size = 4
_it$42 = -280						; size = 4
_pFontTexture$ = -276					; size = 4
_i$43 = -272						; size = 4
_fFontAdvance$44 = -268					; size = 4
_diffuse$45 = -264					; size = 4
_curpos$46 = -260					; size = 4
_fFontHeight$47 = -256					; size = 4
_fFontWidth$48 = -252					; size = 4
_i$49 = -248						; size = 4
_lx$50 = -244						; size = 4
_ey$51 = -240						; size = 4
_fStanY$ = -236						; size = 4
$T52 = -232						; size = 1
$T53 = -231						; size = 1
$T54 = -230						; size = 1
$T55 = -229						; size = 1
_fFontEy$56 = -228					; size = 4
_fFontEx$57 = -224					; size = 4
_fCurY$58 = -220					; size = 4
_fFontSy$59 = -216					; size = 4
_fFontSx$60 = -212					; size = 4
_ex$61 = -208						; size = 4
_sx$62 = -204						; size = 4
_fStanX$ = -200						; size = 4
_fCurX$63 = -196					; size = 4
_sy$64 = -192						; size = 4
_feather$65 = -188					; size = 4
_pCurCharInfo$66 = -184					; size = 4
_this$ = -180						; size = 4
$T67 = -176						; size = 12
$T68 = -164						; size = 12
$T69 = -152						; size = 12
$T70 = -140						; size = 12
$T71 = -128						; size = 12
$T72 = -116						; size = 12
$T73 = -104						; size = 12
$T74 = -92						; size = 12
_vertices$75 = -80					; size = 96
_akVertex$76 = 16					; size = 96
__$ArrayPad$ = 112					; size = 4
_pClipRect$ = 124					; size = 4
?Render@CGraphicTextInstance@@QAEXPAUtagRECT@@@Z PROC	; CGraphicTextInstance::Render, COMDAT
; _this$ = ecx

; 478  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec b4 02 00
	00		 sub	 esp, 692		; 000002b4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 70	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 479  : 	if (!m_isUpdate)

  0001d	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00023	0f b6 40 44	 movzx	 eax, BYTE PTR [eax+68]
  00027	85 c0		 test	 eax, eax
  00029	75 05		 jne	 SHORT $LN18@Render

; 480  : 		return;	

  0002b	e9 91 18 00 00	 jmp	 $LN1@Render
$LN18@Render:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 80   : 			return static_cast<T*>(m_pObject);

  00030	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  00039	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _pkText$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 483  : 	if (!pkText)

  0003f	83 bd c0 fe ff
	ff 00		 cmp	 DWORD PTR _pkText$[ebp], 0
  00046	75 05		 jne	 SHORT $LN19@Render

; 484  : 		return;

  00048	e9 74 18 00 00	 jmp	 $LN1@Render
$LN19@Render:

; 485  : 
; 486  : 	CGraphicFontTexture* pFontTexture = pkText->GetFontTexturePointer();

  0004d	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _pkText$[ebp]
  00053	e8 00 00 00 00	 call	 ?GetFontTexturePointer@CGraphicText@@QAEPAVCGraphicFontTexture@@XZ ; CGraphicText::GetFontTexturePointer
  00058	89 85 ec fe ff
	ff		 mov	 DWORD PTR _pFontTexture$[ebp], eax

; 487  : 	if (!pFontTexture)

  0005e	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _pFontTexture$[ebp], 0
  00065	75 05		 jne	 SHORT $LN20@Render

; 488  : 		return;

  00067	e9 55 18 00 00	 jmp	 $LN1@Render
$LN20@Render:

; 489  : 
; 490  : 	float fStanX = m_v3Position.x;

  0006c	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00072	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  00077	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _fStanX$[ebp], xmm0

; 491  : 	float fStanY = m_v3Position.y + 1.0f;

  0007f	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00085	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  0008a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00092	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _fStanY$[ebp], xmm0

; 492  : 
; 493  : 	UINT defCodePage = GetDefaultCodePage();

  0009a	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  0009f	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _defCodePage$[ebp], eax

; 494  : 
; 495  : 	if (defCodePage == CP_ARABIC)

  000a5	81 bd d0 fe ff
	ff e8 04 00 00	 cmp	 DWORD PTR _defCodePage$[ebp], 1256 ; 000004e8H
  000af	75 70		 jne	 SHORT $LN21@Render

; 496  : 	{
; 497  : 		switch (m_hAlign)

  000b1	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000b7	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  000ba	88 85 a8 fe ff
	ff		 mov	 BYTE PTR tv91[ebp], al
  000c0	80 bd a8 fe ff
	ff 01		 cmp	 BYTE PTR tv91[ebp], 1
  000c7	74 0b		 je	 SHORT $LN23@Render
  000c9	80 bd a8 fe ff
	ff 02		 cmp	 BYTE PTR tv91[ebp], 2
  000d0	74 26		 je	 SHORT $LN24@Render
  000d2	eb 4b		 jmp	 SHORT $LN2@Render
$LN23@Render:

; 498  : 		{
; 499  : 			case HORIZONTAL_ALIGN_LEFT:
; 500  : 				fStanX -= m_textWidth;

  000d4	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000da	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  000de	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000e2	f3 0f 10 8d 38
	ff ff ff	 movss	 xmm1, DWORD PTR _fStanX$[ebp]
  000ea	f3 0f 5c c8	 subss	 xmm1, xmm0
  000ee	f3 0f 11 8d 38
	ff ff ff	 movss	 DWORD PTR _fStanX$[ebp], xmm1

; 501  : 				break;

  000f6	eb 27		 jmp	 SHORT $LN2@Render
$LN24@Render:

; 502  : 
; 503  : 			case HORIZONTAL_ALIGN_CENTER:
; 504  : 				fStanX -= float(m_textWidth / 2);

  000f8	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000fe	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  00102	99		 cdq
  00103	2b c2		 sub	 eax, edx
  00105	d1 f8		 sar	 eax, 1
  00107	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0010b	f3 0f 10 8d 38
	ff ff ff	 movss	 xmm1, DWORD PTR _fStanX$[ebp]
  00113	f3 0f 5c c8	 subss	 xmm1, xmm0
  00117	f3 0f 11 8d 38
	ff ff ff	 movss	 DWORD PTR _fStanX$[ebp], xmm1
$LN2@Render:

; 505  : 				break;	
; 506  : 		}
; 507  : 	}

  0011f	eb 6e		 jmp	 SHORT $LN4@Render
$LN21@Render:

; 508  : 	else
; 509  : 	{	
; 510  : 		switch (m_hAlign)

  00121	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00127	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  0012a	88 85 a4 fe ff
	ff		 mov	 BYTE PTR tv139[ebp], al
  00130	80 bd a4 fe ff
	ff 02		 cmp	 BYTE PTR tv139[ebp], 2
  00137	74 2f		 je	 SHORT $LN26@Render
  00139	80 bd a4 fe ff
	ff 03		 cmp	 BYTE PTR tv139[ebp], 3
  00140	74 02		 je	 SHORT $LN25@Render
  00142	eb 4b		 jmp	 SHORT $LN4@Render
$LN25@Render:

; 511  : 		{
; 512  : 			case HORIZONTAL_ALIGN_RIGHT:
; 513  : 				fStanX -= m_textWidth;

  00144	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0014a	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  0014e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00152	f3 0f 10 8d 38
	ff ff ff	 movss	 xmm1, DWORD PTR _fStanX$[ebp]
  0015a	f3 0f 5c c8	 subss	 xmm1, xmm0
  0015e	f3 0f 11 8d 38
	ff ff ff	 movss	 DWORD PTR _fStanX$[ebp], xmm1

; 514  : 				break;

  00166	eb 27		 jmp	 SHORT $LN4@Render
$LN26@Render:

; 515  : 
; 516  : 			case HORIZONTAL_ALIGN_CENTER:
; 517  : 				fStanX -= float(m_textWidth / 2);

  00168	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0016e	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  00172	99		 cdq
  00173	2b c2		 sub	 eax, edx
  00175	d1 f8		 sar	 eax, 1
  00177	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0017b	f3 0f 10 8d 38
	ff ff ff	 movss	 xmm1, DWORD PTR _fStanX$[ebp]
  00183	f3 0f 5c c8	 subss	 xmm1, xmm0
  00187	f3 0f 11 8d 38
	ff ff ff	 movss	 DWORD PTR _fStanX$[ebp], xmm1
$LN4@Render:

; 518  : 				break;	
; 519  : 		}
; 520  : 	}
; 521  : 
; 522  : 	switch (m_vAlign)

  0018f	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00195	8a 40 11	 mov	 al, BYTE PTR [eax+17]
  00198	88 85 a0 fe ff
	ff		 mov	 BYTE PTR tv155[ebp], al
  0019e	80 bd a0 fe ff
	ff 20		 cmp	 BYTE PTR tv155[ebp], 32	; 00000020H
  001a5	74 2f		 je	 SHORT $LN28@Render
  001a7	80 bd a0 fe ff
	ff 30		 cmp	 BYTE PTR tv155[ebp], 48	; 00000030H
  001ae	74 02		 je	 SHORT $LN27@Render
  001b0	eb 4e		 jmp	 SHORT $LN6@Render
$LN27@Render:

; 523  : 	{
; 524  : 		case VERTICAL_ALIGN_BOTTOM:
; 525  : 			fStanY -= m_textHeight;

  001b2	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001b8	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  001bc	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001c0	f3 0f 10 8d 14
	ff ff ff	 movss	 xmm1, DWORD PTR _fStanY$[ebp]
  001c8	f3 0f 5c c8	 subss	 xmm1, xmm0
  001cc	f3 0f 11 8d 14
	ff ff ff	 movss	 DWORD PTR _fStanY$[ebp], xmm1

; 526  : 			break;

  001d4	eb 2a		 jmp	 SHORT $LN6@Render
$LN28@Render:

; 527  : 
; 528  : 		case VERTICAL_ALIGN_CENTER:
; 529  : 			fStanY -= float(m_textHeight) / 2.0f;

  001d6	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001dc	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  001e0	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001e4	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  001ec	f3 0f 10 8d 14
	ff ff ff	 movss	 xmm1, DWORD PTR _fStanY$[ebp]
  001f4	f3 0f 5c c8	 subss	 xmm1, xmm0
  001f8	f3 0f 11 8d 14
	ff ff ff	 movss	 DWORD PTR _fStanY$[ebp], xmm1
$LN6@Render:

; 530  : 			break;
; 531  : 	}
; 532  : 
; 533  : 	//WORD FillRectIndices[6] = { 0, 2, 1, 2, 3, 1 };
; 534  : 
; 535  : 	STATEMANAGER.SaveRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

  00200	6a 05		 push	 5
  00202	6a 13		 push	 19			; 00000013H
  00204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0020a	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 536  : 	STATEMANAGER.SaveRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

  0020f	6a 06		 push	 6
  00211	6a 14		 push	 20			; 00000014H
  00213	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00219	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0021e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00223	89 85 30 fe ff
	ff		 mov	 DWORD PTR $T22[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 537  : 	DWORD dwFogEnable = STATEMANAGER.GetRenderState(D3DRS_FOGENABLE);

  00229	6a 1c		 push	 28			; 0000001cH
  0022b	8b 8d 30 fe ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp]
  00231	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState
  00236	89 85 2c fe ff
	ff		 mov	 DWORD PTR _dwFogEnable$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0023c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00241	89 85 f4 fd ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 538  : 	DWORD dwLighting = STATEMANAGER.GetRenderState(D3DRS_LIGHTING);

  00247	68 89 00 00 00	 push	 137			; 00000089H
  0024c	8b 8d f4 fd ff
	ff		 mov	 ecx, DWORD PTR $T12[ebp]
  00252	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState
  00257	89 85 28 fe ff
	ff		 mov	 DWORD PTR _dwLighting$[ebp], eax

; 539  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  0025d	6a 00		 push	 0
  0025f	6a 1c		 push	 28			; 0000001cH
  00261	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00267	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 540  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  0026c	6a 00		 push	 0
  0026e	68 89 00 00 00	 push	 137			; 00000089H
  00273	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00279	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 541  : 
; 542  : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1);

  0027e	68 42 01 00 00	 push	 322			; 00000142H
  00283	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00289	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 543  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1,	D3DTA_TEXTURE);

  0028e	6a 02		 push	 2
  00290	6a 02		 push	 2
  00292	6a 00		 push	 0
  00294	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0029a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 544  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2,	D3DTA_DIFFUSE);

  0029f	6a 00		 push	 0
  002a1	6a 03		 push	 3
  002a3	6a 00		 push	 0
  002a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ab	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 545  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,	D3DTOP_MODULATE);

  002b0	6a 04		 push	 4
  002b2	6a 01		 push	 1
  002b4	6a 00		 push	 0
  002b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002bc	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 546  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1,	D3DTA_TEXTURE);

  002c1	6a 02		 push	 2
  002c3	6a 05		 push	 5
  002c5	6a 00		 push	 0
  002c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002cd	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 547  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG2,	D3DTA_DIFFUSE);

  002d2	6a 00		 push	 0
  002d4	6a 06		 push	 6
  002d6	6a 00		 push	 0
  002d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002de	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 548  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,	D3DTOP_MODULATE);

  002e3	6a 04		 push	 4
  002e5	6a 04		 push	 4
  002e7	6a 00		 push	 0
  002e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ef	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 549  : 
; 550  : 	{
; 551  : 		const float fFontHalfWeight=1.0f;

  002f4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002fc	f3 0f 11 85 c0
	fd ff ff	 movss	 DWORD PTR _fFontHalfWeight$1[ebp], xmm0

; 552  : 
; 553  : 		float fCurX;
; 554  : 		float fCurY;
; 555  : 
; 556  : 		float fFontSx;
; 557  : 		float fFontSy;
; 558  : 		float fFontEx;
; 559  : 		float fFontEy;
; 560  : 		float fFontWidth;
; 561  : 		float fFontHeight;
; 562  : 		float fFontMaxHeight;
; 563  : 		float fFontAdvance;
; 564  : 
; 565  : 		SVertex akVertex[4];
; 566  : 		akVertex[0].z=m_v3Position.z;

  00304	6a 18		 push	 24			; 00000018H
  00306	58		 pop	 eax
  00307	6b c0 00	 imul	 eax, eax, 0
  0030a	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00310	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  00313	89 4c 05 18	 mov	 DWORD PTR _akVertex$76[ebp+eax+8], ecx

; 567  : 		akVertex[1].z=m_v3Position.z;

  00317	6a 18		 push	 24			; 00000018H
  00319	58		 pop	 eax
  0031a	c1 e0 00	 shl	 eax, 0
  0031d	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00323	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  00326	89 4c 05 18	 mov	 DWORD PTR _akVertex$76[ebp+eax+8], ecx

; 568  : 		akVertex[2].z=m_v3Position.z;

  0032a	6a 18		 push	 24			; 00000018H
  0032c	58		 pop	 eax
  0032d	d1 e0		 shl	 eax, 1
  0032f	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00335	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  00338	89 4c 05 18	 mov	 DWORD PTR _akVertex$76[ebp+eax+8], ecx

; 569  : 		akVertex[3].z=m_v3Position.z;

  0033c	6a 18		 push	 24			; 00000018H
  0033e	58		 pop	 eax
  0033f	6b c0 03	 imul	 eax, eax, 3
  00342	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00348	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  0034b	89 4c 05 18	 mov	 DWORD PTR _akVertex$76[ebp+eax+8], ecx

; 570  : 
; 571  : 		CGraphicFontTexture::TCharacterInfomation* pCurCharInfo;		
; 572  : 
; 573  : 		// 
; 574  : 		if (m_isOutline)

  0034f	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00355	0f b6 40 1b	 movzx	 eax, BYTE PTR [eax+27]
  00359	85 c0		 test	 eax, eax
  0035b	0f 84 8b 07 00
	00		 je	 $LN9@Render

; 575  : 		{
; 576  : 			fCurX=fStanX;

  00361	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _fStanX$[ebp]
  00369	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fCurX$63[ebp], xmm0

; 577  : 			fCurY=fStanY;

  00371	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _fStanY$[ebp]
  00379	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _fCurY$58[ebp], xmm0

; 578  : 			fFontMaxHeight=0.0f;

  00381	0f 57 c0	 xorps	 xmm0, xmm0
  00384	f3 0f 11 85 e0
	fe ff ff	 movss	 DWORD PTR _fFontMaxHeight$40[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  0038c	83 a5 08 ff ff
	ff 00		 and	 DWORD PTR _i$49[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00393	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00399	83 c0 4c	 add	 eax, 76			; 0000004cH
  0039c	89 85 9c fe ff
	ff		 mov	 DWORD PTR __My_data$33[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  003a2	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$33[ebp]
  003a8	89 85 c4 fd ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  003ae	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$33[ebp]
  003b4	8b 00		 mov	 eax, DWORD PTR [eax]
  003b6	89 85 f0 fd ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  003bc	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  003c2	89 85 ec fd ff
	ff		 mov	 DWORD PTR $T11[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  003c8	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  003ce	89 85 e8 fd ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 581  : 			for (i=m_pCharInfoVector.begin(); i!=m_pCharInfoVector.end(); ++i)

  003d4	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR $T10[ebp]
  003da	8b 00		 mov	 eax, DWORD PTR [eax]
  003dc	89 85 08 ff ff
	ff		 mov	 DWORD PTR _i$49[ebp], eax
  003e2	eb 0f		 jmp	 SHORT $LN110@Render
$LN8@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  003e4	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _i$49[ebp]
  003ea	83 c0 04	 add	 eax, 4
  003ed	89 85 08 ff ff
	ff		 mov	 DWORD PTR _i$49[ebp], eax
$LN110@Render:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  003f3	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003f9	83 c0 4c	 add	 eax, 76			; 0000004cH
  003fc	89 85 98 fe ff
	ff		 mov	 DWORD PTR __My_data$32[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00402	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$32[ebp]
  00408	89 85 d0 fd ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0040e	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$32[ebp]
  00414	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00417	89 85 e4 fd ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0041d	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00423	89 85 e0 fd ff
	ff		 mov	 DWORD PTR $T9[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00429	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  0042f	89 85 dc fd ff
	ff		 mov	 DWORD PTR $T8[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00435	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  0043b	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _i$49[ebp]
  00441	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00443	75 0c		 jne	 SHORT $LN138@Render
  00445	c7 85 90 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1177[ebp], 1
  0044f	eb 07		 jmp	 SHORT $LN139@Render
$LN138@Render:
  00451	83 a5 90 fe ff
	ff 00		 and	 DWORD PTR tv1177[ebp], 0
$LN139@Render:
  00458	8a 85 90 fe ff
	ff		 mov	 al, BYTE PTR tv1177[ebp]
  0045e	88 85 18 ff ff
	ff		 mov	 BYTE PTR $T52[ebp], al

; 153  :         return !(*this == _Right);

  00464	0f b6 85 18 ff
	ff ff		 movzx	 eax, BYTE PTR $T52[ebp]
  0046b	85 c0		 test	 eax, eax
  0046d	75 0c		 jne	 SHORT $LN133@Render
  0046f	c7 85 8c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1163[ebp], 1
  00479	eb 07		 jmp	 SHORT $LN134@Render
$LN133@Render:
  0047b	83 a5 8c fe ff
	ff 00		 and	 DWORD PTR tv1163[ebp], 0
$LN134@Render:
  00482	8a 85 8c fe ff
	ff		 mov	 al, BYTE PTR tv1163[ebp]
  00488	88 85 1b ff ff
	ff		 mov	 BYTE PTR $T55[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 581  : 			for (i=m_pCharInfoVector.begin(); i!=m_pCharInfoVector.end(); ++i)

  0048e	0f b6 85 1b ff
	ff ff		 movzx	 eax, BYTE PTR $T55[ebp]
  00495	85 c0		 test	 eax, eax
  00497	0f 84 4f 06 00
	00		 je	 $LN9@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  0049d	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _i$49[ebp]
  004a3	89 85 d8 fd ff
	ff		 mov	 DWORD PTR $T7[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  004a9	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  004af	89 85 d4 fd ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 583  : 				pCurCharInfo = *i;

  004b5	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  004bb	8b 00		 mov	 eax, DWORD PTR [eax]
  004bd	89 85 48 ff ff
	ff		 mov	 DWORD PTR _pCurCharInfo$66[ebp], eax

; 584  : 
; 585  : 				fFontWidth=float(pCurCharInfo->width);

  004c3	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _pCurCharInfo$66[ebp]
  004c9	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  004cd	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004d1	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _fFontWidth$48[ebp], xmm0

; 586  : 				fFontHeight=float(pCurCharInfo->height);

  004d9	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _pCurCharInfo$66[ebp]
  004df	0f bf 40 04	 movsx	 eax, WORD PTR [eax+4]
  004e3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004e7	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _fFontHeight$47[ebp], xmm0

; 587  : 				fFontAdvance=float(pCurCharInfo->advance);

  004ef	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _pCurCharInfo$66[ebp]
  004f5	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  004fa	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _fFontAdvance$44[ebp], xmm0

; 588  : 
; 589  : 				// NOTE :   Width  . - [levites]
; 590  : 				if ((fCurX+fFontWidth)-m_v3Position.x > m_fLimitWidth)

  00502	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fCurX$63[ebp]
  0050a	f3 0f 58 85 04
	ff ff ff	 addss	 xmm0, DWORD PTR _fFontWidth$48[ebp]
  00512	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00518	f3 0f 5c 40 38	 subss	 xmm0, DWORD PTR [eax+56]
  0051d	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00523	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  00527	76 3d		 jbe	 SHORT $LN32@Render

; 591  : 				{
; 592  : 					if (m_isMultiLine)

  00529	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0052f	0f b6 40 1a	 movzx	 eax, BYTE PTR [eax+26]
  00533	85 c0		 test	 eax, eax
  00535	74 2a		 je	 SHORT $LN31@Render

; 593  : 					{
; 594  : 						fCurX=fStanX;

  00537	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _fStanX$[ebp]
  0053f	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fCurX$63[ebp], xmm0

; 595  : 						fCurY+=fFontMaxHeight;

  00547	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _fCurY$58[ebp]
  0054f	f3 0f 58 85 e0
	fe ff ff	 addss	 xmm0, DWORD PTR _fFontMaxHeight$40[ebp]
  00557	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _fCurY$58[ebp], xmm0

; 596  : 					}

  0055f	eb 05		 jmp	 SHORT $LN32@Render
$LN31@Render:

; 597  : 					else
; 598  : 					{
; 599  : 						break;

  00561	e9 86 05 00 00	 jmp	 $LN9@Render
$LN32@Render:

; 600  : 					}
; 601  : 				}
; 602  : 
; 603  : 				if (pClipRect)

  00566	83 7d 7c 00	 cmp	 DWORD PTR _pClipRect$[ebp], 0
  0056a	74 2e		 je	 SHORT $LN34@Render

; 604  : 				{
; 605  : 					if (fCurY <= pClipRect->top)

  0056c	8b 45 7c	 mov	 eax, DWORD PTR _pClipRect$[ebp]
  0056f	f3 0f 2a 40 04	 cvtsi2ss xmm0, DWORD PTR [eax+4]
  00574	0f 2f 85 24 ff
	ff ff		 comiss	 xmm0, DWORD PTR _fCurY$58[ebp]
  0057b	72 1d		 jb	 SHORT $LN34@Render

; 606  : 					{
; 607  : 						fCurX += fFontAdvance;

  0057d	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fCurX$63[ebp]
  00585	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _fFontAdvance$44[ebp]
  0058d	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fCurX$63[ebp], xmm0

; 608  : 						continue;

  00595	e9 4a fe ff ff	 jmp	 $LN8@Render
$LN34@Render:

; 609  : 					}
; 610  : 				}
; 611  : 
; 612  : 				fFontSx = fCurX - 0.5f;

  0059a	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fCurX$63[ebp]
  005a2	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  005aa	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _fFontSx$60[ebp], xmm0

; 613  : 				fFontSy = fCurY - 0.5f;

  005b2	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _fCurY$58[ebp]
  005ba	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  005c2	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _fFontSy$59[ebp], xmm0

; 614  : 				fFontEx = fFontSx + fFontWidth;

  005ca	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSx$60[ebp]
  005d2	f3 0f 58 85 04
	ff ff ff	 addss	 xmm0, DWORD PTR _fFontWidth$48[ebp]
  005da	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _fFontEx$57[ebp], xmm0

; 615  : 				fFontEy = fFontSy + fFontHeight;

  005e2	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSy$59[ebp]
  005ea	f3 0f 58 85 00
	ff ff ff	 addss	 xmm0, DWORD PTR _fFontHeight$47[ebp]
  005f2	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _fFontEy$56[ebp], xmm0

; 616  : 
; 617  : 				pFontTexture->SelectTexture(pCurCharInfo->index);

  005fa	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _pCurCharInfo$66[ebp]
  00600	0f bf 00	 movsx	 eax, WORD PTR [eax]
  00603	50		 push	 eax
  00604	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _pFontTexture$[ebp]
  0060a	e8 00 00 00 00	 call	 ?SelectTexture@CGraphicFontTexture@@QAEXK@Z ; CGraphicFontTexture::SelectTexture
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0060f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00614	89 85 7c fe ff
	ff		 mov	 DWORD PTR $T29[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 618  : 				STATEMANAGER.SetTexture(0, pFontTexture->GetD3DTexture());

  0061a	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _pFontTexture$[ebp]
  00620	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00625	50		 push	 eax
  00626	6a 00		 push	 0
  00628	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR $T29[ebp]
  0062e	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 619  : 
; 620  : 				akVertex[0].u=pCurCharInfo->left;

  00633	6a 18		 push	 24			; 00000018H
  00635	58		 pop	 eax
  00636	6b c0 00	 imul	 eax, eax, 0
  00639	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  0063f	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00642	89 4c 05 20	 mov	 DWORD PTR _akVertex$76[ebp+eax+16], ecx

; 621  : 				akVertex[0].v=pCurCharInfo->top;

  00646	6a 18		 push	 24			; 00000018H
  00648	58		 pop	 eax
  00649	6b c0 00	 imul	 eax, eax, 0
  0064c	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  00652	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00655	89 4c 05 24	 mov	 DWORD PTR _akVertex$76[ebp+eax+20], ecx

; 622  : 				akVertex[1].u=pCurCharInfo->left;

  00659	6a 18		 push	 24			; 00000018H
  0065b	58		 pop	 eax
  0065c	c1 e0 00	 shl	 eax, 0
  0065f	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  00665	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00668	89 4c 05 20	 mov	 DWORD PTR _akVertex$76[ebp+eax+16], ecx

; 623  : 				akVertex[1].v=pCurCharInfo->bottom;

  0066c	6a 18		 push	 24			; 00000018H
  0066e	58		 pop	 eax
  0066f	c1 e0 00	 shl	 eax, 0
  00672	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  00678	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0067b	89 4c 05 24	 mov	 DWORD PTR _akVertex$76[ebp+eax+20], ecx

; 624  : 				akVertex[2].u=pCurCharInfo->right;

  0067f	6a 18		 push	 24			; 00000018H
  00681	58		 pop	 eax
  00682	d1 e0		 shl	 eax, 1
  00684	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  0068a	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  0068d	89 4c 05 20	 mov	 DWORD PTR _akVertex$76[ebp+eax+16], ecx

; 625  : 				akVertex[2].v=pCurCharInfo->top;

  00691	6a 18		 push	 24			; 00000018H
  00693	58		 pop	 eax
  00694	d1 e0		 shl	 eax, 1
  00696	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  0069c	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0069f	89 4c 05 24	 mov	 DWORD PTR _akVertex$76[ebp+eax+20], ecx

; 626  : 				akVertex[3].u=pCurCharInfo->right;

  006a3	6a 18		 push	 24			; 00000018H
  006a5	58		 pop	 eax
  006a6	6b c0 03	 imul	 eax, eax, 3
  006a9	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  006af	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  006b2	89 4c 05 20	 mov	 DWORD PTR _akVertex$76[ebp+eax+16], ecx

; 627  : 				akVertex[3].v=pCurCharInfo->bottom;

  006b6	6a 18		 push	 24			; 00000018H
  006b8	58		 pop	 eax
  006b9	6b c0 03	 imul	 eax, eax, 3
  006bc	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  006c2	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  006c5	89 4c 05 24	 mov	 DWORD PTR _akVertex$76[ebp+eax+20], ecx

; 628  : 
; 629  : 				akVertex[3].color = akVertex[2].color = akVertex[1].color = akVertex[0].color = m_dwOutLineColor;

  006c9	6a 18		 push	 24			; 00000018H
  006cb	58		 pop	 eax
  006cc	6b c0 00	 imul	 eax, eax, 0
  006cf	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006d5	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  006d8	89 4c 05 1c	 mov	 DWORD PTR _akVertex$76[ebp+eax+12], ecx
  006dc	6a 18		 push	 24			; 00000018H
  006de	58		 pop	 eax
  006df	6b c0 00	 imul	 eax, eax, 0
  006e2	6a 18		 push	 24			; 00000018H
  006e4	59		 pop	 ecx
  006e5	c1 e1 00	 shl	 ecx, 0
  006e8	8b 44 05 1c	 mov	 eax, DWORD PTR _akVertex$76[ebp+eax+12]
  006ec	89 44 0d 1c	 mov	 DWORD PTR _akVertex$76[ebp+ecx+12], eax
  006f0	6a 18		 push	 24			; 00000018H
  006f2	58		 pop	 eax
  006f3	c1 e0 00	 shl	 eax, 0
  006f6	6a 18		 push	 24			; 00000018H
  006f8	59		 pop	 ecx
  006f9	d1 e1		 shl	 ecx, 1
  006fb	8b 44 05 1c	 mov	 eax, DWORD PTR _akVertex$76[ebp+eax+12]
  006ff	89 44 0d 1c	 mov	 DWORD PTR _akVertex$76[ebp+ecx+12], eax
  00703	6a 18		 push	 24			; 00000018H
  00705	58		 pop	 eax
  00706	d1 e0		 shl	 eax, 1
  00708	6a 18		 push	 24			; 00000018H
  0070a	59		 pop	 ecx
  0070b	6b c9 03	 imul	 ecx, ecx, 3
  0070e	8b 44 05 1c	 mov	 eax, DWORD PTR _akVertex$76[ebp+eax+12]
  00712	89 44 0d 1c	 mov	 DWORD PTR _akVertex$76[ebp+ecx+12], eax

; 630  : 
; 631  : 				
; 632  : 				float feather = 0.0f; // m_fFontFeather

  00716	0f 57 c0	 xorps	 xmm0, xmm0
  00719	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _feather$65[ebp], xmm0

; 633  : 				
; 634  : 				akVertex[0].y=fFontSy-feather;

  00721	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSy$59[ebp]
  00729	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _feather$65[ebp]
  00731	6a 18		 push	 24			; 00000018H
  00733	58		 pop	 eax
  00734	6b c0 00	 imul	 eax, eax, 0
  00737	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 635  : 				akVertex[1].y=fFontEy+feather;

  0073d	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEy$56[ebp]
  00745	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _feather$65[ebp]
  0074d	6a 18		 push	 24			; 00000018H
  0074f	58		 pop	 eax
  00750	c1 e0 00	 shl	 eax, 0
  00753	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 636  : 				akVertex[2].y=fFontSy-feather;

  00759	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSy$59[ebp]
  00761	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _feather$65[ebp]
  00769	6a 18		 push	 24			; 00000018H
  0076b	58		 pop	 eax
  0076c	d1 e0		 shl	 eax, 1
  0076e	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 637  : 				akVertex[3].y=fFontEy+feather;

  00774	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEy$56[ebp]
  0077c	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _feather$65[ebp]
  00784	6a 18		 push	 24			; 00000018H
  00786	58		 pop	 eax
  00787	6b c0 03	 imul	 eax, eax, 3
  0078a	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 638  : 
; 639  : 				// 
; 640  : 				akVertex[0].x=fFontSx-fFontHalfWeight-feather;

  00790	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSx$60[ebp]
  00798	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  007a0	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _feather$65[ebp]
  007a8	6a 18		 push	 24			; 00000018H
  007aa	58		 pop	 eax
  007ab	6b c0 00	 imul	 eax, eax, 0
  007ae	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 641  : 				akVertex[1].x=fFontSx-fFontHalfWeight-feather;

  007b4	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSx$60[ebp]
  007bc	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  007c4	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _feather$65[ebp]
  007cc	6a 18		 push	 24			; 00000018H
  007ce	58		 pop	 eax
  007cf	c1 e0 00	 shl	 eax, 0
  007d2	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 642  : 				akVertex[2].x=fFontEx-fFontHalfWeight+feather;

  007d8	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEx$57[ebp]
  007e0	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  007e8	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _feather$65[ebp]
  007f0	6a 18		 push	 24			; 00000018H
  007f2	58		 pop	 eax
  007f3	d1 e0		 shl	 eax, 1
  007f5	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 643  : 				akVertex[3].x=fFontEx-fFontHalfWeight+feather;

  007fb	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEx$57[ebp]
  00803	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0080b	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _feather$65[ebp]
  00813	6a 18		 push	 24			; 00000018H
  00815	58		 pop	 eax
  00816	6b c0 03	 imul	 eax, eax, 3
  00819	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 644  : 				
; 645  : 				if (CGraphicBase::SetPDTStream((SPDTVertex*)akVertex, 4))

  0081f	6a 04		 push	 4
  00821	8d 45 10	 lea	 eax, DWORD PTR _akVertex$76[ebp]
  00824	50		 push	 eax
  00825	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  0082a	59		 pop	 ecx
  0082b	59		 pop	 ecx
  0082c	0f b6 c0	 movzx	 eax, al
  0082f	85 c0		 test	 eax, eax
  00831	74 11		 je	 SHORT $LN35@Render

; 646  : 					STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

  00833	6a 02		 push	 2
  00835	6a 00		 push	 0
  00837	6a 05		 push	 5
  00839	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0083f	e8 00 00 00 00	 call	 ?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z ; CStateManager::DrawPrimitive
$LN35@Render:

; 647  : 				
; 648  : 
; 649  : 				// 
; 650  : 				akVertex[0].x=fFontSx+fFontHalfWeight-feather;

  00844	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSx$60[ebp]
  0084c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00854	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _feather$65[ebp]
  0085c	6a 18		 push	 24			; 00000018H
  0085e	58		 pop	 eax
  0085f	6b c0 00	 imul	 eax, eax, 0
  00862	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 651  : 				akVertex[1].x=fFontSx+fFontHalfWeight-feather;

  00868	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSx$60[ebp]
  00870	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00878	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _feather$65[ebp]
  00880	6a 18		 push	 24			; 00000018H
  00882	58		 pop	 eax
  00883	c1 e0 00	 shl	 eax, 0
  00886	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 652  : 				akVertex[2].x=fFontEx+fFontHalfWeight+feather;

  0088c	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEx$57[ebp]
  00894	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  0089c	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _feather$65[ebp]
  008a4	6a 18		 push	 24			; 00000018H
  008a6	58		 pop	 eax
  008a7	d1 e0		 shl	 eax, 1
  008a9	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 653  : 				akVertex[3].x=fFontEx+fFontHalfWeight+feather;

  008af	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEx$57[ebp]
  008b7	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  008bf	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _feather$65[ebp]
  008c7	6a 18		 push	 24			; 00000018H
  008c9	58		 pop	 eax
  008ca	6b c0 03	 imul	 eax, eax, 3
  008cd	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 654  : 
; 655  : 				if (CGraphicBase::SetPDTStream((SPDTVertex*)akVertex, 4))

  008d3	6a 04		 push	 4
  008d5	8d 45 10	 lea	 eax, DWORD PTR _akVertex$76[ebp]
  008d8	50		 push	 eax
  008d9	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  008de	59		 pop	 ecx
  008df	59		 pop	 ecx
  008e0	0f b6 c0	 movzx	 eax, al
  008e3	85 c0		 test	 eax, eax
  008e5	74 11		 je	 SHORT $LN36@Render

; 656  : 					STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

  008e7	6a 02		 push	 2
  008e9	6a 00		 push	 0
  008eb	6a 05		 push	 5
  008ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  008f3	e8 00 00 00 00	 call	 ?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z ; CStateManager::DrawPrimitive
$LN36@Render:

; 657  : 				
; 658  : 				akVertex[0].x=fFontSx-feather;

  008f8	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSx$60[ebp]
  00900	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _feather$65[ebp]
  00908	6a 18		 push	 24			; 00000018H
  0090a	58		 pop	 eax
  0090b	6b c0 00	 imul	 eax, eax, 0
  0090e	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 659  : 				akVertex[1].x=fFontSx-feather;

  00914	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSx$60[ebp]
  0091c	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _feather$65[ebp]
  00924	6a 18		 push	 24			; 00000018H
  00926	58		 pop	 eax
  00927	c1 e0 00	 shl	 eax, 0
  0092a	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 660  : 				akVertex[2].x=fFontEx+feather;

  00930	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEx$57[ebp]
  00938	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _feather$65[ebp]
  00940	6a 18		 push	 24			; 00000018H
  00942	58		 pop	 eax
  00943	d1 e0		 shl	 eax, 1
  00945	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 661  : 				akVertex[3].x=fFontEx+feather;

  0094b	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEx$57[ebp]
  00953	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _feather$65[ebp]
  0095b	6a 18		 push	 24			; 00000018H
  0095d	58		 pop	 eax
  0095e	6b c0 03	 imul	 eax, eax, 3
  00961	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 662  : 				
; 663  : 				// 
; 664  : 				akVertex[0].y=fFontSy-fFontHalfWeight-feather;

  00967	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSy$59[ebp]
  0096f	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00977	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _feather$65[ebp]
  0097f	6a 18		 push	 24			; 00000018H
  00981	58		 pop	 eax
  00982	6b c0 00	 imul	 eax, eax, 0
  00985	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 665  : 				akVertex[1].y=fFontEy-fFontHalfWeight+feather;

  0098b	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEy$56[ebp]
  00993	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0099b	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _feather$65[ebp]
  009a3	6a 18		 push	 24			; 00000018H
  009a5	58		 pop	 eax
  009a6	c1 e0 00	 shl	 eax, 0
  009a9	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 666  : 				akVertex[2].y=fFontSy-fFontHalfWeight-feather;

  009af	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSy$59[ebp]
  009b7	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  009bf	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _feather$65[ebp]
  009c7	6a 18		 push	 24			; 00000018H
  009c9	58		 pop	 eax
  009ca	d1 e0		 shl	 eax, 1
  009cc	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 667  : 				akVertex[3].y=fFontEy-fFontHalfWeight+feather;

  009d2	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEy$56[ebp]
  009da	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  009e2	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _feather$65[ebp]
  009ea	6a 18		 push	 24			; 00000018H
  009ec	58		 pop	 eax
  009ed	6b c0 03	 imul	 eax, eax, 3
  009f0	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 668  : 
; 669  : 				// 20041216.myevan.DrawPrimitiveUP
; 670  : 				if (CGraphicBase::SetPDTStream((SPDTVertex*)akVertex, 4))

  009f6	6a 04		 push	 4
  009f8	8d 45 10	 lea	 eax, DWORD PTR _akVertex$76[ebp]
  009fb	50		 push	 eax
  009fc	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  00a01	59		 pop	 ecx
  00a02	59		 pop	 ecx
  00a03	0f b6 c0	 movzx	 eax, al
  00a06	85 c0		 test	 eax, eax
  00a08	74 11		 je	 SHORT $LN37@Render

; 671  : 					STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

  00a0a	6a 02		 push	 2
  00a0c	6a 00		 push	 0
  00a0e	6a 05		 push	 5
  00a10	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a16	e8 00 00 00 00	 call	 ?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z ; CStateManager::DrawPrimitive
$LN37@Render:

; 672  : 				
; 673  : 				// 
; 674  : 				akVertex[0].y=fFontSy+fFontHalfWeight-feather;

  00a1b	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSy$59[ebp]
  00a23	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00a2b	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _feather$65[ebp]
  00a33	6a 18		 push	 24			; 00000018H
  00a35	58		 pop	 eax
  00a36	6b c0 00	 imul	 eax, eax, 0
  00a39	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 675  : 				akVertex[1].y=fFontEy+fFontHalfWeight+feather;

  00a3f	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEy$56[ebp]
  00a47	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00a4f	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _feather$65[ebp]
  00a57	6a 18		 push	 24			; 00000018H
  00a59	58		 pop	 eax
  00a5a	c1 e0 00	 shl	 eax, 0
  00a5d	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 676  : 				akVertex[2].y=fFontSy+fFontHalfWeight-feather;

  00a63	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSy$59[ebp]
  00a6b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00a73	f3 0f 5c 85 44
	ff ff ff	 subss	 xmm0, DWORD PTR _feather$65[ebp]
  00a7b	6a 18		 push	 24			; 00000018H
  00a7d	58		 pop	 eax
  00a7e	d1 e0		 shl	 eax, 1
  00a80	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 677  : 				akVertex[3].y=fFontEy+fFontHalfWeight+feather;

  00a86	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEy$56[ebp]
  00a8e	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00a96	f3 0f 58 85 44
	ff ff ff	 addss	 xmm0, DWORD PTR _feather$65[ebp]
  00a9e	6a 18		 push	 24			; 00000018H
  00aa0	58		 pop	 eax
  00aa1	6b c0 03	 imul	 eax, eax, 3
  00aa4	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 678  : 
; 679  : 				// 20041216.myevan.DrawPrimitiveUP
; 680  : 				if (CGraphicBase::SetPDTStream((SPDTVertex*)akVertex, 4))

  00aaa	6a 04		 push	 4
  00aac	8d 45 10	 lea	 eax, DWORD PTR _akVertex$76[ebp]
  00aaf	50		 push	 eax
  00ab0	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  00ab5	59		 pop	 ecx
  00ab6	59		 pop	 ecx
  00ab7	0f b6 c0	 movzx	 eax, al
  00aba	85 c0		 test	 eax, eax
  00abc	74 11		 je	 SHORT $LN38@Render

; 681  : 					STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

  00abe	6a 02		 push	 2
  00ac0	6a 00		 push	 0
  00ac2	6a 05		 push	 5
  00ac4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00aca	e8 00 00 00 00	 call	 ?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z ; CStateManager::DrawPrimitive
$LN38@Render:

; 682  : 				
; 683  : 				fCurX += fFontAdvance;

  00acf	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fCurX$63[ebp]
  00ad7	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _fFontAdvance$44[ebp]
  00adf	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fCurX$63[ebp], xmm0

; 684  : 			}

  00ae7	e9 f8 f8 ff ff	 jmp	 $LN8@Render
$LN9@Render:

; 685  : 		}
; 686  : 
; 687  : 		//  
; 688  : 		fCurX=fStanX;

  00aec	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _fStanX$[ebp]
  00af4	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fCurX$63[ebp], xmm0

; 689  : 		fCurY=fStanY;

  00afc	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _fStanY$[ebp]
  00b04	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _fCurY$58[ebp], xmm0

; 690  : 		fFontMaxHeight=0.0f;

  00b0c	0f 57 c0	 xorps	 xmm0, xmm0
  00b0f	f3 0f 11 85 e0
	fe ff ff	 movss	 DWORD PTR _fFontMaxHeight$40[ebp], xmm0

; 692  : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  00b17	83 a5 f0 fe ff
	ff 00		 and	 DWORD PTR _i$43[ebp], 0
  00b1e	eb 0d		 jmp	 SHORT $LN13@Render
$LN11@Render:
  00b20	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _i$43[ebp]
  00b26	40		 inc	 eax
  00b27	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _i$43[ebp], eax
$LN13@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00b2d	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b33	83 c0 4c	 add	 eax, 76			; 0000004cH
  00b36	89 85 88 fe ff
	ff		 mov	 DWORD PTR __My_data$31[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00b3c	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$31[ebp]
  00b42	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$31[ebp]
  00b48	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00b4b	2b 01		 sub	 eax, DWORD PTR [ecx]
  00b4d	c1 f8 02	 sar	 eax, 2
  00b50	89 85 78 fe ff
	ff		 mov	 DWORD PTR $T28[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 692  : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  00b56	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _i$43[ebp]
  00b5c	3b 85 78 fe ff
	ff		 cmp	 eax, DWORD PTR $T28[ebp]
  00b62	0f 83 df 03 00
	00		 jae	 $LN12@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00b68	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b6e	83 c0 4c	 add	 eax, 76			; 0000004cH
  00b71	89 85 74 fe ff
	ff		 mov	 DWORD PTR __My_data$27[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00b77	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$27[ebp]
  00b7d	8b 00		 mov	 eax, DWORD PTR [eax]
  00b7f	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _i$43[ebp]
  00b85	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00b88	89 85 70 fe ff
	ff		 mov	 DWORD PTR $T26[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 694  : 			pCurCharInfo = m_pCharInfoVector[i];

  00b8e	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR $T26[ebp]
  00b94	8b 00		 mov	 eax, DWORD PTR [eax]
  00b96	89 85 48 ff ff
	ff		 mov	 DWORD PTR _pCurCharInfo$66[ebp], eax

; 695  : 
; 696  : 			fFontWidth=float(pCurCharInfo->width);

  00b9c	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _pCurCharInfo$66[ebp]
  00ba2	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  00ba6	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00baa	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _fFontWidth$48[ebp], xmm0

; 697  : 			fFontHeight=float(pCurCharInfo->height);

  00bb2	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _pCurCharInfo$66[ebp]
  00bb8	0f bf 40 04	 movsx	 eax, WORD PTR [eax+4]
  00bbc	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00bc0	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _fFontHeight$47[ebp], xmm0

; 698  : 			fFontMaxHeight=max(fFontHeight, pCurCharInfo->height);

  00bc8	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _pCurCharInfo$66[ebp]
  00bce	0f bf 40 04	 movsx	 eax, WORD PTR [eax+4]
  00bd2	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00bd6	f3 0f 10 8d 00
	ff ff ff	 movss	 xmm1, DWORD PTR _fFontHeight$47[ebp]
  00bde	0f 2f c8	 comiss	 xmm1, xmm0
  00be1	76 12		 jbe	 SHORT $LN59@Render
  00be3	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontHeight$47[ebp]
  00beb	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR tv568[ebp], xmm0
  00bf3	eb 16		 jmp	 SHORT $LN60@Render
$LN59@Render:
  00bf5	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _pCurCharInfo$66[ebp]
  00bfb	0f bf 40 04	 movsx	 eax, WORD PTR [eax+4]
  00bff	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00c03	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR tv568[ebp], xmm0
$LN60@Render:
  00c0b	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR tv568[ebp]
  00c13	f3 0f 11 85 e0
	fe ff ff	 movss	 DWORD PTR _fFontMaxHeight$40[ebp], xmm0

; 699  : 			fFontAdvance=float(pCurCharInfo->advance);

  00c1b	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _pCurCharInfo$66[ebp]
  00c21	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00c26	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _fFontAdvance$44[ebp], xmm0

; 700  : 
; 701  : 			// NOTE :   Width  . - [levites]
; 702  : 			if ((fCurX+fFontWidth)-m_v3Position.x > m_fLimitWidth)

  00c2e	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fCurX$63[ebp]
  00c36	f3 0f 58 85 04
	ff ff ff	 addss	 xmm0, DWORD PTR _fFontWidth$48[ebp]
  00c3e	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c44	f3 0f 5c 40 38	 subss	 xmm0, DWORD PTR [eax+56]
  00c49	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c4f	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  00c53	76 3d		 jbe	 SHORT $LN41@Render

; 703  : 			{
; 704  : 				if (m_isMultiLine)

  00c55	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c5b	0f b6 40 1a	 movzx	 eax, BYTE PTR [eax+26]
  00c5f	85 c0		 test	 eax, eax
  00c61	74 2a		 je	 SHORT $LN40@Render

; 705  : 				{
; 706  : 					fCurX=fStanX;

  00c63	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _fStanX$[ebp]
  00c6b	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fCurX$63[ebp], xmm0

; 707  : 					fCurY+=fFontMaxHeight;

  00c73	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _fCurY$58[ebp]
  00c7b	f3 0f 58 85 e0
	fe ff ff	 addss	 xmm0, DWORD PTR _fFontMaxHeight$40[ebp]
  00c83	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _fCurY$58[ebp], xmm0

; 708  : 				}

  00c8b	eb 05		 jmp	 SHORT $LN41@Render
$LN40@Render:

; 709  : 				else
; 710  : 				{
; 711  : 					break;

  00c8d	e9 b5 02 00 00	 jmp	 $LN12@Render
$LN41@Render:

; 712  : 				}
; 713  : 			}
; 714  : 
; 715  : 			if (pClipRect)

  00c92	83 7d 7c 00	 cmp	 DWORD PTR _pClipRect$[ebp], 0
  00c96	74 2e		 je	 SHORT $LN43@Render

; 716  : 			{
; 717  : 				if (fCurY <= pClipRect->top)

  00c98	8b 45 7c	 mov	 eax, DWORD PTR _pClipRect$[ebp]
  00c9b	f3 0f 2a 40 04	 cvtsi2ss xmm0, DWORD PTR [eax+4]
  00ca0	0f 2f 85 24 ff
	ff ff		 comiss	 xmm0, DWORD PTR _fCurY$58[ebp]
  00ca7	72 1d		 jb	 SHORT $LN43@Render

; 718  : 				{
; 719  : 					fCurX += fFontAdvance;

  00ca9	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fCurX$63[ebp]
  00cb1	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _fFontAdvance$44[ebp]
  00cb9	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fCurX$63[ebp], xmm0

; 720  : 					continue;

  00cc1	e9 5a fe ff ff	 jmp	 $LN11@Render
$LN43@Render:

; 721  : 				}
; 722  : 			}
; 723  : 
; 724  : 			fFontSx = fCurX-0.5f;

  00cc6	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fCurX$63[ebp]
  00cce	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  00cd6	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _fFontSx$60[ebp], xmm0

; 725  : 			fFontSy = fCurY-0.5f;

  00cde	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _fCurY$58[ebp]
  00ce6	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  00cee	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _fFontSy$59[ebp], xmm0

; 726  : 			fFontEx = fFontSx + fFontWidth;

  00cf6	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSx$60[ebp]
  00cfe	f3 0f 58 85 04
	ff ff ff	 addss	 xmm0, DWORD PTR _fFontWidth$48[ebp]
  00d06	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _fFontEx$57[ebp], xmm0

; 727  : 			fFontEy = fFontSy + fFontHeight;

  00d0e	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSy$59[ebp]
  00d16	f3 0f 58 85 00
	ff ff ff	 addss	 xmm0, DWORD PTR _fFontHeight$47[ebp]
  00d1e	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _fFontEy$56[ebp], xmm0

; 728  : 
; 729  : 			pFontTexture->SelectTexture(pCurCharInfo->index);

  00d26	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _pCurCharInfo$66[ebp]
  00d2c	0f bf 00	 movsx	 eax, WORD PTR [eax]
  00d2f	50		 push	 eax
  00d30	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _pFontTexture$[ebp]
  00d36	e8 00 00 00 00	 call	 ?SelectTexture@CGraphicFontTexture@@QAEXK@Z ; CGraphicFontTexture::SelectTexture
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00d3b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d40	89 85 6c fe ff
	ff		 mov	 DWORD PTR $T25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 730  : 			STATEMANAGER.SetTexture(0, pFontTexture->GetD3DTexture());

  00d46	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _pFontTexture$[ebp]
  00d4c	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00d51	50		 push	 eax
  00d52	6a 00		 push	 0
  00d54	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR $T25[ebp]
  00d5a	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 731  : 
; 732  : 			akVertex[0].x=fFontSx;

  00d5f	6a 18		 push	 24			; 00000018H
  00d61	58		 pop	 eax
  00d62	6b c0 00	 imul	 eax, eax, 0
  00d65	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSx$60[ebp]
  00d6d	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 733  : 			akVertex[0].y=fFontSy;

  00d73	6a 18		 push	 24			; 00000018H
  00d75	58		 pop	 eax
  00d76	6b c0 00	 imul	 eax, eax, 0
  00d79	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSy$59[ebp]
  00d81	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 734  : 			akVertex[0].u=pCurCharInfo->left;

  00d87	6a 18		 push	 24			; 00000018H
  00d89	58		 pop	 eax
  00d8a	6b c0 00	 imul	 eax, eax, 0
  00d8d	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  00d93	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00d96	89 4c 05 20	 mov	 DWORD PTR _akVertex$76[ebp+eax+16], ecx

; 735  : 			akVertex[0].v=pCurCharInfo->top;

  00d9a	6a 18		 push	 24			; 00000018H
  00d9c	58		 pop	 eax
  00d9d	6b c0 00	 imul	 eax, eax, 0
  00da0	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  00da6	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00da9	89 4c 05 24	 mov	 DWORD PTR _akVertex$76[ebp+eax+20], ecx

; 736  : 
; 737  : 			akVertex[1].x=fFontSx;

  00dad	6a 18		 push	 24			; 00000018H
  00daf	58		 pop	 eax
  00db0	c1 e0 00	 shl	 eax, 0
  00db3	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSx$60[ebp]
  00dbb	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 738  : 			akVertex[1].y=fFontEy;

  00dc1	6a 18		 push	 24			; 00000018H
  00dc3	58		 pop	 eax
  00dc4	c1 e0 00	 shl	 eax, 0
  00dc7	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEy$56[ebp]
  00dcf	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 739  : 			akVertex[1].u=pCurCharInfo->left;

  00dd5	6a 18		 push	 24			; 00000018H
  00dd7	58		 pop	 eax
  00dd8	c1 e0 00	 shl	 eax, 0
  00ddb	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  00de1	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00de4	89 4c 05 20	 mov	 DWORD PTR _akVertex$76[ebp+eax+16], ecx

; 740  : 			akVertex[1].v=pCurCharInfo->bottom;

  00de8	6a 18		 push	 24			; 00000018H
  00dea	58		 pop	 eax
  00deb	c1 e0 00	 shl	 eax, 0
  00dee	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  00df4	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00df7	89 4c 05 24	 mov	 DWORD PTR _akVertex$76[ebp+eax+20], ecx

; 741  : 
; 742  : 			akVertex[2].x=fFontEx;

  00dfb	6a 18		 push	 24			; 00000018H
  00dfd	58		 pop	 eax
  00dfe	d1 e0		 shl	 eax, 1
  00e00	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEx$57[ebp]
  00e08	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 743  : 			akVertex[2].y=fFontSy;

  00e0e	6a 18		 push	 24			; 00000018H
  00e10	58		 pop	 eax
  00e11	d1 e0		 shl	 eax, 1
  00e13	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSy$59[ebp]
  00e1b	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 744  : 			akVertex[2].u=pCurCharInfo->right;

  00e21	6a 18		 push	 24			; 00000018H
  00e23	58		 pop	 eax
  00e24	d1 e0		 shl	 eax, 1
  00e26	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  00e2c	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00e2f	89 4c 05 20	 mov	 DWORD PTR _akVertex$76[ebp+eax+16], ecx

; 745  : 			akVertex[2].v=pCurCharInfo->top;

  00e33	6a 18		 push	 24			; 00000018H
  00e35	58		 pop	 eax
  00e36	d1 e0		 shl	 eax, 1
  00e38	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  00e3e	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00e41	89 4c 05 24	 mov	 DWORD PTR _akVertex$76[ebp+eax+20], ecx

; 746  : 
; 747  : 			akVertex[3].x=fFontEx;

  00e45	6a 18		 push	 24			; 00000018H
  00e47	58		 pop	 eax
  00e48	6b c0 03	 imul	 eax, eax, 3
  00e4b	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEx$57[ebp]
  00e53	f3 0f 11 44 05
	10		 movss	 DWORD PTR _akVertex$76[ebp+eax], xmm0

; 748  : 			akVertex[3].y=fFontEy;

  00e59	6a 18		 push	 24			; 00000018H
  00e5b	58		 pop	 eax
  00e5c	6b c0 03	 imul	 eax, eax, 3
  00e5f	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEy$56[ebp]
  00e67	f3 0f 11 44 05
	14		 movss	 DWORD PTR _akVertex$76[ebp+eax+4], xmm0

; 749  : 			akVertex[3].u=pCurCharInfo->right;

  00e6d	6a 18		 push	 24			; 00000018H
  00e6f	58		 pop	 eax
  00e70	6b c0 03	 imul	 eax, eax, 3
  00e73	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  00e79	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00e7c	89 4c 05 20	 mov	 DWORD PTR _akVertex$76[ebp+eax+16], ecx

; 750  : 			akVertex[3].v=pCurCharInfo->bottom;

  00e80	6a 18		 push	 24			; 00000018H
  00e82	58		 pop	 eax
  00e83	6b c0 03	 imul	 eax, eax, 3
  00e86	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _pCurCharInfo$66[ebp]
  00e8c	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00e8f	89 4c 05 24	 mov	 DWORD PTR _akVertex$76[ebp+eax+20], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00e93	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00e99	83 c0 58	 add	 eax, 88			; 00000058H
  00e9c	89 85 68 fe ff
	ff		 mov	 DWORD PTR __My_data$24[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00ea2	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$24[ebp]
  00ea8	8b 00		 mov	 eax, DWORD PTR [eax]
  00eaa	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _i$43[ebp]
  00eb0	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00eb3	89 85 64 fe ff
	ff		 mov	 DWORD PTR $T23[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 754  : 			akVertex[0].color = akVertex[1].color = akVertex[2].color = akVertex[3].color = m_dwColorInfoVector[i];

  00eb9	6a 18		 push	 24			; 00000018H
  00ebb	58		 pop	 eax
  00ebc	6b c0 03	 imul	 eax, eax, 3
  00ebf	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR $T23[ebp]
  00ec5	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00ec7	89 4c 05 1c	 mov	 DWORD PTR _akVertex$76[ebp+eax+12], ecx
  00ecb	6a 18		 push	 24			; 00000018H
  00ecd	58		 pop	 eax
  00ece	6b c0 03	 imul	 eax, eax, 3
  00ed1	6a 18		 push	 24			; 00000018H
  00ed3	59		 pop	 ecx
  00ed4	d1 e1		 shl	 ecx, 1
  00ed6	8b 44 05 1c	 mov	 eax, DWORD PTR _akVertex$76[ebp+eax+12]
  00eda	89 44 0d 1c	 mov	 DWORD PTR _akVertex$76[ebp+ecx+12], eax
  00ede	6a 18		 push	 24			; 00000018H
  00ee0	58		 pop	 eax
  00ee1	d1 e0		 shl	 eax, 1
  00ee3	6a 18		 push	 24			; 00000018H
  00ee5	59		 pop	 ecx
  00ee6	c1 e1 00	 shl	 ecx, 0
  00ee9	8b 44 05 1c	 mov	 eax, DWORD PTR _akVertex$76[ebp+eax+12]
  00eed	89 44 0d 1c	 mov	 DWORD PTR _akVertex$76[ebp+ecx+12], eax
  00ef1	6a 18		 push	 24			; 00000018H
  00ef3	58		 pop	 eax
  00ef4	c1 e0 00	 shl	 eax, 0
  00ef7	6a 18		 push	 24			; 00000018H
  00ef9	59		 pop	 ecx
  00efa	6b c9 00	 imul	 ecx, ecx, 0
  00efd	8b 44 05 1c	 mov	 eax, DWORD PTR _akVertex$76[ebp+eax+12]
  00f01	89 44 0d 1c	 mov	 DWORD PTR _akVertex$76[ebp+ecx+12], eax

; 755  : 
; 756  : 			// 20041216.myevan.DrawPrimitiveUP
; 757  : 			if (CGraphicBase::SetPDTStream((SPDTVertex*)akVertex, 4))

  00f05	6a 04		 push	 4
  00f07	8d 45 10	 lea	 eax, DWORD PTR _akVertex$76[ebp]
  00f0a	50		 push	 eax
  00f0b	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  00f10	59		 pop	 ecx
  00f11	59		 pop	 ecx
  00f12	0f b6 c0	 movzx	 eax, al
  00f15	85 c0		 test	 eax, eax
  00f17	74 11		 je	 SHORT $LN44@Render

; 758  : 				STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

  00f19	6a 02		 push	 2
  00f1b	6a 00		 push	 0
  00f1d	6a 05		 push	 5
  00f1f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00f25	e8 00 00 00 00	 call	 ?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z ; CStateManager::DrawPrimitive
$LN44@Render:

; 759  : 			//STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, akVertex, sizeof(SVertex));
; 760  : 
; 761  : 			fCurX += fFontAdvance;

  00f2a	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fCurX$63[ebp]
  00f32	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _fFontAdvance$44[ebp]
  00f3a	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fCurX$63[ebp], xmm0

; 762  : 		}

  00f42	e9 d9 fb ff ff	 jmp	 $LN11@Render
$LN12@Render:

; 763  : 	}
; 764  : 
; 765  : 	if (m_isCursor)

  00f47	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00f4d	0f b6 40 18	 movzx	 eax, BYTE PTR [eax+24]
  00f51	85 c0		 test	 eax, eax
  00f53	0f 84 9d 06 00
	00		 je	 $LN53@Render

; 766  : 	{
; 767  : 		// Draw Cursor
; 768  : 		float sx, sy, ex, ey;
; 769  : 		TDiffuse diffuse;
; 770  : 
; 771  : 		int curpos = CIME::GetCurPos();

  00f59	e8 00 00 00 00	 call	 ?GetCurPos@CIME@@SAHXZ	; CIME::GetCurPos
  00f5e	89 85 fc fe ff
	ff		 mov	 DWORD PTR _curpos$46[ebp], eax

; 772  : 		int compend = curpos + CIME::GetCompLen();

  00f64	e8 00 00 00 00	 call	 ?GetCompLen@CIME@@SAHXZ	; CIME::GetCompLen
  00f69	03 85 fc fe ff
	ff		 add	 eax, DWORD PTR _curpos$46[ebp]
  00f6f	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _compend$38[ebp], eax

; 773  : 
; 774  : 		__GetTextPos(curpos, &sx, &sy);

  00f75	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _sy$64[ebp]
  00f7b	50		 push	 eax
  00f7c	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _sx$62[ebp]
  00f82	50		 push	 eax
  00f83	ff b5 fc fe ff
	ff		 push	 DWORD PTR _curpos$46[ebp]
  00f89	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00f8f	e8 00 00 00 00	 call	 ?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z ; CGraphicTextInstance::__GetTextPos

; 775  : 
; 776  : 		// If Composition
; 777  : 		if(curpos<compend)

  00f94	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _curpos$46[ebp]
  00f9a	3b 85 d4 fe ff
	ff		 cmp	 eax, DWORD PTR _compend$38[ebp]
  00fa0	7d 2b		 jge	 SHORT $LN46@Render

; 778  : 		{
; 779  : 			diffuse = 0x7fffffff;

  00fa2	c7 85 f8 fe ff
	ff ff ff ff 7f	 mov	 DWORD PTR _diffuse$45[ebp], 2147483647 ; 7fffffffH

; 780  : 			__GetTextPos(compend, &ex, &sy);

  00fac	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _sy$64[ebp]
  00fb2	50		 push	 eax
  00fb3	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _ex$61[ebp]
  00fb9	50		 push	 eax
  00fba	ff b5 d4 fe ff
	ff		 push	 DWORD PTR _compend$38[ebp]
  00fc0	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00fc6	e8 00 00 00 00	 call	 ?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z ; CGraphicTextInstance::__GetTextPos

; 781  : 		}

  00fcb	eb 1f		 jmp	 SHORT $LN47@Render
$LN46@Render:

; 782  : 		else
; 783  : 		{
; 784  : 			diffuse = 0xffffffff;

  00fcd	83 8d f8 fe ff
	ff ff		 or	 DWORD PTR _diffuse$45[ebp], -1

; 785  : 			ex = sx + 2;

  00fd4	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _sx$62[ebp]
  00fdc	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00fe4	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _ex$61[ebp], xmm0
$LN47@Render:

; 786  : 		}
; 787  : 
; 788  : 		// FOR_ARABIC_ALIGN
; 789  : 		if (defCodePage == CP_ARABIC)

  00fec	81 bd d0 fe ff
	ff e8 04 00 00	 cmp	 DWORD PTR _defCodePage$[ebp], 1256 ; 000004e8H
  00ff6	0f 85 95 00 00
	00		 jne	 $LN48@Render

; 790  : 		{
; 791  : 			sx += m_v3Position.x - m_textWidth;

  00ffc	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01002	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  01006	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0100a	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01010	f3 0f 10 48 38	 movss	 xmm1, DWORD PTR [eax+56]
  01015	f3 0f 5c c8	 subss	 xmm1, xmm0
  01019	f3 0f 58 8d 34
	ff ff ff	 addss	 xmm1, DWORD PTR _sx$62[ebp]
  01021	f3 0f 11 8d 34
	ff ff ff	 movss	 DWORD PTR _sx$62[ebp], xmm1

; 792  : 			ex += m_v3Position.x - m_textWidth;

  01029	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0102f	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  01033	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  01037	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0103d	f3 0f 10 48 38	 movss	 xmm1, DWORD PTR [eax+56]
  01042	f3 0f 5c c8	 subss	 xmm1, xmm0
  01046	f3 0f 58 8d 30
	ff ff ff	 addss	 xmm1, DWORD PTR _ex$61[ebp]
  0104e	f3 0f 11 8d 30
	ff ff ff	 movss	 DWORD PTR _ex$61[ebp], xmm1

; 793  : 			sy += m_v3Position.y;			

  01056	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0105c	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _sy$64[ebp]
  01064	f3 0f 58 40 3c	 addss	 xmm0, DWORD PTR [eax+60]
  01069	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _sy$64[ebp], xmm0

; 794  : 			ey = sy + m_textHeight;

  01071	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01077	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  0107b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0107f	f3 0f 58 85 40
	ff ff ff	 addss	 xmm0, DWORD PTR _sy$64[ebp]
  01087	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _ey$51[ebp], xmm0

; 795  : 		}

  0108f	eb 6f		 jmp	 SHORT $LN49@Render
$LN48@Render:

; 796  : 		else
; 797  : 		{
; 798  : 			sx += m_v3Position.x;

  01091	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01097	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _sx$62[ebp]
  0109f	f3 0f 58 40 38	 addss	 xmm0, DWORD PTR [eax+56]
  010a4	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR _sx$62[ebp], xmm0

; 799  : 			sy += m_v3Position.y;

  010ac	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  010b2	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _sy$64[ebp]
  010ba	f3 0f 58 40 3c	 addss	 xmm0, DWORD PTR [eax+60]
  010bf	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _sy$64[ebp], xmm0

; 800  : 			ex += m_v3Position.x;

  010c7	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  010cd	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _ex$61[ebp]
  010d5	f3 0f 58 40 38	 addss	 xmm0, DWORD PTR [eax+56]
  010da	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _ex$61[ebp], xmm0

; 801  : 			ey = sy + m_textHeight;

  010e2	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  010e8	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  010ec	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  010f0	f3 0f 58 85 40
	ff ff ff	 addss	 xmm0, DWORD PTR _sy$64[ebp]
  010f8	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _ey$51[ebp], xmm0
$LN49@Render:

; 802  : 		}
; 803  : 
; 804  : 		switch (m_vAlign)

  01100	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01106	8a 40 11	 mov	 al, BYTE PTR [eax+17]
  01109	88 85 cc fe ff
	ff		 mov	 BYTE PTR tv812[ebp], al
  0110f	80 bd cc fe ff
	ff 20		 cmp	 BYTE PTR tv812[ebp], 32	; 00000020H
  01116	74 2f		 je	 SHORT $LN51@Render
  01118	80 bd cc fe ff
	ff 30		 cmp	 BYTE PTR tv812[ebp], 48	; 00000030H
  0111f	74 02		 je	 SHORT $LN50@Render
  01121	eb 4e		 jmp	 SHORT $LN14@Render
$LN50@Render:

; 805  : 		{
; 806  : 			case VERTICAL_ALIGN_BOTTOM:
; 807  : 				sy -= m_textHeight;

  01123	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01129	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  0112d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  01131	f3 0f 10 8d 40
	ff ff ff	 movss	 xmm1, DWORD PTR _sy$64[ebp]
  01139	f3 0f 5c c8	 subss	 xmm1, xmm0
  0113d	f3 0f 11 8d 40
	ff ff ff	 movss	 DWORD PTR _sy$64[ebp], xmm1

; 808  : 				break;

  01145	eb 2a		 jmp	 SHORT $LN14@Render
$LN51@Render:

; 809  : 
; 810  : 			case VERTICAL_ALIGN_CENTER:
; 811  : 				sy -= float(m_textHeight) / 2.0f;

  01147	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0114d	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  01151	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  01155	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0115d	f3 0f 10 8d 40
	ff ff ff	 movss	 xmm1, DWORD PTR _sy$64[ebp]
  01165	f3 0f 5c c8	 subss	 xmm1, xmm0
  01169	f3 0f 11 8d 40
	ff ff ff	 movss	 DWORD PTR _sy$64[ebp], xmm1
$LN14@Render:

; 812  : 				break;
; 813  : 		}		
; 814  : 		//  
; 815  : 		//  ... STRIP ,    DrawPrimitive 
; 816  : 		//   !
; 817  : 
; 818  : 		TPDTVertex vertices[4];

  01171	c7 85 dc fe ff
	ff 04 00 00 00	 mov	 DWORD PTR ___n$[ebp], 4
  0117b	8d 45 b0	 lea	 eax, DWORD PTR _vertices$75[ebp]
  0117e	89 85 c8 fe ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
$LN174@Render:
  01184	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  0118a	89 85 60 fe ff
	ff		 mov	 DWORD PTR tv1191[ebp], eax
  01190	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  01196	48		 dec	 eax
  01197	89 85 dc fe ff
	ff		 mov	 DWORD PTR ___n$[ebp], eax
  0119d	83 bd 60 fe ff
	ff 00		 cmp	 DWORD PTR tv1191[ebp], 0
  011a4	76 11		 jbe	 SHORT $LN175@Render
  011a6	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR ___t$[ebp]
  011ac	83 c0 18	 add	 eax, 24			; 00000018H
  011af	89 85 c8 fe ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
  011b5	eb cd		 jmp	 SHORT $LN174@Render
$LN175@Render:

; 819  : 		vertices[0].diffuse = diffuse;

  011b7	6a 18		 push	 24			; 00000018H
  011b9	58		 pop	 eax
  011ba	6b c0 00	 imul	 eax, eax, 0
  011bd	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _diffuse$45[ebp]
  011c3	89 4c 05 bc	 mov	 DWORD PTR _vertices$75[ebp+eax+12], ecx

; 820  : 		vertices[1].diffuse = diffuse;

  011c7	6a 18		 push	 24			; 00000018H
  011c9	58		 pop	 eax
  011ca	c1 e0 00	 shl	 eax, 0
  011cd	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _diffuse$45[ebp]
  011d3	89 4c 05 bc	 mov	 DWORD PTR _vertices$75[ebp+eax+12], ecx

; 821  : 		vertices[2].diffuse = diffuse;

  011d7	6a 18		 push	 24			; 00000018H
  011d9	58		 pop	 eax
  011da	d1 e0		 shl	 eax, 1
  011dc	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _diffuse$45[ebp]
  011e2	89 4c 05 bc	 mov	 DWORD PTR _vertices$75[ebp+eax+12], ecx

; 822  : 		vertices[3].diffuse = diffuse;

  011e6	6a 18		 push	 24			; 00000018H
  011e8	58		 pop	 eax
  011e9	6b c0 03	 imul	 eax, eax, 3
  011ec	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _diffuse$45[ebp]
  011f2	89 4c 05 bc	 mov	 DWORD PTR _vertices$75[ebp+eax+12], ecx

; 823  : 		vertices[0].position = TPosition(sx, sy, 0.0f);

  011f6	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _sx$62[ebp]
  011fe	f3 0f 11 85 5c
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  01206	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _sy$64[ebp]
  0120e	f3 0f 11 85 58
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  01216	f3 0f 10 85 5c
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0121e	f3 0f 11 45 98	 movss	 DWORD PTR $T73[ebp], xmm0

; 181  :     y = fy;

  01223	f3 0f 10 85 58
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0122b	f3 0f 11 45 9c	 movss	 DWORD PTR $T73[ebp+4], xmm0

; 182  :     z = fz;

  01230	0f 57 c0	 xorps	 xmm0, xmm0
  01233	f3 0f 11 45 a0	 movss	 DWORD PTR $T73[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 823  : 		vertices[0].position = TPosition(sx, sy, 0.0f);

  01238	6a 18		 push	 24			; 00000018H
  0123a	58		 pop	 eax
  0123b	6b c0 00	 imul	 eax, eax, 0
  0123e	8d 7c 05 b0	 lea	 edi, DWORD PTR _vertices$75[ebp+eax]
  01242	8d 75 98	 lea	 esi, DWORD PTR $T73[ebp]
  01245	a5		 movsd
  01246	a5		 movsd
  01247	a5		 movsd

; 824  : 		vertices[1].position = TPosition(ex, sy, 0.0f);

  01248	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _ex$61[ebp]
  01250	f3 0f 11 85 54
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  01258	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _sy$64[ebp]
  01260	f3 0f 11 85 50
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  01268	f3 0f 10 85 54
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  01270	f3 0f 11 45 a4	 movss	 DWORD PTR $T74[ebp], xmm0

; 181  :     y = fy;

  01275	f3 0f 10 85 50
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0127d	f3 0f 11 45 a8	 movss	 DWORD PTR $T74[ebp+4], xmm0

; 182  :     z = fz;

  01282	0f 57 c0	 xorps	 xmm0, xmm0
  01285	f3 0f 11 45 ac	 movss	 DWORD PTR $T74[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 824  : 		vertices[1].position = TPosition(ex, sy, 0.0f);

  0128a	6a 18		 push	 24			; 00000018H
  0128c	58		 pop	 eax
  0128d	c1 e0 00	 shl	 eax, 0
  01290	8d 7c 05 b0	 lea	 edi, DWORD PTR _vertices$75[ebp+eax]
  01294	8d 75 a4	 lea	 esi, DWORD PTR $T74[ebp]
  01297	a5		 movsd
  01298	a5		 movsd
  01299	a5		 movsd

; 825  : 		vertices[2].position = TPosition(sx, ey, 0.0f);

  0129a	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _sx$62[ebp]
  012a2	f3 0f 11 85 4c
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  012aa	f3 0f 10 85 4c
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  012b2	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR $T67[ebp], xmm0

; 181  :     y = fy;

  012ba	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _ey$51[ebp]
  012c2	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR $T67[ebp+4], xmm0

; 182  :     z = fz;

  012ca	0f 57 c0	 xorps	 xmm0, xmm0
  012cd	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR $T67[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 825  : 		vertices[2].position = TPosition(sx, ey, 0.0f);

  012d5	6a 18		 push	 24			; 00000018H
  012d7	58		 pop	 eax
  012d8	d1 e0		 shl	 eax, 1
  012da	8d 7c 05 b0	 lea	 edi, DWORD PTR _vertices$75[ebp+eax]
  012de	8d b5 50 ff ff
	ff		 lea	 esi, DWORD PTR $T67[ebp]
  012e4	a5		 movsd
  012e5	a5		 movsd
  012e6	a5		 movsd

; 826  : 		vertices[3].position = TPosition(ex, ey, 0.0f);

  012e7	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _ex$61[ebp]
  012ef	f3 0f 11 85 48
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  012f7	f3 0f 10 85 48
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  012ff	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR $T68[ebp], xmm0

; 181  :     y = fy;

  01307	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _ey$51[ebp]
  0130f	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR $T68[ebp+4], xmm0

; 182  :     z = fz;

  01317	0f 57 c0	 xorps	 xmm0, xmm0
  0131a	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR $T68[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 826  : 		vertices[3].position = TPosition(ex, ey, 0.0f);

  01322	6a 18		 push	 24			; 00000018H
  01324	58		 pop	 eax
  01325	6b c0 03	 imul	 eax, eax, 3
  01328	8d 7c 05 b0	 lea	 edi, DWORD PTR _vertices$75[ebp+eax]
  0132c	8d b5 5c ff ff
	ff		 lea	 esi, DWORD PTR $T68[ebp]
  01332	a5		 movsd
  01333	a5		 movsd
  01334	a5		 movsd

; 827  : 
; 828  : 		STATEMANAGER.SetTexture(0, NULL);

  01335	6a 00		 push	 0
  01337	6a 00		 push	 0
  01339	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0133f	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 829  : 
; 830  : 
; 831  : 		// 2004.11.18.myevan.DrawIndexPrimitiveUP -> DynamicVertexBuffer
; 832  : 		CGraphicBase::SetDefaultIndexBuffer(CGraphicBase::DEFAULT_IB_FILL_RECT);

  01344	6a 05		 push	 5
  01346	e8 00 00 00 00	 call	 ?SetDefaultIndexBuffer@CGraphicBase@@SAXI@Z ; CGraphicBase::SetDefaultIndexBuffer
  0134b	59		 pop	 ecx

; 833  : 		if (CGraphicBase::SetPDTStream(vertices, 4))

  0134c	6a 04		 push	 4
  0134e	8d 45 b0	 lea	 eax, DWORD PTR _vertices$75[ebp]
  01351	50		 push	 eax
  01352	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  01357	59		 pop	 ecx
  01358	59		 pop	 ecx
  01359	0f b6 c0	 movzx	 eax, al
  0135c	85 c0		 test	 eax, eax
  0135e	74 15		 je	 SHORT $LN52@Render

; 834  : 			STATEMANAGER.DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 4, 0, 2);

  01360	6a 02		 push	 2
  01362	6a 00		 push	 0
  01364	6a 04		 push	 4
  01366	6a 00		 push	 0
  01368	6a 04		 push	 4
  0136a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01370	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN52@Render:

; 835  : 
; 836  : 		int ulbegin = CIME::GetULBegin();

  01375	e8 00 00 00 00	 call	 ?GetULBegin@CIME@@SAHXZ	; CIME::GetULBegin
  0137a	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _ulbegin$37[ebp], eax

; 837  : 		int ulend = CIME::GetULEnd();

  01380	e8 00 00 00 00	 call	 ?GetULEnd@CIME@@SAHXZ	; CIME::GetULEnd
  01385	89 85 80 fe ff
	ff		 mov	 DWORD PTR _ulend$30[ebp], eax

; 838  : 
; 839  : 		if(ulbegin < ulend)

  0138b	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _ulbegin$37[ebp]
  01391	3b 85 80 fe ff
	ff		 cmp	 eax, DWORD PTR _ulend$30[ebp]
  01397	0f 8d 59 02 00
	00		 jge	 $LN53@Render

; 840  : 		{
; 841  : 			__GetTextPos(curpos+ulbegin, &sx, &sy);

  0139d	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _sy$64[ebp]
  013a3	50		 push	 eax
  013a4	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _sx$62[ebp]
  013aa	50		 push	 eax
  013ab	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _curpos$46[ebp]
  013b1	03 85 c4 fe ff
	ff		 add	 eax, DWORD PTR _ulbegin$37[ebp]
  013b7	50		 push	 eax
  013b8	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  013be	e8 00 00 00 00	 call	 ?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z ; CGraphicTextInstance::__GetTextPos

; 842  : 			__GetTextPos(curpos+ulend, &ex, &sy);

  013c3	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _sy$64[ebp]
  013c9	50		 push	 eax
  013ca	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _ex$61[ebp]
  013d0	50		 push	 eax
  013d1	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _curpos$46[ebp]
  013d7	03 85 80 fe ff
	ff		 add	 eax, DWORD PTR _ulend$30[ebp]
  013dd	50		 push	 eax
  013de	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  013e4	e8 00 00 00 00	 call	 ?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z ; CGraphicTextInstance::__GetTextPos

; 843  : 
; 844  : 			sx += m_v3Position.x;

  013e9	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  013ef	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _sx$62[ebp]
  013f7	f3 0f 58 40 38	 addss	 xmm0, DWORD PTR [eax+56]
  013fc	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR _sx$62[ebp], xmm0

; 845  : 			sy += m_v3Position.y + m_textHeight;

  01404	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0140a	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  0140e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  01412	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01418	f3 0f 58 40 3c	 addss	 xmm0, DWORD PTR [eax+60]
  0141d	f3 0f 58 85 40
	ff ff ff	 addss	 xmm0, DWORD PTR _sy$64[ebp]
  01425	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _sy$64[ebp], xmm0

; 846  : 			ex += m_v3Position.x;

  0142d	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01433	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _ex$61[ebp]
  0143b	f3 0f 58 40 38	 addss	 xmm0, DWORD PTR [eax+56]
  01440	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _ex$61[ebp], xmm0

; 847  : 			ey = sy + 2;

  01448	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _sy$64[ebp]
  01450	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  01458	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _ey$51[ebp], xmm0

; 848  : 
; 849  : 			vertices[0].diffuse = 0xFFFF0000;

  01460	6a 18		 push	 24			; 00000018H
  01462	58		 pop	 eax
  01463	6b c0 00	 imul	 eax, eax, 0
  01466	c7 44 05 bc 00
	00 ff ff	 mov	 DWORD PTR _vertices$75[ebp+eax+12], -65536 ; ffff0000H

; 850  : 			vertices[1].diffuse = 0xFFFF0000;

  0146e	6a 18		 push	 24			; 00000018H
  01470	58		 pop	 eax
  01471	c1 e0 00	 shl	 eax, 0
  01474	c7 44 05 bc 00
	00 ff ff	 mov	 DWORD PTR _vertices$75[ebp+eax+12], -65536 ; ffff0000H

; 851  : 			vertices[2].diffuse = 0xFFFF0000;

  0147c	6a 18		 push	 24			; 00000018H
  0147e	58		 pop	 eax
  0147f	d1 e0		 shl	 eax, 1
  01481	c7 44 05 bc 00
	00 ff ff	 mov	 DWORD PTR _vertices$75[ebp+eax+12], -65536 ; ffff0000H

; 852  : 			vertices[3].diffuse = 0xFFFF0000;

  01489	6a 18		 push	 24			; 00000018H
  0148b	58		 pop	 eax
  0148c	6b c0 03	 imul	 eax, eax, 3
  0148f	c7 44 05 bc 00
	00 ff ff	 mov	 DWORD PTR _vertices$75[ebp+eax+12], -65536 ; ffff0000H

; 853  : 			vertices[0].position = TPosition(sx, sy, 0.0f);

  01497	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _sx$62[ebp]
  0149f	f3 0f 11 85 44
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  014a7	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _sy$64[ebp]
  014af	f3 0f 11 85 40
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  014b7	f3 0f 10 85 44
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  014bf	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR $T69[ebp], xmm0

; 181  :     y = fy;

  014c7	f3 0f 10 85 40
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  014cf	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR $T69[ebp+4], xmm0

; 182  :     z = fz;

  014d7	0f 57 c0	 xorps	 xmm0, xmm0
  014da	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR $T69[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 853  : 			vertices[0].position = TPosition(sx, sy, 0.0f);

  014e2	6a 18		 push	 24			; 00000018H
  014e4	58		 pop	 eax
  014e5	6b c0 00	 imul	 eax, eax, 0
  014e8	8d 7c 05 b0	 lea	 edi, DWORD PTR _vertices$75[ebp+eax]
  014ec	8d b5 68 ff ff
	ff		 lea	 esi, DWORD PTR $T69[ebp]
  014f2	a5		 movsd
  014f3	a5		 movsd
  014f4	a5		 movsd

; 854  : 			vertices[1].position = TPosition(ex, sy, 0.0f);

  014f5	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _ex$61[ebp]
  014fd	f3 0f 11 85 3c
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  01505	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _sy$64[ebp]
  0150d	f3 0f 11 85 38
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  01515	f3 0f 10 85 3c
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0151d	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR $T70[ebp], xmm0

; 181  :     y = fy;

  01525	f3 0f 10 85 38
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0152d	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR $T70[ebp+4], xmm0

; 182  :     z = fz;

  01535	0f 57 c0	 xorps	 xmm0, xmm0
  01538	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR $T70[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 854  : 			vertices[1].position = TPosition(ex, sy, 0.0f);

  01540	6a 18		 push	 24			; 00000018H
  01542	58		 pop	 eax
  01543	c1 e0 00	 shl	 eax, 0
  01546	8d 7c 05 b0	 lea	 edi, DWORD PTR _vertices$75[ebp+eax]
  0154a	8d b5 74 ff ff
	ff		 lea	 esi, DWORD PTR $T70[ebp]
  01550	a5		 movsd
  01551	a5		 movsd
  01552	a5		 movsd

; 855  : 			vertices[2].position = TPosition(sx, ey, 0.0f);

  01553	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _sx$62[ebp]
  0155b	f3 0f 11 85 34
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  01563	f3 0f 10 85 34
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0156b	f3 0f 11 45 80	 movss	 DWORD PTR $T71[ebp], xmm0

; 181  :     y = fy;

  01570	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _ey$51[ebp]
  01578	f3 0f 11 45 84	 movss	 DWORD PTR $T71[ebp+4], xmm0

; 182  :     z = fz;

  0157d	0f 57 c0	 xorps	 xmm0, xmm0
  01580	f3 0f 11 45 88	 movss	 DWORD PTR $T71[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 855  : 			vertices[2].position = TPosition(sx, ey, 0.0f);

  01585	6a 18		 push	 24			; 00000018H
  01587	58		 pop	 eax
  01588	d1 e0		 shl	 eax, 1
  0158a	8d 7c 05 b0	 lea	 edi, DWORD PTR _vertices$75[ebp+eax]
  0158e	8d 75 80	 lea	 esi, DWORD PTR $T71[ebp]
  01591	a5		 movsd
  01592	a5		 movsd
  01593	a5		 movsd

; 856  : 			vertices[3].position = TPosition(ex, ey, 0.0f);

  01594	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _ex$61[ebp]
  0159c	f3 0f 11 85 f8
	fd ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  015a4	f3 0f 10 85 f8
	fd ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  015ac	f3 0f 11 45 8c	 movss	 DWORD PTR $T72[ebp], xmm0

; 181  :     y = fy;

  015b1	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _ey$51[ebp]
  015b9	f3 0f 11 45 90	 movss	 DWORD PTR $T72[ebp+4], xmm0

; 182  :     z = fz;

  015be	0f 57 c0	 xorps	 xmm0, xmm0
  015c1	f3 0f 11 45 94	 movss	 DWORD PTR $T72[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 856  : 			vertices[3].position = TPosition(ex, ey, 0.0f);

  015c6	6a 18		 push	 24			; 00000018H
  015c8	58		 pop	 eax
  015c9	6b c0 03	 imul	 eax, eax, 3
  015cc	8d 7c 05 b0	 lea	 edi, DWORD PTR _vertices$75[ebp+eax]
  015d0	8d 75 8c	 lea	 esi, DWORD PTR $T72[ebp]
  015d3	a5		 movsd
  015d4	a5		 movsd
  015d5	a5		 movsd

; 857  : 
; 858  : 			STATEMANAGER.DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 4, 2, c_FillRectIndices, D3DFMT_INDEX16, vertices, sizeof(TPDTVertex));

  015d6	6a 18		 push	 24			; 00000018H
  015d8	8d 45 b0	 lea	 eax, DWORD PTR _vertices$75[ebp]
  015db	50		 push	 eax
  015dc	6a 65		 push	 101			; 00000065H
  015de	68 00 00 00 00	 push	 OFFSET ?c_FillRectIndices@@3QBGB
  015e3	6a 02		 push	 2
  015e5	6a 04		 push	 4
  015e7	6a 00		 push	 0
  015e9	6a 04		 push	 4
  015eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  015f1	e8 00 00 00 00	 call	 ?DrawIndexedPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIIPBXW4_D3DFORMAT@@1I@Z ; CStateManager::DrawIndexedPrimitiveUP
$LN53@Render:

; 859  : 		}		
; 860  : 	}
; 861  : 
; 862  : 	STATEMANAGER.RestoreRenderState(D3DRS_SRCBLEND);

  015f6	6a 13		 push	 19			; 00000013H
  015f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  015fe	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 863  : 	STATEMANAGER.RestoreRenderState(D3DRS_DESTBLEND);

  01603	6a 14		 push	 20			; 00000014H
  01605	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0160b	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 864  : 
; 865  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, dwFogEnable);

  01610	ff b5 2c fe ff
	ff		 push	 DWORD PTR _dwFogEnable$[ebp]
  01616	6a 1c		 push	 28			; 0000001cH
  01618	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0161e	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 866  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, dwLighting);

  01623	ff b5 28 fe ff
	ff		 push	 DWORD PTR _dwLighting$[ebp]
  01629	68 89 00 00 00	 push	 137			; 00000089H
  0162e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01634	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  01639	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0163f	83 c0 64	 add	 eax, 100		; 00000064H
  01642	89 85 bc fe ff
	ff		 mov	 DWORD PTR __My_data$36[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  01648	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR __My_data$36[ebp]
  0164e	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$36[ebp]
  01654	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01657	2b 01		 sub	 eax, DWORD PTR [ecx]
  01659	99		 cdq
  0165a	6a 1c		 push	 28			; 0000001cH
  0165c	59		 pop	 ecx
  0165d	f7 f9		 idiv	 ecx
  0165f	89 85 24 fe ff
	ff		 mov	 DWORD PTR $T21[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 869  : 	if (m_hyperlinkVector.size() != 0)

  01665	83 bd 24 fe ff
	ff 00		 cmp	 DWORD PTR $T21[ebp], 0
  0166c	0f 84 4f 02 00
	00		 je	 $LN17@Render

; 870  : 	{
; 871  : 		int lx = gs_mx - m_v3Position.x;

  01672	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?gs_mx@@3HA
  0167a	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01680	f3 0f 5c 40 38	 subss	 xmm0, DWORD PTR [eax+56]
  01685	f3 0f 2c c0	 cvttss2si eax, xmm0
  01689	89 85 0c ff ff
	ff		 mov	 DWORD PTR _lx$50[ebp], eax

; 872  : 		int ly = gs_my - m_v3Position.y;

  0168f	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?gs_my@@3HA
  01697	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0169d	f3 0f 5c 40 3c	 subss	 xmm0, DWORD PTR [eax+60]
  016a2	f3 0f 2c c0	 cvttss2si eax, xmm0
  016a6	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _ly$41[ebp], eax

; 873  : 
; 874  : 		//   .
; 875  : 		if (GetDefaultCodePage() == CP_ARABIC) {

  016ac	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  016b1	3d e8 04 00 00	 cmp	 eax, 1256		; 000004e8H
  016b6	75 28		 jne	 SHORT $LN55@Render

; 876  : 			lx = -lx;

  016b8	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _lx$50[ebp]
  016be	f7 d8		 neg	 eax
  016c0	89 85 0c ff ff
	ff		 mov	 DWORD PTR _lx$50[ebp], eax

; 877  : 			ly = -ly + m_textHeight;

  016c6	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _ly$41[ebp]
  016cc	f7 d8		 neg	 eax
  016ce	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  016d4	0f b7 49 0e	 movzx	 ecx, WORD PTR [ecx+14]
  016d8	03 c1		 add	 eax, ecx
  016da	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _ly$41[ebp], eax
$LN55@Render:

; 878  : 		}
; 879  : 
; 880  : 		if (lx >= 0 && ly >= 0 && lx < m_textWidth && ly < m_textHeight)

  016e0	83 bd 0c ff ff
	ff 00		 cmp	 DWORD PTR _lx$50[ebp], 0
  016e7	0f 8c d4 01 00
	00		 jl	 $LN17@Render
  016ed	83 bd e4 fe ff
	ff 00		 cmp	 DWORD PTR _ly$41[ebp], 0
  016f4	0f 8c c7 01 00
	00		 jl	 $LN17@Render
  016fa	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01700	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  01704	39 85 0c ff ff
	ff		 cmp	 DWORD PTR _lx$50[ebp], eax
  0170a	0f 8d b1 01 00
	00		 jge	 $LN17@Render
  01710	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01716	0f b7 40 0e	 movzx	 eax, WORD PTR [eax+14]
  0171a	39 85 e4 fe ff
	ff		 cmp	 DWORD PTR _ly$41[ebp], eax
  01720	0f 8d 9b 01 00
	00		 jge	 $LN17@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  01726	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0172c	83 c0 64	 add	 eax, 100		; 00000064H
  0172f	89 85 b8 fe ff
	ff		 mov	 DWORD PTR __My_data$35[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  01735	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$35[ebp]
  0173b	89 85 cc fd ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  01741	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$35[ebp]
  01747	8b 00		 mov	 eax, DWORD PTR [eax]
  01749	89 85 20 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0174f	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  01755	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _it$42[ebp], eax
$LN216@Render:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0175b	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01761	83 c0 64	 add	 eax, 100		; 00000064H
  01764	89 85 b4 fe ff
	ff		 mov	 DWORD PTR __My_data$34[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0176a	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$34[ebp]
  01770	89 85 c8 fd ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  01776	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$34[ebp]
  0177c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0177f	89 85 1c fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  01785	8b 85 1c fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  0178b	89 85 18 fe ff
	ff		 mov	 DWORD PTR $T20[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  01791	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  01797	89 85 14 fe ff
	ff		 mov	 DWORD PTR $T19[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0179d	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR $T19[ebp]
  017a3	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _it$42[ebp]
  017a9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  017ab	75 0c		 jne	 SHORT $LN253@Render
  017ad	c7 85 b0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1400[ebp], 1
  017b7	eb 07		 jmp	 SHORT $LN254@Render
$LN253@Render:
  017b9	83 a5 b0 fe ff
	ff 00		 and	 DWORD PTR tv1400[ebp], 0
$LN254@Render:
  017c0	8a 85 b0 fe ff
	ff		 mov	 al, BYTE PTR tv1400[ebp]
  017c6	88 85 1a ff ff
	ff		 mov	 BYTE PTR $T54[ebp], al

; 153  :         return !(*this == _Right);

  017cc	0f b6 85 1a ff
	ff ff		 movzx	 eax, BYTE PTR $T54[ebp]
  017d3	85 c0		 test	 eax, eax
  017d5	75 0c		 jne	 SHORT $LN248@Render
  017d7	c7 85 ac fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv1386[ebp], 1
  017e1	eb 07		 jmp	 SHORT $LN249@Render
$LN248@Render:
  017e3	83 a5 ac fe ff
	ff 00		 and	 DWORD PTR tv1386[ebp], 0
$LN249@Render:
  017ea	8a 85 ac fe ff
	ff		 mov	 al, BYTE PTR tv1386[ebp]
  017f0	88 85 19 ff ff
	ff		 mov	 BYTE PTR $T53[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 884  : 			while (it != m_hyperlinkVector.end())

  017f6	0f b6 85 19 ff
	ff ff		 movzx	 eax, BYTE PTR $T53[ebp]
  017fd	85 c0		 test	 eax, eax
  017ff	0f 84 bc 00 00
	00		 je	 $LN17@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 265  :         _Vector_iterator _Tmp = *this;

  01805	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _it$42[ebp]
  0180b	89 85 10 fe ff
	ff		 mov	 DWORD PTR __Tmp$18[ebp], eax

; 75   :         ++_Ptr;

  01811	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _it$42[ebp]
  01817	83 c0 1c	 add	 eax, 28			; 0000001cH
  0181a	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _it$42[ebp], eax

; 267  :         return _Tmp;

  01820	8b 85 10 fe ff
	ff		 mov	 eax, DWORD PTR __Tmp$18[ebp]
  01826	89 85 0c fe ff
	ff		 mov	 DWORD PTR $T17[ebp], eax
  0182c	8d 85 0c fe ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  01832	89 85 08 fe ff
	ff		 mov	 DWORD PTR $T16[ebp], eax

; 54   :         return *_Ptr;

  01838	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR $T16[ebp]
  0183e	8b 00		 mov	 eax, DWORD PTR [eax]
  01840	89 85 04 fe ff
	ff		 mov	 DWORD PTR $T15[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  01846	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR $T15[ebp]
  0184c	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _link$39[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 887  : 				if (lx >= link.sx && lx < link.ex)

  01852	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _link$39[ebp]
  01858	0f bf 00	 movsx	 eax, WORD PTR [eax]
  0185b	39 85 0c ff ff
	ff		 cmp	 DWORD PTR _lx$50[ebp], eax
  01861	7c 59		 jl	 SHORT $LN57@Render
  01863	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _link$39[ebp]
  01869	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  0186d	39 85 0c ff ff
	ff		 cmp	 DWORD PTR _lx$50[ebp], eax
  01873	7d 47		 jge	 SHORT $LN57@Render

; 888  : 				{
; 889  : 					gs_hyperlinkText = link.text;

  01875	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _link$39[ebp]
  0187b	83 c0 04	 add	 eax, 4
  0187e	89 85 94 fe ff
	ff		 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  01884	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR __Right$[ebp]
  0188a	89 85 00 fe ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  01890	81 bd 00 fe ff
	ff 00 00 00 00	 cmp	 DWORD PTR $T14[ebp], OFFSET ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  0189a	74 1e		 je	 SHORT $LN272@Render

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  0189c	33 c0		 xor	 eax, eax
  0189e	88 85 fc fd ff
	ff		 mov	 BYTE PTR $T13[ebp], al
  018a4	ff b5 fc fd ff
	ff		 push	 DWORD PTR $T13[ebp]
  018aa	ff b5 94 fe ff
	ff		 push	 DWORD PTR __Right$[ebp]
  018b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  018b5	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy_assign
$LN272@Render:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 894  : 					break;

  018ba	eb 05		 jmp	 SHORT $LN17@Render
$LN57@Render:

; 895  : 				}
; 896  : 			}

  018bc	e9 9a fe ff ff	 jmp	 $LN216@Render
$LN17@Render:
$LN1@Render:

; 897  : 		}
; 898  : 	}
; 899  : }

  018c1	5f		 pop	 edi
  018c2	5e		 pop	 esi
  018c3	8b 4d 70	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  018c6	33 cd		 xor	 ecx, ebp
  018c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  018cd	83 c5 74	 add	 ebp, 116		; 00000074H
  018d0	c9		 leave
  018d1	c2 04 00	 ret	 4
?Render@CGraphicTextInstance@@QAEXPAUtagRECT@@@Z ENDP	; CGraphicTextInstance::Render
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Utils.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Utils.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Utils.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?Update@CGraphicTextInstance@@QAEXXZ
_TEXT	SEGMENT
_temptest$2 = -440					; size = 4
_this$ = -436						; size = 4
$T3 = -432						; size = 4
_spaceHeight$ = -428					; size = 4
$T4 = -424						; size = 4
_newCodePage$5 = -420					; size = 4
_len$6 = -416						; size = 4
$T7 = -412						; size = 4
$T8 = -408						; size = 4
$T9 = -404						; size = 1
$T10 = -400						; size = 4
$T11 = -396						; size = 4
$T12 = -392						; size = 4
_t$13 = -388						; size = 4
__My_data$14 = -384					; size = 4
$T15 = -380						; size = 4
$T16 = -376						; size = 4
$T17 = -372						; size = 1
$T18 = -368						; size = 4
$T19 = -364						; size = 4
$T20 = -360						; size = 4
_t$21 = -356						; size = 4
__My_data$22 = -352					; size = 4
$T23 = -348						; size = 4
$T24 = -344						; size = 4
__My_data$25 = -340					; size = 4
$T26 = -336						; size = 4
$T27 = -332						; size = 4
$T28 = -328						; size = 4
$T29 = -324						; size = 4
$T30 = -320						; size = 4
$T31 = -316						; size = 4
$T32 = -312						; size = 4
$T33 = -308						; size = 1
$T34 = -304						; size = 4
$T35 = -300						; size = 4
$T36 = -296						; size = 4
_t$37 = -292						; size = 4
__My_data$38 = -288					; size = 4
$T39 = -284						; size = 4
$T40 = -280						; size = 4
_this$ = -276						; size = 4
tv179 = -272						; size = 4
tv151 = -268						; size = 4
_defCodePage$ = -264					; size = 4
_wTextMax$ = -260					; size = 4
tv130 = -256						; size = 4
_pSpaceInfo$ = -252					; size = 4
$T41 = -248						; size = 4
_charWidth$42 = -244					; size = 4
$T43 = -240						; size = 4
__My_data$44 = -236					; size = 4
__My_data$45 = -232					; size = 4
__My_data$46 = -228					; size = 4
__My_data$47 = -224					; size = 4
_x$48 = -220						; size = 4
__My_data$49 = -216					; size = 4
__My_data$50 = -212					; size = 4
$T51 = -208						; size = 4
__My_data$52 = -204					; size = 4
__My_data$53 = -200					; size = 4
_charWidth$54 = -196					; size = 4
_x$55 = -192						; size = 4
_len$56 = -188						; size = 4
_nEnglishBase$57 = -184					; size = 4
_charWidth$58 = -180					; size = 4
_charWidth$59 = -176					; size = 4
_i$60 = -172						; size = 4
_tempLink$61 = -168					; size = 4
_charWidth$62 = -164					; size = 4
_tempLink$63 = -160					; size = 4
_tempLink$64 = -156					; size = 4
_end$ = -152						; size = 4
_tempLink$65 = -148					; size = 4
_wArabicChar$66 = -144					; size = 2
_j$67 = -140						; size = 4
_y$68 = -136						; size = 4
_j$69 = -132						; size = 4
_token$70 = -128					; size = 4
_y$71 = -124						; size = 4
_wText$ = -120						; size = 4
_y$72 = -116						; size = 4
_j$73 = -112						; size = 4
_wArabicTextLen$74 = -108				; size = 4
_j$75 = -104						; size = 4
_hyperlinkStep$76 = -100				; size = 4
_ret$77 = -96						; size = 4
_wTextLen$78 = -92					; size = 4
_ret$79 = -88						; size = 4
_ret$80 = -84						; size = 4
_i$81 = -80						; size = 4
_x$82 = -76						; size = 4
_e$83 = -72						; size = 4
_x$84 = -68						; size = 4
_e$85 = -64						; size = 4
_x$86 = -60						; size = 4
_begin$ = -56						; size = 4
_no_hyperlink$87 = -52					; size = 4
_pFontTexture$ = -48					; size = 4
_dataCodePage$ = -44					; size = 4
tv612 = -37						; size = 1
_dwColor$ = -36						; size = 4
_hyperlinkStep$88 = -32					; size = 4
_s$ = -28						; size = 4
_s$ = -24						; size = 4
_wArabicText$89 = -20					; size = 4
_s$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_i$90 = 0						; size = 4
_isEnglish$91 = 7					; size = 1
_this$ = 8						; size = 4
_kHyperlink$92 = 12					; size = 28
_hyperlinkBuffer$93 = 40				; size = 24
_hyperlinkBuffer$94 = 64				; size = 24
_kHyperlink$95 = 88					; size = 28
__$ArrayPad$ = 116					; size = 4
?Update@CGraphicTextInstance@@QAEXXZ PROC		; CGraphicTextInstance::Update, COMDAT
; _this$ = ecx

; 123  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	83 ec 78	 sub	 esp, 120		; 00000078H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$?Update@CGraphicTextInstance@@QAEXXZ
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 ec ac 01 00
	00		 sub	 esp, 428		; 000001acH
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 74	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	50		 push	 eax
  00027	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 4d 08	 mov	 DWORD PTR _this$[ebp], ecx

; 124  : 	if (m_isUpdate) //     .

  00033	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00036	0f b6 40 44	 movzx	 eax, BYTE PTR [eax+68]
  0003a	85 c0		 test	 eax, eax
  0003c	74 05		 je	 SHORT $LN31@Update

; 125  : 		return;

  0003e	e9 9b 10 00 00	 jmp	 $LN1@Update
$LN31@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 62   : 			return m_pObject == NULL ? true : false;

  00043	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  0004a	75 06		 jne	 SHORT $LN109@Update
  0004c	c6 45 db 01	 mov	 BYTE PTR tv612[ebp], 1
  00050	eb 04		 jmp	 SHORT $LN107@Update
$LN109@Update:
  00052	c6 45 db 00	 mov	 BYTE PTR tv612[ebp], 0
$LN107@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 127  : 	if (m_roText.IsNull())

  00056	0f b6 45 db	 movzx	 eax, BYTE PTR tv612[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	74 10		 je	 SHORT $LN32@Update

; 128  : 	{
; 129  : 		Tracef("CGraphicTextInstance::Update -   \n");

  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@KFHPELNP@CGraphicTextInstance?3?3Update?5?9?5@
  00063	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00068	59		 pop	 ecx

; 130  : 		return;

  00069	e9 70 10 00 00	 jmp	 $LN1@Update
$LN32@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 86   : 			return static_cast<T*>(m_pObject);

  0006e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00071	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  00074	89 85 b8 fe ff
	ff		 mov	 DWORD PTR $T28[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 133  : 	if (m_roText->IsEmpty())

  0007a	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR $T28[ebp]
  00080	e8 00 00 00 00	 call	 ?IsEmpty@CResource@@QBE_NXZ ; CResource::IsEmpty
  00085	0f b6 c0	 movzx	 eax, al
  00088	85 c0		 test	 eax, eax
  0008a	74 05		 je	 SHORT $LN33@Update

; 134  : 		return;

  0008c	e9 4d 10 00 00	 jmp	 $LN1@Update
$LN33@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 86   : 			return static_cast<T*>(m_pObject);

  00091	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00094	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  00097	89 85 58 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 136  : 	CGraphicFontTexture* pFontTexture = m_roText->GetFontTexturePointer();

  0009d	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  000a3	e8 00 00 00 00	 call	 ?GetFontTexturePointer@CGraphicText@@QAEPAVCGraphicFontTexture@@XZ ; CGraphicText::GetFontTexturePointer
  000a8	89 45 d0	 mov	 DWORD PTR _pFontTexture$[ebp], eax

; 137  : 	if (!pFontTexture)

  000ab	83 7d d0 00	 cmp	 DWORD PTR _pFontTexture$[ebp], 0
  000af	75 05		 jne	 SHORT $LN34@Update

; 138  : 		return;

  000b1	e9 28 10 00 00	 jmp	 $LN1@Update
$LN34@Update:

; 139  : 
; 140  : 	UINT defCodePage = GetDefaultCodePage();

  000b6	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  000bb	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _defCodePage$[ebp], eax

; 141  : 
; 142  : 	UINT dataCodePage = defCodePage; //      UTF8    

  000c1	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _defCodePage$[ebp]
  000c7	89 45 d4	 mov	 DWORD PTR _dataCodePage$[ebp], eax

; 143  : 		
; 144  : 	CGraphicFontTexture::TCharacterInfomation* pSpaceInfo = pFontTexture->GetCharacterInfomation(dataCodePage, ' ');

  000ca	6a 20		 push	 32			; 00000020H
  000cc	ff 75 d4	 push	 DWORD PTR _dataCodePage$[ebp]
  000cf	8b 4d d0	 mov	 ecx, DWORD PTR _pFontTexture$[ebp]
  000d2	e8 00 00 00 00	 call	 ?GetCharacterInfomation@CGraphicFontTexture@@QAEPAUSCharacterInfomation@1@G_W@Z ; CGraphicFontTexture::GetCharacterInfomation
  000d7	89 85 04 ff ff
	ff		 mov	 DWORD PTR _pSpaceInfo$[ebp], eax

; 145  : 
; 146  : 	int spaceHeight = pSpaceInfo ? pSpaceInfo->height : 12;

  000dd	83 bd 04 ff ff
	ff 00		 cmp	 DWORD PTR _pSpaceInfo$[ebp], 0
  000e4	74 12		 je	 SHORT $LN101@Update
  000e6	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR _pSpaceInfo$[ebp]
  000ec	0f bf 40 04	 movsx	 eax, WORD PTR [eax+4]
  000f0	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv130[ebp], eax
  000f6	eb 0a		 jmp	 SHORT $LN102@Update
$LN101@Update:
  000f8	c7 85 00 ff ff
	ff 0c 00 00 00	 mov	 DWORD PTR tv130[ebp], 12 ; 0000000cH
$LN102@Update:
  00102	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv130[ebp]
  00108	89 85 54 fe ff
	ff		 mov	 DWORD PTR _spaceHeight$[ebp], eax

; 147  : 	
; 148  : 	m_pCharInfoVector.clear();

  0010e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00111	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00114	e8 00 00 00 00	 call	 ?clear@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEXXZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::clear

; 149  : 	m_dwColorInfoVector.clear();

  00119	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	83 c1 58	 add	 ecx, 88			; 00000058H
  0011f	e8 00 00 00 00	 call	 ?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::clear

; 150  : 	m_hyperlinkVector.clear();

  00124	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00127	83 c1 64	 add	 ecx, 100		; 00000064H
  0012a	e8 00 00 00 00	 call	 ?clear@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::clear

; 151  : 
; 152  : 	m_textWidth = 0;

  0012f	33 c0		 xor	 eax, eax
  00131	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00134	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 153  : 	m_textHeight = spaceHeight;

  00138	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0013b	66 8b 8d 54 fe
	ff ff		 mov	 cx, WORD PTR _spaceHeight$[ebp]
  00142	66 89 48 0e	 mov	 WORD PTR [eax+14], cx

; 154  : 
; 155  : 	/* wstring begin */ 	
; 156  : 
; 157  : 	const char* begin = m_stText.c_str();

  00146	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00149	83 c1 20	 add	 ecx, 32			; 00000020H
  0014c	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00151	89 45 c8	 mov	 DWORD PTR _begin$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  00154	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00157	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0015a	89 85 50 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 158  : 	const char* end = begin + m_stText.length();

  00160	8b 45 c8	 mov	 eax, DWORD PTR _begin$[ebp]
  00163	03 85 50 fe ff
	ff		 add	 eax, DWORD PTR $T3[ebp]
  00169	89 85 68 ff ff
	ff		 mov	 DWORD PTR _end$[ebp], eax

; 159  : 
; 160  : 	int wTextMax = (end - begin) * 2;

  0016f	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _end$[ebp]
  00175	2b 45 c8	 sub	 eax, DWORD PTR _begin$[ebp]
  00178	d1 e0		 shl	 eax, 1
  0017a	89 85 fc fe ff
	ff		 mov	 DWORD PTR _wTextMax$[ebp], eax

; 161  : 	wchar_t* wText = (wchar_t*)_alloca(sizeof(wchar_t)*wTextMax);

  00180	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR _wTextMax$[ebp]
  00186	d1 e0		 shl	 eax, 1
  00188	e8 00 00 00 00	 call	 __alloca_probe_16
  0018d	89 a5 f4 fe ff
	ff		 mov	 DWORD PTR tv151[ebp], esp
  00193	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv151[ebp]
  00199	89 45 88	 mov	 DWORD PTR _wText$[ebp], eax

; 162  : 
; 163  : 	DWORD dwColor = m_dwTextColor;

  0019c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0019f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a2	89 45 dc	 mov	 DWORD PTR _dwColor$[ebp], eax
$LN2@Update:

; 164  : 
; 165  : 	/* wstring end */
; 166  : 	while (begin < end)

  001a5	8b 45 c8	 mov	 eax, DWORD PTR _begin$[ebp]
  001a8	3b 85 68 ff ff
	ff		 cmp	 eax, DWORD PTR _end$[ebp]
  001ae	0f 83 1b 0f 00
	00		 jae	 $LN3@Update

; 167  : 	{
; 168  : 		const char * token = FindToken(begin, end);

  001b4	ff b5 68 ff ff
	ff		 push	 DWORD PTR _end$[ebp]
  001ba	ff 75 c8	 push	 DWORD PTR _begin$[ebp]
  001bd	e8 00 00 00 00	 call	 ?FindToken@@YAPBDPBD0@Z	; FindToken
  001c2	59		 pop	 ecx
  001c3	59		 pop	 ecx
  001c4	89 45 80	 mov	 DWORD PTR _token$70[ebp], eax

; 169  : 
; 170  : 		int wTextLen = Ymir_MultiByteToWideChar(dataCodePage, 0, begin, token - begin, wText, wTextMax);

  001c7	ff b5 fc fe ff
	ff		 push	 DWORD PTR _wTextMax$[ebp]
  001cd	ff 75 88	 push	 DWORD PTR _wText$[ebp]
  001d0	8b 45 80	 mov	 eax, DWORD PTR _token$70[ebp]
  001d3	2b 45 c8	 sub	 eax, DWORD PTR _begin$[ebp]
  001d6	50		 push	 eax
  001d7	ff 75 c8	 push	 DWORD PTR _begin$[ebp]
  001da	6a 00		 push	 0
  001dc	ff 75 d4	 push	 DWORD PTR _dataCodePage$[ebp]
  001df	e8 00 00 00 00	 call	 ?Ymir_MultiByteToWideChar@@YAHIKPBDHPA_WH@Z ; Ymir_MultiByteToWideChar
  001e4	83 c4 18	 add	 esp, 24			; 00000018H
  001e7	89 45 a4	 mov	 DWORD PTR _wTextLen$78[ebp], eax

; 171  : 
; 172  : 		if (m_isSecret)

  001ea	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001ed	0f b6 40 19	 movzx	 eax, BYTE PTR [eax+25]
  001f1	85 c0		 test	 eax, eax
  001f3	74 3b		 je	 SHORT $LN35@Update

; 173  : 		{
; 174  : 			for(int i=0; i<wTextLen; ++i)

  001f5	83 a5 54 ff ff
	ff 00		 and	 DWORD PTR _i$60[ebp], 0
  001fc	eb 0d		 jmp	 SHORT $LN6@Update
$LN4@Update:
  001fe	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _i$60[ebp]
  00204	40		 inc	 eax
  00205	89 85 54 ff ff
	ff		 mov	 DWORD PTR _i$60[ebp], eax
$LN6@Update:
  0020b	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _i$60[ebp]
  00211	3b 45 a4	 cmp	 eax, DWORD PTR _wTextLen$78[ebp]
  00214	7d 15		 jge	 SHORT $LN5@Update

; 175  : 				__DrawCharacter(pFontTexture, dataCodePage, '*', dwColor);

  00216	ff 75 dc	 push	 DWORD PTR _dwColor$[ebp]
  00219	6a 2a		 push	 42			; 0000002aH
  0021b	ff 75 d4	 push	 DWORD PTR _dataCodePage$[ebp]
  0021e	ff 75 d0	 push	 DWORD PTR _pFontTexture$[ebp]
  00221	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00224	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter
  00229	eb d3		 jmp	 SHORT $LN4@Update
$LN5@Update:

; 176  : 		} 

  0022b	e9 66 0e 00 00	 jmp	 $LN36@Update
$LN35@Update:

; 177  : 		else 
; 178  : 		{
; 179  : 			if (defCodePage == CP_ARABIC) // ARABIC

  00230	81 bd f8 fe ff
	ff e8 04 00 00	 cmp	 DWORD PTR _defCodePage$[ebp], 1256 ; 000004e8H
  0023a	0f 85 5f 0b 00
	00		 jne	 $LN37@Update

; 180  : 			{
; 181  : 
; 182  : 				wchar_t* wArabicText = (wchar_t*)_alloca(sizeof(wchar_t) * wTextLen);

  00240	8b 45 a4	 mov	 eax, DWORD PTR _wTextLen$78[ebp]
  00243	d1 e0		 shl	 eax, 1
  00245	e8 00 00 00 00	 call	 __alloca_probe_16
  0024a	89 a5 f0 fe ff
	ff		 mov	 DWORD PTR tv179[ebp], esp
  00250	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv179[ebp]
  00256	89 45 ec	 mov	 DWORD PTR _wArabicText$89[ebp], eax

; 183  : 				int wArabicTextLen = Arabic_MakeShape(wText, wTextLen, wArabicText, wTextLen);

  00259	ff 75 a4	 push	 DWORD PTR _wTextLen$78[ebp]
  0025c	ff 75 ec	 push	 DWORD PTR _wArabicText$89[ebp]
  0025f	ff 75 a4	 push	 DWORD PTR _wTextLen$78[ebp]
  00262	ff 75 88	 push	 DWORD PTR _wText$[ebp]
  00265	e8 00 00 00 00	 call	 ?Arabic_MakeShape@@YAIPA_WI0I@Z ; Arabic_MakeShape
  0026a	83 c4 10	 add	 esp, 16			; 00000010H
  0026d	89 45 94	 mov	 DWORD PTR _wArabicTextLen$74[ebp], eax

; 184  : 
; 185  : 				bool isEnglish = true;

  00270	c6 45 07 01	 mov	 BYTE PTR _isEnglish$91[ebp], 1

; 186  : 				int nEnglishBase = wArabicTextLen - 1;

  00274	8b 45 94	 mov	 eax, DWORD PTR _wArabicTextLen$74[ebp]
  00277	48		 dec	 eax
  00278	89 85 48 ff ff
	ff		 mov	 DWORD PTR _nEnglishBase$57[ebp], eax

; 187  : 
; 188  : 				//<< >>
; 189  : 				int x = 0;

  0027e	83 a5 24 ff ff
	ff 00		 and	 DWORD PTR _x$48[ebp], 0

; 190  : 
; 191  : 				int len;				
; 192  : 				int hyperlinkStep = 0;

  00285	83 65 e0 00	 and	 DWORD PTR _hyperlinkStep$88[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.h

; 84   : 			SHyperlink() : sx(0), ex(0) { }

  00289	33 c0		 xor	 eax, eax
  0028b	66 89 45 58	 mov	 WORD PTR _kHyperlink$95[ebp], ax
  0028f	33 c0		 xor	 eax, eax
  00291	66 89 45 5a	 mov	 WORD PTR _kHyperlink$95[ebp+2], ax
  00295	8d 4d 5c	 lea	 ecx, DWORD PTR _kHyperlink$95[ebp+4]
  00298	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 193  : 				SHyperlink kHyperlink;

  0029d	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  002a1	8d 45 40	 lea	 eax, DWORD PTR _hyperlinkBuffer$94[ebp]
  002a4	89 85 ec fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  002aa	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002b0	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  002b5	8d 4d 40	 lea	 ecx, DWORD PTR _hyperlinkBuffer$94[ebp]
  002b8	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 194  : 				std::wstring hyperlinkBuffer;

  002bd	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 195  : 				int no_hyperlink = 0;

  002c1	83 65 cc 00	 and	 DWORD PTR _no_hyperlink$87[ebp], 0

; 196  : 
; 197  : 				//     
; 198  : 				if (Arabic_IsInSymbol(wArabicText[wArabicTextLen - 1]))

  002c5	8b 45 94	 mov	 eax, DWORD PTR _wArabicTextLen$74[ebp]
  002c8	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  002cb	0f b7 44 41 fe	 movzx	 eax, WORD PTR [ecx+eax*2-2]
  002d0	50		 push	 eax
  002d1	e8 00 00 00 00	 call	 ?Arabic_IsInSymbol@@YA_N_W@Z ; Arabic_IsInSymbol
  002d6	59		 pop	 ecx
  002d7	0f b6 c0	 movzx	 eax, al
  002da	85 c0		 test	 eax, eax
  002dc	74 04		 je	 SHORT $LN39@Update

; 199  : 				{
; 200  : 					isEnglish = false;

  002de	c6 45 07 00	 mov	 BYTE PTR _isEnglish$91[ebp], 0
$LN39@Update:

; 201  : 				}
; 202  : 				
; 203  : 				int i = 0;

  002e2	83 65 00 00	 and	 DWORD PTR _i$90[ebp], 0

; 204  : 				for (i = wArabicTextLen - 1 ; i >= 0; --i)

  002e6	8b 45 94	 mov	 eax, DWORD PTR _wArabicTextLen$74[ebp]
  002e9	48		 dec	 eax
  002ea	89 45 00	 mov	 DWORD PTR _i$90[ebp], eax
  002ed	eb 07		 jmp	 SHORT $LN9@Update
$LN7@Update:
  002ef	8b 45 00	 mov	 eax, DWORD PTR _i$90[ebp]
  002f2	48		 dec	 eax
  002f3	89 45 00	 mov	 DWORD PTR _i$90[ebp], eax
$LN9@Update:
  002f6	83 7d 00 00	 cmp	 DWORD PTR _i$90[ebp], 0
  002fa	0f 8c f9 06 00
	00		 jl	 $LN8@Update

; 205  : 				{
; 206  : 					wchar_t wArabicChar = wArabicText[i];

  00300	8b 45 00	 mov	 eax, DWORD PTR _i$90[ebp]
  00303	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  00306	66 8b 04 41	 mov	 ax, WORD PTR [ecx+eax*2]
  0030a	66 89 85 70 ff
	ff ff		 mov	 WORD PTR _wArabicChar$66[ebp], ax

; 207  : 
; 208  : 					if (isEnglish)

  00311	0f b6 45 07	 movzx	 eax, BYTE PTR _isEnglish$91[ebp]
  00315	85 c0		 test	 eax, eax
  00317	0f 84 77 05 00
	00		 je	 $LN40@Update

; 209  : 					{
; 210  : 
; 211  : 						// <<  (ex. , )>> ->   .
; 212  : 						//		<<(   : , , )>>
; 213  : 						//  (1)    or
; 214  : 						//	(2) 
; 215  : 						//		1)     &&
; 216  : 						//		2)     &&
; 217  : 						//		3)   '|'  &&
; 218  : 						//		or
; 219  : 						//	(3)   '|'
; 220  : 						// <<    : .>>
; 221  : 						//	1)  
; 222  : 						//	2)  
; 223  : 						//
; 224  : 						//
; 225  : 						if (Arabic_IsInSymbol(wArabicChar) && (

  0031d	ff b5 70 ff ff
	ff		 push	 DWORD PTR _wArabicChar$66[ebp]
  00323	e8 00 00 00 00	 call	 ?Arabic_IsInSymbol@@YA_N_W@Z ; Arabic_IsInSymbol
  00328	59		 pop	 ecx
  00329	0f b6 c0	 movzx	 eax, al
  0032c	85 c0		 test	 eax, eax
  0032e	74 69		 je	 SHORT $LN42@Update
  00330	83 7d 00 00	 cmp	 DWORD PTR _i$90[ebp], 0
  00334	74 54		 je	 SHORT $LN44@Update
  00336	83 7d 00 00	 cmp	 DWORD PTR _i$90[ebp], 0
  0033a	7e 3f		 jle	 SHORT $LN45@Update
  0033c	8b 45 00	 mov	 eax, DWORD PTR _i$90[ebp]
  0033f	48		 dec	 eax
  00340	50		 push	 eax
  00341	ff 75 ec	 push	 DWORD PTR _wArabicText$89[ebp]
  00344	e8 00 00 00 00	 call	 ?Arabic_HasPresentation@@YA_NPA_WH@Z ; Arabic_HasPresentation
  00349	59		 pop	 ecx
  0034a	59		 pop	 ecx
  0034b	0f b6 c0	 movzx	 eax, al
  0034e	85 c0		 test	 eax, eax
  00350	75 29		 jne	 SHORT $LN45@Update
  00352	8b 45 00	 mov	 eax, DWORD PTR _i$90[ebp]
  00355	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  00358	0f b7 44 41 02	 movzx	 eax, WORD PTR [ecx+eax*2+2]
  0035d	50		 push	 eax
  0035e	e8 00 00 00 00	 call	 ?Arabic_IsInPresentation@@YA_N_W@Z ; Arabic_IsInPresentation
  00363	59		 pop	 ecx
  00364	0f b6 c0	 movzx	 eax, al
  00367	85 c0		 test	 eax, eax
  00369	75 10		 jne	 SHORT $LN45@Update
  0036b	8b 45 00	 mov	 eax, DWORD PTR _i$90[ebp]
  0036e	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  00371	0f b7 44 41 02	 movzx	 eax, WORD PTR [ecx+eax*2+2]
  00376	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00379	75 0f		 jne	 SHORT $LN44@Update
$LN45@Update:
  0037b	8b 45 00	 mov	 eax, DWORD PTR _i$90[ebp]
  0037e	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  00381	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00385	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00388	75 0f		 jne	 SHORT $LN42@Update
$LN44@Update:

; 226  : 								(i == 0) ||
; 227  : 								(i > 0 && 
; 228  : 									!(Arabic_HasPresentation(wArabicText, i - 1) || Arabic_IsInPresentation(wArabicText[i + 1]))  && //,   .
; 229  : 									wArabicText[i+1] != '|'
; 230  : 								) ||
; 231  : 								wArabicText[i] == '|'
; 232  : 							))//if end.
; 233  : 						{
; 234  : 							// pass
; 235  : 							int temptest = 1;

  0038a	c7 85 48 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _temptest$2[ebp], 1

; 236  : 						}

  00394	e9 f6 04 00 00	 jmp	 $LN43@Update
$LN42@Update:

; 237  : 						// (1) (2)     
; 238  : 						else if (Arabic_IsInPresentation(wArabicChar) || Arabic_IsInSymbol(wArabicChar))

  00399	ff b5 70 ff ff
	ff		 push	 DWORD PTR _wArabicChar$66[ebp]
  0039f	e8 00 00 00 00	 call	 ?Arabic_IsInPresentation@@YA_N_W@Z ; Arabic_IsInPresentation
  003a4	59		 pop	 ecx
  003a5	0f b6 c0	 movzx	 eax, al
  003a8	85 c0		 test	 eax, eax
  003aa	75 17		 jne	 SHORT $LN47@Update
  003ac	ff b5 70 ff ff
	ff		 push	 DWORD PTR _wArabicChar$66[ebp]
  003b2	e8 00 00 00 00	 call	 ?Arabic_IsInSymbol@@YA_N_W@Z ; Arabic_IsInSymbol
  003b7	59		 pop	 ecx
  003b8	0f b6 c0	 movzx	 eax, al
  003bb	85 c0		 test	 eax, eax
  003bd	0f 84 cc 04 00
	00		 je	 $LN43@Update
$LN47@Update:

; 239  : 						{
; 240  : 							//   .
; 241  : 							for (int e = i + 1; e <= nEnglishBase;) {

  003c3	8b 45 00	 mov	 eax, DWORD PTR _i$90[ebp]
  003c6	40		 inc	 eax
  003c7	89 45 c0	 mov	 DWORD PTR _e$85[ebp], eax
$LN12@Update:
  003ca	8b 45 c0	 mov	 eax, DWORD PTR _e$85[ebp]
  003cd	3b 85 48 ff ff
	ff		 cmp	 eax, DWORD PTR _nEnglishBase$57[ebp]
  003d3	0f 8f 8b 03 00
	00		 jg	 $LN11@Update

; 242  : 								int ret = GetTextTag(&wArabicText[e], wArabicTextLen - e, len, hyperlinkBuffer);

  003d9	8d 45 40	 lea	 eax, DWORD PTR _hyperlinkBuffer$94[ebp]
  003dc	50		 push	 eax
  003dd	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _len$56[ebp]
  003e3	50		 push	 eax
  003e4	8b 45 94	 mov	 eax, DWORD PTR _wArabicTextLen$74[ebp]
  003e7	2b 45 c0	 sub	 eax, DWORD PTR _e$85[ebp]
  003ea	50		 push	 eax
  003eb	8b 45 c0	 mov	 eax, DWORD PTR _e$85[ebp]
  003ee	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  003f1	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  003f4	50		 push	 eax
  003f5	e8 00 00 00 00	 call	 ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
  003fa	83 c4 10	 add	 esp, 16			; 00000010H
  003fd	89 45 ac	 mov	 DWORD PTR _ret$80[ebp], eax

; 243  : 
; 244  : 								if (ret == TEXT_TAG_PLAIN || ret == TEXT_TAG_TAG)

  00400	83 7d ac 00	 cmp	 DWORD PTR _ret$80[ebp], 0
  00404	74 0a		 je	 SHORT $LN50@Update
  00406	83 7d ac 01	 cmp	 DWORD PTR _ret$80[ebp], 1
  0040a	0f 85 42 01 00
	00		 jne	 $LN48@Update
$LN50@Update:

; 245  : 								{
; 246  : 									if (hyperlinkStep == 1)

  00410	83 7d e0 01	 cmp	 DWORD PTR _hyperlinkStep$88[ebp], 1
  00414	75 1a		 jne	 SHORT $LN51@Update

; 247  : 										hyperlinkBuffer.append(1, wArabicText[e]);

  00416	8b 45 c0	 mov	 eax, DWORD PTR _e$85[ebp]
  00419	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  0041c	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00420	50		 push	 eax
  00421	6a 01		 push	 1
  00423	8d 4d 40	 lea	 ecx, DWORD PTR _hyperlinkBuffer$94[ebp]
  00426	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  0042b	e9 1d 01 00 00	 jmp	 $LN52@Update
$LN51@Update:

; 248  : 									else
; 249  : 									{
; 250  : 										int charWidth = __DrawCharacter(pFontTexture, dataCodePage, wArabicText[e], dwColor);

  00430	ff 75 dc	 push	 DWORD PTR _dwColor$[ebp]
  00433	8b 45 c0	 mov	 eax, DWORD PTR _e$85[ebp]
  00436	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  00439	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  0043d	50		 push	 eax
  0043e	ff 75 d4	 push	 DWORD PTR _dataCodePage$[ebp]
  00441	ff 75 d0	 push	 DWORD PTR _pFontTexture$[ebp]
  00444	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00447	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter
  0044c	89 85 50 ff ff
	ff		 mov	 DWORD PTR _charWidth$59[ebp], eax

; 251  : 										kHyperlink.ex += charWidth;

  00452	0f bf 45 5a	 movsx	 eax, WORD PTR _kHyperlink$95[ebp+2]
  00456	03 85 50 ff ff
	ff		 add	 eax, DWORD PTR _charWidth$59[ebp]
  0045c	66 89 45 5a	 mov	 WORD PTR _kHyperlink$95[ebp+2], ax

; 252  : 										//x += charWidth;
; 253  : 										
; 254  : 										//    .
; 255  : 										for (int j = 1; j <= no_hyperlink; j++)

  00460	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _j$69[ebp], 1
  0046a	eb 0d		 jmp	 SHORT $LN15@Update
$LN13@Update:
  0046c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _j$69[ebp]
  00472	40		 inc	 eax
  00473	89 85 7c ff ff
	ff		 mov	 DWORD PTR _j$69[ebp], eax
$LN15@Update:
  00479	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _j$69[ebp]
  0047f	3b 45 cc	 cmp	 eax, DWORD PTR _no_hyperlink$87[ebp]
  00482	0f 8f c5 00 00
	00		 jg	 $LN52@Update
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00488	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0048b	83 c0 64	 add	 eax, 100		; 00000064H
  0048e	89 85 38 ff ff
	ff		 mov	 DWORD PTR __My_data$53[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00494	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$53[ebp]
  0049a	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$53[ebp]
  004a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004a3	2b 01		 sub	 eax, DWORD PTR [ecx]
  004a5	99		 cdq
  004a6	6a 1c		 push	 28			; 0000001cH
  004a8	59		 pop	 ecx
  004a9	f7 f9		 idiv	 ecx
  004ab	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T40[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 257  : 											if(m_hyperlinkVector.size() < j)

  004b1	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR $T40[ebp]
  004b7	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR _j$69[ebp]
  004bd	73 05		 jae	 SHORT $LN53@Update

; 258  : 												break;

  004bf	e9 89 00 00 00	 jmp	 $LN52@Update
$LN53@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  004c4	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  004c7	83 c0 64	 add	 eax, 100		; 00000064H
  004ca	89 85 34 ff ff
	ff		 mov	 DWORD PTR __My_data$52[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  004d0	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$52[ebp]
  004d6	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$52[ebp]
  004dc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004df	2b 01		 sub	 eax, DWORD PTR [ecx]
  004e1	99		 cdq
  004e2	6a 1c		 push	 28			; 0000001cH
  004e4	59		 pop	 ecx
  004e5	f7 f9		 idiv	 ecx
  004e7	89 85 e4 fe ff
	ff		 mov	 DWORD PTR $T39[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  004ed	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  004f0	83 c0 64	 add	 eax, 100		; 00000064H
  004f3	89 85 e0 fe ff
	ff		 mov	 DWORD PTR __My_data$38[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 260  : 											SHyperlink & tempLink = m_hyperlinkVector[m_hyperlinkVector.size() - j];

  004f9	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR $T39[ebp]
  004ff	2b 85 7c ff ff
	ff		 sub	 eax, DWORD PTR _j$69[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00505	6b c0 1c	 imul	 eax, eax, 28
  00508	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$38[ebp]
  0050e	03 01		 add	 eax, DWORD PTR [ecx]
  00510	89 85 6c ff ff
	ff		 mov	 DWORD PTR _tempLink$65[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 261  : 											tempLink.ex += charWidth;

  00516	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _tempLink$65[ebp]
  0051c	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  00520	03 85 50 ff ff
	ff		 add	 eax, DWORD PTR _charWidth$59[ebp]
  00526	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _tempLink$65[ebp]
  0052c	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 262  : 											tempLink.sx += charWidth;

  00530	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _tempLink$65[ebp]
  00536	0f bf 00	 movsx	 eax, WORD PTR [eax]
  00539	03 85 50 ff ff
	ff		 add	 eax, DWORD PTR _charWidth$59[ebp]
  0053f	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _tempLink$65[ebp]
  00545	66 89 01	 mov	 WORD PTR [ecx], ax

; 263  : 										}

  00548	e9 1f ff ff ff	 jmp	 $LN13@Update
$LN52@Update:

; 264  : 									}
; 265  : 								}

  0054d	e9 01 02 00 00	 jmp	 $LN49@Update
$LN48@Update:

; 266  : 								else
; 267  : 								{
; 268  : 									if (ret == TEXT_TAG_COLOR)

  00552	83 7d ac 02	 cmp	 DWORD PTR _ret$80[ebp], 2
  00556	0f 85 02 01 00
	00		 jne	 $LN54@Update

; 269  : 										dwColor = htoi(hyperlinkBuffer.c_str(), 8);

  0055c	8d 4d 40	 lea	 ecx, DWORD PTR _hyperlinkBuffer$94[ebp]
  0055f	e8 00 00 00 00	 call	 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
  00564	89 45 f0	 mov	 DWORD PTR _s$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Utils.h

; 148  :     const wchar_t *t = s;

  00567	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  0056a	89 85 dc fe ff
	ff		 mov	 DWORD PTR _t$37[ebp], eax

; 149  :     int x = 0, y = 1;

  00570	83 65 c4 00	 and	 DWORD PTR _x$86[ebp], 0
  00574	c7 85 78 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _y$68[ebp], 1

; 150  :     s += size;

  0057e	6a 08		 push	 8
  00580	58		 pop	 eax
  00581	d1 e0		 shl	 eax, 1
  00583	03 45 f0	 add	 eax, DWORD PTR _s$[ebp]
  00586	89 45 f0	 mov	 DWORD PTR _s$[ebp], eax
$LN241@Update:

; 151  : 
; 152  :     while (t <= --s)

  00589	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  0058c	48		 dec	 eax
  0058d	48		 dec	 eax
  0058e	89 45 f0	 mov	 DWORD PTR _s$[ebp], eax
  00591	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _t$37[ebp]
  00597	3b 45 f0	 cmp	 eax, DWORD PTR _s$[ebp]
  0059a	0f 87 a7 00 00
	00		 ja	 $LN242@Update

; 153  :     {
; 154  : 		if (L'0' <= *s && *s <= L'9')

  005a0	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  005a3	0f b7 00	 movzx	 eax, WORD PTR [eax]
  005a6	83 f8 30	 cmp	 eax, 48			; 00000030H
  005a9	7c 23		 jl	 SHORT $LN243@Update
  005ab	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  005ae	0f b7 00	 movzx	 eax, WORD PTR [eax]
  005b1	83 f8 39	 cmp	 eax, 57			; 00000039H
  005b4	7f 18		 jg	 SHORT $LN243@Update

; 155  :             x += y * (*s - L'0');

  005b6	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  005b9	0f b7 00	 movzx	 eax, WORD PTR [eax]
  005bc	83 e8 30	 sub	 eax, 48			; 00000030H
  005bf	0f af 85 78 ff
	ff ff		 imul	 eax, DWORD PTR _y$68[ebp]
  005c6	03 45 c4	 add	 eax, DWORD PTR _x$86[ebp]
  005c9	89 45 c4	 mov	 DWORD PTR _x$86[ebp], eax
  005cc	eb 65		 jmp	 SHORT $LN244@Update
$LN243@Update:

; 156  :         else if (L'a' <= *s && *s <= L'f')

  005ce	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  005d1	0f b7 00	 movzx	 eax, WORD PTR [eax]
  005d4	83 f8 61	 cmp	 eax, 97			; 00000061H
  005d7	7c 23		 jl	 SHORT $LN245@Update
  005d9	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  005dc	0f b7 00	 movzx	 eax, WORD PTR [eax]
  005df	83 f8 66	 cmp	 eax, 102		; 00000066H
  005e2	7f 18		 jg	 SHORT $LN245@Update

; 157  :             x += y * (*s - L'a' + 10);

  005e4	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  005e7	0f b7 00	 movzx	 eax, WORD PTR [eax]
  005ea	83 e8 57	 sub	 eax, 87			; 00000057H
  005ed	0f af 85 78 ff
	ff ff		 imul	 eax, DWORD PTR _y$68[ebp]
  005f4	03 45 c4	 add	 eax, DWORD PTR _x$86[ebp]
  005f7	89 45 c4	 mov	 DWORD PTR _x$86[ebp], eax
  005fa	eb 37		 jmp	 SHORT $LN244@Update
$LN245@Update:

; 158  :         else if (L'A' <= *s && *s <= L'F')

  005fc	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  005ff	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00602	83 f8 41	 cmp	 eax, 65			; 00000041H
  00605	7c 23		 jl	 SHORT $LN247@Update
  00607	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  0060a	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0060d	83 f8 46	 cmp	 eax, 70			; 00000046H
  00610	7f 18		 jg	 SHORT $LN247@Update

; 159  :             x += y * (10 + *s - L'A');

  00612	8b 45 f0	 mov	 eax, DWORD PTR _s$[ebp]
  00615	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00618	83 e8 37	 sub	 eax, 55			; 00000037H
  0061b	0f af 85 78 ff
	ff ff		 imul	 eax, DWORD PTR _y$68[ebp]
  00622	03 45 c4	 add	 eax, DWORD PTR _x$86[ebp]
  00625	89 45 c4	 mov	 DWORD PTR _x$86[ebp], eax
  00628	eb 09		 jmp	 SHORT $LN244@Update
$LN247@Update:

; 160  :         else
; 161  :             return -1; /* invalid input! */

  0062a	83 8d 30 ff ff
	ff ff		 or	 DWORD PTR $T51[ebp], -1
  00631	eb 1d		 jmp	 SHORT $LN240@Update
$LN244@Update:

; 162  :         y <<= 4;

  00633	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _y$68[ebp]
  00639	c1 e0 04	 shl	 eax, 4
  0063c	89 85 78 ff ff
	ff		 mov	 DWORD PTR _y$68[ebp], eax

; 163  :     }

  00642	e9 42 ff ff ff	 jmp	 $LN241@Update
$LN242@Update:

; 164  : 
; 165  :     return x;

  00647	8b 45 c4	 mov	 eax, DWORD PTR _x$86[ebp]
  0064a	89 85 30 ff ff
	ff		 mov	 DWORD PTR $T51[ebp], eax
$LN240@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 269  : 										dwColor = htoi(hyperlinkBuffer.c_str(), 8);

  00650	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR $T51[ebp]
  00656	89 45 dc	 mov	 DWORD PTR _dwColor$[ebp], eax
  00659	e9 f5 00 00 00	 jmp	 $LN49@Update
$LN54@Update:

; 270  : 									else if (ret == TEXT_TAG_RESTORE_COLOR)

  0065e	83 7d ac 05	 cmp	 DWORD PTR _ret$80[ebp], 5
  00662	75 0e		 jne	 SHORT $LN56@Update

; 271  : 										dwColor = m_dwTextColor;

  00664	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00667	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0066a	89 45 dc	 mov	 DWORD PTR _dwColor$[ebp], eax
  0066d	e9 e1 00 00 00	 jmp	 $LN49@Update
$LN56@Update:

; 272  : 									else if (ret == TEXT_TAG_HYPERLINK_START)

  00672	83 7d ac 03	 cmp	 DWORD PTR _ret$80[ebp], 3
  00676	75 3c		 jne	 SHORT $LN58@Update

; 273  : 									{
; 274  : 										hyperlinkStep = 1;

  00678	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _hyperlinkStep$88[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 249  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  0067f	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00684	e8 00 00 00 00	 call	 _wcslen
  00689	59		 pop	 ecx
  0068a	89 85 d8 fe ff
	ff		 mov	 DWORD PTR $T36[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00690	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR $T36[ebp]
  00696	89 85 d4 fe ff
	ff		 mov	 DWORD PTR $T35[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0069c	ff b5 d4 fe ff
	ff		 push	 DWORD PTR $T35[ebp]
  006a2	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  006a7	8d 4d 40	 lea	 ecx, DWORD PTR _hyperlinkBuffer$94[ebp]
  006aa	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 276  : 									}

  006af	e9 9f 00 00 00	 jmp	 $LN49@Update
$LN58@Update:

; 277  : 									else if (ret == TEXT_TAG_HYPERLINK_END)

  006b4	83 7d ac 04	 cmp	 DWORD PTR _ret$80[ebp], 4
  006b8	0f 85 95 00 00
	00		 jne	 $LN49@Update

; 278  : 									{
; 279  : 										if (hyperlinkStep == 1)

  006be	83 7d e0 01	 cmp	 DWORD PTR _hyperlinkStep$88[ebp], 1
  006c2	75 17		 jne	 SHORT $LN61@Update

; 280  : 										{
; 281  : 											++hyperlinkStep;

  006c4	8b 45 e0	 mov	 eax, DWORD PTR _hyperlinkStep$88[ebp]
  006c7	40		 inc	 eax
  006c8	89 45 e0	 mov	 DWORD PTR _hyperlinkStep$88[ebp], eax

; 282  : 											kHyperlink.ex = kHyperlink.sx = 0; //    

  006cb	33 c0		 xor	 eax, eax
  006cd	66 89 45 58	 mov	 WORD PTR _kHyperlink$95[ebp], ax
  006d1	66 8b 45 58	 mov	 ax, WORD PTR _kHyperlink$95[ebp]
  006d5	66 89 45 5a	 mov	 WORD PTR _kHyperlink$95[ebp+2], ax

; 283  : 										}

  006d9	eb 78		 jmp	 SHORT $LN49@Update
$LN61@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  006db	8d 45 40	 lea	 eax, DWORD PTR _hyperlinkBuffer$94[ebp]
  006de	89 85 d0 fe ff
	ff		 mov	 DWORD PTR $T34[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  006e4	8d 45 5c	 lea	 eax, DWORD PTR _kHyperlink$95[ebp+4]
  006e7	3b 85 d0 fe ff
	ff		 cmp	 eax, DWORD PTR $T34[ebp]
  006ed	74 1a		 je	 SHORT $LN260@Update

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  006ef	33 c0		 xor	 eax, eax
  006f1	88 85 cc fe ff
	ff		 mov	 BYTE PTR $T33[ebp], al
  006f7	ff b5 cc fe ff
	ff		 push	 DWORD PTR $T33[ebp]
  006fd	8d 45 40	 lea	 eax, DWORD PTR _hyperlinkBuffer$94[ebp]
  00700	50		 push	 eax
  00701	8d 4d 5c	 lea	 ecx, DWORD PTR _kHyperlink$95[ebp+4]
  00704	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy_assign
$LN260@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00709	8d 45 58	 lea	 eax, DWORD PTR _kHyperlink$95[ebp]
  0070c	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 287  : 											m_hyperlinkVector.push_back(kHyperlink);

  0070d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00710	83 c1 64	 add	 ecx, 100		; 00000064H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00713	e8 00 00 00 00	 call	 ??$emplace_back@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXABUSHyperlink@CGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::emplace_back<CGraphicTextInstance::SHyperlink const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 288  : 											no_hyperlink++;

  00718	8b 45 cc	 mov	 eax, DWORD PTR _no_hyperlink$87[ebp]
  0071b	40		 inc	 eax
  0071c	89 45 cc	 mov	 DWORD PTR _no_hyperlink$87[ebp], eax

; 289  : 
; 290  : 
; 291  : 											hyperlinkStep = 0;

  0071f	83 65 e0 00	 and	 DWORD PTR _hyperlinkStep$88[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 249  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00723	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00728	e8 00 00 00 00	 call	 _wcslen
  0072d	59		 pop	 ecx
  0072e	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T32[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00734	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T32[ebp]
  0073a	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T31[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00740	ff b5 c4 fe ff
	ff		 push	 DWORD PTR $T31[ebp]
  00746	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  0074b	8d 4d 40	 lea	 ecx, DWORD PTR _hyperlinkBuffer$94[ebp]
  0074e	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN49@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 296  : 								e += len;

  00753	8b 45 c0	 mov	 eax, DWORD PTR _e$85[ebp]
  00756	03 85 44 ff ff
	ff		 add	 eax, DWORD PTR _len$56[ebp]
  0075c	89 45 c0	 mov	 DWORD PTR _e$85[ebp], eax

; 297  : 							}

  0075f	e9 66 fc ff ff	 jmp	 $LN12@Update
$LN11@Update:

; 298  : 
; 299  : 							int charWidth = __DrawCharacter(pFontTexture, dataCodePage, Arabic_ConvSymbol(wArabicText[i]), dwColor);

  00764	ff 75 dc	 push	 DWORD PTR _dwColor$[ebp]
  00767	8b 45 00	 mov	 eax, DWORD PTR _i$90[ebp]
  0076a	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  0076d	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00771	50		 push	 eax
  00772	e8 00 00 00 00	 call	 ?Arabic_ConvSymbol@@YA_W_W@Z ; Arabic_ConvSymbol
  00777	59		 pop	 ecx
  00778	0f b7 c0	 movzx	 eax, ax
  0077b	50		 push	 eax
  0077c	ff 75 d4	 push	 DWORD PTR _dataCodePage$[ebp]
  0077f	ff 75 d0	 push	 DWORD PTR _pFontTexture$[ebp]
  00782	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00785	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter
  0078a	89 85 4c ff ff
	ff		 mov	 DWORD PTR _charWidth$58[ebp], eax

; 300  : 							kHyperlink.ex += charWidth;

  00790	0f bf 45 5a	 movsx	 eax, WORD PTR _kHyperlink$95[ebp+2]
  00794	03 85 4c ff ff
	ff		 add	 eax, DWORD PTR _charWidth$58[ebp]
  0079a	66 89 45 5a	 mov	 WORD PTR _kHyperlink$95[ebp+2], ax

; 301  : 							
; 302  : 							//    .
; 303  : 							for (int j = 1; j <= no_hyperlink; j++)

  0079e	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _j$67[ebp], 1
  007a8	eb 0d		 jmp	 SHORT $LN18@Update
$LN16@Update:
  007aa	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _j$67[ebp]
  007b0	40		 inc	 eax
  007b1	89 85 74 ff ff
	ff		 mov	 DWORD PTR _j$67[ebp], eax
$LN18@Update:
  007b7	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _j$67[ebp]
  007bd	3b 45 cc	 cmp	 eax, DWORD PTR _no_hyperlink$87[ebp]
  007c0	0f 8f c5 00 00
	00		 jg	 $LN17@Update
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  007c6	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  007c9	83 c0 64	 add	 eax, 100		; 00000064H
  007cc	89 85 2c ff ff
	ff		 mov	 DWORD PTR __My_data$50[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  007d2	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR __My_data$50[ebp]
  007d8	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$50[ebp]
  007de	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  007e1	2b 01		 sub	 eax, DWORD PTR [ecx]
  007e3	99		 cdq
  007e4	6a 1c		 push	 28			; 0000001cH
  007e6	59		 pop	 ecx
  007e7	f7 f9		 idiv	 ecx
  007e9	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T30[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 305  : 								if(m_hyperlinkVector.size() < j)

  007ef	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR $T30[ebp]
  007f5	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _j$67[ebp]
  007fb	73 05		 jae	 SHORT $LN63@Update

; 306  : 									break;

  007fd	e9 89 00 00 00	 jmp	 $LN17@Update
$LN63@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00802	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00805	83 c0 64	 add	 eax, 100		; 00000064H
  00808	89 85 28 ff ff
	ff		 mov	 DWORD PTR __My_data$49[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0080e	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$49[ebp]
  00814	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$49[ebp]
  0081a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0081d	2b 01		 sub	 eax, DWORD PTR [ecx]
  0081f	99		 cdq
  00820	6a 1c		 push	 28			; 0000001cH
  00822	59		 pop	 ecx
  00823	f7 f9		 idiv	 ecx
  00825	89 85 bc fe ff
	ff		 mov	 DWORD PTR $T29[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0082b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0082e	83 c0 64	 add	 eax, 100		; 00000064H
  00831	89 85 80 fe ff
	ff		 mov	 DWORD PTR __My_data$14[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 308  : 								SHyperlink & tempLink = m_hyperlinkVector[m_hyperlinkVector.size() - j];

  00837	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR $T29[ebp]
  0083d	2b 85 74 ff ff
	ff		 sub	 eax, DWORD PTR _j$67[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00843	6b c0 1c	 imul	 eax, eax, 28
  00846	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$14[ebp]
  0084c	03 01		 add	 eax, DWORD PTR [ecx]
  0084e	89 85 60 ff ff
	ff		 mov	 DWORD PTR _tempLink$63[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 309  : 								tempLink.ex += charWidth;

  00854	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _tempLink$63[ebp]
  0085a	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  0085e	03 85 4c ff ff
	ff		 add	 eax, DWORD PTR _charWidth$58[ebp]
  00864	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _tempLink$63[ebp]
  0086a	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 310  : 								tempLink.sx += charWidth;

  0086e	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _tempLink$63[ebp]
  00874	0f bf 00	 movsx	 eax, WORD PTR [eax]
  00877	03 85 4c ff ff
	ff		 add	 eax, DWORD PTR _charWidth$58[ebp]
  0087d	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _tempLink$63[ebp]
  00883	66 89 01	 mov	 WORD PTR [ecx], ax

; 311  : 							}

  00886	e9 1f ff ff ff	 jmp	 $LN16@Update
$LN17@Update:

; 312  : 
; 313  : 							isEnglish = false;

  0088b	c6 45 07 00	 mov	 BYTE PTR _isEnglish$91[ebp], 0
$LN43@Update:

; 314  : 						}
; 315  : 					}

  0088f	e9 60 01 00 00	 jmp	 $LN41@Update
$LN40@Update:

; 316  : 					else //[[[ ]]]
; 317  : 					{
; 318  : 						//     
; 319  : 						if (Arabic_IsInPresentation(wArabicChar) || Arabic_IsInSymbol(wArabicChar))

  00894	ff b5 70 ff ff
	ff		 push	 DWORD PTR _wArabicChar$66[ebp]
  0089a	e8 00 00 00 00	 call	 ?Arabic_IsInPresentation@@YA_N_W@Z ; Arabic_IsInPresentation
  0089f	59		 pop	 ecx
  008a0	0f b6 c0	 movzx	 eax, al
  008a3	85 c0		 test	 eax, eax
  008a5	75 17		 jne	 SHORT $LN66@Update
  008a7	ff b5 70 ff ff
	ff		 push	 DWORD PTR _wArabicChar$66[ebp]
  008ad	e8 00 00 00 00	 call	 ?Arabic_IsInSymbol@@YA_N_W@Z ; Arabic_IsInSymbol
  008b2	59		 pop	 ecx
  008b3	0f b6 c0	 movzx	 eax, al
  008b6	85 c0		 test	 eax, eax
  008b8	0f 84 29 01 00
	00		 je	 $LN64@Update
$LN66@Update:

; 320  : 						{
; 321  : 							int charWidth = __DrawCharacter(pFontTexture, dataCodePage, Arabic_ConvSymbol(wArabicText[i]), dwColor);

  008be	ff 75 dc	 push	 DWORD PTR _dwColor$[ebp]
  008c1	8b 45 00	 mov	 eax, DWORD PTR _i$90[ebp]
  008c4	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  008c7	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  008cb	50		 push	 eax
  008cc	e8 00 00 00 00	 call	 ?Arabic_ConvSymbol@@YA_W_W@Z ; Arabic_ConvSymbol
  008d1	59		 pop	 ecx
  008d2	0f b7 c0	 movzx	 eax, ax
  008d5	50		 push	 eax
  008d6	ff 75 d4	 push	 DWORD PTR _dataCodePage$[ebp]
  008d9	ff 75 d0	 push	 DWORD PTR _pFontTexture$[ebp]
  008dc	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  008df	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter
  008e4	89 85 5c ff ff
	ff		 mov	 DWORD PTR _charWidth$62[ebp], eax

; 322  : 							kHyperlink.ex += charWidth;

  008ea	0f bf 45 5a	 movsx	 eax, WORD PTR _kHyperlink$95[ebp+2]
  008ee	03 85 5c ff ff
	ff		 add	 eax, DWORD PTR _charWidth$62[ebp]
  008f4	66 89 45 5a	 mov	 WORD PTR _kHyperlink$95[ebp+2], ax

; 323  : 							x += charWidth;

  008f8	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _x$48[ebp]
  008fe	03 85 5c ff ff
	ff		 add	 eax, DWORD PTR _charWidth$62[ebp]
  00904	89 85 24 ff ff
	ff		 mov	 DWORD PTR _x$48[ebp], eax

; 324  : 							
; 325  : 							//    .
; 326  : 							for (int j = 1; j <= no_hyperlink; j++)

  0090a	c7 45 98 01 00
	00 00		 mov	 DWORD PTR _j$75[ebp], 1
  00911	eb 07		 jmp	 SHORT $LN21@Update
$LN19@Update:
  00913	8b 45 98	 mov	 eax, DWORD PTR _j$75[ebp]
  00916	40		 inc	 eax
  00917	89 45 98	 mov	 DWORD PTR _j$75[ebp], eax
$LN21@Update:
  0091a	8b 45 98	 mov	 eax, DWORD PTR _j$75[ebp]
  0091d	3b 45 cc	 cmp	 eax, DWORD PTR _no_hyperlink$87[ebp]
  00920	0f 8f bf 00 00
	00		 jg	 $LN20@Update
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00926	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00929	83 c0 64	 add	 eax, 100		; 00000064H
  0092c	89 85 20 ff ff
	ff		 mov	 DWORD PTR __My_data$47[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00932	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$47[ebp]
  00938	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$47[ebp]
  0093e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00941	2b 01		 sub	 eax, DWORD PTR [ecx]
  00943	99		 cdq
  00944	6a 1c		 push	 28			; 0000001cH
  00946	59		 pop	 ecx
  00947	f7 f9		 idiv	 ecx
  00949	89 85 b4 fe ff
	ff		 mov	 DWORD PTR $T27[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 328  : 								if(m_hyperlinkVector.size() < j)

  0094f	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR $T27[ebp]
  00955	3b 45 98	 cmp	 eax, DWORD PTR _j$75[ebp]
  00958	73 05		 jae	 SHORT $LN67@Update

; 329  : 									break;

  0095a	e9 86 00 00 00	 jmp	 $LN20@Update
$LN67@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0095f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00962	83 c0 64	 add	 eax, 100		; 00000064H
  00965	89 85 1c ff ff
	ff		 mov	 DWORD PTR __My_data$46[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0096b	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR __My_data$46[ebp]
  00971	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$46[ebp]
  00977	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0097a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0097c	99		 cdq
  0097d	6a 1c		 push	 28			; 0000001cH
  0097f	59		 pop	 ecx
  00980	f7 f9		 idiv	 ecx
  00982	89 85 b0 fe ff
	ff		 mov	 DWORD PTR $T26[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00988	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0098b	83 c0 64	 add	 eax, 100		; 00000064H
  0098e	89 85 ac fe ff
	ff		 mov	 DWORD PTR __My_data$25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 331  : 								SHyperlink & tempLink = m_hyperlinkVector[m_hyperlinkVector.size() - j];

  00994	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR $T26[ebp]
  0099a	2b 45 98	 sub	 eax, DWORD PTR _j$75[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  0099d	6b c0 1c	 imul	 eax, eax, 28
  009a0	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$25[ebp]
  009a6	03 01		 add	 eax, DWORD PTR [ecx]
  009a8	89 85 58 ff ff
	ff		 mov	 DWORD PTR _tempLink$61[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 332  : 								tempLink.ex += charWidth;

  009ae	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _tempLink$61[ebp]
  009b4	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  009b8	03 85 5c ff ff
	ff		 add	 eax, DWORD PTR _charWidth$62[ebp]
  009be	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _tempLink$61[ebp]
  009c4	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 333  : 								tempLink.sx += charWidth;

  009c8	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _tempLink$61[ebp]
  009ce	0f bf 00	 movsx	 eax, WORD PTR [eax]
  009d1	03 85 5c ff ff
	ff		 add	 eax, DWORD PTR _charWidth$62[ebp]
  009d7	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _tempLink$61[ebp]
  009dd	66 89 01	 mov	 WORD PTR [ecx], ax

; 334  : 							}

  009e0	e9 2e ff ff ff	 jmp	 $LN19@Update
$LN20@Update:

; 335  : 						}

  009e5	eb 0d		 jmp	 SHORT $LN41@Update
$LN64@Update:

; 336  : 						else //,    ,
; 337  : 						{
; 338  : 							nEnglishBase = i;

  009e7	8b 45 00	 mov	 eax, DWORD PTR _i$90[ebp]
  009ea	89 85 48 ff ff
	ff		 mov	 DWORD PTR _nEnglishBase$57[ebp], eax

; 339  : 							isEnglish = true;

  009f0	c6 45 07 01	 mov	 BYTE PTR _isEnglish$91[ebp], 1
$LN41@Update:

; 340  : 						}
; 341  : 					}
; 342  : 				}

  009f4	e9 f6 f8 ff ff	 jmp	 $LN7@Update
$LN8@Update:

; 343  : 
; 344  : 				if (isEnglish)

  009f9	0f b6 45 07	 movzx	 eax, BYTE PTR _isEnglish$91[ebp]
  009fd	85 c0		 test	 eax, eax
  009ff	0f 84 7d 03 00
	00		 je	 $LN68@Update

; 345  : 				{
; 346  : 					for (int e = i + 1; e <= nEnglishBase;) {

  00a05	8b 45 00	 mov	 eax, DWORD PTR _i$90[ebp]
  00a08	40		 inc	 eax
  00a09	89 45 b8	 mov	 DWORD PTR _e$83[ebp], eax
$LN24@Update:
  00a0c	8b 45 b8	 mov	 eax, DWORD PTR _e$83[ebp]
  00a0f	3b 85 48 ff ff
	ff		 cmp	 eax, DWORD PTR _nEnglishBase$57[ebp]
  00a15	0f 8f 67 03 00
	00		 jg	 $LN68@Update

; 347  : 						int ret = GetTextTag(&wArabicText[e], wArabicTextLen - e, len, hyperlinkBuffer);

  00a1b	8d 45 40	 lea	 eax, DWORD PTR _hyperlinkBuffer$94[ebp]
  00a1e	50		 push	 eax
  00a1f	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _len$56[ebp]
  00a25	50		 push	 eax
  00a26	8b 45 94	 mov	 eax, DWORD PTR _wArabicTextLen$74[ebp]
  00a29	2b 45 b8	 sub	 eax, DWORD PTR _e$83[ebp]
  00a2c	50		 push	 eax
  00a2d	8b 45 b8	 mov	 eax, DWORD PTR _e$83[ebp]
  00a30	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  00a33	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00a36	50		 push	 eax
  00a37	e8 00 00 00 00	 call	 ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
  00a3c	83 c4 10	 add	 esp, 16			; 00000010H
  00a3f	89 45 a8	 mov	 DWORD PTR _ret$79[ebp], eax

; 348  : 
; 349  : 						if (ret == TEXT_TAG_PLAIN || ret == TEXT_TAG_TAG)

  00a42	83 7d a8 00	 cmp	 DWORD PTR _ret$79[ebp], 0
  00a46	74 0a		 je	 SHORT $LN71@Update
  00a48	83 7d a8 01	 cmp	 DWORD PTR _ret$79[ebp], 1
  00a4c	0f 85 30 01 00
	00		 jne	 $LN69@Update
$LN71@Update:

; 350  : 						{
; 351  : 							if (hyperlinkStep == 1)

  00a52	83 7d e0 01	 cmp	 DWORD PTR _hyperlinkStep$88[ebp], 1
  00a56	75 1a		 jne	 SHORT $LN72@Update

; 352  : 								hyperlinkBuffer.append(1, wArabicText[e]);

  00a58	8b 45 b8	 mov	 eax, DWORD PTR _e$83[ebp]
  00a5b	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  00a5e	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00a62	50		 push	 eax
  00a63	6a 01		 push	 1
  00a65	8d 4d 40	 lea	 ecx, DWORD PTR _hyperlinkBuffer$94[ebp]
  00a68	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00a6d	e9 0b 01 00 00	 jmp	 $LN73@Update
$LN72@Update:

; 353  : 							else
; 354  : 							{
; 355  : 								int charWidth = __DrawCharacter(pFontTexture, dataCodePage, wArabicText[e], dwColor);

  00a72	ff 75 dc	 push	 DWORD PTR _dwColor$[ebp]
  00a75	8b 45 b8	 mov	 eax, DWORD PTR _e$83[ebp]
  00a78	8b 4d ec	 mov	 ecx, DWORD PTR _wArabicText$89[ebp]
  00a7b	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00a7f	50		 push	 eax
  00a80	ff 75 d4	 push	 DWORD PTR _dataCodePage$[ebp]
  00a83	ff 75 d0	 push	 DWORD PTR _pFontTexture$[ebp]
  00a86	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00a89	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter
  00a8e	89 85 3c ff ff
	ff		 mov	 DWORD PTR _charWidth$54[ebp], eax

; 356  : 								kHyperlink.ex += charWidth;

  00a94	0f bf 45 5a	 movsx	 eax, WORD PTR _kHyperlink$95[ebp+2]
  00a98	03 85 3c ff ff
	ff		 add	 eax, DWORD PTR _charWidth$54[ebp]
  00a9e	66 89 45 5a	 mov	 WORD PTR _kHyperlink$95[ebp+2], ax

; 357  : 
; 358  : 								//    .
; 359  : 								for (int j = 1; j <= no_hyperlink; j++)

  00aa2	c7 45 90 01 00
	00 00		 mov	 DWORD PTR _j$73[ebp], 1
  00aa9	eb 07		 jmp	 SHORT $LN27@Update
$LN25@Update:
  00aab	8b 45 90	 mov	 eax, DWORD PTR _j$73[ebp]
  00aae	40		 inc	 eax
  00aaf	89 45 90	 mov	 DWORD PTR _j$73[ebp], eax
$LN27@Update:
  00ab2	8b 45 90	 mov	 eax, DWORD PTR _j$73[ebp]
  00ab5	3b 45 cc	 cmp	 eax, DWORD PTR _no_hyperlink$87[ebp]
  00ab8	0f 8f bf 00 00
	00		 jg	 $LN73@Update
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00abe	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00ac1	83 c0 64	 add	 eax, 100		; 00000064H
  00ac4	89 85 18 ff ff
	ff		 mov	 DWORD PTR __My_data$45[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00aca	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$45[ebp]
  00ad0	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$45[ebp]
  00ad6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00ad9	2b 01		 sub	 eax, DWORD PTR [ecx]
  00adb	99		 cdq
  00adc	6a 1c		 push	 28			; 0000001cH
  00ade	59		 pop	 ecx
  00adf	f7 f9		 idiv	 ecx
  00ae1	89 85 a8 fe ff
	ff		 mov	 DWORD PTR $T24[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 361  : 									if(m_hyperlinkVector.size() < j)

  00ae7	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR $T24[ebp]
  00aed	3b 45 90	 cmp	 eax, DWORD PTR _j$73[ebp]
  00af0	73 05		 jae	 SHORT $LN74@Update

; 362  : 										break;

  00af2	e9 86 00 00 00	 jmp	 $LN73@Update
$LN74@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00af7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00afa	83 c0 64	 add	 eax, 100		; 00000064H
  00afd	89 85 14 ff ff
	ff		 mov	 DWORD PTR __My_data$44[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00b03	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR __My_data$44[ebp]
  00b09	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$44[ebp]
  00b0f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00b12	2b 01		 sub	 eax, DWORD PTR [ecx]
  00b14	99		 cdq
  00b15	6a 1c		 push	 28			; 0000001cH
  00b17	59		 pop	 ecx
  00b18	f7 f9		 idiv	 ecx
  00b1a	89 85 a4 fe ff
	ff		 mov	 DWORD PTR $T23[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00b20	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00b23	83 c0 64	 add	 eax, 100		; 00000064H
  00b26	89 85 a0 fe ff
	ff		 mov	 DWORD PTR __My_data$22[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 364  : 									SHyperlink & tempLink = m_hyperlinkVector[m_hyperlinkVector.size() - j];

  00b2c	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR $T23[ebp]
  00b32	2b 45 90	 sub	 eax, DWORD PTR _j$73[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  00b35	6b c0 1c	 imul	 eax, eax, 28
  00b38	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$22[ebp]
  00b3e	03 01		 add	 eax, DWORD PTR [ecx]
  00b40	89 85 64 ff ff
	ff		 mov	 DWORD PTR _tempLink$64[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 365  : 									tempLink.ex += charWidth;

  00b46	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _tempLink$64[ebp]
  00b4c	0f bf 40 02	 movsx	 eax, WORD PTR [eax+2]
  00b50	03 85 3c ff ff
	ff		 add	 eax, DWORD PTR _charWidth$54[ebp]
  00b56	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _tempLink$64[ebp]
  00b5c	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 366  : 									tempLink.sx += charWidth;

  00b60	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _tempLink$64[ebp]
  00b66	0f bf 00	 movsx	 eax, WORD PTR [eax]
  00b69	03 85 3c ff ff
	ff		 add	 eax, DWORD PTR _charWidth$54[ebp]
  00b6f	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _tempLink$64[ebp]
  00b75	66 89 01	 mov	 WORD PTR [ecx], ax

; 367  : 								}

  00b78	e9 2e ff ff ff	 jmp	 $LN25@Update
$LN73@Update:

; 368  : 							}
; 369  : 						}

  00b7d	e9 ef 01 00 00	 jmp	 $LN70@Update
$LN69@Update:

; 370  : 						else
; 371  : 						{
; 372  : 							if (ret == TEXT_TAG_COLOR)

  00b82	83 7d a8 02	 cmp	 DWORD PTR _ret$79[ebp], 2
  00b86	0f 85 f0 00 00
	00		 jne	 $LN75@Update

; 373  : 								dwColor = htoi(hyperlinkBuffer.c_str(), 8);

  00b8c	8d 4d 40	 lea	 ecx, DWORD PTR _hyperlinkBuffer$94[ebp]
  00b8f	e8 00 00 00 00	 call	 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
  00b94	89 45 e8	 mov	 DWORD PTR _s$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Utils.h

; 148  :     const wchar_t *t = s;

  00b97	8b 45 e8	 mov	 eax, DWORD PTR _s$[ebp]
  00b9a	89 85 9c fe ff
	ff		 mov	 DWORD PTR _t$21[ebp], eax

; 149  :     int x = 0, y = 1;

  00ba0	83 65 bc 00	 and	 DWORD PTR _x$84[ebp], 0
  00ba4	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR _y$72[ebp], 1

; 150  :     s += size;

  00bab	6a 08		 push	 8
  00bad	58		 pop	 eax
  00bae	d1 e0		 shl	 eax, 1
  00bb0	03 45 e8	 add	 eax, DWORD PTR _s$[ebp]
  00bb3	89 45 e8	 mov	 DWORD PTR _s$[ebp], eax
$LN370@Update:

; 151  : 
; 152  :     while (t <= --s)

  00bb6	8b 45 e8	 mov	 eax, DWORD PTR _s$[ebp]
  00bb9	48		 dec	 eax
  00bba	48		 dec	 eax
  00bbb	89 45 e8	 mov	 DWORD PTR _s$[ebp], eax
  00bbe	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _t$21[ebp]
  00bc4	3b 45 e8	 cmp	 eax, DWORD PTR _s$[ebp]
  00bc7	0f 87 98 00 00
	00		 ja	 $LN371@Update

; 153  :     {
; 154  : 		if (L'0' <= *s && *s <= L'9')

  00bcd	8b 45 e8	 mov	 eax, DWORD PTR _s$[ebp]
  00bd0	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00bd3	83 f8 30	 cmp	 eax, 48			; 00000030H
  00bd6	7c 20		 jl	 SHORT $LN372@Update
  00bd8	8b 45 e8	 mov	 eax, DWORD PTR _s$[ebp]
  00bdb	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00bde	83 f8 39	 cmp	 eax, 57			; 00000039H
  00be1	7f 15		 jg	 SHORT $LN372@Update

; 155  :             x += y * (*s - L'0');

  00be3	8b 45 e8	 mov	 eax, DWORD PTR _s$[ebp]
  00be6	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00be9	83 e8 30	 sub	 eax, 48			; 00000030H
  00bec	0f af 45 8c	 imul	 eax, DWORD PTR _y$72[ebp]
  00bf0	03 45 bc	 add	 eax, DWORD PTR _x$84[ebp]
  00bf3	89 45 bc	 mov	 DWORD PTR _x$84[ebp], eax
  00bf6	eb 5f		 jmp	 SHORT $LN373@Update
$LN372@Update:

; 156  :         else if (L'a' <= *s && *s <= L'f')

  00bf8	8b 45 e8	 mov	 eax, DWORD PTR _s$[ebp]
  00bfb	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00bfe	83 f8 61	 cmp	 eax, 97			; 00000061H
  00c01	7c 20		 jl	 SHORT $LN374@Update
  00c03	8b 45 e8	 mov	 eax, DWORD PTR _s$[ebp]
  00c06	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00c09	83 f8 66	 cmp	 eax, 102		; 00000066H
  00c0c	7f 15		 jg	 SHORT $LN374@Update

; 157  :             x += y * (*s - L'a' + 10);

  00c0e	8b 45 e8	 mov	 eax, DWORD PTR _s$[ebp]
  00c11	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00c14	83 e8 57	 sub	 eax, 87			; 00000057H
  00c17	0f af 45 8c	 imul	 eax, DWORD PTR _y$72[ebp]
  00c1b	03 45 bc	 add	 eax, DWORD PTR _x$84[ebp]
  00c1e	89 45 bc	 mov	 DWORD PTR _x$84[ebp], eax
  00c21	eb 34		 jmp	 SHORT $LN373@Update
$LN374@Update:

; 158  :         else if (L'A' <= *s && *s <= L'F')

  00c23	8b 45 e8	 mov	 eax, DWORD PTR _s$[ebp]
  00c26	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00c29	83 f8 41	 cmp	 eax, 65			; 00000041H
  00c2c	7c 20		 jl	 SHORT $LN376@Update
  00c2e	8b 45 e8	 mov	 eax, DWORD PTR _s$[ebp]
  00c31	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00c34	83 f8 46	 cmp	 eax, 70			; 00000046H
  00c37	7f 15		 jg	 SHORT $LN376@Update

; 159  :             x += y * (10 + *s - L'A');

  00c39	8b 45 e8	 mov	 eax, DWORD PTR _s$[ebp]
  00c3c	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00c3f	83 e8 37	 sub	 eax, 55			; 00000037H
  00c42	0f af 45 8c	 imul	 eax, DWORD PTR _y$72[ebp]
  00c46	03 45 bc	 add	 eax, DWORD PTR _x$84[ebp]
  00c49	89 45 bc	 mov	 DWORD PTR _x$84[ebp], eax
  00c4c	eb 09		 jmp	 SHORT $LN373@Update
$LN376@Update:

; 160  :         else
; 161  :             return -1; /* invalid input! */

  00c4e	83 8d 10 ff ff
	ff ff		 or	 DWORD PTR $T43[ebp], -1
  00c55	eb 17		 jmp	 SHORT $LN369@Update
$LN373@Update:

; 162  :         y <<= 4;

  00c57	8b 45 8c	 mov	 eax, DWORD PTR _y$72[ebp]
  00c5a	c1 e0 04	 shl	 eax, 4
  00c5d	89 45 8c	 mov	 DWORD PTR _y$72[ebp], eax

; 163  :     }

  00c60	e9 51 ff ff ff	 jmp	 $LN370@Update
$LN371@Update:

; 164  : 
; 165  :     return x;

  00c65	8b 45 bc	 mov	 eax, DWORD PTR _x$84[ebp]
  00c68	89 85 10 ff ff
	ff		 mov	 DWORD PTR $T43[ebp], eax
$LN369@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 373  : 								dwColor = htoi(hyperlinkBuffer.c_str(), 8);

  00c6e	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR $T43[ebp]
  00c74	89 45 dc	 mov	 DWORD PTR _dwColor$[ebp], eax
  00c77	e9 f5 00 00 00	 jmp	 $LN70@Update
$LN75@Update:

; 374  : 							else if (ret == TEXT_TAG_RESTORE_COLOR)

  00c7c	83 7d a8 05	 cmp	 DWORD PTR _ret$79[ebp], 5
  00c80	75 0e		 jne	 SHORT $LN77@Update

; 375  : 								dwColor = m_dwTextColor;

  00c82	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00c85	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00c88	89 45 dc	 mov	 DWORD PTR _dwColor$[ebp], eax
  00c8b	e9 e1 00 00 00	 jmp	 $LN70@Update
$LN77@Update:

; 376  : 							else if (ret == TEXT_TAG_HYPERLINK_START)

  00c90	83 7d a8 03	 cmp	 DWORD PTR _ret$79[ebp], 3
  00c94	75 3c		 jne	 SHORT $LN79@Update

; 377  : 							{
; 378  : 								hyperlinkStep = 1;

  00c96	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _hyperlinkStep$88[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 249  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00c9d	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00ca2	e8 00 00 00 00	 call	 _wcslen
  00ca7	59		 pop	 ecx
  00ca8	89 85 98 fe ff
	ff		 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00cae	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR $T20[ebp]
  00cb4	89 85 94 fe ff
	ff		 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00cba	ff b5 94 fe ff
	ff		 push	 DWORD PTR $T19[ebp]
  00cc0	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00cc5	8d 4d 40	 lea	 ecx, DWORD PTR _hyperlinkBuffer$94[ebp]
  00cc8	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 380  : 							}

  00ccd	e9 9f 00 00 00	 jmp	 $LN70@Update
$LN79@Update:

; 381  : 							else if (ret == TEXT_TAG_HYPERLINK_END)

  00cd2	83 7d a8 04	 cmp	 DWORD PTR _ret$79[ebp], 4
  00cd6	0f 85 95 00 00
	00		 jne	 $LN70@Update

; 382  : 							{
; 383  : 								if (hyperlinkStep == 1)

  00cdc	83 7d e0 01	 cmp	 DWORD PTR _hyperlinkStep$88[ebp], 1
  00ce0	75 17		 jne	 SHORT $LN82@Update

; 384  : 								{
; 385  : 									++hyperlinkStep;

  00ce2	8b 45 e0	 mov	 eax, DWORD PTR _hyperlinkStep$88[ebp]
  00ce5	40		 inc	 eax
  00ce6	89 45 e0	 mov	 DWORD PTR _hyperlinkStep$88[ebp], eax

; 386  : 									kHyperlink.ex = kHyperlink.sx = 0; //    

  00ce9	33 c0		 xor	 eax, eax
  00ceb	66 89 45 58	 mov	 WORD PTR _kHyperlink$95[ebp], ax
  00cef	66 8b 45 58	 mov	 ax, WORD PTR _kHyperlink$95[ebp]
  00cf3	66 89 45 5a	 mov	 WORD PTR _kHyperlink$95[ebp+2], ax

; 387  : 								}

  00cf7	eb 78		 jmp	 SHORT $LN70@Update
$LN82@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00cf9	8d 45 40	 lea	 eax, DWORD PTR _hyperlinkBuffer$94[ebp]
  00cfc	89 85 90 fe ff
	ff		 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  00d02	8d 45 5c	 lea	 eax, DWORD PTR _kHyperlink$95[ebp+4]
  00d05	3b 85 90 fe ff
	ff		 cmp	 eax, DWORD PTR $T18[ebp]
  00d0b	74 1a		 je	 SHORT $LN410@Update

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00d0d	33 c0		 xor	 eax, eax
  00d0f	88 85 8c fe ff
	ff		 mov	 BYTE PTR $T17[ebp], al
  00d15	ff b5 8c fe ff
	ff		 push	 DWORD PTR $T17[ebp]
  00d1b	8d 45 40	 lea	 eax, DWORD PTR _hyperlinkBuffer$94[ebp]
  00d1e	50		 push	 eax
  00d1f	8d 4d 5c	 lea	 ecx, DWORD PTR _kHyperlink$95[ebp+4]
  00d22	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy_assign
$LN410@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00d27	8d 45 58	 lea	 eax, DWORD PTR _kHyperlink$95[ebp]
  00d2a	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 391  : 									m_hyperlinkVector.push_back(kHyperlink);

  00d2b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00d2e	83 c1 64	 add	 ecx, 100		; 00000064H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00d31	e8 00 00 00 00	 call	 ??$emplace_back@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXABUSHyperlink@CGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::emplace_back<CGraphicTextInstance::SHyperlink const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 392  : 									no_hyperlink++;

  00d36	8b 45 cc	 mov	 eax, DWORD PTR _no_hyperlink$87[ebp]
  00d39	40		 inc	 eax
  00d3a	89 45 cc	 mov	 DWORD PTR _no_hyperlink$87[ebp], eax

; 393  : 
; 394  : 									hyperlinkStep = 0;

  00d3d	83 65 e0 00	 and	 DWORD PTR _hyperlinkStep$88[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 249  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00d41	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00d46	e8 00 00 00 00	 call	 _wcslen
  00d4b	59		 pop	 ecx
  00d4c	89 85 88 fe ff
	ff		 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00d52	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR $T16[ebp]
  00d58	89 85 84 fe ff
	ff		 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00d5e	ff b5 84 fe ff
	ff		 push	 DWORD PTR $T15[ebp]
  00d64	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00d69	8d 4d 40	 lea	 ecx, DWORD PTR _hyperlinkBuffer$94[ebp]
  00d6c	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN70@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 399  : 						e += len;

  00d71	8b 45 b8	 mov	 eax, DWORD PTR _e$83[ebp]
  00d74	03 85 44 ff ff
	ff		 add	 eax, DWORD PTR _len$56[ebp]
  00d7a	89 45 b8	 mov	 DWORD PTR _e$83[ebp], eax

; 400  : 					}

  00d7d	e9 8a fc ff ff	 jmp	 $LN24@Update
$LN68@Update:

; 403  : 			}

  00d82	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00d86	8d 4d 40	 lea	 ecx, DWORD PTR _hyperlinkBuffer$94[ebp]
  00d89	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 403  : 			}

  00d8e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00d92	8d 4d 5c	 lea	 ecx, DWORD PTR _kHyperlink$95[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00d95	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 403  : 			}

  00d9a	e9 f7 02 00 00	 jmp	 $LN36@Update
$LN37@Update:

; 404  : 			else	//   .
; 405  : 			{
; 406  : 				int x = 0;

  00d9f	83 a5 40 ff ff
	ff 00		 and	 DWORD PTR _x$55[ebp], 0

; 407  : 				int len;				
; 408  : 				int hyperlinkStep = 0;

  00da6	83 65 9c 00	 and	 DWORD PTR _hyperlinkStep$76[ebp], 0

; 409  : 				SHyperlink kHyperlink;

  00daa	8d 4d 0c	 lea	 ecx, DWORD PTR _kHyperlink$92[ebp]
  00dad	e8 00 00 00 00	 call	 ??0SHyperlink@CGraphicTextInstance@@QAE@XZ ; CGraphicTextInstance::SHyperlink::SHyperlink
  00db2	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00db9	8d 45 28	 lea	 eax, DWORD PTR _hyperlinkBuffer$93[ebp]
  00dbc	89 85 4c fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00dc2	8b 8d 4c fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00dc8	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  00dcd	8d 4d 28	 lea	 ecx, DWORD PTR _hyperlinkBuffer$93[ebp]
  00dd0	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 410  : 				std::wstring hyperlinkBuffer;

  00dd5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 411  : 
; 412  : 				for (int i = 0; i < wTextLen; )

  00dd9	83 65 b0 00	 and	 DWORD PTR _i$81[ebp], 0
$LN30@Update:
  00ddd	8b 45 b0	 mov	 eax, DWORD PTR _i$81[ebp]
  00de0	3b 45 a4	 cmp	 eax, DWORD PTR _wTextLen$78[ebp]
  00de3	0f 8d 95 02 00
	00		 jge	 $LN29@Update

; 413  : 				{
; 414  : 					int ret = GetTextTag(&wText[i], wTextLen - i, len, hyperlinkBuffer);

  00de9	8d 45 28	 lea	 eax, DWORD PTR _hyperlinkBuffer$93[ebp]
  00dec	50		 push	 eax
  00ded	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _len$6[ebp]
  00df3	50		 push	 eax
  00df4	8b 45 a4	 mov	 eax, DWORD PTR _wTextLen$78[ebp]
  00df7	2b 45 b0	 sub	 eax, DWORD PTR _i$81[ebp]
  00dfa	50		 push	 eax
  00dfb	8b 45 b0	 mov	 eax, DWORD PTR _i$81[ebp]
  00dfe	8b 4d 88	 mov	 ecx, DWORD PTR _wText$[ebp]
  00e01	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00e04	50		 push	 eax
  00e05	e8 00 00 00 00	 call	 ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
  00e0a	83 c4 10	 add	 esp, 16			; 00000010H
  00e0d	89 45 a0	 mov	 DWORD PTR _ret$77[ebp], eax

; 415  : 
; 416  : 					if (ret == TEXT_TAG_PLAIN || ret == TEXT_TAG_TAG)

  00e10	83 7d a0 00	 cmp	 DWORD PTR _ret$77[ebp], 0
  00e14	74 06		 je	 SHORT $LN86@Update
  00e16	83 7d a0 01	 cmp	 DWORD PTR _ret$77[ebp], 1
  00e1a	75 64		 jne	 SHORT $LN84@Update
$LN86@Update:

; 417  : 					{
; 418  : 						if (hyperlinkStep == 1)

  00e1c	83 7d 9c 01	 cmp	 DWORD PTR _hyperlinkStep$76[ebp], 1
  00e20	75 17		 jne	 SHORT $LN87@Update

; 419  : 							hyperlinkBuffer.append(1, wText[i]);

  00e22	8b 45 b0	 mov	 eax, DWORD PTR _i$81[ebp]
  00e25	8b 4d 88	 mov	 ecx, DWORD PTR _wText$[ebp]
  00e28	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00e2c	50		 push	 eax
  00e2d	6a 01		 push	 1
  00e2f	8d 4d 28	 lea	 ecx, DWORD PTR _hyperlinkBuffer$93[ebp]
  00e32	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
  00e37	eb 42		 jmp	 SHORT $LN88@Update
$LN87@Update:

; 420  : 						else
; 421  : 						{
; 422  : 							int charWidth = __DrawCharacter(pFontTexture, dataCodePage, wText[i], dwColor);

  00e39	ff 75 dc	 push	 DWORD PTR _dwColor$[ebp]
  00e3c	8b 45 b0	 mov	 eax, DWORD PTR _i$81[ebp]
  00e3f	8b 4d 88	 mov	 ecx, DWORD PTR _wText$[ebp]
  00e42	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00e46	50		 push	 eax
  00e47	ff 75 d4	 push	 DWORD PTR _dataCodePage$[ebp]
  00e4a	ff 75 d0	 push	 DWORD PTR _pFontTexture$[ebp]
  00e4d	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00e50	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter
  00e55	89 85 0c ff ff
	ff		 mov	 DWORD PTR _charWidth$42[ebp], eax

; 423  : 							kHyperlink.ex += charWidth;

  00e5b	0f bf 45 0e	 movsx	 eax, WORD PTR _kHyperlink$92[ebp+2]
  00e5f	03 85 0c ff ff
	ff		 add	 eax, DWORD PTR _charWidth$42[ebp]
  00e65	66 89 45 0e	 mov	 WORD PTR _kHyperlink$92[ebp+2], ax

; 424  : 							x += charWidth;

  00e69	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _x$55[ebp]
  00e6f	03 85 0c ff ff
	ff		 add	 eax, DWORD PTR _charWidth$42[ebp]
  00e75	89 85 40 ff ff
	ff		 mov	 DWORD PTR _x$55[ebp], eax
$LN88@Update:

; 425  : 						}
; 426  : 					}

  00e7b	e9 ed 01 00 00	 jmp	 $LN85@Update
$LN84@Update:

; 427  : 					else
; 428  : 					{
; 429  : 						if (ret == TEXT_TAG_COLOR)

  00e80	83 7d a0 02	 cmp	 DWORD PTR _ret$77[ebp], 2
  00e84	0f 85 f0 00 00
	00		 jne	 $LN89@Update

; 430  : 							dwColor = htoi(hyperlinkBuffer.c_str(), 8);

  00e8a	8d 4d 28	 lea	 ecx, DWORD PTR _hyperlinkBuffer$93[ebp]
  00e8d	e8 00 00 00 00	 call	 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
  00e92	89 45 e4	 mov	 DWORD PTR _s$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Utils.h

; 148  :     const wchar_t *t = s;

  00e95	8b 45 e4	 mov	 eax, DWORD PTR _s$[ebp]
  00e98	89 85 7c fe ff
	ff		 mov	 DWORD PTR _t$13[ebp], eax

; 149  :     int x = 0, y = 1;

  00e9e	83 65 b4 00	 and	 DWORD PTR _x$82[ebp], 0
  00ea2	c7 45 84 01 00
	00 00		 mov	 DWORD PTR _y$71[ebp], 1

; 150  :     s += size;

  00ea9	6a 08		 push	 8
  00eab	58		 pop	 eax
  00eac	d1 e0		 shl	 eax, 1
  00eae	03 45 e4	 add	 eax, DWORD PTR _s$[ebp]
  00eb1	89 45 e4	 mov	 DWORD PTR _s$[ebp], eax
$LN610@Update:

; 151  : 
; 152  :     while (t <= --s)

  00eb4	8b 45 e4	 mov	 eax, DWORD PTR _s$[ebp]
  00eb7	48		 dec	 eax
  00eb8	48		 dec	 eax
  00eb9	89 45 e4	 mov	 DWORD PTR _s$[ebp], eax
  00ebc	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR _t$13[ebp]
  00ec2	3b 45 e4	 cmp	 eax, DWORD PTR _s$[ebp]
  00ec5	0f 87 98 00 00
	00		 ja	 $LN611@Update

; 153  :     {
; 154  : 		if (L'0' <= *s && *s <= L'9')

  00ecb	8b 45 e4	 mov	 eax, DWORD PTR _s$[ebp]
  00ece	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00ed1	83 f8 30	 cmp	 eax, 48			; 00000030H
  00ed4	7c 20		 jl	 SHORT $LN612@Update
  00ed6	8b 45 e4	 mov	 eax, DWORD PTR _s$[ebp]
  00ed9	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00edc	83 f8 39	 cmp	 eax, 57			; 00000039H
  00edf	7f 15		 jg	 SHORT $LN612@Update

; 155  :             x += y * (*s - L'0');

  00ee1	8b 45 e4	 mov	 eax, DWORD PTR _s$[ebp]
  00ee4	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00ee7	83 e8 30	 sub	 eax, 48			; 00000030H
  00eea	0f af 45 84	 imul	 eax, DWORD PTR _y$71[ebp]
  00eee	03 45 b4	 add	 eax, DWORD PTR _x$82[ebp]
  00ef1	89 45 b4	 mov	 DWORD PTR _x$82[ebp], eax
  00ef4	eb 5f		 jmp	 SHORT $LN613@Update
$LN612@Update:

; 156  :         else if (L'a' <= *s && *s <= L'f')

  00ef6	8b 45 e4	 mov	 eax, DWORD PTR _s$[ebp]
  00ef9	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00efc	83 f8 61	 cmp	 eax, 97			; 00000061H
  00eff	7c 20		 jl	 SHORT $LN614@Update
  00f01	8b 45 e4	 mov	 eax, DWORD PTR _s$[ebp]
  00f04	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00f07	83 f8 66	 cmp	 eax, 102		; 00000066H
  00f0a	7f 15		 jg	 SHORT $LN614@Update

; 157  :             x += y * (*s - L'a' + 10);

  00f0c	8b 45 e4	 mov	 eax, DWORD PTR _s$[ebp]
  00f0f	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00f12	83 e8 57	 sub	 eax, 87			; 00000057H
  00f15	0f af 45 84	 imul	 eax, DWORD PTR _y$71[ebp]
  00f19	03 45 b4	 add	 eax, DWORD PTR _x$82[ebp]
  00f1c	89 45 b4	 mov	 DWORD PTR _x$82[ebp], eax
  00f1f	eb 34		 jmp	 SHORT $LN613@Update
$LN614@Update:

; 158  :         else if (L'A' <= *s && *s <= L'F')

  00f21	8b 45 e4	 mov	 eax, DWORD PTR _s$[ebp]
  00f24	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00f27	83 f8 41	 cmp	 eax, 65			; 00000041H
  00f2a	7c 20		 jl	 SHORT $LN616@Update
  00f2c	8b 45 e4	 mov	 eax, DWORD PTR _s$[ebp]
  00f2f	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00f32	83 f8 46	 cmp	 eax, 70			; 00000046H
  00f35	7f 15		 jg	 SHORT $LN616@Update

; 159  :             x += y * (10 + *s - L'A');

  00f37	8b 45 e4	 mov	 eax, DWORD PTR _s$[ebp]
  00f3a	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00f3d	83 e8 37	 sub	 eax, 55			; 00000037H
  00f40	0f af 45 84	 imul	 eax, DWORD PTR _y$71[ebp]
  00f44	03 45 b4	 add	 eax, DWORD PTR _x$82[ebp]
  00f47	89 45 b4	 mov	 DWORD PTR _x$82[ebp], eax
  00f4a	eb 09		 jmp	 SHORT $LN613@Update
$LN616@Update:

; 160  :         else
; 161  :             return -1; /* invalid input! */

  00f4c	83 8d 08 ff ff
	ff ff		 or	 DWORD PTR $T41[ebp], -1
  00f53	eb 17		 jmp	 SHORT $LN609@Update
$LN613@Update:

; 162  :         y <<= 4;

  00f55	8b 45 84	 mov	 eax, DWORD PTR _y$71[ebp]
  00f58	c1 e0 04	 shl	 eax, 4
  00f5b	89 45 84	 mov	 DWORD PTR _y$71[ebp], eax

; 163  :     }

  00f5e	e9 51 ff ff ff	 jmp	 $LN610@Update
$LN611@Update:

; 164  : 
; 165  :     return x;

  00f63	8b 45 b4	 mov	 eax, DWORD PTR _x$82[ebp]
  00f66	89 85 08 ff ff
	ff		 mov	 DWORD PTR $T41[ebp], eax
$LN609@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 430  : 							dwColor = htoi(hyperlinkBuffer.c_str(), 8);

  00f6c	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR $T41[ebp]
  00f72	89 45 dc	 mov	 DWORD PTR _dwColor$[ebp], eax
  00f75	e9 f3 00 00 00	 jmp	 $LN85@Update
$LN89@Update:

; 431  : 						else if (ret == TEXT_TAG_RESTORE_COLOR)

  00f7a	83 7d a0 05	 cmp	 DWORD PTR _ret$77[ebp], 5
  00f7e	75 0e		 jne	 SHORT $LN91@Update

; 432  : 							dwColor = m_dwTextColor;

  00f80	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00f83	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00f86	89 45 dc	 mov	 DWORD PTR _dwColor$[ebp], eax
  00f89	e9 df 00 00 00	 jmp	 $LN85@Update
$LN91@Update:

; 433  : 						else if (ret == TEXT_TAG_HYPERLINK_START)

  00f8e	83 7d a0 03	 cmp	 DWORD PTR _ret$77[ebp], 3
  00f92	75 3c		 jne	 SHORT $LN93@Update

; 434  : 						{
; 435  : 							hyperlinkStep = 1;

  00f94	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR _hyperlinkStep$76[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 249  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00f9b	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00fa0	e8 00 00 00 00	 call	 _wcslen
  00fa5	59		 pop	 ecx
  00fa6	89 85 78 fe ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00fac	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  00fb2	89 85 74 fe ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00fb8	ff b5 74 fe ff
	ff		 push	 DWORD PTR $T11[ebp]
  00fbe	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00fc3	8d 4d 28	 lea	 ecx, DWORD PTR _hyperlinkBuffer$93[ebp]
  00fc6	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 437  : 						}

  00fcb	e9 9d 00 00 00	 jmp	 $LN85@Update
$LN93@Update:

; 438  : 						else if (ret == TEXT_TAG_HYPERLINK_END)

  00fd0	83 7d a0 04	 cmp	 DWORD PTR _ret$77[ebp], 4
  00fd4	0f 85 93 00 00
	00		 jne	 $LN85@Update

; 439  : 						{
; 440  : 							if (hyperlinkStep == 1)

  00fda	83 7d 9c 01	 cmp	 DWORD PTR _hyperlinkStep$76[ebp], 1
  00fde	75 1c		 jne	 SHORT $LN96@Update

; 441  : 							{
; 442  : 								++hyperlinkStep;

  00fe0	8b 45 9c	 mov	 eax, DWORD PTR _hyperlinkStep$76[ebp]
  00fe3	40		 inc	 eax
  00fe4	89 45 9c	 mov	 DWORD PTR _hyperlinkStep$76[ebp], eax

; 443  : 								kHyperlink.ex = kHyperlink.sx = x; //    

  00fe7	66 8b 85 40 ff
	ff ff		 mov	 ax, WORD PTR _x$55[ebp]
  00fee	66 89 45 0c	 mov	 WORD PTR _kHyperlink$92[ebp], ax
  00ff2	66 8b 45 0c	 mov	 ax, WORD PTR _kHyperlink$92[ebp]
  00ff6	66 89 45 0e	 mov	 WORD PTR _kHyperlink$92[ebp+2], ax

; 444  : 							}

  00ffa	eb 71		 jmp	 SHORT $LN85@Update
$LN96@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00ffc	8d 45 28	 lea	 eax, DWORD PTR _hyperlinkBuffer$93[ebp]
  00fff	89 85 70 fe ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  01005	8d 45 10	 lea	 eax, DWORD PTR _kHyperlink$92[ebp+4]
  01008	3b 85 70 fe ff
	ff		 cmp	 eax, DWORD PTR $T10[ebp]
  0100e	74 1a		 je	 SHORT $LN650@Update

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  01010	33 c0		 xor	 eax, eax
  01012	88 85 6c fe ff
	ff		 mov	 BYTE PTR $T9[ebp], al
  01018	ff b5 6c fe ff
	ff		 push	 DWORD PTR $T9[ebp]
  0101e	8d 45 28	 lea	 eax, DWORD PTR _hyperlinkBuffer$93[ebp]
  01021	50		 push	 eax
  01022	8d 4d 10	 lea	 ecx, DWORD PTR _kHyperlink$92[ebp+4]
  01025	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy_assign
$LN650@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0102a	8d 45 0c	 lea	 eax, DWORD PTR _kHyperlink$92[ebp]
  0102d	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 448  : 								m_hyperlinkVector.push_back(kHyperlink);

  0102e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  01031	83 c1 64	 add	 ecx, 100		; 00000064H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  01034	e8 00 00 00 00	 call	 ??$emplace_back@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXABUSHyperlink@CGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::emplace_back<CGraphicTextInstance::SHyperlink const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 450  : 								hyperlinkStep = 0;

  01039	83 65 9c 00	 and	 DWORD PTR _hyperlinkStep$76[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 249  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  0103d	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  01042	e8 00 00 00 00	 call	 _wcslen
  01047	59		 pop	 ecx
  01048	89 85 68 fe ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0104e	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  01054	89 85 64 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0105a	ff b5 64 fe ff
	ff		 push	 DWORD PTR $T7[ebp]
  01060	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  01065	8d 4d 28	 lea	 ecx, DWORD PTR _hyperlinkBuffer$93[ebp]
  01068	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN85@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 455  : 					i += len;

  0106d	8b 45 b0	 mov	 eax, DWORD PTR _i$81[ebp]
  01070	03 85 60 fe ff
	ff		 add	 eax, DWORD PTR _len$6[ebp]
  01076	89 45 b0	 mov	 DWORD PTR _i$81[ebp], eax

; 456  : 				}

  01079	e9 5f fd ff ff	 jmp	 $LN30@Update
$LN29@Update:

; 457  : 			}

  0107e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  01082	8d 4d 28	 lea	 ecx, DWORD PTR _hyperlinkBuffer$93[ebp]
  01085	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 457  : 			}

  0108a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0108e	8d 4d 10	 lea	 ecx, DWORD PTR _kHyperlink$92[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  01091	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
$LN36@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 460  : 		if (token < end)

  01096	8b 45 80	 mov	 eax, DWORD PTR _token$70[ebp]
  01099	3b 85 68 ff ff
	ff		 cmp	 eax, DWORD PTR _end$[ebp]
  0109f	73 23		 jae	 SHORT $LN98@Update

; 461  : 		{			
; 462  : 			int newCodePage = ReadToken(token);			

  010a1	ff 75 80	 push	 DWORD PTR _token$70[ebp]
  010a4	e8 00 00 00 00	 call	 ?ReadToken@@YAHPBD@Z	; ReadToken
  010a9	59		 pop	 ecx
  010aa	89 85 5c fe ff
	ff		 mov	 DWORD PTR _newCodePage$5[ebp], eax

; 463  : 			dataCodePage = newCodePage;	//      UTF8    

  010b0	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR _newCodePage$5[ebp]
  010b6	89 45 d4	 mov	 DWORD PTR _dataCodePage$[ebp], eax

; 464  : 			begin = token + 5;			

  010b9	8b 45 80	 mov	 eax, DWORD PTR _token$70[ebp]
  010bc	83 c0 05	 add	 eax, 5
  010bf	89 45 c8	 mov	 DWORD PTR _begin$[ebp], eax

; 465  : 		}

  010c2	eb 06		 jmp	 SHORT $LN99@Update
$LN98@Update:

; 466  : 		else
; 467  : 		{
; 468  : 			begin = token;

  010c4	8b 45 80	 mov	 eax, DWORD PTR _token$70[ebp]
  010c7	89 45 c8	 mov	 DWORD PTR _begin$[ebp], eax
$LN99@Update:

; 469  : 		}
; 470  : 	}

  010ca	e9 d6 f0 ff ff	 jmp	 $LN2@Update
$LN3@Update:

; 471  : 
; 472  : 	pFontTexture->UpdateTexture();

  010cf	8b 4d d0	 mov	 ecx, DWORD PTR _pFontTexture$[ebp]
  010d2	e8 00 00 00 00	 call	 ?UpdateTexture@CGraphicFontTexture@@QAE_NXZ ; CGraphicFontTexture::UpdateTexture

; 473  : 
; 474  : 	m_isUpdate = true;

  010d7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  010da	c6 40 44 01	 mov	 BYTE PTR [eax+68], 1
$LN1@Update:

; 475  : }

  010de	8d a5 44 fe ff
	ff		 lea	 esp, DWORD PTR [ebp-444]
  010e4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  010e7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  010ee	59		 pop	 ecx
  010ef	8b 4d 74	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010f2	33 cd		 xor	 ecx, ebp
  010f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010f9	83 c5 78	 add	 ebp, 120		; 00000078H
  010fc	c9		 leave
  010fd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$0:
  00000	8d 4d 58	 lea	 ecx, DWORD PTR _kHyperlink$95[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1SHyperlink@CGraphicTextInstance@@QAE@XZ
__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$1:
  00008	8d 4d 40	 lea	 ecx, DWORD PTR _hyperlinkBuffer$94[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$2:
  00010	8d 4d 0c	 lea	 ecx, DWORD PTR _kHyperlink$92[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1SHyperlink@CGraphicTextInstance@@QAE@XZ
__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$3:
  00018	8d 4d 28	 lea	 ecx, DWORD PTR _hyperlinkBuffer$93[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
__ehhandler$?Update@CGraphicTextInstance@@QAEXXZ:
  00025	90		 npad	 1
  00026	90		 npad	 1
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 8a 50 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-432]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	8b 8a 80 00 00
	00		 mov	 ecx, DWORD PTR [edx+128]
  00041	33 c8		 xor	 ecx, eax
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Update@CGraphicTextInstance@@QAEXXZ
  0004d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Update@CGraphicTextInstance@@QAEXXZ ENDP		; CGraphicTextInstance::Update
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?Destroy@CGraphicTextInstance@@QAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?Destroy@CGraphicTextInstance@@QAEXXZ PROC		; CGraphicTextInstance::Destroy, COMDAT
; _this$ = ecx

; 1133 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0000e	e8 00 00 00 00	 call	 _strlen
  00013	59		 pop	 ecx
  00014	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00017	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001a	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001d	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1134 : 	m_stText="";

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	83 c1 20	 add	 ecx, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1135 : 	m_pCharInfoVector.clear();

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00036	e8 00 00 00 00	 call	 ?clear@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAEXXZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::clear

; 1136 : 	m_dwColorInfoVector.clear();

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	83 c1 58	 add	 ecx, 88			; 00000058H
  00041	e8 00 00 00 00	 call	 ?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::clear

; 1137 : 	m_hyperlinkVector.clear();

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 64	 add	 ecx, 100		; 00000064H
  0004c	e8 00 00 00 00	 call	 ?clear@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::clear

; 1138 : 
; 1139 : 	__Initialize();

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?__Initialize@CGraphicTextInstance@@IAEXXZ ; CGraphicTextInstance::__Initialize

; 1140 : }

  00059	c9		 leave
  0005a	c3		 ret	 0
?Destroy@CGraphicTextInstance@@QAEXXZ ENDP		; CGraphicTextInstance::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ??1CGraphicTextInstance@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CGraphicTextInstance@@UAE@XZ PROC			; CGraphicTextInstance::~CGraphicTextInstance, COMDAT
; _this$ = ecx

; 1148 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGraphicTextInstance@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGraphicTextInstance@@6B@

; 1149 : 	Destroy();

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?Destroy@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Destroy

; 1150 : }

  00038	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 64	 add	 ecx, 100		; 00000064H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003e	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1150 : }

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 58	 add	 ecx, 88			; 00000058H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00049	e8 00 00 00 00	 call	 ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1150 : }

  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	83 c1 4c	 add	 ecx, 76			; 0000004cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00054	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEXXZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1150 : }

  00059	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 c0 48	 add	 eax, 72			; 00000048H
  0005f	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 37   : 		{

  00062	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 53   : 			if (m_pObject)

  00066	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00069	83 38 00	 cmp	 DWORD PTR [eax], 0
  0006c	74 10		 je	 SHORT $LN81@CGraphicTe

; 54   : 			{
; 55   : 				m_pObject->Release();

  0006e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	83 20 00	 and	 DWORD PTR [eax], 0
$LN81@CGraphicTe:

; 39   : 		}

  0007e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1150 : }

  00082	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	83 c1 20	 add	 ecx, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00088	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1150 : }

  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	c9		 leave
  00099	c3		 ret	 0
  0009a	cc		 int	 3
  0009b	cc		 int	 3
  0009c	cc		 int	 3
  0009d	cc		 int	 3
  0009e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CGraphicTextInstance@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CGraphicTextInstance@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CGraphicTextInstance@@UAE@XZ ENDP			; CGraphicTextInstance::~CGraphicTextInstance
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ??0CGraphicTextInstance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -64						; size = 4
_this$ = -60						; size = 4
_this$ = -56						; size = 4
_this$ = -52						; size = 4
_this$ = -48						; size = 4
_this$ = -44						; size = 4
_this$ = -40						; size = 4
_this$ = -36						; size = 4
_this$ = -32						; size = 4
_this$2 = -28						; size = 4
_this$3 = -24						; size = 4
_this$4 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CGraphicTextInstance@@QAE@XZ PROC			; CGraphicTextInstance::CGraphicTextInstance, COMDAT
; _this$ = ecx

; 1143 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CGraphicTextInstance@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGraphicTextInstance@@6B@
  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 c0 20	 add	 eax, 32			; 00000020H
  00037	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0003a	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00040	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  00048	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1143 : {

  00050	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00054	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00057	83 c0 48	 add	 eax, 72			; 00000048H
  0005a	89 45 d8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 20   : 		CRef() : m_pObject(NULL)

  0005d	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00060	83 20 00	 and	 DWORD PTR [eax], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1143 : {

  00063	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00067	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	83 c0 4c	 add	 eax, 76			; 0000004cH
  0006d	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00070	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00076	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00079	89 45 ec	 mov	 DWORD PTR _this$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0007c	8b 45 ec	 mov	 eax, DWORD PTR _this$4[ebp]
  0007f	83 20 00	 and	 DWORD PTR [eax], 0
  00082	8b 45 ec	 mov	 eax, DWORD PTR _this$4[ebp]
  00085	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00089	8b 45 ec	 mov	 eax, DWORD PTR _this$4[ebp]
  0008c	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1143 : {

  00090	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00094	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00097	83 c0 58	 add	 eax, 88			; 00000058H
  0009a	89 45 cc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0009d	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	89 45 c8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000a3	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	89 45 e8	 mov	 DWORD PTR _this$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000a9	8b 45 e8	 mov	 eax, DWORD PTR _this$3[ebp]
  000ac	83 20 00	 and	 DWORD PTR [eax], 0
  000af	8b 45 e8	 mov	 eax, DWORD PTR _this$3[ebp]
  000b2	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  000b6	8b 45 e8	 mov	 eax, DWORD PTR _this$3[ebp]
  000b9	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1143 : {

  000bd	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000c1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	83 c0 64	 add	 eax, 100		; 00000064H
  000c7	89 45 c4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  000ca	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	89 45 c0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000d0	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	89 45 e4	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000d6	8b 45 e4	 mov	 eax, DWORD PTR _this$2[ebp]
  000d9	83 20 00	 and	 DWORD PTR [eax], 0
  000dc	8b 45 e4	 mov	 eax, DWORD PTR _this$2[ebp]
  000df	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  000e3	8b 45 e4	 mov	 eax, DWORD PTR _this$2[ebp]
  000e6	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 1143 : {

  000ea	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 1144 : 	__Initialize();

  000ee	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	e8 00 00 00 00	 call	 ?__Initialize@CGraphicTextInstance@@IAEXXZ ; CGraphicTextInstance::__Initialize

; 1145 : }

  000f6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000fa	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00100	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00107	59		 pop	 ecx
  00108	c9		 leave
  00109	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 20	 add	 ecx, 32			; 00000020H
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 48	 add	 ecx, 72			; 00000048H
  00011	e9 00 00 00 00	 jmp	 ??1?$CRef@VCGraphicText@@@@QAE@XZ ; CRef<CGraphicText>::~CRef<CGraphicText>
__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAE@XZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::~vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 58	 add	 ecx, 88			; 00000058H
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$4:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 64	 add	 ecx, 100		; 00000064H
  00032	e9 00 00 00 00	 jmp	 ??1?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::~vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >
  00037	cc		 int	 3
  00038	cc		 int	 3
  00039	cc		 int	 3
  0003a	cc		 int	 3
  0003b	cc		 int	 3
__ehhandler$??0CGraphicTextInstance@@QAE@XZ:
  0003c	90		 npad	 1
  0003d	90		 npad	 1
  0003e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00042	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00045	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00048	33 c8		 xor	 ecx, eax
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CGraphicTextInstance@@QAE@XZ
  00054	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CGraphicTextInstance@@QAE@XZ ENDP			; CGraphicTextInstance::CGraphicTextInstance
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?Hyperlink_GetText@CGraphicTextInstance@@SAHPADH@Z
_TEXT	SEGMENT
_codePage$ = -20					; size = 4
$T1 = -16						; size = 4
$T2 = -12						; size = 4
tv85 = -8						; size = 4
$T3 = -1						; size = 1
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
?Hyperlink_GetText@CGraphicTextInstance@@SAHPADH@Z PROC	; CGraphicTextInstance::Hyperlink_GetText, COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  00006	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+16
  0000b	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax

; 3848 :         return size() == 0;

  0000e	83 7d f4 00	 cmp	 DWORD PTR $T2[ebp], 0
  00012	75 09		 jne	 SHORT $LN6@Hyperlink_
  00014	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv85[ebp], 1
  0001b	eb 04		 jmp	 SHORT $LN7@Hyperlink_
$LN6@Hyperlink_:
  0001d	83 65 f8 00	 and	 DWORD PTR tv85[ebp], 0
$LN7@Hyperlink_:
  00021	8a 45 f8	 mov	 al, BYTE PTR tv85[ebp]
  00024	88 45 ff	 mov	 BYTE PTR $T3[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 30   : 	if (gs_hyperlinkText.empty())

  00027	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  0002b	85 c0		 test	 eax, eax
  0002d	74 04		 je	 SHORT $LN2@Hyperlink_

; 31   : 		return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 35		 jmp	 SHORT $LN1@Hyperlink_
$LN2@Hyperlink_:

; 32   : 
; 33   : 	int codePage = GetDefaultCodePage();

  00033	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  00038	89 45 ec	 mov	 DWORD PTR _codePage$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  0003b	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+16
  00040	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 35   : 	return Ymir_WideCharToMultiByte(codePage, 0, gs_hyperlinkText.c_str(), gs_hyperlinkText.length(), buf, len, NULL, NULL);	

  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  0004a	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  0004d	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00050	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  00055	e8 00 00 00 00	 call	 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
  0005a	50		 push	 eax
  0005b	6a 00		 push	 0
  0005d	ff 75 ec	 push	 DWORD PTR _codePage$[ebp]
  00060	e8 00 00 00 00	 call	 ?Ymir_WideCharToMultiByte@@YAHIKPB_WHPADHPBDPAH@Z ; Ymir_WideCharToMultiByte
  00065	83 c4 20	 add	 esp, 32			; 00000020H
$LN1@Hyperlink_:

; 36   : }

  00068	c9		 leave
  00069	c3		 ret	 0
?Hyperlink_GetText@CGraphicTextInstance@@SAHPADH@Z ENDP	; CGraphicTextInstance::Hyperlink_GetText
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?Hyperlink_UpdateMousePos@CGraphicTextInstance@@SAXHH@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?Hyperlink_UpdateMousePos@CGraphicTextInstance@@SAXHH@Z PROC ; CGraphicTextInstance::Hyperlink_UpdateMousePos, COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 23   : 	gs_mx = x;

  00005	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?gs_mx@@3HA, eax

; 24   : 	gs_my = y;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00010	a3 00 00 00 00	 mov	 DWORD PTR ?gs_my@@3HA, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 249  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  0001a	e8 00 00 00 00	 call	 _wcslen
  0001f	59		 pop	 ecx
  00020	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00023	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00029	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00031	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  00036	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpTextInstance.cpp

; 26   : }

  0003b	c9		 leave
  0003c	c3		 ret	 0
?Hyperlink_UpdateMousePos@CGraphicTextInstance@@SAXHH@Z ENDP ; CGraphicTextInstance::Hyperlink_UpdateMousePos
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z
_TEXT	SEGMENT
__Max_possible$1 = -56					; size = 4
__Al$ = -52						; size = 4
__Ptr$ = -48						; size = 4
__Ptr$ = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
__Old_capacity$ = -28					; size = 4
$T5 = -24						; size = 4
__New_capacity$ = -20					; size = 4
__Count$ = -16						; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
$T6 = -4						; size = 2
__Overflow_is_possible$7 = -1				; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e4	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
  0002f	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  0003b	89 45 cc	 mov	 DWORD PTR __Al$[ebp], eax

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0003e	8b 45 ec	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00041	40		 inc	 eax
  00042	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00045	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$7[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00049	c7 45 c8 ff ff
	ff 7f		 mov	 DWORD PTR __Max_possible$1[ebp], 2147483647 ; 7fffffffH

; 60   :         if (_Count > _Max_possible) {

  00050	81 7d f0 ff ff
	ff 7f		 cmp	 DWORD PTR __Count$[ebp], 2147483647 ; 7fffffffH
  00057	76 05		 jbe	 SHORT $LN78@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00059	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN78@Reallocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00061	d1 e0		 shl	 eax, 1
  00063	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00066	ff 75 dc	 push	 DWORD PTR $T3[ebp]
  00069	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0006e	59		 pop	 ecx
  0006f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00072	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00075	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00078	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007e	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 4d ec	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00087	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  0008a	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008d	89 45 d4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00090	8b 45 d4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00093	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00096	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00099	d1 e0		 shl	 eax, 1
  0009b	50		 push	 eax
  0009c	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  0009f	ff 75 e8	 push	 DWORD PTR $T5[ebp]
  000a2	e8 00 00 00 00	 call	 _memcpy
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000aa	33 c0		 xor	 eax, eax
  000ac	66 89 45 fc	 mov	 WORD PTR $T6[ebp], ax

; 281  :         _Left = _Right;

  000b0	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  000b3	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp]
  000b6	66 8b 55 fc	 mov	 dx, WORD PTR $T6[ebp]
  000ba	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  000be	83 7d e4 08	 cmp	 DWORD PTR __Old_capacity$[ebp], 8
  000c2	72 24		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	8b 00		 mov	 eax, DWORD PTR [eax]
  000c9	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000cc	8b 45 e4	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000cf	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  000d3	50		 push	 eax
  000d4	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  000d7	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000dc	59		 pop	 ecx
  000dd	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000de	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000e4	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000e6	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000e8	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000eb	50		 push	 eax
  000ec	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000ef	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  000f4	59		 pop	 ecx
  000f5	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN81@Reallocate:

; 4325 :     }

  000f9	c9		 leave
  000fa	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z PROC		; std::_Destroy_in_place<wchar_t *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ENDP		; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -4						; size = 2
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 37		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ; std::_Destroy_in_place<wchar_t *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	8b 45 ec	 mov	 eax, DWORD PTR __Count$[ebp]
  00057	d1 e0		 shl	 eax, 1
  00059	50		 push	 eax
  0005a	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00062	59		 pop	 ecx
  00063	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00075	33 c0		 xor	 eax, eax
  00077	66 89 45 fc	 mov	 WORD PTR $T4[ebp], ax
  0007b	6a 02		 push	 2
  0007d	58		 pop	 eax
  0007e	6b c0 00	 imul	 eax, eax, 0

; 281  :         _Left = _Right;

  00081	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	66 8b 55 fc	 mov	 dx, WORD PTR $T4[ebp]
  00088	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx

; 4396 :     }

  0008c	c9		 leave
  0008d	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 2
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	33 c0		 xor	 eax, eax
  0001b	66 89 45 fe	 mov	 WORD PTR $T1[ebp], ax
  0001f	6a 02		 push	 2
  00021	58		 pop	 eax
  00022	6b c0 00	 imul	 eax, eax, 0

; 281  :         _Left = _Right;

  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	66 8b 55 fe	 mov	 dx, WORD PTR $T1[ebp]
  0002c	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx

; 4381 :     }

  00030	c9		 leave
  00031	c3		 ret	 0
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 07	 or	 eax, 7
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv75 = -12						; size = 4
$T3 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 4284 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 07	 or	 eax, 7
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  00012	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4287 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 46		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0001f	d1 e8		 shr	 eax, 1
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4291 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 32		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003e	3b 45 f8	 cmp	 eax, DWORD PTR $T3[ebp]
  00041	73 08		 jae	 SHORT $LN7@Calculate_
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00046	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00049	eb 06		 jmp	 SHORT $LN8@Calculate_
$LN7@Calculate_:
  0004b	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  0004e	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
$LN8@Calculate_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00057	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4295 :     }

  00062	c9		 leave
  00063	c3		 ret	 0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR __Alloc_max$[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  0001c	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR $T10[ebp], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00023	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00026	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00029	73 08		 jae	 SHORT $LN14@max_size
  0002b	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002e	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  00031	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00033	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00036	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00039	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  0003c	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003f	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  00042	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00045	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004d	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  00050	48		 dec	 eax
  00051	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00054	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0005b	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005e	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00061	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00064	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00067	73 08		 jae	 SHORT $LN22@max_size
  00069	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  0006c	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006f	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  00071	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00074	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00077	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  0007a	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007d	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  00080	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00083	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00086	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00088	c9		 leave
  00089	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -2						; size = 2
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 41		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0002b	d1 e0		 shl	 eax, 1
  0002d	50		 push	 eax
  0002e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00031	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00034	e8 00 00 00 00	 call	 _memmove
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0003c	33 c0		 xor	 eax, eax
  0003e	66 89 45 fe	 mov	 WORD PTR $T3[ebp], ax

; 281  :         _Left = _Right;

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00045	8b 4d f4	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  00048	66 8b 55 fe	 mov	 dx, WORD PTR $T3[ebp]
  0004c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 3049 :             return *this;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  00055	33 c0		 xor	 eax, eax
  00057	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  0005a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0005d	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00060	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  0006b	c9		 leave
  0006c	c2 08 00	 ret	 8
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z
_TEXT	SEGMENT
$T1 = -32						; size = 1
__First$ = -28						; size = 4
__Old_ptr$2 = -24					; size = 4
__Su$3 = -20						; size = 4
__N$ = -16						; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 2
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 2
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 2961 :     basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // append _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2962 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 2963 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 08	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 6e		 ja	 SHORT $LN2@append

; 2964 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00023	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2965 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  00034	89 45 e8	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 2966 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  00037	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0003a	8b 4d e8	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  0003d	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00040	89 45 e4	 mov	 DWORD PTR __First$[ebp], eax

; 277  :         return reinterpret_cast<_Elem*>(_CSTD wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));

  00043	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00046	89 45 f0	 mov	 DWORD PTR __N$[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 258  :         wchar_t *_Su = _S;

  00049	8b 45 e4	 mov	 eax, DWORD PTR __First$[ebp]
  0004c	89 45 ec	 mov	 DWORD PTR __Su$3[ebp], eax

; 259  :         for (; 0 < _N; ++_Su, --_N)

  0004f	eb 0f		 jmp	 SHORT $LN22@append
$LN20@append:
  00051	8b 45 ec	 mov	 eax, DWORD PTR __Su$3[ebp]
  00054	40		 inc	 eax
  00055	40		 inc	 eax
  00056	89 45 ec	 mov	 DWORD PTR __Su$3[ebp], eax
  00059	8b 45 f0	 mov	 eax, DWORD PTR __N$[ebp]
  0005c	48		 dec	 eax
  0005d	89 45 f0	 mov	 DWORD PTR __N$[ebp], eax
$LN22@append:
  00060	83 7d f0 00	 cmp	 DWORD PTR __N$[ebp], 0
  00064	76 0c		 jbe	 SHORT $LN17@append

; 260  :         {
; 261  :             *_Su = _C;

  00066	8b 45 ec	 mov	 eax, DWORD PTR __Su$3[ebp]
  00069	66 8b 4d 0c	 mov	 cx, WORD PTR __Ch$[ebp]
  0006d	66 89 08	 mov	 WORD PTR [eax], cx

; 262  :         }

  00070	eb df		 jmp	 SHORT $LN20@append
$LN17@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2967 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00072	33 c0		 xor	 eax, eax
  00074	66 89 45 fe	 mov	 WORD PTR $T4[ebp], ax
  00078	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0007b	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]

; 281  :         _Left = _Right;

  0007e	8b 4d e8	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  00081	66 8b 55 fe	 mov	 dx, WORD PTR $T4[ebp]
  00085	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 2968 :             return *this;

  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	eb 19		 jmp	 SHORT $LN1@append
$LN2@append:

; 2969 :         }
; 2970 : 
; 2971 :         return _Reallocate_grow_by(

  0008e	33 c0		 xor	 eax, eax
  00090	88 45 e0	 mov	 BYTE PTR $T1[ebp], al
  00093	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00096	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00099	ff 75 e0	 push	 DWORD PTR $T1[ebp]
  0009c	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0009f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>
$LN1@append:

; 2972 :             _Count,
; 2973 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 2974 :                 const _Elem _Ch) {
; 2975 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2976 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2977 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2978 :             },
; 2979 :             _Count, _Ch);
; 2980 :     }

  000a7	c9		 leave
  000a8	c2 08 00	 ret	 8
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Copy_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
__Ptr$ = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
__Result$6 = -16					; size = 4
tv134 = -12						; size = 4
_this$ = -8						; size = 4
$T7 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy_assign, COMDAT
; _this$ = ecx

; 2826 :     void _Copy_assign(const basic_string& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0001b	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0001e	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2827 :         _Pocca(_Getal(), _Right._Getal());

  00021	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00024	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@ABV10@@Z ; std::_Pocca<std::allocator<wchar_t> >
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00041	72 09		 jb	 SHORT $LN21@Copy_assig
  00043	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv134[ebp], 1
  0004a	eb 04		 jmp	 SHORT $LN22@Copy_assig
$LN21@Copy_assig:
  0004c	83 65 f4 00	 and	 DWORD PTR tv134[ebp], 0
$LN22@Copy_assig:
  00050	8a 45 f4	 mov	 al, BYTE PTR tv134[ebp]
  00053	88 45 ff	 mov	 BYTE PTR $T7[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00056	0f b6 45 ff	 movzx	 eax, BYTE PTR $T7[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	74 0e		 je	 SHORT $LN16@Copy_assig

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00066	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00069	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax
$LN16@Copy_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR __Result$6[ebp]
  0006f	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00072	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00075	ff 70 10	 push	 DWORD PTR [eax+16]
  00078	ff 75 d4	 push	 DWORD PTR $T1[ebp]
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 2829 :     }

  00083	c9		 leave
  00084	c2 08 00	 ret	 8
?_Copy_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Max_possible$1 = -88					; size = 4
__Al$ = -84						; size = 4
$T2 = -80						; size = 4
__Ptr$ = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
$T6 = -60						; size = 4
$T7 = -56						; size = 4
__First1$ = -52						; size = 4
__New_capacity$ = -48					; size = 4
__Right_ptr$ = -44					; size = 4
__New_array$ = -40					; size = 4
__Count$ = -36						; size = 4
tv144 = -32						; size = 4
$T8 = -28						; size = 4
$T9 = -24						; size = 4
__Right_data$ = -20					; size = 4
_this$ = -16						; size = 4
__Right_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$10 = -1				; size = 1
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2728 :     void _Construct_lv_contents(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2729 :         // assign by copying data stored in _Right
; 2730 :         // pre: this != &_Right
; 2731 :         // pre: *this owns no memory, iterators orphaned (note:
; 2732 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2733 :         auto& _Right_data             = _Right._Mypair._Myval2;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __Right_data$[ebp], eax

; 2734 :         const size_type _Right_size   = _Right_data._Mysize;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax

; 2735 :         const _Elem* const _Right_ptr = _Right_data._Myptr();

  00018	8b 4d ec	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  00020	89 45 d4	 mov	 DWORD PTR __Right_ptr$[ebp], eax

; 2736 :         auto& _My_data                = _Mypair._Myval2;

  00023	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2737 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00029	83 7d f4 08	 cmp	 DWORD PTR __Right_size$[ebp], 8
  0002d	73 32		 jae	 SHORT $LN2@Construct_

; 2738 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00032	89 45 cc	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00035	6a 08		 push	 8
  00037	58		 pop	 eax
  00038	d1 e0		 shl	 eax, 1
  0003a	50		 push	 eax
  0003b	ff 75 d4	 push	 DWORD PTR __Right_ptr$[ebp]
  0003e	ff 75 cc	 push	 DWORD PTR __First1$[ebp]
  00041	e8 00 00 00 00	 call	 _memcpy
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2739 :             _My_data._Mysize = _Right_size;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  0004f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2740 :             _My_data._Myres  = _BUF_SIZE - 1;

  00052	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00055	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7

; 2741 :             return;

  0005c	e9 c6 00 00 00	 jmp	 $LN61@Construct_
$LN2@Construct_:

; 4409 :         return _Mypair._Get_first();

  00061	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00064	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00067	8b 45 c8	 mov	 eax, DWORD PTR $T7[ebp]
  0006a	89 45 ac	 mov	 DWORD PTR __Al$[ebp], eax

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0006d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00075	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
  00078	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  0007b	83 c8 07	 or	 eax, 7
  0007e	89 45 e4	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00081	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  00084	3b 45 e4	 cmp	 eax, DWORD PTR $T8[ebp]
  00087	73 08		 jae	 SHORT $LN52@Construct_
  00089	8d 45 e8	 lea	 eax, DWORD PTR $T9[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR tv144[ebp], eax
  0008f	eb 06		 jmp	 SHORT $LN53@Construct_
$LN52@Construct_:
  00091	8d 45 e4	 lea	 eax, DWORD PTR $T8[ebp]
  00094	89 45 e0	 mov	 DWORD PTR tv144[ebp], eax
$LN53@Construct_:
  00097	8b 45 e0	 mov	 eax, DWORD PTR tv144[ebp]
  0009a	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
  0009d	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000a0	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  000a3	8b 45 c0	 mov	 eax, DWORD PTR $T5[ebp]
  000a6	8b 00		 mov	 eax, DWORD PTR [eax]
  000a8	89 45 d0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000ab	8b 45 d0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  000ae	40		 inc	 eax
  000af	89 45 dc	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000b2	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$10[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000b6	c7 45 a8 ff ff
	ff 7f		 mov	 DWORD PTR __Max_possible$1[ebp], 2147483647 ; 7fffffffH

; 60   :         if (_Count > _Max_possible) {

  000bd	81 7d dc ff ff
	ff 7f		 cmp	 DWORD PTR __Count$[ebp], 2147483647 ; 7fffffffH
  000c4	76 05		 jbe	 SHORT $LN58@Construct_

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000c6	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN58@Construct_:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000cb	8b 45 dc	 mov	 eax, DWORD PTR __Count$[ebp]
  000ce	d1 e0		 shl	 eax, 1
  000d0	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000d3	ff 75 bc	 push	 DWORD PTR $T4[ebp]
  000d6	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000db	59		 pop	 ecx
  000dc	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000df	8b 45 b8	 mov	 eax, DWORD PTR $T3[ebp]
  000e2	89 45 d8	 mov	 DWORD PTR __New_array$[ebp], eax

; 2747 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  000e5	8d 45 d8	 lea	 eax, DWORD PTR __New_array$[ebp]
  000e8	50		 push	 eax
  000e9	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  000ec	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  000f1	59		 pop	 ecx
  000f2	59		 pop	 ecx

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000f3	8b 45 d8	 mov	 eax, DWORD PTR __New_array$[ebp]
  000f6	89 45 b4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f9	8b 45 b4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000fc	89 45 b0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ff	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00102	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00106	50		 push	 eax
  00107	ff 75 d4	 push	 DWORD PTR __Right_ptr$[ebp]
  0010a	ff 75 b0	 push	 DWORD PTR $T2[ebp]
  0010d	e8 00 00 00 00	 call	 _memcpy
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2749 :         _My_data._Mysize = _Right_size;

  00115	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00118	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  0011b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2750 :         _My_data._Myres  = _New_capacity;

  0011e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00121	8b 4d d0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00124	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN61@Construct_:

; 2751 :     }

  00127	c9		 leave
  00128	c2 04 00	 ret	 4
?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
__My_data_mem$2 = -36					; size = 4
__Right_data_mem$3 = -32				; size = 4
_this$ = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T6 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4409 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00015	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00035	33 c0		 xor	 eax, eax
  00037	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
  0003a	8a 45 ff	 mov	 al, BYTE PTR $T6[ebp]
  0003d	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00040	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 dc	 mov	 DWORD PTR __My_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00046	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00049	89 45 e0	 mov	 DWORD PTR __Right_data_mem$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004c	6a 18		 push	 24			; 00000018H
  0004e	ff 75 e0	 push	 DWORD PTR __Right_data_mem$3[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __My_data_mem$2[ebp]
  00054	e8 00 00 00 00	 call	 _memcpy
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init

; 2499 :     }

  00064	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c9		 leave
  00068	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
_this$ = -32						; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S12$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00031	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00034	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003a	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00040	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00047	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  0004e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00052	8d 45 f3	 lea	 eax, DWORD PTR _$S12$[ebp]
  00055	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);

  00058	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents

; 2355 :         _Proxy._Release();
; 2356 :     }

  00063	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	c9		 leave
  00076	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 14 00	 and	 DWORD PTR [eax+20], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c9		 leave
  00019	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z
_TEXT	SEGMENT
$T1 = -64						; size = 4
__Count$ = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Ptr$ = -44						; size = 4
__Ans$5 = -40						; size = 4
tv132 = -36						; size = 4
_this$ = -32						; size = 4
__Result$6 = -28					; size = 4
tv91 = -24						; size = 4
_this$ = -20						; size = 4
$T7 = -16						; size = 4
__Right_size$ = -12					; size = 4
__Left_size$ = -8					; size = 4
$T8 = -1						; size = 1
__Ptr$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 4233 :     _NODISCARD int compare(_In_z_ const _Elem* const _Ptr) const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000c	e8 00 00 00 00	 call	 _strlen
  00011	59		 pop	 ecx
  00012	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax

; 4234 :         // compare [0, size()) with [_Ptr, <null>)
; 4235 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00015	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0001b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 e4	 mov	 DWORD PTR __Result$6[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00028	72 09		 jb	 SHORT $LN12@compare
  0002a	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  00031	eb 04		 jmp	 SHORT $LN13@compare
$LN12@compare:
  00033	83 65 e8 00	 and	 DWORD PTR tv91[ebp], 0
$LN13@compare:
  00037	8a 45 e8	 mov	 al, BYTE PTR tv91[ebp]
  0003a	88 45 ff	 mov	 BYTE PTR $T8[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0003d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  00041	85 c0		 test	 eax, eax
  00043	74 0e		 je	 SHORT $LN7@compare

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00045	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 d4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004d	8b 45 d4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00050	89 45 e4	 mov	 DWORD PTR __Result$6[ebp], eax
$LN7@compare:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00053	8b 45 e4	 mov	 eax, DWORD PTR __Result$6[ebp]
  00056	89 45 c0	 mov	 DWORD PTR $T1[ebp], eax

; 4234 :         // compare [0, size()) with [_Ptr, <null>)
; 4235 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00059	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005c	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax
  0005f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00065	89 45 f8	 mov	 DWORD PTR __Left_size$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00068	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  0006b	3b 45 f8	 cmp	 eax, DWORD PTR __Left_size$[ebp]
  0006e	73 08		 jae	 SHORT $LN26@compare
  00070	8d 45 f4	 lea	 eax, DWORD PTR __Right_size$[ebp]
  00073	89 45 dc	 mov	 DWORD PTR tv132[ebp], eax
  00076	eb 06		 jmp	 SHORT $LN27@compare
$LN26@compare:
  00078	8d 45 f8	 lea	 eax, DWORD PTR __Left_size$[ebp]
  0007b	89 45 dc	 mov	 DWORD PTR tv132[ebp], eax
$LN27@compare:
  0007e	8b 45 dc	 mov	 eax, DWORD PTR tv132[ebp]
  00081	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  00084	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  00087	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 568  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  0008a	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  0008d	8b 00		 mov	 eax, DWORD PTR [eax]
  0008f	89 45 c4	 mov	 DWORD PTR __Count$[ebp], eax

; 369  :         return _CSTD memcmp(_First1, _First2, _Count);

  00092	ff 75 c4	 push	 DWORD PTR __Count$[ebp]
  00095	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00098	ff 75 c0	 push	 DWORD PTR $T1[ebp]
  0009b	e8 00 00 00 00	 call	 _memcmp
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	89 45 d8	 mov	 DWORD PTR __Ans$5[ebp], eax

; 570  :     if (_Ans != 0) {

  000a6	83 7d d8 00	 cmp	 DWORD PTR __Ans$5[ebp], 0
  000aa	74 08		 je	 SHORT $LN19@compare

; 571  :         return _Ans;

  000ac	8b 45 d8	 mov	 eax, DWORD PTR __Ans$5[ebp]
  000af	89 45 f0	 mov	 DWORD PTR $T7[ebp], eax
  000b2	eb 23		 jmp	 SHORT $LN22@compare
$LN19@compare:

; 572  :     }
; 573  : 
; 574  :     if (_Left_size < _Right_size) {

  000b4	8b 45 f8	 mov	 eax, DWORD PTR __Left_size$[ebp]
  000b7	3b 45 f4	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  000ba	73 06		 jae	 SHORT $LN20@compare

; 575  :         return -1;

  000bc	83 4d f0 ff	 or	 DWORD PTR $T7[ebp], -1
  000c0	eb 15		 jmp	 SHORT $LN22@compare
$LN20@compare:

; 576  :     }
; 577  : 
; 578  :     if (_Left_size > _Right_size) {

  000c2	8b 45 f8	 mov	 eax, DWORD PTR __Left_size$[ebp]
  000c5	3b 45 f4	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  000c8	76 09		 jbe	 SHORT $LN21@compare

; 579  :         return 1;

  000ca	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T7[ebp], 1
  000d1	eb 04		 jmp	 SHORT $LN22@compare
$LN21@compare:

; 580  :     }
; 581  : 
; 582  :     return 0;

  000d3	83 65 f0 00	 and	 DWORD PTR $T7[ebp], 0
$LN22@compare:

; 4234 :         // compare [0, size()) with [_Ptr, <null>)
; 4235 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  000d7	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]

; 4236 :     }

  000da	c9		 leave
  000db	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 4
__Count$ = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
__Ptr$ = -60						; size = 4
__Ptr$ = -56						; size = 4
__Ans$5 = -52						; size = 4
tv146 = -48						; size = 4
_this$ = -44						; size = 4
__Result$6 = -40					; size = 4
tv137 = -36						; size = 4
__Result$7 = -32					; size = 4
tv95 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T8 = -16						; size = 4
__Right_size$ = -12					; size = 4
__Left_size$ = -8					; size = 4
$T9 = -2						; size = 1
$T10 = -1						; size = 1
__Right$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 4212 :     _NODISCARD int compare(const basic_string& _Right) const noexcept { // compare [0, size()) with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 e0	 mov	 DWORD PTR __Result$7[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@compare
  0001e	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@compare
$LN9@compare:
  00027	83 65 e4 00	 and	 DWORD PTR tv95[ebp], 0
$LN10@compare:
  0002b	8a 45 e4	 mov	 al, BYTE PTR tv95[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T10[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T10[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@compare

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 c8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 e0	 mov	 DWORD PTR __Result$7[ebp], eax
$LN4@compare:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 e0	 mov	 eax, DWORD PTR __Result$7[ebp]
  0004a	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0004d	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00050	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  00053	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	89 45 d8	 mov	 DWORD PTR __Result$6[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00059	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00060	72 09		 jb	 SHORT $LN21@compare
  00062	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv137[ebp], 1
  00069	eb 04		 jmp	 SHORT $LN22@compare
$LN21@compare:
  0006b	83 65 dc 00	 and	 DWORD PTR tv137[ebp], 0
$LN22@compare:
  0006f	8a 45 dc	 mov	 al, BYTE PTR tv137[ebp]
  00072	88 45 fe	 mov	 BYTE PTR $T9[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00075	0f b6 45 fe	 movzx	 eax, BYTE PTR $T9[ebp]
  00079	85 c0		 test	 eax, eax
  0007b	74 0e		 je	 SHORT $LN16@compare

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  0007d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
  00082	89 45 c4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00085	8b 45 c4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00088	89 45 d8	 mov	 DWORD PTR __Result$6[ebp], eax
$LN16@compare:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  0008b	8b 45 d8	 mov	 eax, DWORD PTR __Result$6[ebp]
  0008e	89 45 b0	 mov	 DWORD PTR $T1[ebp], eax

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00091	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00094	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00097	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax
  0009a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000a0	89 45 f8	 mov	 DWORD PTR __Left_size$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  000a3	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  000a6	3b 45 f8	 cmp	 eax, DWORD PTR __Left_size$[ebp]
  000a9	73 08		 jae	 SHORT $LN35@compare
  000ab	8d 45 f4	 lea	 eax, DWORD PTR __Right_size$[ebp]
  000ae	89 45 d0	 mov	 DWORD PTR tv146[ebp], eax
  000b1	eb 06		 jmp	 SHORT $LN36@compare
$LN35@compare:
  000b3	8d 45 f8	 lea	 eax, DWORD PTR __Left_size$[ebp]
  000b6	89 45 d0	 mov	 DWORD PTR tv146[ebp], eax
$LN36@compare:
  000b9	8b 45 d0	 mov	 eax, DWORD PTR tv146[ebp]
  000bc	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
  000bf	8b 45 c0	 mov	 eax, DWORD PTR $T4[ebp]
  000c2	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 568  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  000c5	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  000c8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ca	89 45 b8	 mov	 DWORD PTR __Count$[ebp], eax

; 369  :         return _CSTD memcmp(_First1, _First2, _Count);

  000cd	ff 75 b8	 push	 DWORD PTR __Count$[ebp]
  000d0	ff 75 b4	 push	 DWORD PTR $T2[ebp]
  000d3	ff 75 b0	 push	 DWORD PTR $T1[ebp]
  000d6	e8 00 00 00 00	 call	 _memcmp
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH
  000de	89 45 cc	 mov	 DWORD PTR __Ans$5[ebp], eax

; 570  :     if (_Ans != 0) {

  000e1	83 7d cc 00	 cmp	 DWORD PTR __Ans$5[ebp], 0
  000e5	74 08		 je	 SHORT $LN28@compare

; 571  :         return _Ans;

  000e7	8b 45 cc	 mov	 eax, DWORD PTR __Ans$5[ebp]
  000ea	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
  000ed	eb 23		 jmp	 SHORT $LN31@compare
$LN28@compare:

; 572  :     }
; 573  : 
; 574  :     if (_Left_size < _Right_size) {

  000ef	8b 45 f8	 mov	 eax, DWORD PTR __Left_size$[ebp]
  000f2	3b 45 f4	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  000f5	73 06		 jae	 SHORT $LN29@compare

; 575  :         return -1;

  000f7	83 4d f0 ff	 or	 DWORD PTR $T8[ebp], -1
  000fb	eb 15		 jmp	 SHORT $LN31@compare
$LN29@compare:

; 576  :     }
; 577  : 
; 578  :     if (_Left_size > _Right_size) {

  000fd	8b 45 f8	 mov	 eax, DWORD PTR __Left_size$[ebp]
  00100	3b 45 f4	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  00103	76 09		 jbe	 SHORT $LN30@compare

; 579  :         return 1;

  00105	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T8[ebp], 1
  0010c	eb 04		 jmp	 SHORT $LN31@compare
$LN30@compare:

; 580  :     }
; 581  : 
; 582  :     return 0;

  0010e	83 65 f0 00	 and	 DWORD PTR $T8[ebp], 0
$LN31@compare:

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00112	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]

; 4214 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 4215 :     }

  00115	c9		 leave
  00116	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
__Ptr$ = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
__Result$6 = -16					; size = 4
tv134 = -12						; size = 4
_this$ = -8						; size = 4
$T7 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign, COMDAT
; _this$ = ecx

; 2826 :     void _Copy_assign(const basic_string& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0001b	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0001e	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2827 :         _Pocca(_Getal(), _Right._Getal());

  00021	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00024	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00041	72 09		 jb	 SHORT $LN21@Copy_assig
  00043	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv134[ebp], 1
  0004a	eb 04		 jmp	 SHORT $LN22@Copy_assig
$LN21@Copy_assig:
  0004c	83 65 f4 00	 and	 DWORD PTR tv134[ebp], 0
$LN22@Copy_assig:
  00050	8a 45 f4	 mov	 al, BYTE PTR tv134[ebp]
  00053	88 45 ff	 mov	 BYTE PTR $T7[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00056	0f b6 45 ff	 movzx	 eax, BYTE PTR $T7[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	74 0e		 je	 SHORT $LN16@Copy_assig

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00066	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00069	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax
$LN16@Copy_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR __Result$6[ebp]
  0006f	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00072	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00075	ff 70 10	 push	 DWORD PTR [eax+16]
  00078	ff 75 d4	 push	 DWORD PTR $T1[ebp]
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2829 :     }

  00083	c9		 leave
  00084	c2 08 00	 ret	 8
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 14 00	 and	 DWORD PTR [eax+20], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c9		 leave
  00019	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
