; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?GRAPHICS_CAPS_CAN_NOT_DRAW_LINE@@3_NA		; GRAPHICS_CAPS_CAN_NOT_DRAW_LINE
PUBLIC	?GRAPHICS_CAPS_CAN_NOT_DRAW_SHADOW@@3_NA	; GRAPHICS_CAPS_CAN_NOT_DRAW_SHADOW
PUBLIC	?GRAPHICS_CAPS_HALF_SIZE_IMAGE@@3_NA		; GRAPHICS_CAPS_HALF_SIZE_IMAGE
PUBLIC	?GRAPHICS_CAPS_CAN_NOT_TEXTURE_ADDRESS_BORDER@@3_NA ; GRAPHICS_CAPS_CAN_NOT_TEXTURE_ADDRESS_BORDER
PUBLIC	?GRAPHICS_CAPS_SOFTWARE_TILING@@3_NA		; GRAPHICS_CAPS_SOFTWARE_TILING
PUBLIC	?g_kD3DPP@@3U_D3DPRESENT_PARAMETERS_@@A		; g_kD3DPP
PUBLIC	?g_isBrowserMode@@3_NA				; g_isBrowserMode
PUBLIC	?g_rcBrowser@@3UtagRECT@@A			; g_rcBrowser
_BSS	SEGMENT
?GRAPHICS_CAPS_CAN_NOT_DRAW_LINE@@3_NA DB 01H DUP (?)	; GRAPHICS_CAPS_CAN_NOT_DRAW_LINE
	ALIGN	4

?GRAPHICS_CAPS_CAN_NOT_DRAW_SHADOW@@3_NA DB 01H DUP (?)	; GRAPHICS_CAPS_CAN_NOT_DRAW_SHADOW
	ALIGN	4

?GRAPHICS_CAPS_HALF_SIZE_IMAGE@@3_NA DB 01H DUP (?)	; GRAPHICS_CAPS_HALF_SIZE_IMAGE
	ALIGN	4

?GRAPHICS_CAPS_CAN_NOT_TEXTURE_ADDRESS_BORDER@@3_NA DB 01H DUP (?) ; GRAPHICS_CAPS_CAN_NOT_TEXTURE_ADDRESS_BORDER
	ALIGN	4

?GRAPHICS_CAPS_SOFTWARE_TILING@@3_NA DB 01H DUP (?)	; GRAPHICS_CAPS_SOFTWARE_TILING
	ALIGN	4

?g_kD3DPP@@3U_D3DPRESENT_PARAMETERS_@@A DB 034H DUP (?)	; g_kD3DPP
?g_isBrowserMode@@3_NA DB 01H DUP (?)			; g_isBrowserMode
	ALIGN	4

?g_rcBrowser@@3UtagRECT@@A DB 010H DUP (?)		; g_rcBrowser
_BSS	ENDS
CONST	SEGMENT
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	___local_stdio_scanf_options
PUBLIC	_sscanf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0CGraphicDevice@@QAE@XZ			; CGraphicDevice::CGraphicDevice
PUBLIC	??1CGraphicDevice@@UAE@XZ			; CGraphicDevice::~CGraphicDevice
PUBLIC	?InitBackBufferCount@CGraphicDevice@@QAEXI@Z	; CGraphicDevice::InitBackBufferCount
PUBLIC	?Destroy@CGraphicDevice@@QAEXXZ			; CGraphicDevice::Destroy
PUBLIC	?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z	; CGraphicDevice::Create
PUBLIC	?GetDeviceState@CGraphicDevice@@QAE?AW4EDeviceState@1@XZ ; CGraphicDevice::GetDeviceState
PUBLIC	?Reset@CGraphicDevice@@QAE_NXZ			; CGraphicDevice::Reset
PUBLIC	?EnableWebBrowserMode@CGraphicDevice@@QAEXABUtagRECT@@@Z ; CGraphicDevice::EnableWebBrowserMode
PUBLIC	?DisableWebBrowserMode@CGraphicDevice@@QAEXXZ	; CGraphicDevice::DisableWebBrowserMode
PUBLIC	?MoveWebBrowserRect@CGraphicDevice@@QAEXABUtagRECT@@@Z ; CGraphicDevice::MoveWebBrowserRect
PUBLIC	?ResizeBackBuffer@CGraphicDevice@@QAE_NII@Z	; CGraphicDevice::ResizeBackBuffer
PUBLIC	?RegisterWarningString@CGraphicDevice@@QAEXIPBD@Z ; CGraphicDevice::RegisterWarningString
PUBLIC	?__Initialize@CGraphicDevice@@IAEXXZ		; CGraphicDevice::__Initialize
PUBLIC	?__IsInDriverBlackList@CGraphicDevice@@IAE_NAAVD3D_CAdapterInfo@@@Z ; CGraphicDevice::__IsInDriverBlackList
PUBLIC	?__WarningMessage@CGraphicDevice@@IAEXPAUHWND__@@I@Z ; CGraphicDevice::__WarningMessage
PUBLIC	?__InitializeDefaultIndexBufferList@CGraphicDevice@@IAEXXZ ; CGraphicDevice::__InitializeDefaultIndexBufferList
PUBLIC	?__DestroyDefaultIndexBufferList@CGraphicDevice@@IAEXXZ ; CGraphicDevice::__DestroyDefaultIndexBufferList
PUBLIC	?__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ ; CGraphicDevice::__CreateDefaultIndexBufferList
PUBLIC	?__CreateDefaultIndexBuffer@CGraphicDevice@@IAE_NIIPBG@Z ; CGraphicDevice::__CreateDefaultIndexBuffer
PUBLIC	?__InitializePDTVertexBufferList@CGraphicDevice@@IAEXXZ ; CGraphicDevice::__InitializePDTVertexBufferList
PUBLIC	?__DestroyPDTVertexBufferList@CGraphicDevice@@IAEXXZ ; CGraphicDevice::__DestroyPDTVertexBufferList
PUBLIC	?__CreatePDTVertexBufferList@CGraphicDevice@@IAE_NXZ ; CGraphicDevice::__CreatePDTVertexBufferList
PUBLIC	?CreatePTStreamVertexShader@CGraphicDevice@@IAEKXZ ; CGraphicDevice::CreatePTStreamVertexShader
PUBLIC	?CreatePNTStreamVertexShader@CGraphicDevice@@IAEKXZ ; CGraphicDevice::CreatePNTStreamVertexShader
PUBLIC	?CreatePNT2StreamVertexShader@CGraphicDevice@@IAEKXZ ; CGraphicDevice::CreatePNT2StreamVertexShader
PUBLIC	?CreateDoublePNTStreamVertexShader@CGraphicDevice@@IAEKXZ ; CGraphicDevice::CreateDoublePNTStreamVertexShader
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rrotate
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Insert_node
PUBLIC	??1?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??_GCGraphicDevice@@UAEPAXI@Z			; CGraphicDevice::`scalar deleting destructor'
PUBLIC	?EL3D_ConfirmDevice@@YAHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z ; EL3D_ConfirmDevice
PUBLIC	?GetMaxTextureWidth@@YAKXZ			; GetMaxTextureWidth
PUBLIC	?GetMaxTextureHeight@@YAKXZ			; GetMaxTextureHeight
PUBLIC	??$_Try_emplace@ABI$$V@?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@_N@1@ABI@Z ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Try_emplace<unsigned int const &>
PUBLIC	??$_Find@I@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find<unsigned int>
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$_Find_lower_bound@I@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<unsigned int>
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><std::piecewise_construct_t const &,std::tuple<unsigned int const &>,std::tuple<> >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
PUBLIC	??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABI@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@QAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::piecewise_construct_t const &,std::tuple<unsigned int const &>,std::tuple<> >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	??$?0ABI$$Z$$V@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABI@1@V?$tuple@$$V@1@@Z ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int const &>
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_7CGraphicDevice@@6B@				; CGraphicDevice::`vftable'
PUBLIC	??_C@_07KGMMFLDN@Warning@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0L@NIHOAGKC@grpblk?4txt@			; `string'
PUBLIC	??_C@_08NLGDGEBC@?$CFs?5?$CFx?5?$CFx@		; `string'
PUBLIC	??_C@_0BE@JAEGAKLI@adapter?5?$CFd?5is?5EMPTY@	; `string'
PUBLIC	??_C@_0BM@LIHILKDJ@device?5?$CFd?0?5mode?5?$CFd?5is?5EMPTY@ ; `string'
PUBLIC	??_C@_04MAKEOOIM@3dfx@				; `string'
PUBLIC	??_C@_0JB@NCJOPOMN@IDirect3DDevice?4CreateDevice?5?9?5@ ; `string'
PUBLIC	??_C@_0GO@ICOCNPJJ@IDirect3DDevice?4CreateDevice?5?9?5@ ; `string'
PUBLIC	??_C@_0ID@GFNIEGEI@IDirect3DDevice?4CreateDevice?5?9?5@ ; `string'
PUBLIC	??_C@_0CI@IPGGGCFB@IDirect3DDevice?4CreateDevice?5?9?5@ ; `string'
PUBLIC	??_C@_0CJ@PKDINAHJ@IDirect3DDevice?4GetDeviceCaps?5?9@ ; `string'
PUBLIC	??_C@_03OJNODIHH@SIS@				; `string'
PUBLIC	??_R4CGraphicDevice@@6B@			; CGraphicDevice::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGraphicDevice@@@8			; CGraphicDevice `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicDevice@@8				; CGraphicDevice::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicDevice@@8				; CGraphicDevice::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicDevice@@8			; CGraphicDevice::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CGraphicBase@@8			; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicBase@@@8			; CGraphicBase `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicBase@@8				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicBase@@8				; CGraphicBase::`RTTI Base Class Array'
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@bf800000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	__strnicmp:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_Direct3DCreate8@4:PROC
EXTRN	_D3DXCreateMatrixStack@8:PROC
EXTRN	_D3DXCreateCylinder@32:PROC
EXTRN	_D3DXCreateSphere@24:PROC
EXTRN	_fclose:PROC
EXTRN	_fgets:PROC
EXTRN	_fopen:PROC
EXTRN	___stdio_common_vsscanf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Tracen@@YAXPBD@Z:PROC				; Tracen
EXTRN	?Tracenf@@YAXPBDZZ:PROC				; Tracenf
EXTRN	?GetString@D3D_SModeInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; D3D_SModeInfo::GetString
EXTRN	?GetDesktopD3DDisplayModer@D3D_CAdapterInfo@@QAEAAU_D3DDISPLAYMODE@@XZ:PROC ; D3D_CAdapterInfo::GetDesktopD3DDisplayModer
EXTRN	?GetD3DModeInfop@D3D_CAdapterInfo@@QAEPAUD3D_SModeInfo@@II@Z:PROC ; D3D_CAdapterInfo::GetD3DModeInfop
EXTRN	?Find@D3D_CDisplayModeAutoDetector@@QAEHIIIHPAI00@Z:PROC ; D3D_CDisplayModeAutoDetector::Find
EXTRN	?Build@D3D_CDisplayModeAutoDetector@@QAEHAAUIDirect3D8@@P6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z:PROC ; D3D_CDisplayModeAutoDetector::Build
EXTRN	?GetD3DAdapterInfop@D3D_CDisplayModeAutoDetector@@QAEPAVD3D_CAdapterInfo@@I@Z:PROC ; D3D_CDisplayModeAutoDetector::GetD3DAdapterInfop
EXTRN	?GetString@D3D_CDisplayModeAutoDetector@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; D3D_CDisplayModeAutoDetector::GetString
EXTRN	?GetAvailableTextureMemory@CGraphicBase@@SAKXZ:PROC ; CGraphicBase::GetAvailableTextureMemory
EXTRN	??0CGraphicBase@@QAE@XZ:PROC			; CGraphicBase::CGraphicBase
EXTRN	??1CGraphicBase@@UAE@XZ:PROC			; CGraphicBase::~CGraphicBase
EXTRN	??0CStateManager@@QAE@PAUIDirect3DDevice8@@@Z:PROC ; CStateManager::CStateManager
EXTRN	?SetDefaultState@CStateManager@@QAEXXZ:PROC	; CStateManager::SetDefaultState
EXTRN	??_ECGraphicDevice@@UAEPAXI@Z:PROC		; CGraphicDevice::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__allshr:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A:BYTE ; CGraphicBase::ms_matIdentity
EXTRN	?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A:BYTE	; CGraphicBase::ms_matView
EXTRN	?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A:BYTE	; CGraphicBase::ms_matProj
EXTRN	?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A:BYTE ; CGraphicBase::ms_matInverseView
EXTRN	?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A:BYTE ; CGraphicBase::ms_matInverseViewYAxis
EXTRN	?ms_lpSphereMesh@CGraphicBase@@1PAUID3DXMesh@@A:DWORD ; CGraphicBase::ms_lpSphereMesh
EXTRN	?ms_lpCylinderMesh@CGraphicBase@@1PAUID3DXMesh@@A:DWORD ; CGraphicBase::ms_lpCylinderMesh
EXTRN	?ms_hLastResult@CGraphicBase@@1JA:DWORD		; CGraphicBase::ms_hLastResult
EXTRN	?ms_iWidth@CGraphicBase@@1HA:DWORD		; CGraphicBase::ms_iWidth
EXTRN	?ms_iHeight@CGraphicBase@@1HA:DWORD		; CGraphicBase::ms_iHeight
EXTRN	?ms_iD3DAdapterInfo@CGraphicBase@@1IA:DWORD	; CGraphicBase::ms_iD3DAdapterInfo
EXTRN	?ms_iD3DDevInfo@CGraphicBase@@1IA:DWORD		; CGraphicBase::ms_iD3DDevInfo
EXTRN	?ms_iD3DModeInfo@CGraphicBase@@1IA:DWORD	; CGraphicBase::ms_iD3DModeInfo
EXTRN	?ms_kD3DDetector@CGraphicBase@@1VD3D_CDisplayModeAutoDetector@@A:BYTE ; CGraphicBase::ms_kD3DDetector
EXTRN	?ms_hWnd@CGraphicBase@@1PAUHWND__@@A:DWORD	; CGraphicBase::ms_hWnd
EXTRN	?ms_hDC@CGraphicBase@@1PAUHDC__@@A:DWORD	; CGraphicBase::ms_hDC
EXTRN	?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A:DWORD	; CGraphicBase::ms_lpd3d
EXTRN	?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A:DWORD ; CGraphicBase::ms_lpd3dDevice
EXTRN	?ms_lpd3dMatStack@CGraphicBase@@1PAUID3DXMatrixStack@@A:DWORD ; CGraphicBase::ms_lpd3dMatStack
EXTRN	?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A:BYTE ; CGraphicBase::ms_Viewport
EXTRN	?ms_d3dCaps@CGraphicBase@@1U_D3DCAPS8@@A:BYTE	; CGraphicBase::ms_d3dCaps
EXTRN	?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A:BYTE ; CGraphicBase::ms_d3dPresentParameter
EXTRN	?ms_dwD3DBehavior@CGraphicBase@@1KA:DWORD	; CGraphicBase::ms_dwD3DBehavior
EXTRN	?ms_ptVS@CGraphicBase@@1KA:DWORD		; CGraphicBase::ms_ptVS
EXTRN	?ms_pntVS@CGraphicBase@@1KA:DWORD		; CGraphicBase::ms_pntVS
EXTRN	?ms_pnt2VS@CGraphicBase@@1KA:DWORD		; CGraphicBase::ms_pnt2VS
EXTRN	?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A:BYTE ; CGraphicBase::ms_matScreen0
EXTRN	?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A:BYTE ; CGraphicBase::ms_matScreen1
EXTRN	?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A:BYTE ; CGraphicBase::ms_matScreen2
EXTRN	?ms_dwWavingEndTime@CGraphicBase@@1KA:DWORD	; CGraphicBase::ms_dwWavingEndTime
EXTRN	?ms_dwFlashingEndTime@CGraphicBase@@1KA:DWORD	; CGraphicBase::ms_dwFlashingEndTime
EXTRN	?ms_bSupportDXT@CGraphicBase@@1_NA:BYTE		; CGraphicBase::ms_bSupportDXT
EXTRN	?ms_isLowTextureMemory@CGraphicBase@@1_NA:BYTE	; CGraphicBase::ms_isLowTextureMemory
EXTRN	?ms_isHighTextureMemory@CGraphicBase@@1_NA:BYTE	; CGraphicBase::ms_isHighTextureMemory
EXTRN	?ms_alpd3dPDTVB@CGraphicBase@@1PAPAUIDirect3DVertexBuffer8@@A:BYTE ; CGraphicBase::ms_alpd3dPDTVB
EXTRN	?ms_alpd3dDefIB@CGraphicBase@@1PAPAUIDirect3DIndexBuffer8@@A:BYTE ; CGraphicBase::ms_alpd3dDefIB
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?s_MaxTextureWidth@@3KA DD 01H DUP (?)			; s_MaxTextureWidth
?s_MaxTextureHeight@@3KA DD 01H DUP (?)			; s_MaxTextureHeight
_BSS	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R2CGraphicBase@@8
rdata$r	SEGMENT
??_R2CGraphicBase@@8 DD FLAT:??_R1A@?0A@EA@CGraphicBase@@8 ; CGraphicBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicBase@@8
rdata$r	SEGMENT
??_R3CGraphicBase@@8 DD 00H				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicBase@@@8
data$rs	SEGMENT
??_R0?AVCGraphicBase@@@8 DD FLAT:??_7type_info@@6B@	; CGraphicBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicBase@@8 DD FLAT:??_R0?AVCGraphicBase@@@8 ; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicDevice@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicDevice@@8 DD FLAT:??_R0?AVCGraphicDevice@@@8 ; CGraphicDevice::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicDevice@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicDevice@@8
rdata$r	SEGMENT
??_R2CGraphicDevice@@8 DD FLAT:??_R1A@?0A@EA@CGraphicDevice@@8 ; CGraphicDevice::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CGraphicDevice@@8
rdata$r	SEGMENT
??_R3CGraphicDevice@@8 DD 00H				; CGraphicDevice::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGraphicDevice@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicDevice@@@8
data$rs	SEGMENT
??_R0?AVCGraphicDevice@@@8 DD FLAT:??_7type_info@@6B@	; CGraphicDevice `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicDevice@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CGraphicDevice@@6B@
rdata$r	SEGMENT
??_R4CGraphicDevice@@6B@ DD 00H				; CGraphicDevice::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGraphicDevice@@@8
	DD	FLAT:??_R3CGraphicDevice@@8
rdata$r	ENDS
;	COMDAT ?c_awFillCubeIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
CONST	SEGMENT
?c_awFillCubeIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB DW 00H ; `CGraphicDevice::__CreateDefaultIndexBufferList'::`2'::c_awFillCubeIndices
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	00H
	DW	06H
	DW	00H
	DW	04H
	DW	06H
	DW	00H
	DW	01H
	DW	04H
	DW	01H
	DW	05H
	DW	04H
	DW	01H
	DW	03H
	DW	05H
	DW	03H
	DW	07H
	DW	05H
	DW	03H
	DW	02H
	DW	07H
	DW	02H
	DW	06H
	DW	07H
	DW	04H
	DW	05H
	DW	06H
	DW	05H
	DW	07H
	DW	06H
CONST	ENDS
;	COMDAT ?c_awFillRectIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
CONST	SEGMENT
?c_awFillRectIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB DW 00H ; `CGraphicDevice::__CreateDefaultIndexBufferList'::`2'::c_awFillRectIndices
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
CONST	ENDS
;	COMDAT ?c_awFillTriIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
CONST	SEGMENT
?c_awFillTriIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB DW 00H ; `CGraphicDevice::__CreateDefaultIndexBufferList'::`2'::c_awFillTriIndices
	DW	01H
	DW	02H
CONST	ENDS
;	COMDAT ?c_awLineCubeIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
CONST	SEGMENT
?c_awLineCubeIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB DW 00H ; `CGraphicDevice::__CreateDefaultIndexBufferList'::`2'::c_awLineCubeIndices
	DW	01H
	DW	00H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	00H
	DW	04H
	DW	01H
	DW	05H
	DW	02H
	DW	06H
	DW	03H
	DW	07H
	DW	04H
	DW	05H
	DW	04H
	DW	06H
	DW	05H
	DW	07H
	DW	06H
	DW	07H
CONST	ENDS
;	COMDAT ?c_awLineRectIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
CONST	SEGMENT
?c_awLineRectIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB DW 00H ; `CGraphicDevice::__CreateDefaultIndexBufferList'::`2'::c_awLineRectIndices
	DW	01H
	DW	00H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
CONST	ENDS
;	COMDAT ?c_awLineTriIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
CONST	SEGMENT
?c_awLineTriIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB DW 00H ; `CGraphicDevice::__CreateDefaultIndexBufferList'::`2'::c_awLineTriIndices
	DW	01H
	DW	00H
	DW	02H
	DW	01H
	DW	02H
CONST	ENDS
;	COMDAT ?c_awLineIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
CONST	SEGMENT
?c_awLineIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB DW 00H ; `CGraphicDevice::__CreateDefaultIndexBufferList'::`2'::c_awLineIndices
	DW	01H
CONST	ENDS
;	COMDAT ??_C@_03OJNODIHH@SIS@
CONST	SEGMENT
??_C@_03OJNODIHH@SIS@ DB 'SIS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PKDINAHJ@IDirect3DDevice?4GetDeviceCaps?5?9@
CONST	SEGMENT
??_C@_0CJ@PKDINAHJ@IDirect3DDevice?4GetDeviceCaps?5?9@ DB 'IDirect3DDevic'
	DB	'e.GetDeviceCaps - ERROR %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IPGGGCFB@IDirect3DDevice?4CreateDevice?5?9?5@
CONST	SEGMENT
??_C@_0CI@IPGGGCFB@IDirect3DDevice?4CreateDevice?5?9?5@ DB 'IDirect3DDevi'
	DB	'ce.CreateDevice - ERROR %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ID@GFNIEGEI@IDirect3DDevice?4CreateDevice?5?9?5@
CONST	SEGMENT
??_C@_0ID@GFNIEGEI@IDirect3DDevice?4CreateDevice?5?9?5@ DB 'IDirect3DDevi'
	DB	'ce.CreateDevice - ERROR D3DERR_OUTOFVIDEOMEMORY', 0aH, 'Direc'
	DB	't3D does not have enough display memory to perform the operat'
	DB	'ion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GO@ICOCNPJJ@IDirect3DDevice?4CreateDevice?5?9?5@
CONST	SEGMENT
??_C@_0GO@ICOCNPJJ@IDirect3DDevice?4CreateDevice?5?9?5@ DB 'IDirect3DDevi'
	DB	'ce.CreateDevice - ERROR D3DERR_NOTAVAILABLE', 0aH, 'This devi'
	DB	'ce does not support the queried technique. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JB@NCJOPOMN@IDirect3DDevice?4CreateDevice?5?9?5@
CONST	SEGMENT
??_C@_0JB@NCJOPOMN@IDirect3DDevice?4CreateDevice?5?9?5@ DB 'IDirect3DDevi'
	DB	'ce.CreateDevice - ERROR D3DERR_INVALIDCALL', 0aH, 'The method'
	DB	' call is invalid. For example, a method''s parameter may have'
	DB	' an invalid value.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MAKEOOIM@3dfx@
CONST	SEGMENT
??_C@_04MAKEOOIM@3dfx@ DB '3dfx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LIHILKDJ@device?5?$CFd?0?5mode?5?$CFd?5is?5EMPTY@
CONST	SEGMENT
??_C@_0BM@LIHILKDJ@device?5?$CFd?0?5mode?5?$CFd?5is?5EMPTY@ DB 'device %d'
	DB	', mode %d is EMPTY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JAEGAKLI@adapter?5?$CFd?5is?5EMPTY@
CONST	SEGMENT
??_C@_0BE@JAEGAKLI@adapter?5?$CFd?5is?5EMPTY@ DB 'adapter %d is EMPTY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLGDGEBC@?$CFs?5?$CFx?5?$CFx@
CONST	SEGMENT
??_C@_08NLGDGEBC@?$CFs?5?$CFx?5?$CFx@ DB '%s %x %x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NIHOAGKC@grpblk?4txt@
CONST	SEGMENT
??_C@_0L@NIHOAGKC@grpblk?4txt@ DB 'grpblk.txt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07KGMMFLDN@Warning@
CONST	SEGMENT
??_C@_07KGMMFLDN@Warning@ DB 'Warning', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7CGraphicDevice@@6B@
CONST	SEGMENT
??_7CGraphicDevice@@6B@ DD FLAT:??_R4CGraphicDevice@@6B@ ; CGraphicDevice::`vftable'
	DD	FLAT:??_ECGraphicDevice@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z$0
__ehfuncinfo$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z$2
__ehfuncinfo$?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CGraphicDevice@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CGraphicDevice@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CGraphicDevice@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CGraphicDevice@@QAE@XZ$1
__ehfuncinfo$??0CGraphicDevice@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CGraphicDevice@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
;	COMDAT ??$?0ABI$$Z$$V@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABI@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
___formal$ = -12					; size = 1
___formal$ = -8						; size = 1
$T3 = -2						; size = 1
$T4 = -1						; size = 1
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0ABI$$Z$$V@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABI@1@V?$tuple@$$V@1@@Z PROC ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int const &>, COMDAT
; _this$ = ecx

; 986  :     : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	33 c0		 xor	 eax, eax
  0000b	88 45 ff	 mov	 BYTE PTR $T4[ebp], al
  0000e	33 c0		 xor	 eax, eax
  00010	88 45 fe	 mov	 BYTE PTR $T3[ebp], al
  00013	8a 45 ff	 mov	 al, BYTE PTR $T4[ebp]
  00016	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  00019	8a 45 fe	 mov	 al, BYTE PTR $T3[ebp]
  0001c	88 45 f4	 mov	 BYTE PTR ___formal$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0001f	8d 45 0c	 lea	 eax, DWORD PTR __Val1$[ebp]
  00022	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 790  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

  00025	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 980  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...), second(_STD get<_Indexes2>(_STD move(_Val2))...) {}

  0002d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d e8	 mov	 ecx, DWORD PTR $T1[ebp]
  00033	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00035	89 08		 mov	 DWORD PTR [eax], ecx
  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 04	 add	 ecx, 4
  0003d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 986  :     : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

  00042	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00045	c9		 leave
  00046	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABI$$Z$$V@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABI@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 377  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 378  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00007	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00010	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00013	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00018	33 c0		 xor	 eax, eax
  0001a	83 e0 01	 and	 eax, 1
  0001d	74 0c		 je	 SHORT $LN6@Freenode
  0001f	6a 1c		 push	 28			; 0000001cH
  00021	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	59		 pop	 ecx
  0002a	59		 pop	 ecx
$LN6@Freenode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  0002b	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx

; 381  :     }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABI@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@QAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABI@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@QAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::piecewise_construct_t const &,std::tuple<unsigned int const &>,std::tuple<> >, COMDAT

; 700  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000c	8b 45 18	 mov	 eax, DWORD PTR _<_Args_2>$[ebp]
  0000f	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00012	51		 push	 ecx
  00013	89 65 e8	 mov	 DWORD PTR _this$[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00016	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  00019	89 45 fc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0001c	51		 push	 ecx
  0001d	89 65 f8	 mov	 DWORD PTR _this$[ebp], esp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

  00020	8b 45 fc	 mov	 eax, DWORD PTR $T4[ebp]
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0002d	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00030	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00033	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00036	50		 push	 eax
  00037	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0003a	e8 00 00 00 00	 call	 ??$?0ABI$$Z$$V@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABI@1@V?$tuple@$$V@1@@Z ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int const &>

; 702  :     }

  0003f	c9		 leave
  00040	c3		 ret	 0
??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABI@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@QAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::piecewise_construct_t const &,std::tuple<unsigned int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 2c	 imul	 eax, eax, 44
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Old_val$2 = -12					; size = 4
__New_val$ = -8						; size = 4
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 3a		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f8	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f4	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f8	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f4	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  0003f	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00042	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  00045	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
  0004a	59		 pop	 ecx
  0004b	59		 pop	 ecx

; 746  :         }

  0004c	eb bb		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  0004e	c9		 leave
  0004f	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
_<_Vals_1>$ = 20					; size = 4
_<_Vals_2>$ = 24					; size = 4
??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><std::piecewise_construct_t const &,std::tuple<unsigned int const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 785  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Allocate

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00043	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0004a	8b 45 18	 mov	 eax, DWORD PTR _<_Vals_2>$[ebp]
  0004d	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
  00050	8b 45 14	 mov	 eax, DWORD PTR _<_Vals_1>$[ebp]
  00053	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
  00056	8b 45 10	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00059	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	83 c0 10	 add	 eax, 16			; 00000010H
  00065	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0006b	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0006e	ff 75 e8	 push	 DWORD PTR $T5[ebp]
  00071	ff 75 e4	 push	 DWORD PTR $T4[ebp]
  00074	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00077	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  0007a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	ff 30		 push	 DWORD PTR [eax]
  0007f	e8 00 00 00 00	 call	 ??$construct@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABI@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@QAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::piecewise_construct_t const &,std::tuple<unsigned int const &>,std::tuple<> >
  00084	83 c4 14	 add	 esp, 20			; 00000014H

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00087	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  0008a	50		 push	 eax
  0008b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	ff 70 04	 push	 DWORD PTR [eax+4]
  00091	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
  00096	59		 pop	 ecx
  00097	59		 pop	 ecx

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00098	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  0009b	50		 push	 eax
  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a2	83 c0 04	 add	 eax, 4
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
  000ab	59		 pop	 ecx
  000ac	59		 pop	 ecx

; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000ad	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  000b0	50		 push	 eax
  000b1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b7	83 c0 08	 add	 eax, 8
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
  000c0	59		 pop	 ecx
  000c1	59		 pop	 ecx

; 810  :         this->_Ptr->_Color = _Red;

  000c2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c8	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 811  :         this->_Ptr->_Isnil = false;

  000cc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d2	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 812  :     }

  000d6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000da	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e7	59		 pop	 ecx
  000e8	c9		 leave
  000e9	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z$0:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><std::piecewise_construct_t const &,std::tuple<unsigned int const &>,std::tuple<> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
___formal$ = -16					; size = 4
__Val$ = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT
; _this$ = ecx

; 817  :     ~_Tree_temp_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 818  :         if (this->_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 64		 je	 SHORT $LN28@Tree_temp_

; 819  :             _Destroy_in_place(this->_Ptr->_Left);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
  0001d	59		 pop	 ecx

; 820  :             _Destroy_in_place(this->_Ptr->_Parent);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
  0002d	59		 pop	 ecx

; 821  :             _Destroy_in_place(this->_Ptr->_Right);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	83 c0 08	 add	 eax, 8
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
  0003d	59		 pop	 ecx

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 10	 add	 eax, 16			; 00000010H
  00047	89 45 f4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Val$[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	89 45 f0	 mov	 DWORD PTR ___formal$[ebp], eax
  00058	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  0005b	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0005e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00063	33 c0		 xor	 eax, eax
  00065	83 e0 01	 and	 eax, 1
  00068	74 0c		 je	 SHORT $LN28@Tree_temp_
  0006a	6a 1c		 push	 28			; 0000001cH
  0006c	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0006f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00074	59		 pop	 ecx
  00075	59		 pop	 ecx
$LN28@Tree_temp_:
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 824  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 2c	 imul	 eax, eax, 44
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 5d 74
	d1 05		 mov	 DWORD PTR __Max_possible$1[ebp], 97612893 ; 05d1745dH

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d 5d 74 d1 05	 cmp	 eax, 97612893		; 05d1745dH
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 2c	 imul	 eax, eax, 44
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find_lower_bound@I@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@ABI@Z
_TEXT	SEGMENT
__Result$ = -40						; size = 12
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
tv64 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Trynode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@I@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<unsigned int>, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00011	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1700 :         const auto _Scary = _Get_scary();
; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax
  00022	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0
  00026	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  0002e	8b 45 d8	 mov	 eax, DWORD PTR __Result$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00037	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0003b	85 c0		 test	 eax, eax
  0003d	75 5a		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00042	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax

; 2035 :         return _Mypair._Get_first();

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00048	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004b	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00057	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005a	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0005c	73 09		 jae	 SHORT $LN23@Find_lower
  0005e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv64[ebp], 1
  00065	eb 04		 jmp	 SHORT $LN21@Find_lower
$LN23@Find_lower:
  00067	83 65 f0 00	 and	 DWORD PTR tv64[ebp], 0
$LN21@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  0006b	0f b6 45 f0	 movzx	 eax, BYTE PTR tv64[ebp]
  0006f	85 c0		 test	 eax, eax
  00071	74 0f		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00073	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  00077	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0007a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007d	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax

; 1708 :             } else {

  00080	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00082	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  00089	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00092	8b 00		 mov	 eax, DWORD PTR [eax]
  00094	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  00097	eb 9b		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  00099	8d 75 d8	 lea	 esi, DWORD PTR __Result$[ebp]
  0009c	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0009f	a5		 movsd
  000a0	a5		 movsd
  000a1	a5		 movsd
  000a2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	c9		 leave
  000a8	c2 08 00	 ret	 8
??$_Find_lower_bound@I@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec 5d 74
	d1 05		 mov	 DWORD PTR __Max_possible$1[ebp], 97612893 ; 05d1745dH

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d 5d 74 d1 05	 cmp	 eax, 97612893		; 05d1745dH
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 2c	 imul	 eax, eax, 44
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find@I@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABI@Z
_TEXT	SEGMENT
__Loc$ = -44						; size = 12
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
tv79 = -16						; size = 4
tv131 = -12						; size = 4
__Bound$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@I@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find<unsigned int>, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00009	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000c	8d 45 d4	 lea	 eax, DWORD PTR __Loc$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Find_lower_bound@I@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<unsigned int>

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00018	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0001b	89 45 f8	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Bound$[ebp]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 37		 jne	 SHORT $LN30@Find

; 2035 :         return _Mypair._Get_first();

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002c	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0002f	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00032	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	8b 4d f8	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00040	73 09		 jae	 SHORT $LN42@Find
  00042	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  00049	eb 04		 jmp	 SHORT $LN40@Find
$LN42@Find:
  0004b	83 65 f4 00	 and	 DWORD PTR tv131[ebp], 0
$LN40@Find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0004f	0f b6 45 f4	 movzx	 eax, BYTE PTR tv131[ebp]
  00053	85 c0		 test	 eax, eax
  00055	75 09		 jne	 SHORT $LN30@Find
  00057	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  0005e	eb 04		 jmp	 SHORT $LN28@Find
$LN30@Find:
  00060	83 65 f0 00	 and	 DWORD PTR tv79[ebp], 0
$LN28@Find:

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00064	0f b6 45 f0	 movzx	 eax, BYTE PTR tv79[ebp]
  00068	85 c0		 test	 eax, eax
  0006a	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  0006c	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0006f	eb 11		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00074	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00077	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0007a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  0007d	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00082	c9		 leave
  00083	c2 04 00	 ret	 4
??$_Find@I@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
;	COMDAT ??$_Try_emplace@ABI$$V@?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@_N@1@ABI@Z
_TEXT	SEGMENT
$T1 = -32						; size = 8
$T2 = -24						; size = 4
__Loc$ = -20						; size = 12
$T3 = -8						; size = 4
$T4 = -4						; size = 4
$T5 = 0							; size = 4
__Inserted$ = 4						; size = 4
$T6 = 8							; size = 4
__Old_val$7 = 12					; size = 4
$T8 = 16						; size = 4
$T9 = 20						; size = 4
$T10 = 24						; size = 4
$T11 = 28						; size = 4
$T12 = 32						; size = 4
$T13 = 36						; size = 4
$T14 = 40						; size = 4
$T15 = 44						; size = 4
_this$16 = 48						; size = 4
$T17 = 52						; size = 4
$T18 = 56						; size = 4
$T19 = 60						; size = 4
$T20 = 64						; size = 4
$T21 = 68						; size = 4
$T22 = 72						; size = 4
$T23 = 76						; size = 4
__Scary$ = 80						; size = 4
__Val$ = 84						; size = 4
tv168 = 88						; size = 4
tv188 = 92						; size = 4
__Bound$ = 96						; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
$T25 = 110						; size = 1
$T26 = 111						; size = 1
___$ReturnUdt$ = 120					; size = 4
__Keyval$ = 124						; size = 4
??$_Try_emplace@ABI$$V@?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@_N@1@ABI@Z PROC ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Try_emplace<unsigned int const &>, COMDAT
; _this$ = ecx

; 175  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval, _Mappedty&&... _Mapval) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  0000b	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 176  :         const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);

  0000e	ff 75 7c	 push	 DWORD PTR __Keyval$[ebp]
  00011	8d 45 ec	 lea	 eax, DWORD PTR __Loc$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??$_Find_lower_bound@I@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find_lower_bound<unsigned int>

; 177  :         if (_Mybase::_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  0001d	8b 45 f4	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  00020	89 45 60	 mov	 DWORD PTR __Bound$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00023	8b 45 60	 mov	 eax, DWORD PTR __Bound$[ebp]
  00026	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0002a	85 c0		 test	 eax, eax
  0002c	75 37		 jne	 SHORT $LN31@Try_emplac

; 2035 :         return _Mypair._Get_first();

  0002e	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00031	89 45 4c	 mov	 DWORD PTR $T23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  00034	8b 45 4c	 mov	 eax, DWORD PTR $T23[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  0003a	8b 45 7c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0003d	8b 4d 60	 mov	 ecx, DWORD PTR __Bound$[ebp]
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
  00042	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00045	73 09		 jae	 SHORT $LN43@Try_emplac
  00047	c7 45 5c 01 00
	00 00		 mov	 DWORD PTR tv188[ebp], 1
  0004e	eb 04		 jmp	 SHORT $LN41@Try_emplac
$LN43@Try_emplac:
  00050	83 65 5c 00	 and	 DWORD PTR tv188[ebp], 0
$LN41@Try_emplac:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00054	0f b6 45 5c	 movzx	 eax, BYTE PTR tv188[ebp]
  00058	85 c0		 test	 eax, eax
  0005a	75 09		 jne	 SHORT $LN31@Try_emplac
  0005c	c7 45 58 01 00
	00 00		 mov	 DWORD PTR tv168[ebp], 1
  00063	eb 04		 jmp	 SHORT $LN29@Try_emplac
$LN31@Try_emplac:
  00065	83 65 58 00	 and	 DWORD PTR tv168[ebp], 0
$LN29@Try_emplac:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 177  :         if (_Mybase::_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00069	0f b6 45 58	 movzx	 eax, BYTE PTR tv168[ebp]
  0006d	85 c0		 test	 eax, eax
  0006f	74 2d		 je	 SHORT $LN2@Try_emplac

; 178  :             return {_Loc._Bound, false};

  00071	c6 45 6f 00	 mov	 BYTE PTR $T26[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00075	8d 45 f4	 lea	 eax, DWORD PTR __Loc$[ebp+8]
  00078	89 45 48	 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0007b	8b 45 78	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007e	8b 4d 48	 mov	 ecx, DWORD PTR $T22[ebp]
  00081	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00083	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00085	8d 45 6f	 lea	 eax, DWORD PTR $T26[ebp]
  00088	89 45 44	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0008b	8b 45 78	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0008e	8b 4d 44	 mov	 ecx, DWORD PTR $T21[ebp]
  00091	8a 09		 mov	 cl, BYTE PTR [ecx]
  00093	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 178  :             return {_Loc._Bound, false};

  00096	8b 45 78	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00099	e9 dd 00 00 00	 jmp	 $LN1@Try_emplac
$LN2@Try_emplac:

; 179  :         }
; 180  : 
; 181  :         _Mybase::_Check_grow_by_1();

  0009e	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_grow_by_1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  000a6	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000a9	89 45 40	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  000ac	8b 45 40	 mov	 eax, DWORD PTR $T20[ebp]
  000af	89 45 50	 mov	 DWORD PTR __Scary$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 854  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

  000b2	8d 45 67	 lea	 eax, DWORD PTR $T24[ebp]
  000b5	89 45 20	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000b8	8b 45 7c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  000bb	89 45 3c	 mov	 DWORD PTR $T19[ebp], eax
  000be	8b 45 3c	 mov	 eax, DWORD PTR $T19[ebp]
  000c1	89 45 38	 mov	 DWORD PTR $T18[ebp], eax
  000c4	8b 45 38	 mov	 eax, DWORD PTR $T18[ebp]
  000c7	89 45 34	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 245  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  000ca	8d 45 28	 lea	 eax, DWORD PTR $T14[ebp]
  000cd	89 45 30	 mov	 DWORD PTR _this$16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000d0	8b 45 34	 mov	 eax, DWORD PTR $T17[ebp]
  000d3	89 45 2c	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 163  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

  000d6	8b 45 30	 mov	 eax, DWORD PTR _this$16[ebp]
  000d9	8b 4d 2c	 mov	 ecx, DWORD PTR $T15[ebp]
  000dc	89 08		 mov	 DWORD PTR [eax], ecx

; 854  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

  000de	8d 45 28	 lea	 eax, DWORD PTR $T14[ebp]
  000e1	89 45 1c	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000e4	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000e7	89 45 24	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000ea	8b 45 24	 mov	 eax, DWORD PTR $T13[ebp]
  000ed	89 45 18	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 184  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

  000f0	ff 75 20	 push	 DWORD PTR $T12[ebp]
  000f3	ff 75 1c	 push	 DWORD PTR $T11[ebp]
  000f6	68 00 00 00 00	 push	 OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
  000fb	8b 45 50	 mov	 eax, DWORD PTR __Scary$[ebp]
  000fe	ff 30		 push	 DWORD PTR [eax]
  00100	ff 75 18	 push	 DWORD PTR $T10[ebp]
  00103	8d 4d e0	 lea	 ecx, DWORD PTR $T1[ebp]
  00106	e8 00 00 00 00	 call	 ??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABI@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABI@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > ><std::piecewise_construct_t const &,std::tuple<unsigned int const &>,std::tuple<> >
  0010b	89 45 14	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  0010e	83 65 10 00	 and	 DWORD PTR $T8[ebp], 0
  00112	8b 45 14	 mov	 eax, DWORD PTR $T9[ebp]
  00115	83 c0 04	 add	 eax, 4
  00118	89 45 54	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0011b	8b 45 54	 mov	 eax, DWORD PTR __Val$[ebp]
  0011e	8b 00		 mov	 eax, DWORD PTR [eax]
  00120	89 45 0c	 mov	 DWORD PTR __Old_val$7[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00123	8b 45 54	 mov	 eax, DWORD PTR __Val$[ebp]
  00126	8b 4d 10	 mov	 ecx, DWORD PTR $T8[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  0012b	8b 45 0c	 mov	 eax, DWORD PTR __Old_val$7[ebp]
  0012e	89 45 08	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  00131	8b 45 08	 mov	 eax, DWORD PTR $T6[ebp]
  00134	89 45 04	 mov	 DWORD PTR __Inserted$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 184  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

  00137	8d 4d e0	 lea	 ecx, DWORD PTR $T1[ebp]
  0013a	e8 00 00 00 00	 call	 ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 190  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0013f	ff 75 04	 push	 DWORD PTR __Inserted$[ebp]
  00142	ff 75 f0	 push	 DWORD PTR __Loc$[ebp+4]
  00145	ff 75 ec	 push	 DWORD PTR __Loc$[ebp]
  00148	8b 4d 50	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0014b	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Insert_node
  00150	89 45 00	 mov	 DWORD PTR $T5[ebp], eax
  00153	c6 45 6e 01	 mov	 BYTE PTR $T25[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00157	8d 45 00	 lea	 eax, DWORD PTR $T5[ebp]
  0015a	89 45 fc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0015d	8b 45 78	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00160	8b 4d fc	 mov	 ecx, DWORD PTR $T4[ebp]
  00163	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00165	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00167	8d 45 6e	 lea	 eax, DWORD PTR $T25[ebp]
  0016a	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0016d	8b 45 78	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00170	8b 4d f8	 mov	 ecx, DWORD PTR $T3[ebp]
  00173	8a 09		 mov	 cl, BYTE PTR [ecx]
  00175	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 190  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00178	8b 45 78	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Try_emplac:

; 191  :     }

  0017b	83 c5 70	 add	 ebp, 112		; 00000070H
  0017e	c9		 leave
  0017f	c2 08 00	 ret	 8
??$_Try_emplace@ABI$$V@?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@_N@1@ABI@Z ENDP ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Try_emplace<unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?GetMaxTextureHeight@@YAKXZ
_TEXT	SEGMENT
?GetMaxTextureHeight@@YAKXZ PROC			; GetMaxTextureHeight, COMDAT

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 305  : 	return s_MaxTextureHeight;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_MaxTextureHeight@@3KA

; 306  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?GetMaxTextureHeight@@YAKXZ ENDP			; GetMaxTextureHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?GetMaxTextureWidth@@YAKXZ
_TEXT	SEGMENT
?GetMaxTextureWidth@@YAKXZ PROC				; GetMaxTextureWidth, COMDAT

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 300  : 	return s_MaxTextureWidth;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_MaxTextureWidth@@3KA

; 301  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?GetMaxTextureWidth@@YAKXZ ENDP				; GetMaxTextureWidth
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?EL3D_ConfirmDevice@@YAHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
_rkD3DCaps$ = 8						; size = 4
_uBehavior$ = 12					; size = 4
___formal$ = 16						; size = 4
?EL3D_ConfirmDevice@@YAHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z PROC ; EL3D_ConfirmDevice, COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 264  : 	// PUREDEVICE GetTransform / GetViewport   .
; 265  : 	if (uBehavior & D3DCREATE_PUREDEVICE) 

  00003	8b 45 0c	 mov	 eax, DWORD PTR _uBehavior$[ebp]
  00006	83 e0 10	 and	 eax, 16			; 00000010H
  00009	74 04		 je	 SHORT $LN2@EL3D_Confi

; 266  :         return FALSE;

  0000b	33 c0		 xor	 eax, eax
  0000d	eb 75		 jmp	 SHORT $LN1@EL3D_Confi
$LN2@EL3D_Confi:

; 267  : 	
; 268  : 	if (uBehavior & D3DCREATE_HARDWARE_VERTEXPROCESSING) 

  0000f	8b 45 0c	 mov	 eax, DWORD PTR _uBehavior$[ebp]
  00012	83 e0 40	 and	 eax, 64			; 00000040H
  00015	74 54		 je	 SHORT $LN3@EL3D_Confi

; 269  : 	{	
; 270  : 		// DirectionalLight
; 271  : 		if (!(rkD3DCaps.VertexProcessingCaps & D3DVTXPCAPS_DIRECTIONALLIGHTS))

  00017	8b 45 08	 mov	 eax, DWORD PTR _rkD3DCaps$[ebp]
  0001a	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [eax+156]
  00020	83 e0 08	 and	 eax, 8
  00023	75 04		 jne	 SHORT $LN4@EL3D_Confi

; 272  : 			return FALSE;

  00025	33 c0		 xor	 eax, eax
  00027	eb 5b		 jmp	 SHORT $LN1@EL3D_Confi
$LN4@EL3D_Confi:

; 273  : 		
; 274  : 		// PositionalLight
; 275  : 		if (!(rkD3DCaps.VertexProcessingCaps & D3DVTXPCAPS_POSITIONALLIGHTS))

  00029	8b 45 08	 mov	 eax, DWORD PTR _rkD3DCaps$[ebp]
  0002c	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [eax+156]
  00032	83 e0 10	 and	 eax, 16			; 00000010H
  00035	75 04		 jne	 SHORT $LN5@EL3D_Confi

; 276  : 			return FALSE;

  00037	33 c0		 xor	 eax, eax
  00039	eb 49		 jmp	 SHORT $LN1@EL3D_Confi
$LN5@EL3D_Confi:

; 277  : 
; 278  : 		// Software T&L Support - ATI NOT SUPPORT CLIP, USE DIRECTX SOFTWARE PROCESSING CLIPPING
; 279  : 		if (GRAPHICS_CAPS_SOFTWARE_TILING)

  0003b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?GRAPHICS_CAPS_SOFTWARE_TILING@@3_NA ; GRAPHICS_CAPS_SOFTWARE_TILING
  00042	85 c0		 test	 eax, eax
  00044	74 13		 je	 SHORT $LN6@EL3D_Confi

; 280  : 		{
; 281  : 			if (!(rkD3DCaps.PrimitiveMiscCaps & D3DPMISCCAPS_CLIPTLVERTS))

  00046	8b 45 08	 mov	 eax, DWORD PTR _rkD3DCaps$[ebp]
  00049	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0004c	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00051	75 04		 jne	 SHORT $LN8@EL3D_Confi

; 282  : 				return FALSE;

  00053	33 c0		 xor	 eax, eax
  00055	eb 2d		 jmp	 SHORT $LN1@EL3D_Confi
$LN8@EL3D_Confi:

; 283  : 		}

  00057	eb 12		 jmp	 SHORT $LN3@EL3D_Confi
$LN6@EL3D_Confi:

; 284  : 		else
; 285  : 		{
; 286  : 			// Shadow/Terrain
; 287  : 			if (!(rkD3DCaps.VertexProcessingCaps & D3DVTXPCAPS_TEXGEN))

  00059	8b 45 08	 mov	 eax, DWORD PTR _rkD3DCaps$[ebp]
  0005c	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [eax+156]
  00062	83 e0 01	 and	 eax, 1
  00065	75 04		 jne	 SHORT $LN3@EL3D_Confi

; 288  : 				return FALSE;

  00067	33 c0		 xor	 eax, eax
  00069	eb 19		 jmp	 SHORT $LN1@EL3D_Confi
$LN3@EL3D_Confi:

; 289  : 		}
; 290  : 	}
; 291  : 
; 292  : 	s_MaxTextureWidth = rkD3DCaps.MaxTextureWidth;

  0006b	8b 45 08	 mov	 eax, DWORD PTR _rkD3DCaps$[ebp]
  0006e	8b 40 58	 mov	 eax, DWORD PTR [eax+88]
  00071	a3 00 00 00 00	 mov	 DWORD PTR ?s_MaxTextureWidth@@3KA, eax

; 293  : 	s_MaxTextureHeight = rkD3DCaps.MaxTextureHeight;

  00076	8b 45 08	 mov	 eax, DWORD PTR _rkD3DCaps$[ebp]
  00079	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  0007c	a3 00 00 00 00	 mov	 DWORD PTR ?s_MaxTextureHeight@@3KA, eax

; 294  : 	
; 295  : 	return TRUE;

  00081	33 c0		 xor	 eax, eax
  00083	40		 inc	 eax
$LN1@EL3D_Confi:

; 296  : }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?EL3D_ConfirmDevice@@YAHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z ENDP ; EL3D_ConfirmDevice
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCGraphicDevice@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCGraphicDevice@@UAEPAXI@Z PROC			; CGraphicDevice::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CGraphicDevice@@UAE@XZ ; CGraphicDevice::~CGraphicDevice
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GCGraphicDevice@@UAEPAXI@Z ENDP			; CGraphicDevice::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Parent_sibling$1 = -20				; size = 4
__Parent_sibling$2 = -16				; size = 4
_this$ = -12						; size = 4
__Head$ = -8						; size = 4
__Pnode$3 = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 645  :         ++_Mysize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	40		 inc	 eax
  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 646  :         const auto _Head  = _Myhead;

  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	89 45 f8	 mov	 DWORD PTR __Head$[ebp], eax

; 647  :         _Newnode->_Parent = _Loc._Parent;

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00027	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0002a	3b 45 f8	 cmp	 eax, DWORD PTR __Head$[ebp]
  0002d	75 29		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 650  :             _Head->_Parent   = _Newnode;

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 651  :             _Head->_Right    = _Newnode;

  00040	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00043	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00046	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 652  :             _Newnode->_Color = _Black; // the root is black

  00049	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0004c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 653  :             return _Newnode;

  00050	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00053	e9 a3 01 00 00	 jmp	 $LN18@Insert_nod
$LN5@Insert_nod:

; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00058	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  0005c	75 1f		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00061	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00064	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0006d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00070	75 09		 jne	 SHORT $LN8@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00075	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00078	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN8@Insert_nod:

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  0007b	eb 1a		 jmp	 SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00085	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0008b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0008d	75 08		 jne	 SHORT $LN7@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00092	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00097	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0009a	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax
$LN4@Insert_nod:
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a3	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000a7	85 c0		 test	 eax, eax
  000a9	0f 85 3f 01 00
	00		 jne	 $LN3@Insert_nod

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  000af	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  000bb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000be	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000c0	0f 85 95 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000c9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d2	89 45 f0	 mov	 DWORD PTR __Parent_sibling$2[ebp], eax

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  000d5	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000d8	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN12@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 676  :                     _Parent_sibling->_Color          = _Black;

  000ea	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000ed	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000f4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000fa	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00101	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00104	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00107	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 679  :                 } else { // parent's sibling has red and black children

  0010a	eb 4a		 jmp	 SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0010c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0010f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00112	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  00115	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00118	75 14		 jne	 SHORT $LN14@Insert_nod

; 681  :                         _Pnode = _Pnode->_Parent;

  0011a	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0011d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00120	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 682  :                         _Lrotate(_Pnode);

  00123	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lrotate
$LN14@Insert_nod:

; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0012e	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00131	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00134	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00138	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0013b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  00145	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00148	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014b	ff 70 04	 push	 DWORD PTR [eax+4]
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rrotate
$LN13@Insert_nod:

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00156	e9 8e 00 00 00	 jmp	 $LN11@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

  0015b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	89 45 ec	 mov	 DWORD PTR __Parent_sibling$1[ebp], eax

; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00169	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  0016c	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00170	85 c0		 test	 eax, eax
  00172	75 2c		 jne	 SHORT $LN15@Insert_nod

; 692  :                     _Pnode->_Parent->_Color          = _Black;

  00174	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00177	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0017a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 693  :                     _Parent_sibling->_Color          = _Black;

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  00181	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00185	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00188	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  00192	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00195	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00198	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019b	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 696  :                 } else { // parent's sibling has red and black children

  0019e	eb 49		 jmp	 SHORT $LN11@Insert_nod
$LN15@Insert_nod:

; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  001a0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  001a9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001ab	75 14		 jne	 SHORT $LN17@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  001ad	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b3	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 699  :                         _Rrotate(_Pnode);

  001b6	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  001b9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bc	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rrotate
$LN17@Insert_nod:

; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  001c1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c7	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001d8	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001db	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001de	ff 70 04	 push	 DWORD PTR [eax+4]
  001e1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lrotate
$LN11@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }

  001e9	e9 af fe ff ff	 jmp	 $LN4@Insert_nod
$LN3@Insert_nod:

; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001ee	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  001f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f4	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001f8	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
$LN18@Insert_nod:

; 711  :     }

  001fb	c9		 leave
  001fc	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rrotate, COMDAT
; _this$ = ecx

; 480  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 08		 mov	 DWORD PTR [eax], ecx

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0c		 jne	 SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  00035	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00049	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004c	75 0d		 jne	 SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00056	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00059	eb 27		 jmp	 SHORT $LN4@Rrotate
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  0005b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00064	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00067	75 0e		 jne	 SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00069	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00072	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  00075	eb 0b		 jmp	 SHORT $LN4@Rrotate
$LN5@Rrotate:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00077	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@Rrotate:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00082	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00088	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 499  :         _Wherenode->_Parent = _Pnode;

  0008b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 500  :     }

  00094	c9		 leave
  00095	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lrotate, COMDAT
; _this$ = ecx

; 458  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000e	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  00011	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0b		 jne	 SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00048	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004b	75 0d		 jne	 SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00055	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00058	eb 26		 jmp	 SHORT $LN4@Lrotate
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00063	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00065	75 0d		 jne	 SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 472  :         } else {

  00072	eb 0c		 jmp	 SHORT $LN4@Lrotate
$LN5@Lrotate:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  00074	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@Lrotate:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  00080	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00086	89 08		 mov	 DWORD PTR [eax], ecx

; 477  :         _Wherenode->_Parent = _Pnode;

  00088	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 478  :     }

  00091	c9		 leave
  00092	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S12$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S12$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1718 :     void _Check_grow_by_1() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1719 :         if (max_size() == _Get_scary()->_Mysize) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00023	75 05		 jne	 SHORT $LN3@Check_grow

; 1720 :             _Throw_tree_length_error();

  00025	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN3@Check_grow:

; 1721 :         }
; 1722 :     }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size, COMDAT
; _this$ = ecx

; 1310 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2043 :         return _Mypair._Myval2._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2043 :         return _Mypair._Myval2._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc 5d 74
	d1 05		 mov	 DWORD PTR $T7[ebp], 97612893 ; 05d1745dH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1312 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1313 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000f	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00015	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	83 20 00	 and	 DWORD PTR [eax], 0
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  00032	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 886  :         _Alloc_sentinel_and_proxy();

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c9		 leave
  00042	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?CreateDoublePNTStreamVertexShader@CGraphicDevice@@IAEKXZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
_ret$ = -44						; size = 4
_declVector$ = -40					; size = 36
__$ArrayPad$ = -4					; size = 4
?CreateDoublePNTStreamVertexShader@CGraphicDevice@@IAEKXZ PROC ; CGraphicDevice::CreateDoublePNTStreamVertexShader, COMDAT
; _this$ = ecx

; 204  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 205  : 	assert(ms_lpd3dDevice != NULL);
; 206  : 
; 207  : 	DWORD declVector[] = 
; 208  : 	{
; 209  : 		D3DVSD_STREAM(0),

  00013	c7 45 d8 00 00
	00 20		 mov	 DWORD PTR _declVector$[ebp], 536870912 ; 20000000H

; 210  : 		D3DVSD_REG(0, D3DVSDT_FLOAT3),

  0001a	c7 45 dc 00 00
	02 40		 mov	 DWORD PTR _declVector$[ebp+4], 1073872896 ; 40020000H

; 211  : 		D3DVSD_REG(3, D3DVSDT_FLOAT3),

  00021	c7 45 e0 03 00
	02 40		 mov	 DWORD PTR _declVector$[ebp+8], 1073872899 ; 40020003H

; 212  : 		D3DVSD_REG(7, D3DVSDT_FLOAT2),

  00028	c7 45 e4 07 00
	01 40		 mov	 DWORD PTR _declVector$[ebp+12], 1073807367 ; 40010007H

; 213  : 		D3DVSD_STREAM(1),

  0002f	c7 45 e8 01 00
	00 20		 mov	 DWORD PTR _declVector$[ebp+16], 536870913 ; 20000001H

; 214  : 		D3DVSD_REG(D3DVSDE_POSITION2, D3DVSDT_FLOAT3),

  00036	c7 45 ec 0f 00
	02 40		 mov	 DWORD PTR _declVector$[ebp+20], 1073872911 ; 4002000fH

; 215  : 		D3DVSD_REG(D3DVSDE_NORMAL2, D3DVSDT_FLOAT3),

  0003d	c7 45 f0 10 00
	02 40		 mov	 DWORD PTR _declVector$[ebp+24], 1073872912 ; 40020010H

; 216  : 		D3DVSD_REG(D3DVSDE_TEXCOORD1, D3DVSDT_FLOAT2),

  00044	c7 45 f4 08 00
	01 40		 mov	 DWORD PTR _declVector$[ebp+28], 1073807368 ; 40010008H

; 217  : 		D3DVSD_END()

  0004b	83 4d f8 ff	 or	 DWORD PTR _declVector$[ebp+32], -1

; 218  : 	};
; 219  : 
; 220  : 	DWORD ret;
; 221  : 
; 222  : 	if (FAILED(ms_lpd3dDevice->CreateVertexShader(&declVector[0], NULL, &ret, 0)))

  0004f	6a 00		 push	 0
  00051	8d 45 d4	 lea	 eax, DWORD PTR _ret$[ebp]
  00054	50		 push	 eax
  00055	6a 00		 push	 0
  00057	6a 04		 push	 4
  00059	58		 pop	 eax
  0005a	6b c0 00	 imul	 eax, eax, 0
  0005d	8d 44 05 d8	 lea	 eax, DWORD PTR _declVector$[ebp+eax]
  00061	50		 push	 eax
  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00067	8b 00		 mov	 eax, DWORD PTR [eax]
  00069	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0006f	ff 90 2c 01 00
	00		 call	 DWORD PTR [eax+300]
  00075	85 c0		 test	 eax, eax
  00077	7d 04		 jge	 SHORT $LN2@CreateDoub

; 223  : 		return 0;

  00079	33 c0		 xor	 eax, eax
  0007b	eb 03		 jmp	 SHORT $LN1@CreateDoub
$LN2@CreateDoub:

; 224  : 
; 225  : 	return ret;

  0007d	8b 45 d4	 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@CreateDoub:

; 226  : }

  00080	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00083	33 cd		 xor	 ecx, ebp
  00085	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008a	c9		 leave
  0008b	c3		 ret	 0
?CreateDoublePNTStreamVertexShader@CGraphicDevice@@IAEKXZ ENDP ; CGraphicDevice::CreateDoublePNTStreamVertexShader
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?CreatePNT2StreamVertexShader@CGraphicDevice@@IAEKXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
_ret$ = -32						; size = 4
_declVector$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
?CreatePNT2StreamVertexShader@CGraphicDevice@@IAEKXZ PROC ; CGraphicDevice::CreatePNT2StreamVertexShader, COMDAT
; _this$ = ecx

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  : 	assert(ms_lpd3dDevice != NULL);
; 162  : 
; 163  : 	DWORD declVector[] =
; 164  : 	{
; 165  : 		D3DVSD_STREAM(0),

  00013	c7 45 e4 00 00
	00 20		 mov	 DWORD PTR _declVector$[ebp], 536870912 ; 20000000H

; 166  : 		D3DVSD_REG(0, D3DVSDT_FLOAT3),

  0001a	c7 45 e8 00 00
	02 40		 mov	 DWORD PTR _declVector$[ebp+4], 1073872896 ; 40020000H

; 167  : 		D3DVSD_REG(3, D3DVSDT_FLOAT3),

  00021	c7 45 ec 03 00
	02 40		 mov	 DWORD PTR _declVector$[ebp+8], 1073872899 ; 40020003H

; 168  : 		D3DVSD_REG(7, D3DVSDT_FLOAT2),

  00028	c7 45 f0 07 00
	01 40		 mov	 DWORD PTR _declVector$[ebp+12], 1073807367 ; 40010007H

; 169  : 		D3DVSD_REG(D3DVSDE_TEXCOORD1, D3DVSDT_FLOAT2),

  0002f	c7 45 f4 08 00
	01 40		 mov	 DWORD PTR _declVector$[ebp+16], 1073807368 ; 40010008H

; 170  : //		D3DVSD_STREAM(1),
; 171  : 		D3DVSD_END()

  00036	83 4d f8 ff	 or	 DWORD PTR _declVector$[ebp+20], -1

; 172  : 	};
; 173  : 
; 174  : 	DWORD ret;
; 175  : 
; 176  : 	if (FAILED(ms_lpd3dDevice->CreateVertexShader(&declVector[0], NULL, &ret, 0)))

  0003a	6a 00		 push	 0
  0003c	8d 45 e0	 lea	 eax, DWORD PTR _ret$[ebp]
  0003f	50		 push	 eax
  00040	6a 00		 push	 0
  00042	6a 04		 push	 4
  00044	58		 pop	 eax
  00045	6b c0 00	 imul	 eax, eax, 0
  00048	8d 44 05 e4	 lea	 eax, DWORD PTR _declVector$[ebp+eax]
  0004c	50		 push	 eax
  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0005a	ff 90 2c 01 00
	00		 call	 DWORD PTR [eax+300]
  00060	85 c0		 test	 eax, eax
  00062	7d 04		 jge	 SHORT $LN2@CreatePNT2

; 177  : 		return 0;

  00064	33 c0		 xor	 eax, eax
  00066	eb 03		 jmp	 SHORT $LN1@CreatePNT2
$LN2@CreatePNT2:

; 178  : 
; 179  : 	return ret;

  00068	8b 45 e0	 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@CreatePNT2:

; 180  : }

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006e	33 cd		 xor	 ecx, ebp
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	c9		 leave
  00076	c3		 ret	 0
?CreatePNT2StreamVertexShader@CGraphicDevice@@IAEKXZ ENDP ; CGraphicDevice::CreatePNT2StreamVertexShader
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?CreatePNTStreamVertexShader@CGraphicDevice@@IAEKXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
_ret$ = -28						; size = 4
_declVector$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
?CreatePNTStreamVertexShader@CGraphicDevice@@IAEKXZ PROC ; CGraphicDevice::CreatePNTStreamVertexShader, COMDAT
; _this$ = ecx

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 140  : 	assert(ms_lpd3dDevice != NULL);
; 141  : 	
; 142  : 	DWORD declVector[] =
; 143  : 	{
; 144  : 		D3DVSD_STREAM(0),

  00013	c7 45 e8 00 00
	00 20		 mov	 DWORD PTR _declVector$[ebp], 536870912 ; 20000000H

; 145  : 		D3DVSD_REG(0, D3DVSDT_FLOAT3),

  0001a	c7 45 ec 00 00
	02 40		 mov	 DWORD PTR _declVector$[ebp+4], 1073872896 ; 40020000H

; 146  : 		D3DVSD_REG(3, D3DVSDT_FLOAT3),

  00021	c7 45 f0 03 00
	02 40		 mov	 DWORD PTR _declVector$[ebp+8], 1073872899 ; 40020003H

; 147  : 		D3DVSD_REG(7, D3DVSDT_FLOAT2),

  00028	c7 45 f4 07 00
	01 40		 mov	 DWORD PTR _declVector$[ebp+12], 1073807367 ; 40010007H

; 148  : 		D3DVSD_END()

  0002f	83 4d f8 ff	 or	 DWORD PTR _declVector$[ebp+16], -1

; 149  : 	};
; 150  : 	
; 151  : 	DWORD ret;
; 152  : 	
; 153  : 	if (FAILED(ms_lpd3dDevice->CreateVertexShader(&declVector[0], NULL, &ret, 0)))

  00033	6a 00		 push	 0
  00035	8d 45 e4	 lea	 eax, DWORD PTR _ret$[ebp]
  00038	50		 push	 eax
  00039	6a 00		 push	 0
  0003b	6a 04		 push	 4
  0003d	58		 pop	 eax
  0003e	6b c0 00	 imul	 eax, eax, 0
  00041	8d 44 05 e8	 lea	 eax, DWORD PTR _declVector$[ebp+eax]
  00045	50		 push	 eax
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00053	ff 90 2c 01 00
	00		 call	 DWORD PTR [eax+300]
  00059	85 c0		 test	 eax, eax
  0005b	7d 04		 jge	 SHORT $LN2@CreatePNTS

; 154  : 		return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 03		 jmp	 SHORT $LN1@CreatePNTS
$LN2@CreatePNTS:

; 155  : 	
; 156  : 	return ret;

  00061	8b 45 e4	 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@CreatePNTS:

; 157  : }

  00064	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00067	33 cd		 xor	 ecx, ebp
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	c9		 leave
  0006f	c3		 ret	 0
?CreatePNTStreamVertexShader@CGraphicDevice@@IAEKXZ ENDP ; CGraphicDevice::CreatePNTStreamVertexShader
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?CreatePTStreamVertexShader@CGraphicDevice@@IAEKXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
_ret$ = -28						; size = 4
_declVector$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
?CreatePTStreamVertexShader@CGraphicDevice@@IAEKXZ PROC	; CGraphicDevice::CreatePTStreamVertexShader, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 	assert(ms_lpd3dDevice != NULL);
; 185  : 
; 186  : 	DWORD declVector[] = 
; 187  : 	{
; 188  : 		D3DVSD_STREAM(0),

  00013	c7 45 e8 00 00
	00 20		 mov	 DWORD PTR _declVector$[ebp], 536870912 ; 20000000H

; 189  : 		D3DVSD_REG(0, D3DVSDT_FLOAT3),

  0001a	c7 45 ec 00 00
	02 40		 mov	 DWORD PTR _declVector$[ebp+4], 1073872896 ; 40020000H

; 190  : 		D3DVSD_STREAM(1),

  00021	c7 45 f0 01 00
	00 20		 mov	 DWORD PTR _declVector$[ebp+8], 536870913 ; 20000001H

; 191  : 		D3DVSD_REG(7, D3DVSDT_FLOAT2),

  00028	c7 45 f4 07 00
	01 40		 mov	 DWORD PTR _declVector$[ebp+12], 1073807367 ; 40010007H

; 192  : 		D3DVSD_END()

  0002f	83 4d f8 ff	 or	 DWORD PTR _declVector$[ebp+16], -1

; 193  : 	};
; 194  : 
; 195  : 	DWORD ret;
; 196  : 
; 197  : 	if (FAILED(ms_lpd3dDevice->CreateVertexShader(&declVector[0], NULL, &ret, 0)))

  00033	6a 00		 push	 0
  00035	8d 45 e4	 lea	 eax, DWORD PTR _ret$[ebp]
  00038	50		 push	 eax
  00039	6a 00		 push	 0
  0003b	6a 04		 push	 4
  0003d	58		 pop	 eax
  0003e	6b c0 00	 imul	 eax, eax, 0
  00041	8d 44 05 e8	 lea	 eax, DWORD PTR _declVector$[ebp+eax]
  00045	50		 push	 eax
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00053	ff 90 2c 01 00
	00		 call	 DWORD PTR [eax+300]
  00059	85 c0		 test	 eax, eax
  0005b	7d 04		 jge	 SHORT $LN2@CreatePTSt

; 198  : 		return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 03		 jmp	 SHORT $LN1@CreatePTSt
$LN2@CreatePTSt:

; 199  : 
; 200  : 	return (ret);

  00061	8b 45 e4	 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@CreatePTSt:

; 201  : }

  00064	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00067	33 cd		 xor	 ecx, ebp
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	c9		 leave
  0006f	c3		 ret	 0
?CreatePTStreamVertexShader@CGraphicDevice@@IAEKXZ ENDP	; CGraphicDevice::CreatePTStreamVertexShader
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?__CreatePDTVertexBufferList@CGraphicDevice@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?__CreatePDTVertexBufferList@CGraphicDevice@@IAE_NXZ PROC ; CGraphicDevice::__CreatePDTVertexBufferList, COMDAT
; _this$ = ecx

; 620  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 	for (UINT i=0; i<PDT_VERTEXBUFFER_NUM; ++i)

  00008	83 65 fc 00	 and	 DWORD PTR _i$1[ebp], 0
  0000c	eb 07		 jmp	 SHORT $LN4@CreatePDTV
$LN2@CreatePDTV:
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00011	40		 inc	 eax
  00012	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@CreatePDTV:
  00015	83 7d fc 64	 cmp	 DWORD PTR _i$1[ebp], 100 ; 00000064H
  00019	73 36		 jae	 SHORT $LN3@CreatePDTV

; 622  : 	{
; 623  : 		if (FAILED(

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0001e	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR ?ms_alpd3dPDTVB@CGraphicBase@@1PAPAUIDirect3DVertexBuffer8@@A[eax*4]
  00025	50		 push	 eax
  00026	6a 02		 push	 2
  00028	68 42 01 00 00	 push	 322			; 00000142H
  0002d	68 08 02 00 00	 push	 520			; 00000208H
  00032	68 80 01 00 00	 push	 384			; 00000180H
  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00044	ff 50 5c	 call	 DWORD PTR [eax+92]
  00047	85 c0		 test	 eax, eax
  00049	7d 04		 jge	 SHORT $LN5@CreatePDTV

; 624  : 			ms_lpd3dDevice->CreateVertexBuffer(
; 625  : 			sizeof(TPDTVertex)*PDT_VERTEX_NUM, 
; 626  : 			D3DUSAGE_DYNAMIC|D3DUSAGE_WRITEONLY, 
; 627  : 			D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1, 
; 628  : 			D3DPOOL_SYSTEMMEM, 
; 629  : 			&ms_alpd3dPDTVB[i])
; 630  : 		))
; 631  : 		return false;

  0004b	32 c0		 xor	 al, al
  0004d	eb 04		 jmp	 SHORT $LN1@CreatePDTV
$LN5@CreatePDTV:

; 632  : 	}

  0004f	eb bd		 jmp	 SHORT $LN2@CreatePDTV
$LN3@CreatePDTV:

; 633  : 	return true;

  00051	b0 01		 mov	 al, 1
$LN1@CreatePDTV:

; 634  : }

  00053	c9		 leave
  00054	c3		 ret	 0
?__CreatePDTVertexBufferList@CGraphicDevice@@IAE_NXZ ENDP ; CGraphicDevice::__CreatePDTVertexBufferList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?__DestroyPDTVertexBufferList@CGraphicDevice@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?__DestroyPDTVertexBufferList@CGraphicDevice@@IAEXXZ PROC ; CGraphicDevice::__DestroyPDTVertexBufferList, COMDAT
; _this$ = ecx

; 608  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 609  : 	for (UINT i=0; i<PDT_VERTEXBUFFER_NUM; ++i)

  00008	83 65 fc 00	 and	 DWORD PTR _i$1[ebp], 0
  0000c	eb 07		 jmp	 SHORT $LN4@DestroyPDT
$LN2@DestroyPDT:
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00011	40		 inc	 eax
  00012	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@DestroyPDT:
  00015	83 7d fc 64	 cmp	 DWORD PTR _i$1[ebp], 100 ; 00000064H
  00019	73 33		 jae	 SHORT $LN1@DestroyPDT

; 610  : 	{
; 611  : 		if (ms_alpd3dPDTVB[i])

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0001e	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR ?ms_alpd3dPDTVB@CGraphicBase@@1PAPAUIDirect3DVertexBuffer8@@A[eax*4], 0
  00026	74 24		 je	 SHORT $LN5@DestroyPDT

; 612  : 		{
; 613  : 			ms_alpd3dPDTVB[i]->Release();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0002b	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?ms_alpd3dPDTVB@CGraphicBase@@1PAPAUIDirect3DVertexBuffer8@@A[eax*4]
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _i$1[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	ff 34 8d 00 00
	00 00		 push	 DWORD PTR ?ms_alpd3dPDTVB@CGraphicBase@@1PAPAUIDirect3DVertexBuffer8@@A[ecx*4]
  0003e	ff 50 08	 call	 DWORD PTR [eax+8]

; 614  : 			ms_alpd3dPDTVB[i]=NULL;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00044	83 24 85 00 00
	00 00 00	 and	 DWORD PTR ?ms_alpd3dPDTVB@CGraphicBase@@1PAPAUIDirect3DVertexBuffer8@@A[eax*4], 0
$LN5@DestroyPDT:

; 615  : 		}
; 616  : 	}

  0004c	eb c0		 jmp	 SHORT $LN2@DestroyPDT
$LN1@DestroyPDT:

; 617  : }

  0004e	c9		 leave
  0004f	c3		 ret	 0
?__DestroyPDTVertexBufferList@CGraphicDevice@@IAEXXZ ENDP ; CGraphicDevice::__DestroyPDTVertexBufferList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?__InitializePDTVertexBufferList@CGraphicDevice@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?__InitializePDTVertexBufferList@CGraphicDevice@@IAEXXZ PROC ; CGraphicDevice::__InitializePDTVertexBufferList, COMDAT
; _this$ = ecx

; 602  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 603  : 	for (UINT i=0; i<PDT_VERTEXBUFFER_NUM; ++i)

  00008	83 65 fc 00	 and	 DWORD PTR _i$1[ebp], 0
  0000c	eb 07		 jmp	 SHORT $LN4@Initialize
$LN2@Initialize:
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00011	40		 inc	 eax
  00012	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Initialize:
  00015	83 7d fc 64	 cmp	 DWORD PTR _i$1[ebp], 100 ; 00000064H
  00019	73 0d		 jae	 SHORT $LN1@Initialize

; 604  : 		ms_alpd3dPDTVB[i]=NULL;	

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0001e	83 24 85 00 00
	00 00 00	 and	 DWORD PTR ?ms_alpd3dPDTVB@CGraphicBase@@1PAPAUIDirect3DVertexBuffer8@@A[eax*4], 0
  00026	eb e6		 jmp	 SHORT $LN2@Initialize
$LN1@Initialize:

; 605  : }

  00028	c9		 leave
  00029	c3		 ret	 0
?__InitializePDTVertexBufferList@CGraphicDevice@@IAEXXZ ENDP ; CGraphicDevice::__InitializePDTVertexBufferList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?__CreateDefaultIndexBuffer@CGraphicDevice@@IAE_NIIPBG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_dstIndices$ = -4					; size = 4
_eDefIB$ = 8						; size = 4
_uIdxCount$ = 12					; size = 4
_c_awIndices$ = 16					; size = 4
?__CreateDefaultIndexBuffer@CGraphicDevice@@IAE_NIIPBG@Z PROC ; CGraphicDevice::__CreateDefaultIndexBuffer, COMDAT
; _this$ = ecx

; 653  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 654  : 	assert(ms_alpd3dDefIB[eDefIB]==NULL);
; 655  : 
; 656  : 	if (FAILED(

  00008	8b 45 08	 mov	 eax, DWORD PTR _eDefIB$[ebp]
  0000b	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR ?ms_alpd3dDefIB@CGraphicBase@@1PAPAUIDirect3DIndexBuffer8@@A[eax*4]
  00012	50		 push	 eax
  00013	6a 01		 push	 1
  00015	6a 65		 push	 101			; 00000065H
  00017	6a 08		 push	 8
  00019	8b 45 0c	 mov	 eax, DWORD PTR _uIdxCount$[ebp]
  0001c	d1 e0		 shl	 eax, 1
  0001e	50		 push	 eax
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0002c	ff 50 60	 call	 DWORD PTR [eax+96]
  0002f	85 c0		 test	 eax, eax
  00031	7d 04		 jge	 SHORT $LN2@CreateDefa

; 657  : 		ms_lpd3dDevice->CreateIndexBuffer(
; 658  : 			sizeof(WORD)*uIdxCount, 
; 659  : 			D3DUSAGE_WRITEONLY, 
; 660  : 			D3DFMT_INDEX16,
; 661  : 			D3DPOOL_MANAGED,
; 662  : 			&ms_alpd3dDefIB[eDefIB])
; 663  : 	)) return false;

  00033	32 c0		 xor	 al, al
  00035	eb 5a		 jmp	 SHORT $LN1@CreateDefa
$LN2@CreateDefa:

; 664  : 	
; 665  : 	WORD* dstIndices;
; 666  : 	if (FAILED(

  00037	6a 00		 push	 0
  00039	8d 45 fc	 lea	 eax, DWORD PTR _dstIndices$[ebp]
  0003c	50		 push	 eax
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	8b 45 08	 mov	 eax, DWORD PTR _eDefIB$[ebp]
  00044	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?ms_alpd3dDefIB@CGraphicBase@@1PAPAUIDirect3DIndexBuffer8@@A[eax*4]
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _eDefIB$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]
  00050	ff 34 8d 00 00
	00 00		 push	 DWORD PTR ?ms_alpd3dDefIB@CGraphicBase@@1PAPAUIDirect3DIndexBuffer8@@A[ecx*4]
  00057	ff 50 2c	 call	 DWORD PTR [eax+44]
  0005a	85 c0		 test	 eax, eax
  0005c	7d 04		 jge	 SHORT $LN3@CreateDefa

; 667  : 		ms_alpd3dDefIB[eDefIB]->Lock(0, 0, (BYTE**)&dstIndices, 0)
; 668  : 	)) return false;

  0005e	32 c0		 xor	 al, al
  00060	eb 2f		 jmp	 SHORT $LN1@CreateDefa
$LN3@CreateDefa:

; 669  : 
; 670  : 	memcpy(dstIndices, c_awIndices, sizeof(WORD)*uIdxCount);

  00062	8b 45 0c	 mov	 eax, DWORD PTR _uIdxCount$[ebp]
  00065	d1 e0		 shl	 eax, 1
  00067	50		 push	 eax
  00068	ff 75 10	 push	 DWORD PTR _c_awIndices$[ebp]
  0006b	ff 75 fc	 push	 DWORD PTR _dstIndices$[ebp]
  0006e	e8 00 00 00 00	 call	 _memcpy
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 671  : 
; 672  : 	ms_alpd3dDefIB[eDefIB]->Unlock();

  00076	8b 45 08	 mov	 eax, DWORD PTR _eDefIB$[ebp]
  00079	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?ms_alpd3dDefIB@CGraphicBase@@1PAPAUIDirect3DIndexBuffer8@@A[eax*4]
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _eDefIB$[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]
  00085	ff 34 8d 00 00
	00 00		 push	 DWORD PTR ?ms_alpd3dDefIB@CGraphicBase@@1PAPAUIDirect3DIndexBuffer8@@A[ecx*4]
  0008c	ff 50 30	 call	 DWORD PTR [eax+48]

; 673  : 
; 674  : 	return true;

  0008f	b0 01		 mov	 al, 1
$LN1@CreateDefa:

; 675  : }

  00091	c9		 leave
  00092	c2 0c 00	 ret	 12			; 0000000cH
?__CreateDefaultIndexBuffer@CGraphicDevice@@IAE_NIIPBG@Z ENDP ; CGraphicDevice::__CreateDefaultIndexBuffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ PROC ; CGraphicDevice::__CreateDefaultIndexBufferList, COMDAT
; _this$ = ecx

; 678  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 679  : 	static const WORD c_awLineIndices[2] = { 0, 1, };
; 680  : 	static const WORD c_awLineTriIndices[6] = { 0, 1, 0, 2, 1, 2, };
; 681  : 	static const WORD c_awLineRectIndices[8] = { 0, 1, 0, 2, 1, 3, 2, 3,};
; 682  : 	static const WORD c_awLineCubeIndices[24] = { 
; 683  : 		0, 1, 0, 2, 1, 3, 2, 3,
; 684  : 		0, 4, 1, 5, 2, 6, 3, 7,
; 685  : 		4, 5, 4, 6, 5, 7, 6, 7,
; 686  : 	};
; 687  : 	static const WORD c_awFillTriIndices[3]= { 0, 1, 2, };
; 688  : 	static const WORD c_awFillRectIndices[6] = { 0, 2, 1, 2, 3, 1, };
; 689  : 	static const WORD c_awFillCubeIndices[36] = { 
; 690  : 		0, 1, 2, 1, 3, 2,
; 691  : 		2, 0, 6, 0, 4, 6,
; 692  : 		0, 1, 4, 1, 5, 4,
; 693  : 		1, 3, 5, 3, 7, 5,
; 694  : 		3, 2, 7, 2, 6, 7,
; 695  : 		4, 5, 6, 5, 7, 6,
; 696  : 	};
; 697  : 	
; 698  : 	if (!__CreateDefaultIndexBuffer(DEFAULT_IB_LINE, 2, c_awLineIndices))

  00007	68 00 00 00 00	 push	 OFFSET ?c_awLineIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
  0000c	6a 02		 push	 2
  0000e	6a 00		 push	 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?__CreateDefaultIndexBuffer@CGraphicDevice@@IAE_NIIPBG@Z ; CGraphicDevice::__CreateDefaultIndexBuffer
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 07		 jne	 SHORT $LN2@CreateDefa

; 699  : 		return false;

  0001f	32 c0		 xor	 al, al
  00021	e9 ad 00 00 00	 jmp	 $LN1@CreateDefa
$LN2@CreateDefa:

; 700  : 	if (!__CreateDefaultIndexBuffer(DEFAULT_IB_LINE_TRI, 6, c_awLineTriIndices))

  00026	68 00 00 00 00	 push	 OFFSET ?c_awLineTriIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
  0002b	6a 06		 push	 6
  0002d	6a 01		 push	 1
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?__CreateDefaultIndexBuffer@CGraphicDevice@@IAE_NIIPBG@Z ; CGraphicDevice::__CreateDefaultIndexBuffer
  00037	0f b6 c0	 movzx	 eax, al
  0003a	85 c0		 test	 eax, eax
  0003c	75 07		 jne	 SHORT $LN3@CreateDefa

; 701  : 		return false;

  0003e	32 c0		 xor	 al, al
  00040	e9 8e 00 00 00	 jmp	 $LN1@CreateDefa
$LN3@CreateDefa:

; 702  : 	if (!__CreateDefaultIndexBuffer(DEFAULT_IB_LINE_RECT, 8, c_awLineRectIndices))

  00045	68 00 00 00 00	 push	 OFFSET ?c_awLineRectIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
  0004a	6a 08		 push	 8
  0004c	6a 02		 push	 2
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?__CreateDefaultIndexBuffer@CGraphicDevice@@IAE_NIIPBG@Z ; CGraphicDevice::__CreateDefaultIndexBuffer
  00056	0f b6 c0	 movzx	 eax, al
  00059	85 c0		 test	 eax, eax
  0005b	75 04		 jne	 SHORT $LN4@CreateDefa

; 703  : 		return false;

  0005d	32 c0		 xor	 al, al
  0005f	eb 72		 jmp	 SHORT $LN1@CreateDefa
$LN4@CreateDefa:

; 704  : 	if (!__CreateDefaultIndexBuffer(DEFAULT_IB_LINE_CUBE, 24, c_awLineCubeIndices))

  00061	68 00 00 00 00	 push	 OFFSET ?c_awLineCubeIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
  00066	6a 18		 push	 24			; 00000018H
  00068	6a 03		 push	 3
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?__CreateDefaultIndexBuffer@CGraphicDevice@@IAE_NIIPBG@Z ; CGraphicDevice::__CreateDefaultIndexBuffer
  00072	0f b6 c0	 movzx	 eax, al
  00075	85 c0		 test	 eax, eax
  00077	75 04		 jne	 SHORT $LN5@CreateDefa

; 705  : 		return false;

  00079	32 c0		 xor	 al, al
  0007b	eb 56		 jmp	 SHORT $LN1@CreateDefa
$LN5@CreateDefa:

; 706  : 	if (!__CreateDefaultIndexBuffer(DEFAULT_IB_FILL_TRI, 3, c_awFillTriIndices))

  0007d	68 00 00 00 00	 push	 OFFSET ?c_awFillTriIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
  00082	6a 03		 push	 3
  00084	6a 04		 push	 4
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?__CreateDefaultIndexBuffer@CGraphicDevice@@IAE_NIIPBG@Z ; CGraphicDevice::__CreateDefaultIndexBuffer
  0008e	0f b6 c0	 movzx	 eax, al
  00091	85 c0		 test	 eax, eax
  00093	75 04		 jne	 SHORT $LN6@CreateDefa

; 707  : 		return false;

  00095	32 c0		 xor	 al, al
  00097	eb 3a		 jmp	 SHORT $LN1@CreateDefa
$LN6@CreateDefa:

; 708  : 	if (!__CreateDefaultIndexBuffer(DEFAULT_IB_FILL_RECT, 6, c_awFillRectIndices))

  00099	68 00 00 00 00	 push	 OFFSET ?c_awFillRectIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
  0009e	6a 06		 push	 6
  000a0	6a 05		 push	 5
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?__CreateDefaultIndexBuffer@CGraphicDevice@@IAE_NIIPBG@Z ; CGraphicDevice::__CreateDefaultIndexBuffer
  000aa	0f b6 c0	 movzx	 eax, al
  000ad	85 c0		 test	 eax, eax
  000af	75 04		 jne	 SHORT $LN7@CreateDefa

; 709  : 		return false;

  000b1	32 c0		 xor	 al, al
  000b3	eb 1e		 jmp	 SHORT $LN1@CreateDefa
$LN7@CreateDefa:

; 710  : 	if (!__CreateDefaultIndexBuffer(DEFAULT_IB_FILL_CUBE, 36, c_awFillCubeIndices))

  000b5	68 00 00 00 00	 push	 OFFSET ?c_awFillCubeIndices@?1??__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ@4QBGB
  000ba	6a 24		 push	 36			; 00000024H
  000bc	6a 06		 push	 6
  000be	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?__CreateDefaultIndexBuffer@CGraphicDevice@@IAE_NIIPBG@Z ; CGraphicDevice::__CreateDefaultIndexBuffer
  000c6	0f b6 c0	 movzx	 eax, al
  000c9	85 c0		 test	 eax, eax
  000cb	75 04		 jne	 SHORT $LN8@CreateDefa

; 711  : 		return false;

  000cd	32 c0		 xor	 al, al
  000cf	eb 02		 jmp	 SHORT $LN1@CreateDefa
$LN8@CreateDefa:

; 712  : 	
; 713  : 	return true;

  000d1	b0 01		 mov	 al, 1
$LN1@CreateDefa:

; 714  : }

  000d3	c9		 leave
  000d4	c3		 ret	 0
?__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ ENDP ; CGraphicDevice::__CreateDefaultIndexBufferList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?__DestroyDefaultIndexBufferList@CGraphicDevice@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?__DestroyDefaultIndexBufferList@CGraphicDevice@@IAEXXZ PROC ; CGraphicDevice::__DestroyDefaultIndexBufferList, COMDAT
; _this$ = ecx

; 643  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 644  : 	for (UINT i=0; i<DEFAULT_IB_NUM; ++i)

  00008	83 65 fc 00	 and	 DWORD PTR _i$1[ebp], 0
  0000c	eb 07		 jmp	 SHORT $LN4@DestroyDef
$LN2@DestroyDef:
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00011	40		 inc	 eax
  00012	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@DestroyDef:
  00015	83 7d fc 07	 cmp	 DWORD PTR _i$1[ebp], 7
  00019	73 33		 jae	 SHORT $LN1@DestroyDef

; 645  : 		if (ms_alpd3dDefIB[i])

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0001e	83 3c 85 00 00
	00 00 00	 cmp	 DWORD PTR ?ms_alpd3dDefIB@CGraphicBase@@1PAPAUIDirect3DIndexBuffer8@@A[eax*4], 0
  00026	74 24		 je	 SHORT $LN5@DestroyDef

; 646  : 		{
; 647  : 			ms_alpd3dDefIB[i]->Release();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0002b	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?ms_alpd3dDefIB@CGraphicBase@@1PAPAUIDirect3DIndexBuffer8@@A[eax*4]
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _i$1[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	ff 34 8d 00 00
	00 00		 push	 DWORD PTR ?ms_alpd3dDefIB@CGraphicBase@@1PAPAUIDirect3DIndexBuffer8@@A[ecx*4]
  0003e	ff 50 08	 call	 DWORD PTR [eax+8]

; 648  : 			ms_alpd3dDefIB[i]=NULL;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00044	83 24 85 00 00
	00 00 00	 and	 DWORD PTR ?ms_alpd3dDefIB@CGraphicBase@@1PAPAUIDirect3DIndexBuffer8@@A[eax*4], 0
$LN5@DestroyDef:

; 649  : 		}	

  0004c	eb c0		 jmp	 SHORT $LN2@DestroyDef
$LN1@DestroyDef:

; 650  : }

  0004e	c9		 leave
  0004f	c3		 ret	 0
?__DestroyDefaultIndexBufferList@CGraphicDevice@@IAEXXZ ENDP ; CGraphicDevice::__DestroyDefaultIndexBufferList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?__InitializeDefaultIndexBufferList@CGraphicDevice@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?__InitializeDefaultIndexBufferList@CGraphicDevice@@IAEXXZ PROC ; CGraphicDevice::__InitializeDefaultIndexBufferList, COMDAT
; _this$ = ecx

; 637  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 638  : 	for (UINT i=0; i<DEFAULT_IB_NUM; ++i)

  00008	83 65 fc 00	 and	 DWORD PTR _i$1[ebp], 0
  0000c	eb 07		 jmp	 SHORT $LN4@Initialize
$LN2@Initialize:
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00011	40		 inc	 eax
  00012	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Initialize:
  00015	83 7d fc 07	 cmp	 DWORD PTR _i$1[ebp], 7
  00019	73 0d		 jae	 SHORT $LN1@Initialize

; 639  : 		ms_alpd3dDefIB[i]=NULL;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0001e	83 24 85 00 00
	00 00 00	 and	 DWORD PTR ?ms_alpd3dDefIB@CGraphicBase@@1PAPAUIDirect3DIndexBuffer8@@A[eax*4], 0
  00026	eb e6		 jmp	 SHORT $LN2@Initialize
$LN1@Initialize:

; 640  : }

  00028	c9		 leave
  00029	c3		 ret	 0
?__InitializeDefaultIndexBufferList@CGraphicDevice@@IAEXXZ ENDP ; CGraphicDevice::__InitializeDefaultIndexBufferList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?__WarningMessage@CGraphicDevice@@IAEXPAUHWND__@@I@Z
_TEXT	SEGMENT
$T1 = -64						; size = 8
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
___param0$ = -36					; size = 4
__Scary$7 = -32						; size = 4
$T8 = -28						; size = 4
___param0$ = -24					; size = 4
$T9 = -20						; size = 4
tv201 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
$T10 = -1						; size = 1
_hWnd$ = 8						; size = 4
_uiMsg$ = 12						; size = 4
?__WarningMessage@CGraphicDevice@@IAEXPAUHWND__@@I@Z PROC ; CGraphicDevice::__WarningMessage, COMDAT
; _this$ = ecx

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 53   : 	if (m_kMap_strWarningMessage.end() == m_kMap_strWarningMessage.find(uiMsg))

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00012	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00015	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00018	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  0001b	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  0001e	8d 45 0c	 lea	 eax, DWORD PTR _uiMsg$[ebp]
  00021	50		 push	 eax
  00022	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ??$_Find@I@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@1@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Find<unsigned int>
  0002a	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0002d	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00030	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00039	89 45 e4	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0003c	8b 45 e4	 mov	 eax, DWORD PTR $T8[ebp]
  0003f	89 45 e0	 mov	 DWORD PTR __Scary$7[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00042	8b 45 e0	 mov	 eax, DWORD PTR __Scary$7[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0004a	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  0004d	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00050	8d 45 d8	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  00056	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	3b 45 d0	 cmp	 eax, DWORD PTR $T4[ebp]
  0005e	75 09		 jne	 SHORT $LN72@WarningMes
  00060	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv201[ebp], 1
  00067	eb 04		 jmp	 SHORT $LN73@WarningMes
$LN72@WarningMes:
  00069	83 65 f0 00	 and	 DWORD PTR tv201[ebp], 0
$LN73@WarningMes:
  0006d	8a 45 f0	 mov	 al, BYTE PTR tv201[ebp]
  00070	88 45 ff	 mov	 BYTE PTR $T10[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 53   : 	if (m_kMap_strWarningMessage.end() == m_kMap_strWarningMessage.find(uiMsg))

  00073	0f b6 45 ff	 movzx	 eax, BYTE PTR $T10[ebp]
  00077	85 c0		 test	 eax, eax
  00079	74 02		 je	 SHORT $LN2@WarningMes

; 54   : 		return;

  0007b	eb 37		 jmp	 SHORT $LN1@WarningMes
$LN2@WarningMes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 325  :         return _Try_emplace(_Keyval).first->_Myval.second;

  0007d	8d 45 0c	 lea	 eax, DWORD PTR _uiMsg$[ebp]
  00080	50		 push	 eax
  00081	8d 45 c0	 lea	 eax, DWORD PTR $T1[ebp]
  00084	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 55   : 	MessageBox(hWnd, m_kMap_strWarningMessage[uiMsg].c_str(), "Warning", MB_OK|MB_TOPMOST);

  00085	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 08	 add	 ecx, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 325  :         return _Try_emplace(_Keyval).first->_Myval.second;

  0008b	e8 00 00 00 00	 call	 ??$_Try_emplace@ABI$$V@?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@_N@1@ABI@Z ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Try_emplace<unsigned int const &>
  00090	8b 00		 mov	 eax, DWORD PTR [eax]
  00092	83 c0 14	 add	 eax, 20			; 00000014H
  00095	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 55   : 	MessageBox(hWnd, m_kMap_strWarningMessage[uiMsg].c_str(), "Warning", MB_OK|MB_TOPMOST);

  00098	68 00 00 04 00	 push	 262144			; 00040000H
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_07KGMMFLDN@Warning@
  000a2	8b 4d cc	 mov	 ecx, DWORD PTR $T3[ebp]
  000a5	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000aa	50		 push	 eax
  000ab	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN1@WarningMes:

; 56   : }

  000b4	c9		 leave
  000b5	c2 08 00	 ret	 8
?__WarningMessage@CGraphicDevice@@IAEXPAUHWND__@@I@Z ENDP ; CGraphicDevice::__WarningMessage
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?__IsInDriverBlackList@CGraphicDevice@@IAE_NAAVD3D_CAdapterInfo@@@Z
_TEXT	SEGMENT
tv151 = -128						; size = 4
_this$ = -124						; size = 4
_dwChkLowVersion$1 = -120				; size = 4
_dwSrcLowVersion$ = -116				; size = 4
_dwChkHighVersion$2 = -112				; size = 4
_dwSrcHighVersion$ = -108				; size = 4
$T3 = -104						; size = 4
_fp$ = -100						; size = 4
_rkD3DAdapterIdentifier$ = -96				; size = 4
_ret$ = -89						; size = 1
_szSrcDriver$ = -88					; size = 256
_szChkDriver$4 = 168					; size = 256
_szLine$5 = 424						; size = 256
__$ArrayPad$ = 680					; size = 4
_rkD3DAdapterInfo$ = 692				; size = 4
?__IsInDriverBlackList@CGraphicDevice@@IAE_NAAVD3D_CAdapterInfo@@@Z PROC ; CGraphicDevice::__IsInDriverBlackList, COMDAT
; _this$ = ecx

; 309  : {

  00000	55		 push	 ebp
  00001	8d ac 24 54 fd
	ff ff		 lea	 ebp, DWORD PTR [esp-684]
  00008	81 ec 2c 03 00
	00		 sub	 esp, 812		; 0000032cH
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 a8 02 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 84	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.h

; 118  : 			return m_kD3DAdapterIdentifier;

  0001e	8b 85 b4 02 00
	00		 mov	 eax, DWORD PTR _rkD3DAdapterInfo$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 310  : 	D3DADAPTER_IDENTIFIER8& rkD3DAdapterIdentifier=rkD3DAdapterInfo.GetIdentifier();

  00024	89 45 a0	 mov	 DWORD PTR _rkD3DAdapterIdentifier$[ebp], eax

; 311  : 
; 312  : 	char szSrcDriver[256];
; 313  : 	strncpy(szSrcDriver, rkD3DAdapterIdentifier.Driver, sizeof(szSrcDriver)-1);

  00027	68 ff 00 00 00	 push	 255			; 000000ffH
  0002c	ff 75 a0	 push	 DWORD PTR _rkD3DAdapterIdentifier$[ebp]
  0002f	8d 45 a8	 lea	 eax, DWORD PTR _szSrcDriver$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _strncpy
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 	DWORD dwSrcHighVersion=rkD3DAdapterIdentifier.DriverVersion.QuadPart>>32;

  0003b	8b 4d a0	 mov	 ecx, DWORD PTR _rkD3DAdapterIdentifier$[ebp]
  0003e	8b 81 00 04 00
	00		 mov	 eax, DWORD PTR [ecx+1024]
  00044	8b 91 04 04 00
	00		 mov	 edx, DWORD PTR [ecx+1028]
  0004a	b1 20		 mov	 cl, 32			; 00000020H
  0004c	e8 00 00 00 00	 call	 __allshr
  00051	89 45 94	 mov	 DWORD PTR _dwSrcHighVersion$[ebp], eax

; 315  : 	DWORD dwSrcLowVersion=rkD3DAdapterIdentifier.DriverVersion.QuadPart&0xffffffff;

  00054	8b 45 a0	 mov	 eax, DWORD PTR _rkD3DAdapterIdentifier$[ebp]
  00057	8b 80 00 04 00
	00		 mov	 eax, DWORD PTR [eax+1024]
  0005d	89 45 8c	 mov	 DWORD PTR _dwSrcLowVersion$[ebp], eax

; 316  : 
; 317  : 	bool ret=false;

  00060	c6 45 a7 00	 mov	 BYTE PTR _ret$[ebp], 0

; 318  : 		
; 319  : 	FILE* fp=fopen("grpblk.txt", "r");

  00064	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NIHOAGKC@grpblk?4txt@
  0006e	e8 00 00 00 00	 call	 _fopen
  00073	59		 pop	 ecx
  00074	59		 pop	 ecx
  00075	89 45 9c	 mov	 DWORD PTR _fp$[ebp], eax

; 320  : 	if (fp)

  00078	83 7d 9c 00	 cmp	 DWORD PTR _fp$[ebp], 0
  0007c	0f 84 9c 00 00
	00		 je	 $LN4@IsInDriver
$LN2@IsInDriver:

; 321  : 	{
; 322  : 		DWORD dwChkHighVersion;
; 323  : 		DWORD dwChkLowVersion;
; 324  : 
; 325  : 		char szChkDriver[256];
; 326  : 
; 327  : 		char szLine[256];
; 328  : 		while (fgets(szLine, sizeof(szLine)-1, fp))

  00082	ff 75 9c	 push	 DWORD PTR _fp$[ebp]
  00085	68 ff 00 00 00	 push	 255			; 000000ffH
  0008a	8d 85 a8 01 00
	00		 lea	 eax, DWORD PTR _szLine$5[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _fgets
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
  00099	85 c0		 test	 eax, eax
  0009b	74 78		 je	 SHORT $LN3@IsInDriver

; 329  : 		{			
; 330  : 			sscanf(szLine, "%s %x %x", szChkDriver, &dwChkHighVersion, &dwChkLowVersion);

  0009d	8d 45 88	 lea	 eax, DWORD PTR _dwChkLowVersion$1[ebp]
  000a0	50		 push	 eax
  000a1	8d 45 90	 lea	 eax, DWORD PTR _dwChkHighVersion$2[ebp]
  000a4	50		 push	 eax
  000a5	8d 85 a8 00 00
	00		 lea	 eax, DWORD PTR _szChkDriver$4[ebp]
  000ab	50		 push	 eax
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_08NLGDGEBC@?$CFs?5?$CFx?5?$CFx@
  000b1	8d 85 a8 01 00
	00		 lea	 eax, DWORD PTR _szLine$5[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _sscanf
  000bd	83 c4 14	 add	 esp, 20			; 00000014H

; 331  : 			
; 332  : 			if (strcmp(szSrcDriver, szChkDriver)==0)

  000c0	8d 85 a8 00 00
	00		 lea	 eax, DWORD PTR _szChkDriver$4[ebp]
  000c6	50		 push	 eax
  000c7	8d 45 a8	 lea	 eax, DWORD PTR _szSrcDriver$[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _strcmp
  000d0	59		 pop	 ecx
  000d1	59		 pop	 ecx
  000d2	85 c0		 test	 eax, eax
  000d4	75 16		 jne	 SHORT $LN5@IsInDriver

; 333  : 				if (dwSrcHighVersion==dwChkHighVersion)

  000d6	8b 45 94	 mov	 eax, DWORD PTR _dwSrcHighVersion$[ebp]
  000d9	3b 45 90	 cmp	 eax, DWORD PTR _dwChkHighVersion$2[ebp]
  000dc	75 0e		 jne	 SHORT $LN5@IsInDriver

; 334  : 					if (dwSrcLowVersion==dwChkLowVersion)

  000de	8b 45 8c	 mov	 eax, DWORD PTR _dwSrcLowVersion$[ebp]
  000e1	3b 45 88	 cmp	 eax, DWORD PTR _dwChkLowVersion$1[ebp]
  000e4	75 06		 jne	 SHORT $LN5@IsInDriver

; 335  : 					{
; 336  : 						ret=true;				

  000e6	c6 45 a7 01	 mov	 BYTE PTR _ret$[ebp], 1

; 337  : 						break;

  000ea	eb 29		 jmp	 SHORT $LN3@IsInDriver
$LN5@IsInDriver:

; 338  : 					}
; 339  : 
; 340  : 			szLine[0]='\0';

  000ec	33 c0		 xor	 eax, eax
  000ee	40		 inc	 eax
  000ef	6b c0 00	 imul	 eax, eax, 0
  000f2	89 45 98	 mov	 DWORD PTR $T3[ebp], eax
  000f5	81 7d 98 00 01
	00 00		 cmp	 DWORD PTR $T3[ebp], 256	; 00000100H
  000fc	73 02		 jae	 SHORT $LN9@IsInDriver
  000fe	eb 05		 jmp	 SHORT $LN10@IsInDriver
$LN9@IsInDriver:
  00100	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN10@IsInDriver:
  00105	8b 45 98	 mov	 eax, DWORD PTR $T3[ebp]
  00108	c6 84 05 a8 01
	00 00 00	 mov	 BYTE PTR _szLine$5[ebp+eax], 0

; 341  : 		}

  00110	e9 6d ff ff ff	 jmp	 $LN2@IsInDriver
$LN3@IsInDriver:

; 342  : 		fclose(fp);

  00115	ff 75 9c	 push	 DWORD PTR _fp$[ebp]
  00118	e8 00 00 00 00	 call	 _fclose
  0011d	59		 pop	 ecx
$LN4@IsInDriver:

; 343  : 	}
; 344  : 
; 345  : 	return ret;

  0011e	8a 45 a7	 mov	 al, BYTE PTR _ret$[ebp]
$LN8@IsInDriver:

; 346  : }

  00121	8b 8d a8 02 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00127	33 cd		 xor	 ecx, ebp
  00129	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012e	81 c5 ac 02 00
	00		 add	 ebp, 684		; 000002acH
  00134	c9		 leave
  00135	c2 04 00	 ret	 4
?__IsInDriverBlackList@CGraphicDevice@@IAE_NAAVD3D_CAdapterInfo@@@Z ENDP ; CGraphicDevice::__IsInDriverBlackList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?__Initialize@CGraphicDevice@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__Initialize@CGraphicDevice@@IAEXXZ PROC		; CGraphicDevice::__Initialize, COMDAT
; _this$ = ecx

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 	ms_iD3DAdapterInfo=D3DADAPTER_DEFAULT;

  00007	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_iD3DAdapterInfo@CGraphicBase@@1IA, 0 ; CGraphicBase::ms_iD3DAdapterInfo

; 30   : 	ms_iD3DDevInfo=D3DADAPTER_DEFAULT;

  0000e	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_iD3DDevInfo@CGraphicBase@@1IA, 0 ; CGraphicBase::ms_iD3DDevInfo

; 31   : 	ms_iD3DModeInfo=D3DADAPTER_DEFAULT;

  00015	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_iD3DModeInfo@CGraphicBase@@1IA, 0 ; CGraphicBase::ms_iD3DModeInfo

; 32   : 
; 33   : 	ms_lpd3d			= NULL;

  0001c	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A, 0 ; CGraphicBase::ms_lpd3d

; 34   : 	ms_lpd3dDevice		= NULL;

  00023	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A, 0 ; CGraphicBase::ms_lpd3dDevice

; 35   : 	ms_lpd3dMatStack	= NULL;

  0002a	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_lpd3dMatStack@CGraphicBase@@1PAUID3DXMatrixStack@@A, 0 ; CGraphicBase::ms_lpd3dMatStack

; 36   : 
; 37   : 	ms_dwWavingEndTime = 0;

  00031	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_dwWavingEndTime@CGraphicBase@@1KA, 0 ; CGraphicBase::ms_dwWavingEndTime

; 38   : 	ms_dwFlashingEndTime = 0;

  00038	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_dwFlashingEndTime@CGraphicBase@@1KA, 0 ; CGraphicBase::ms_dwFlashingEndTime

; 39   : 
; 40   : 	m_pStateManager		= NULL;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 41   : 
; 42   : 	__InitializeDefaultIndexBufferList();

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?__InitializeDefaultIndexBufferList@CGraphicDevice@@IAEXXZ ; CGraphicDevice::__InitializeDefaultIndexBufferList

; 43   : 	__InitializePDTVertexBufferList();

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?__InitializePDTVertexBufferList@CGraphicDevice@@IAEXXZ ; CGraphicDevice::__InitializePDTVertexBufferList

; 44   : }

  00056	c9		 leave
  00057	c3		 ret	 0
?__Initialize@CGraphicDevice@@IAEXXZ ENDP		; CGraphicDevice::__Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?RegisterWarningString@CGraphicDevice@@QAEXIPBD@Z
_TEXT	SEGMENT
$T1 = -24						; size = 8
_this$ = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
_uiMsg$ = 8						; size = 4
_c_szString$ = 12					; size = 4
?RegisterWarningString@CGraphicDevice@@QAEXIPBD@Z PROC	; CGraphicDevice::RegisterWarningString, COMDAT
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 325  :         return _Try_emplace(_Keyval).first->_Myval.second;

  00009	8d 45 08	 lea	 eax, DWORD PTR _uiMsg$[ebp]
  0000c	50		 push	 eax
  0000d	8d 45 e8	 lea	 eax, DWORD PTR $T1[ebp]
  00010	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 48   : 	m_kMap_strWarningMessage[uiMsg] = c_szString;

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	83 c1 08	 add	 ecx, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 325  :         return _Try_emplace(_Keyval).first->_Myval.second;

  00017	e8 00 00 00 00	 call	 ??$_Try_emplace@ABI$$V@?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAX@std@@_N@1@ABI@Z ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Try_emplace<unsigned int const &>
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	83 c0 14	 add	 eax, 20			; 00000014H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 48   : 	m_kMap_strWarningMessage[uiMsg] = c_szString;

  00021	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00024	ff 75 0c	 push	 DWORD PTR _c_szString$[ebp]
  00027	e8 00 00 00 00	 call	 _strlen
  0002c	59		 pop	 ecx
  0002d	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00030	8b 45 f8	 mov	 eax, DWORD PTR $T3[ebp]
  00033	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00036	ff 75 f4	 push	 DWORD PTR $T2[ebp]
  00039	ff 75 0c	 push	 DWORD PTR _c_szString$[ebp]
  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 49   : }

  00044	c9		 leave
  00045	c2 08 00	 ret	 8
?RegisterWarningString@CGraphicDevice@@QAEXIPBD@Z ENDP	; CGraphicDevice::RegisterWarningString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?ResizeBackBuffer@CGraphicDevice@@QAE_NII@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_hr$1 = -12						; size = 4
_rkD3DDev$2 = -8					; size = 4
_rkD3DPP$ = -4						; size = 4
_uWidth$ = 8						; size = 4
_uHeight$ = 12						; size = 4
?ResizeBackBuffer@CGraphicDevice@@QAE_NII@Z PROC	; CGraphicDevice::ResizeBackBuffer, COMDAT
; _this$ = ecx

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 	if (!ms_lpd3dDevice)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A, 0 ; CGraphicBase::ms_lpd3dDevice
  00010	75 04		 jne	 SHORT $LN2@ResizeBack

; 113  : 		return false;

  00012	32 c0		 xor	 al, al
  00014	eb 66		 jmp	 SHORT $LN1@ResizeBack
$LN2@ResizeBack:

; 114  : 
; 115  : 	D3DPRESENT_PARAMETERS& rkD3DPP=ms_d3dPresentParameter;

  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _rkD3DPP$[ebp], OFFSET ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A ; CGraphicBase::ms_d3dPresentParameter

; 116  : 	if (rkD3DPP.Windowed)

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _rkD3DPP$[ebp]
  00020	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00024	74 54		 je	 SHORT $LN3@ResizeBack

; 117  : 	{
; 118  : 		if (rkD3DPP.BackBufferWidth!=uWidth || rkD3DPP.BackBufferHeight!=uHeight)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _rkD3DPP$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	3b 45 08	 cmp	 eax, DWORD PTR _uWidth$[ebp]
  0002e	75 0b		 jne	 SHORT $LN5@ResizeBack
  00030	8b 45 fc	 mov	 eax, DWORD PTR _rkD3DPP$[ebp]
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	3b 45 0c	 cmp	 eax, DWORD PTR _uHeight$[ebp]
  00039	74 3f		 je	 SHORT $LN3@ResizeBack
$LN5@ResizeBack:

; 119  : 		{
; 120  : 			rkD3DPP.BackBufferWidth=uWidth;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _rkD3DPP$[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _uWidth$[ebp]
  00041	89 08		 mov	 DWORD PTR [eax], ecx

; 121  : 			rkD3DPP.BackBufferHeight=uHeight;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _rkD3DPP$[ebp]
  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _uHeight$[ebp]
  00049	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 122  : 
; 123  : 			IDirect3DDevice8& rkD3DDev=*ms_lpd3dDevice;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00051	89 45 f8	 mov	 DWORD PTR _rkD3DDev$2[ebp], eax

; 124  : 
; 125  : 			HRESULT hr=rkD3DDev.Reset(&rkD3DPP);

  00054	ff 75 fc	 push	 DWORD PTR _rkD3DPP$[ebp]
  00057	8b 45 f8	 mov	 eax, DWORD PTR _rkD3DDev$2[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	ff 75 f8	 push	 DWORD PTR _rkD3DDev$2[ebp]
  0005f	ff 50 38	 call	 DWORD PTR [eax+56]
  00062	89 45 f4	 mov	 DWORD PTR _hr$1[ebp], eax

; 126  : 			if (FAILED(hr))

  00065	83 7d f4 00	 cmp	 DWORD PTR _hr$1[ebp], 0
  00069	7d 04		 jge	 SHORT $LN8@ResizeBack

; 127  : 			{
; 128  : 				return false;

  0006b	32 c0		 xor	 al, al
  0006d	eb 0d		 jmp	 SHORT $LN1@ResizeBack
$LN8@ResizeBack:

; 129  : 			}
; 130  : 
; 131  : 			STATEMANAGER.SetDefaultState();

  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00075	e8 00 00 00 00	 call	 ?SetDefaultState@CStateManager@@QAEXXZ ; CStateManager::SetDefaultState
$LN3@ResizeBack:

; 132  : 		}
; 133  : 	}
; 134  : 
; 135  : 	return true;

  0007a	b0 01		 mov	 al, 1
$LN1@ResizeBack:

; 136  : }

  0007c	c9		 leave
  0007d	c2 08 00	 ret	 8
?ResizeBackBuffer@CGraphicDevice@@QAE_NII@Z ENDP	; CGraphicDevice::ResizeBackBuffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?MoveWebBrowserRect@CGraphicDevice@@QAEXABUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_rcWebPage$ = 8					; size = 4
?MoveWebBrowserRect@CGraphicDevice@@QAEXABUtagRECT@@@Z PROC ; CGraphicDevice::MoveWebBrowserRect, COMDAT
; _this$ = ecx

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 60   : 	g_rcBrowser=c_rcWebPage;

  00009	8b 75 08	 mov	 esi, DWORD PTR _c_rcWebPage$[ebp]
  0000c	bf 00 00 00 00	 mov	 edi, OFFSET ?g_rcBrowser@@3UtagRECT@@A ; g_rcBrowser
  00011	a5		 movsd
  00012	a5		 movsd
  00013	a5		 movsd
  00014	a5		 movsd

; 61   : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	c9		 leave
  00018	c2 04 00	 ret	 4
?MoveWebBrowserRect@CGraphicDevice@@QAEXABUtagRECT@@@Z ENDP ; CGraphicDevice::MoveWebBrowserRect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?DisableWebBrowserMode@CGraphicDevice@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_hr$ = -12						; size = 4
_rkD3DDev$ = -8						; size = 4
_rkD3DPP$ = -4						; size = 4
?DisableWebBrowserMode@CGraphicDevice@@QAEXXZ PROC	; CGraphicDevice::DisableWebBrowserMode, COMDAT
; _this$ = ecx

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 93   : 	if (!ms_lpd3dDevice)

  0000b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A, 0 ; CGraphicBase::ms_lpd3dDevice
  00012	75 02		 jne	 SHORT $LN2@DisableWeb

; 94   : 		return;

  00014	eb 47		 jmp	 SHORT $LN1@DisableWeb
$LN2@DisableWeb:

; 95   : 
; 96   : 	D3DPRESENT_PARAMETERS& rkD3DPP=ms_d3dPresentParameter;

  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _rkD3DPP$[ebp], OFFSET ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A ; CGraphicBase::ms_d3dPresentParameter

; 97   : 	
; 98   : 	g_isBrowserMode=false;

  0001d	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_isBrowserMode@@3_NA, 0 ; g_isBrowserMode

; 99   : 
; 100  : 	rkD3DPP=g_kD3DPP;

  00024	6a 0d		 push	 13			; 0000000dH
  00026	59		 pop	 ecx
  00027	be 00 00 00 00	 mov	 esi, OFFSET ?g_kD3DPP@@3U_D3DPRESENT_PARAMETERS_@@A ; g_kD3DPP
  0002c	8b 7d fc	 mov	 edi, DWORD PTR _rkD3DPP$[ebp]
  0002f	f3 a5		 rep movsd

; 101  : 
; 102  : 	IDirect3DDevice8& rkD3DDev=*ms_lpd3dDevice;

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00036	89 45 f8	 mov	 DWORD PTR _rkD3DDev$[ebp], eax

; 103  : 	HRESULT hr=rkD3DDev.Reset(&rkD3DPP);

  00039	ff 75 fc	 push	 DWORD PTR _rkD3DPP$[ebp]
  0003c	8b 45 f8	 mov	 eax, DWORD PTR _rkD3DDev$[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	ff 75 f8	 push	 DWORD PTR _rkD3DDev$[ebp]
  00044	ff 50 38	 call	 DWORD PTR [eax+56]
  00047	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 104  : 	if (FAILED(hr))

  0004a	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0004e	7d 02		 jge	 SHORT $LN5@DisableWeb

; 105  : 		return;

  00050	eb 0b		 jmp	 SHORT $LN1@DisableWeb
$LN5@DisableWeb:

; 106  : 	
; 107  : 	STATEMANAGER.SetDefaultState();	

  00052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00058	e8 00 00 00 00	 call	 ?SetDefaultState@CStateManager@@QAEXXZ ; CStateManager::SetDefaultState
$LN1@DisableWeb:

; 108  : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	c9		 leave
  00060	c3		 ret	 0
?DisableWebBrowserMode@CGraphicDevice@@QAEXXZ ENDP	; CGraphicDevice::DisableWebBrowserMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?EnableWebBrowserMode@CGraphicDevice@@QAEXABUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_hr$ = -12						; size = 4
_rkD3DDev$ = -8						; size = 4
_rkD3DPP$ = -4						; size = 4
_c_rcWebPage$ = 8					; size = 4
?EnableWebBrowserMode@CGraphicDevice@@QAEXABUtagRECT@@@Z PROC ; CGraphicDevice::EnableWebBrowserMode, COMDAT
; _this$ = ecx

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 65   : 	if (!ms_lpd3dDevice)

  0000b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A, 0 ; CGraphicBase::ms_lpd3dDevice
  00012	75 02		 jne	 SHORT $LN2@EnableWebB

; 66   : 		return;

  00014	eb 7c		 jmp	 SHORT $LN1@EnableWebB
$LN2@EnableWebB:

; 67   : 
; 68   : 	D3DPRESENT_PARAMETERS& rkD3DPP=ms_d3dPresentParameter;

  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _rkD3DPP$[ebp], OFFSET ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A ; CGraphicBase::ms_d3dPresentParameter

; 69   : 	
; 70   : 	g_isBrowserMode=true;

  0001d	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?g_isBrowserMode@@3_NA, 1 ; g_isBrowserMode

; 71   : 
; 72   : 	if (D3DSWAPEFFECT_COPY==rkD3DPP.SwapEffect)

  00024	8b 45 fc	 mov	 eax, DWORD PTR _rkD3DPP$[ebp]
  00027	83 78 14 03	 cmp	 DWORD PTR [eax+20], 3
  0002b	75 02		 jne	 SHORT $LN3@EnableWebB

; 73   : 		return;

  0002d	eb 63		 jmp	 SHORT $LN1@EnableWebB
$LN3@EnableWebB:

; 74   : 
; 75   : 	g_kD3DPP=rkD3DPP;

  0002f	6a 0d		 push	 13			; 0000000dH
  00031	59		 pop	 ecx
  00032	8b 75 fc	 mov	 esi, DWORD PTR _rkD3DPP$[ebp]
  00035	bf 00 00 00 00	 mov	 edi, OFFSET ?g_kD3DPP@@3U_D3DPRESENT_PARAMETERS_@@A ; g_kD3DPP
  0003a	f3 a5		 rep movsd

; 76   : 	g_rcBrowser=c_rcWebPage;

  0003c	8b 75 08	 mov	 esi, DWORD PTR _c_rcWebPage$[ebp]
  0003f	bf 00 00 00 00	 mov	 edi, OFFSET ?g_rcBrowser@@3UtagRECT@@A ; g_rcBrowser
  00044	a5		 movsd
  00045	a5		 movsd
  00046	a5		 movsd
  00047	a5		 movsd

; 77   : 	
; 78   : 	//rkD3DPP.Windowed=TRUE;
; 79   : 	rkD3DPP.SwapEffect=D3DSWAPEFFECT_COPY;

  00048	8b 45 fc	 mov	 eax, DWORD PTR _rkD3DPP$[ebp]
  0004b	c7 40 14 03 00
	00 00		 mov	 DWORD PTR [eax+20], 3

; 80   : 	rkD3DPP.BackBufferCount = 1;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _rkD3DPP$[ebp]
  00055	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1

; 81   : 	rkD3DPP.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _rkD3DPP$[ebp]
  0005f	c7 40 30 00 00
	00 80		 mov	 DWORD PTR [eax+48], -2147483648 ; 80000000H

; 82   : 	
; 83   : 	IDirect3DDevice8& rkD3DDev=*ms_lpd3dDevice;

  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0006b	89 45 f8	 mov	 DWORD PTR _rkD3DDev$[ebp], eax

; 84   : 	HRESULT hr=rkD3DDev.Reset(&rkD3DPP);

  0006e	ff 75 fc	 push	 DWORD PTR _rkD3DPP$[ebp]
  00071	8b 45 f8	 mov	 eax, DWORD PTR _rkD3DDev$[ebp]
  00074	8b 00		 mov	 eax, DWORD PTR [eax]
  00076	ff 75 f8	 push	 DWORD PTR _rkD3DDev$[ebp]
  00079	ff 50 38	 call	 DWORD PTR [eax+56]
  0007c	89 45 f4	 mov	 DWORD PTR _hr$[ebp], eax

; 85   : 	if (FAILED(hr))

  0007f	83 7d f4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00083	7d 02		 jge	 SHORT $LN6@EnableWebB

; 86   : 		return;

  00085	eb 0b		 jmp	 SHORT $LN1@EnableWebB
$LN6@EnableWebB:

; 87   : 	
; 88   : 	STATEMANAGER.SetDefaultState();	

  00087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0008d	e8 00 00 00 00	 call	 ?SetDefaultState@CStateManager@@QAEXXZ ; CStateManager::SetDefaultState
$LN1@EnableWebB:

; 89   : }

  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	c9		 leave
  00095	c2 04 00	 ret	 4
?EnableWebBrowserMode@CGraphicDevice@@QAEXABUtagRECT@@@Z ENDP ; CGraphicDevice::EnableWebBrowserMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?Reset@CGraphicDevice@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hr$ = -4						; size = 4
?Reset@CGraphicDevice@@QAE_NXZ PROC			; CGraphicDevice::Reset, COMDAT
; _this$ = ecx

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 251  : 	HRESULT hr;
; 252  : 
; 253  : 	if (FAILED(hr = ms_lpd3dDevice->Reset(&ms_d3dPresentParameter)))

  00008	68 00 00 00 00	 push	 OFFSET ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A ; CGraphicBase::ms_d3dPresentParameter
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0001a	ff 50 38	 call	 DWORD PTR [eax+56]
  0001d	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00020	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00024	7d 04		 jge	 SHORT $LN2@Reset

; 254  : 		return false;

  00026	32 c0		 xor	 al, al
  00028	eb 02		 jmp	 SHORT $LN1@Reset
$LN2@Reset:

; 255  : 
; 256  : 	return true;

  0002a	b0 01		 mov	 al, 1
$LN1@Reset:

; 257  : }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?Reset@CGraphicDevice@@QAE_NXZ ENDP			; CGraphicDevice::Reset
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?GetDeviceState@CGraphicDevice@@QAE?AW4EDeviceState@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hr$ = -4						; size = 4
?GetDeviceState@CGraphicDevice@@QAE?AW4EDeviceState@1@XZ PROC ; CGraphicDevice::GetDeviceState, COMDAT
; _this$ = ecx

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 	if (!ms_lpd3dDevice)

  00008	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A, 0 ; CGraphicBase::ms_lpd3dDevice
  0000f	75 05		 jne	 SHORT $LN2@GetDeviceS

; 231  : 		return DEVICESTATE_NULL;

  00011	6a 03		 push	 3
  00013	58		 pop	 eax
  00014	eb 3c		 jmp	 SHORT $LN1@GetDeviceS
$LN2@GetDeviceS:

; 232  : 
; 233  : 	HRESULT hr;
; 234  : 
; 235  : 	if (FAILED(hr = ms_lpd3dDevice->TestCooperativeLevel()))

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00023	ff 50 0c	 call	 DWORD PTR [eax+12]
  00026	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax
  00029	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002d	7d 21		 jge	 SHORT $LN3@GetDeviceS

; 236  : 	{
; 237  : 		if (D3DERR_DEVICELOST == hr)

  0002f	81 7d fc 68 08
	76 88		 cmp	 DWORD PTR _hr$[ebp], -2005530520 ; 88760868H
  00036	75 05		 jne	 SHORT $LN4@GetDeviceS

; 238  : 			return DEVICESTATE_BROKEN;

  00038	33 c0		 xor	 eax, eax
  0003a	40		 inc	 eax
  0003b	eb 15		 jmp	 SHORT $LN1@GetDeviceS
$LN4@GetDeviceS:

; 239  : 
; 240  : 		if (D3DERR_DEVICENOTRESET == hr)

  0003d	81 7d fc 69 08
	76 88		 cmp	 DWORD PTR _hr$[ebp], -2005530519 ; 88760869H
  00044	75 05		 jne	 SHORT $LN5@GetDeviceS

; 241  : 			return DEVICESTATE_NEEDS_RESET;

  00046	6a 02		 push	 2
  00048	58		 pop	 eax
  00049	eb 07		 jmp	 SHORT $LN1@GetDeviceS
$LN5@GetDeviceS:

; 242  : 
; 243  : 		return DEVICESTATE_BROKEN;

  0004b	33 c0		 xor	 eax, eax
  0004d	40		 inc	 eax
  0004e	eb 02		 jmp	 SHORT $LN1@GetDeviceS
$LN3@GetDeviceS:

; 244  : 	}
; 245  : 	
; 246  : 	return DEVICESTATE_OK;

  00050	33 c0		 xor	 eax, eax
$LN1@GetDeviceS:

; 247  : }

  00052	c9		 leave
  00053	c3		 ret	 0
?GetDeviceState@CGraphicDevice@@QAE?AW4EDeviceState@1@XZ ENDP ; CGraphicDevice::GetDeviceState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z
_TEXT	SEGMENT
$T2 = -52						; size = 4
$T3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
$T10 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 0						; size = 4
_dwTexMemSize$ = 4					; size = 4
tv302 = 8						; size = 4
$T11 = 12						; size = 4
_rkD3DAdapterId$ = 16					; size = 4
_ErrorCorrection$ = 20					; size = 4
tv224 = 24						; size = 4
_iRet$ = 28						; size = 4
_pkD3DAdapterInfo$ = 32					; size = 4
_pkD3DModeInfo$ = 36					; size = 4
_this$ = 40						; size = 4
_stModeInfo$ = 44					; size = 24
_stDevList$ = 68					; size = 24
__$ArrayPad$ = 92					; size = 4
_hWnd$ = 104						; size = 4
_iHres$ = 108						; size = 4
_iVres$ = 112						; size = 4
_Windowed$ = 116					; size = 1
___formal$ = 120					; size = 4
_iReflashRate$ = 124					; size = 4
?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z PROC	; CGraphicDevice::Create, COMDAT
; _this$ = ecx

; 349  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 a0	 lea	 ebp, DWORD PTR [esp-96]
  00005	83 ec 60	 sub	 esp, 96			; 00000060H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 28	 sub	 esp, 40			; 00000028H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 5c	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	89 4d 28	 mov	 DWORD PTR _this$[ebp], ecx

; 350  : 	int iRet = CREATE_OK;

  00030	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR _iRet$[ebp], 1

; 351  : 
; 352  : 	Destroy();

  00037	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?Destroy@CGraphicDevice@@QAEXXZ ; CGraphicDevice::Destroy

; 353  : 
; 354  : 	ms_iWidth	= iHres;

  0003f	8b 45 6c	 mov	 eax, DWORD PTR _iHres$[ebp]
  00042	a3 00 00 00 00	 mov	 DWORD PTR ?ms_iWidth@CGraphicBase@@1HA, eax ; CGraphicBase::ms_iWidth

; 355  : 	ms_iHeight	= iVres;

  00047	8b 45 70	 mov	 eax, DWORD PTR _iVres$[ebp]
  0004a	a3 00 00 00 00	 mov	 DWORD PTR ?ms_iHeight@CGraphicBase@@1HA, eax ; CGraphicBase::ms_iHeight

; 356  : 
; 357  : 	ms_hWnd		= hWnd;

  0004f	8b 45 68	 mov	 eax, DWORD PTR _hWnd$[ebp]
  00052	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hWnd@CGraphicBase@@1PAUHWND__@@A, eax ; CGraphicBase::ms_hWnd

; 358  : 	ms_hDC		= GetDC(hWnd);

  00057	ff 75 68	 push	 DWORD PTR _hWnd$[ebp]
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  00060	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hDC@CGraphicBase@@1PAUHDC__@@A, eax ; CGraphicBase::ms_hDC

; 359  : 	ms_lpd3d	= Direct3DCreate8(D3D_SDK_VERSION);

  00065	68 dc 00 00 00	 push	 220			; 000000dcH
  0006a	e8 00 00 00 00	 call	 _Direct3DCreate8@4
  0006f	a3 00 00 00 00	 mov	 DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A, eax ; CGraphicBase::ms_lpd3d

; 360  : 
; 361  : 	if (!ms_lpd3d)

  00074	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A, 0 ; CGraphicBase::ms_lpd3d
  0007b	75 08		 jne	 SHORT $LN4@Create

; 362  : 		return CREATE_NO_DIRECTX;

  0007d	6a 02		 push	 2
  0007f	58		 pop	 eax
  00080	e9 97 13 00 00	 jmp	 $LN1@Create
$LN4@Create:

; 363  : 
; 364  : 	if (!ms_kD3DDetector.Build(*ms_lpd3d, EL3D_ConfirmDevice))

  00085	68 00 00 00 00	 push	 OFFSET ?EL3D_ConfirmDevice@@YAHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z ; EL3D_ConfirmDevice
  0008a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A ; CGraphicBase::ms_lpd3d
  00090	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kD3DDetector@CGraphicBase@@1VD3D_CDisplayModeAutoDetector@@A ; CGraphicBase::ms_kD3DDetector
  00095	e8 00 00 00 00	 call	 ?Build@D3D_CDisplayModeAutoDetector@@QAEHAAUIDirect3D8@@P6AHAAU_D3DCAPS8@@IW4_D3DFORMAT@@@Z@Z ; D3D_CDisplayModeAutoDetector::Build
  0009a	85 c0		 test	 eax, eax
  0009c	75 08		 jne	 SHORT $LN5@Create

; 365  : 		return CREATE_ENUM;

  0009e	6a 40		 push	 64			; 00000040H
  000a0	58		 pop	 eax
  000a1	e9 76 13 00 00	 jmp	 $LN1@Create
$LN5@Create:

; 366  : 
; 367  : 	if (!ms_kD3DDetector.Find(800, 600, 32, TRUE, &ms_iD3DModeInfo, &ms_iD3DDevInfo, &ms_iD3DAdapterInfo))

  000a6	68 00 00 00 00	 push	 OFFSET ?ms_iD3DAdapterInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DAdapterInfo
  000ab	68 00 00 00 00	 push	 OFFSET ?ms_iD3DDevInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DDevInfo
  000b0	68 00 00 00 00	 push	 OFFSET ?ms_iD3DModeInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DModeInfo
  000b5	6a 01		 push	 1
  000b7	6a 20		 push	 32			; 00000020H
  000b9	68 58 02 00 00	 push	 600			; 00000258H
  000be	68 20 03 00 00	 push	 800			; 00000320H
  000c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kD3DDetector@CGraphicBase@@1VD3D_CDisplayModeAutoDetector@@A ; CGraphicBase::ms_kD3DDetector
  000c8	e8 00 00 00 00	 call	 ?Find@D3D_CDisplayModeAutoDetector@@QAEHIIIHPAI00@Z ; D3D_CDisplayModeAutoDetector::Find
  000cd	85 c0		 test	 eax, eax
  000cf	75 0a		 jne	 SHORT $LN6@Create

; 368  : 		return CREATE_DETECT;

  000d1	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  000d6	e9 41 13 00 00	 jmp	 $LN1@Create
$LN6@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  000db	8d 45 44	 lea	 eax, DWORD PTR _stDevList$[ebp]
  000de	89 45 00	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000e1	8b 4d 00	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  000e9	8d 4d 44	 lea	 ecx, DWORD PTR _stDevList$[ebp]
  000ec	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 370  : 	std::string stDevList;

  000f1	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 371  : 	ms_kD3DDetector.GetString(&stDevList);

  000f5	8d 45 44	 lea	 eax, DWORD PTR _stDevList$[ebp]
  000f8	50		 push	 eax
  000f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kD3DDetector@CGraphicBase@@1VD3D_CDisplayModeAutoDetector@@A ; CGraphicBase::ms_kD3DDetector
  000fe	e8 00 00 00 00	 call	 ?GetString@D3D_CDisplayModeAutoDetector@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; D3D_CDisplayModeAutoDetector::GetString

; 372  : 
; 373  : 	//Tracen(stDevList.c_str());
; 374  : 	//Tracenf("adapter %d, device %d, mode %d", ms_iD3DAdapterInfo, ms_iD3DDevInfo, ms_iD3DModeInfo);
; 375  : 
; 376  : 	D3D_CAdapterInfo * pkD3DAdapterInfo = ms_kD3DDetector.GetD3DAdapterInfop(ms_iD3DAdapterInfo);

  00103	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_iD3DAdapterInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DAdapterInfo
  00109	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kD3DDetector@CGraphicBase@@1VD3D_CDisplayModeAutoDetector@@A ; CGraphicBase::ms_kD3DDetector
  0010e	e8 00 00 00 00	 call	 ?GetD3DAdapterInfop@D3D_CDisplayModeAutoDetector@@QAEPAVD3D_CAdapterInfo@@I@Z ; D3D_CDisplayModeAutoDetector::GetD3DAdapterInfop
  00113	89 45 20	 mov	 DWORD PTR _pkD3DAdapterInfo$[ebp], eax

; 377  : 	if (!pkD3DAdapterInfo)

  00116	83 7d 20 00	 cmp	 DWORD PTR _pkD3DAdapterInfo$[ebp], 0
  0011a	75 2d		 jne	 SHORT $LN7@Create

; 378  : 	{
; 379  : 		Tracenf("adapter %d is EMPTY", ms_iD3DAdapterInfo);

  0011c	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_iD3DAdapterInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DAdapterInfo
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JAEGAKLI@adapter?5?$CFd?5is?5EMPTY@
  00127	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0012c	59		 pop	 ecx
  0012d	59		 pop	 ecx

; 380  : 		return CREATE_DETECT;

  0012e	c7 45 f0 80 00
	00 00		 mov	 DWORD PTR $T10[ebp], 128 ; 00000080H
  00135	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00139	8d 4d 44	 lea	 ecx, DWORD PTR _stDevList$[ebp]
  0013c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 380  : 		return CREATE_DETECT;

  00141	8b 45 f0	 mov	 eax, DWORD PTR $T10[ebp]
  00144	e9 d3 12 00 00	 jmp	 $LN1@Create
$LN7@Create:

; 381  : 	}
; 382  : 
; 383  : 	if (__IsInDriverBlackList(*pkD3DAdapterInfo))

  00149	ff 75 20	 push	 DWORD PTR _pkD3DAdapterInfo$[ebp]
  0014c	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	e8 00 00 00 00	 call	 ?__IsInDriverBlackList@CGraphicDevice@@IAE_NAAVD3D_CAdapterInfo@@@Z ; CGraphicDevice::__IsInDriverBlackList
  00154	0f b6 c0	 movzx	 eax, al
  00157	85 c0		 test	 eax, eax
  00159	74 1b		 je	 SHORT $LN8@Create

; 384  : 	{
; 385  : 		iRet |= CREATE_BAD_DRIVER;

  0015b	8b 45 1c	 mov	 eax, DWORD PTR _iRet$[ebp]
  0015e	0d 00 02 00 00	 or	 eax, 512		; 00000200H
  00163	89 45 1c	 mov	 DWORD PTR _iRet$[ebp], eax

; 386  : 		__WarningMessage(hWnd, CREATE_BAD_DRIVER);

  00166	68 00 02 00 00	 push	 512			; 00000200H
  0016b	ff 75 68	 push	 DWORD PTR _hWnd$[ebp]
  0016e	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?__WarningMessage@CGraphicDevice@@IAEXPAUHWND__@@I@Z ; CGraphicDevice::__WarningMessage
$LN8@Create:

; 387  : 	}
; 388  : 
; 389  : 	D3D_SModeInfo * pkD3DModeInfo = pkD3DAdapterInfo->GetD3DModeInfop(ms_iD3DDevInfo, ms_iD3DModeInfo);		

  00176	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_iD3DModeInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DModeInfo
  0017c	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_iD3DDevInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DDevInfo
  00182	8b 4d 20	 mov	 ecx, DWORD PTR _pkD3DAdapterInfo$[ebp]
  00185	e8 00 00 00 00	 call	 ?GetD3DModeInfop@D3D_CAdapterInfo@@QAEPAUD3D_SModeInfo@@II@Z ; D3D_CAdapterInfo::GetD3DModeInfop
  0018a	89 45 24	 mov	 DWORD PTR _pkD3DModeInfo$[ebp], eax

; 390  : 	if (!pkD3DModeInfo)

  0018d	83 7d 24 00	 cmp	 DWORD PTR _pkD3DModeInfo$[ebp], 0
  00191	75 34		 jne	 SHORT $LN9@Create

; 391  : 	{
; 392  : 		Tracenf("device %d, mode %d is EMPTY", ms_iD3DDevInfo, ms_iD3DModeInfo);

  00193	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_iD3DModeInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DModeInfo
  00199	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_iD3DDevInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DDevInfo
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LIHILKDJ@device?5?$CFd?0?5mode?5?$CFd?5is?5EMPTY@
  001a4	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  001a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 393  : 		return CREATE_DETECT;

  001ac	c7 45 ec 80 00
	00 00		 mov	 DWORD PTR $T9[ebp], 128	; 00000080H
  001b3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  001b7	8d 4d 44	 lea	 ecx, DWORD PTR _stDevList$[ebp]
  001ba	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 393  : 		return CREATE_DETECT;

  001bf	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  001c2	e9 55 12 00 00	 jmp	 $LN1@Create
$LN9@Create:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDetector.h

; 118  : 			return m_kD3DAdapterIdentifier;

  001c7	8b 45 20	 mov	 eax, DWORD PTR _pkD3DAdapterInfo$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 396  : 	D3DADAPTER_IDENTIFIER8& rkD3DAdapterId=pkD3DAdapterInfo->GetIdentifier();

  001ca	89 45 10	 mov	 DWORD PTR _rkD3DAdapterId$[ebp], eax

; 397  : 	if (Windowed &&
; 398  : 		strnicmp(rkD3DAdapterId.Driver, "3dfx", 4)==0 &&

  001cd	0f b6 45 74	 movzx	 eax, BYTE PTR _Windowed$[ebp]
  001d1	85 c0		 test	 eax, eax
  001d3	74 3f		 je	 SHORT $LN10@Create
  001d5	6a 04		 push	 4
  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_04MAKEOOIM@3dfx@
  001dc	ff 75 10	 push	 DWORD PTR _rkD3DAdapterId$[ebp]
  001df	e8 00 00 00 00	 call	 __strnicmp
  001e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e7	85 c0		 test	 eax, eax
  001e9	75 29		 jne	 SHORT $LN10@Create
  001eb	8b 4d 20	 mov	 ecx, DWORD PTR _pkD3DAdapterInfo$[ebp]
  001ee	e8 00 00 00 00	 call	 ?GetDesktopD3DDisplayModer@D3D_CAdapterInfo@@QAEAAU_D3DDISPLAYMODE@@XZ ; D3D_CAdapterInfo::GetDesktopD3DDisplayModer
  001f3	83 78 0c 16	 cmp	 DWORD PTR [eax+12], 22	; 00000016H
  001f7	75 1b		 jne	 SHORT $LN10@Create

; 401  : 		return CREATE_FORMAT;

  001f9	c7 45 e8 00 04
	00 00		 mov	 DWORD PTR $T8[ebp], 1024 ; 00000400H
  00200	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00204	8d 4d 44	 lea	 ecx, DWORD PTR _stDevList$[ebp]
  00207	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 401  : 		return CREATE_FORMAT;

  0020c	8b 45 e8	 mov	 eax, DWORD PTR $T8[ebp]
  0020f	e9 08 12 00 00	 jmp	 $LN1@Create
$LN10@Create:

; 402  : 	}
; 403  : 
; 404  : 	if (pkD3DModeInfo->m_dwD3DBehavior==D3DCREATE_SOFTWARE_VERTEXPROCESSING)

  00214	8b 45 24	 mov	 eax, DWORD PTR _pkD3DModeInfo$[ebp]
  00217	83 78 0c 20	 cmp	 DWORD PTR [eax+12], 32	; 00000020H
  0021b	75 0b		 jne	 SHORT $LN11@Create

; 405  : 	{
; 406  : 		iRet |= CREATE_NO_TNL;

  0021d	8b 45 1c	 mov	 eax, DWORD PTR _iRet$[ebp]
  00220	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  00225	89 45 1c	 mov	 DWORD PTR _iRet$[ebp], eax
$LN11@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00228	8d 45 2c	 lea	 eax, DWORD PTR _stModeInfo$[ebp]
  0022b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0022e	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00231	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  00236	8d 4d 2c	 lea	 ecx, DWORD PTR _stModeInfo$[ebp]
  00239	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 413  : 	std::string stModeInfo;

  0023e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 414  : 	pkD3DModeInfo->GetString(&stModeInfo);

  00242	8d 45 2c	 lea	 eax, DWORD PTR _stModeInfo$[ebp]
  00245	50		 push	 eax
  00246	8b 4d 24	 mov	 ecx, DWORD PTR _pkD3DModeInfo$[ebp]
  00249	e8 00 00 00 00	 call	 ?GetString@D3D_SModeInfo@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; D3D_SModeInfo::GetString

; 415  : 
; 416  : 	//Tracen(stModeInfo.c_str());
; 417  : 
; 418  : 	int ErrorCorrection = 0;

  0024e	83 65 14 00	 and	 DWORD PTR _ErrorCorrection$[ebp], 0
$RETRY$241:

; 419  : 
; 420  : RETRY:
; 421  : 	ZeroMemory(&ms_d3dPresentParameter, sizeof(ms_d3dPresentParameter));

  00252	6a 34		 push	 52			; 00000034H
  00254	6a 00		 push	 0
  00256	68 00 00 00 00	 push	 OFFSET ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A ; CGraphicBase::ms_d3dPresentParameter
  0025b	e8 00 00 00 00	 call	 _memset
  00260	83 c4 0c	 add	 esp, 12			; 0000000cH

; 422  : 	
; 423  : 	ms_d3dPresentParameter.Windowed							= Windowed;

  00263	0f b6 45 74	 movzx	 eax, BYTE PTR _Windowed$[ebp]
  00267	a3 1c 00 00 00	 mov	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+28, eax

; 424  : 	ms_d3dPresentParameter.BackBufferWidth					= iHres;

  0026c	8b 45 6c	 mov	 eax, DWORD PTR _iHres$[ebp]
  0026f	a3 00 00 00 00	 mov	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A, eax

; 425  : 	ms_d3dPresentParameter.BackBufferHeight					= iVres;

  00274	8b 45 70	 mov	 eax, DWORD PTR _iVres$[ebp]
  00277	a3 04 00 00 00	 mov	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+4, eax

; 426  : 	ms_d3dPresentParameter.hDeviceWindow					= hWnd;

  0027c	8b 45 68	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0027f	a3 18 00 00 00	 mov	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+24, eax

; 427  : 	ms_d3dPresentParameter.BackBufferCount					= m_uBackBufferCount;

  00284	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00287	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0028a	a3 0c 00 00 00	 mov	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+12, eax

; 428  : 	ms_d3dPresentParameter.SwapEffect						= D3DSWAPEFFECT_DISCARD;

  0028f	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+20, 1

; 429  : 
; 430  : 	if (Windowed)

  00299	0f b6 45 74	 movzx	 eax, BYTE PTR _Windowed$[ebp]
  0029d	85 c0		 test	 eax, eax
  0029f	74 12		 je	 SHORT $LN12@Create

; 431  : 	{
; 432  : 		ms_d3dPresentParameter.BackBufferFormat				= pkD3DAdapterInfo->GetDesktopD3DDisplayModer().Format;

  002a1	8b 4d 20	 mov	 ecx, DWORD PTR _pkD3DAdapterInfo$[ebp]
  002a4	e8 00 00 00 00	 call	 ?GetDesktopD3DDisplayModer@D3D_CAdapterInfo@@QAEAAU_D3DDISPLAYMODE@@XZ ; D3D_CAdapterInfo::GetDesktopD3DDisplayModer
  002a9	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  002ac	a3 08 00 00 00	 mov	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+8, eax

; 433  : 	}

  002b1	eb 13		 jmp	 SHORT $LN13@Create
$LN12@Create:

; 434  : 	else
; 435  : 	{
; 436  : 		ms_d3dPresentParameter.BackBufferFormat				= pkD3DModeInfo->m_eD3DFmtPixel;

  002b3	8b 45 24	 mov	 eax, DWORD PTR _pkD3DModeInfo$[ebp]
  002b6	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  002b9	a3 08 00 00 00	 mov	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+8, eax

; 437  : 		ms_d3dPresentParameter.FullScreen_RefreshRateInHz	= iReflashRate;

  002be	8b 45 7c	 mov	 eax, DWORD PTR _iReflashRate$[ebp]
  002c1	a3 2c 00 00 00	 mov	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+44, eax
$LN13@Create:

; 438  : 	}
; 439  : 
; 440  : 	ms_d3dPresentParameter.Flags							= D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

  002c6	c7 05 28 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+40, 1

; 441  : 	ms_d3dPresentParameter.EnableAutoDepthStencil			= TRUE;

  002d0	c7 05 20 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+32, 1

; 442  : 	ms_d3dPresentParameter.AutoDepthStencilFormat			= pkD3DModeInfo->m_eD3DFmtDepthStencil;

  002da	8b 45 24	 mov	 eax, DWORD PTR _pkD3DModeInfo$[ebp]
  002dd	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  002e0	a3 24 00 00 00	 mov	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+36, eax

; 443  : 
; 444  : 	ms_dwD3DBehavior = pkD3DModeInfo->m_dwD3DBehavior;

  002e5	8b 45 24	 mov	 eax, DWORD PTR _pkD3DModeInfo$[ebp]
  002e8	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  002eb	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwD3DBehavior@CGraphicBase@@1KA, eax ; CGraphicBase::ms_dwD3DBehavior

; 445  : 
; 446  : 	if (FAILED(ms_hLastResult = ms_lpd3d->CreateDevice(

  002f0	68 00 00 00 00	 push	 OFFSET ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  002f5	68 00 00 00 00	 push	 OFFSET ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A ; CGraphicBase::ms_d3dPresentParameter
  002fa	8b 45 24	 mov	 eax, DWORD PTR _pkD3DModeInfo$[ebp]
  002fd	ff 70 0c	 push	 DWORD PTR [eax+12]
  00300	ff 75 68	 push	 DWORD PTR _hWnd$[ebp]
  00303	6a 01		 push	 1
  00305	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_iD3DAdapterInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DAdapterInfo
  0030b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A ; CGraphicBase::ms_lpd3d
  00310	8b 00		 mov	 eax, DWORD PTR [eax]
  00312	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A ; CGraphicBase::ms_lpd3d
  00318	ff 50 3c	 call	 DWORD PTR [eax+60]
  0031b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hLastResult@CGraphicBase@@1JA, eax ; CGraphicBase::ms_hLastResult
  00320	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_hLastResult@CGraphicBase@@1JA, 0 ; CGraphicBase::ms_hLastResult
  00327	0f 8d a2 00 00
	00		 jge	 $LN14@Create

; 447  : 				ms_iD3DAdapterInfo,
; 448  : 				D3DDEVTYPE_HAL,
; 449  : 				hWnd,
; 450  : 				// 2004. 1. 9 myevan      
; 451  : 				pkD3DModeInfo->m_dwD3DBehavior,
; 452  : 				&ms_d3dPresentParameter,
; 453  : 				&ms_lpd3dDevice)))
; 454  : 	{
; 455  : 		switch (ms_hLastResult)

  0032d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hLastResult@CGraphicBase@@1JA ; CGraphicBase::ms_hLastResult
  00332	89 45 18	 mov	 DWORD PTR tv224[ebp], eax
  00335	81 7d 18 7c 01
	76 88		 cmp	 DWORD PTR tv224[ebp], -2005532292 ; 8876017cH
  0033c	74 2e		 je	 SHORT $LN17@Create
  0033e	81 7d 18 6a 08
	76 88		 cmp	 DWORD PTR tv224[ebp], -2005530518 ; 8876086aH
  00345	74 18		 je	 SHORT $LN16@Create
  00347	81 7d 18 6c 08
	76 88		 cmp	 DWORD PTR tv224[ebp], -2005530516 ; 8876086cH
  0034e	74 02		 je	 SHORT $LN15@Create
  00350	eb 27		 jmp	 SHORT $LN18@Create
$LN15@Create:

; 456  : 		{
; 457  : 			case D3DERR_INVALIDCALL:
; 458  : 				Tracen("IDirect3DDevice.CreateDevice - ERROR D3DERR_INVALIDCALL\nThe method call is invalid. For example, a method's parameter may have an invalid value.");					

  00352	68 00 00 00 00	 push	 OFFSET ??_C@_0JB@NCJOPOMN@IDirect3DDevice?4CreateDevice?5?9?5@
  00357	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0035c	59		 pop	 ecx

; 459  : 				break;

  0035d	eb 2c		 jmp	 SHORT $LN2@Create
$LN16@Create:

; 460  : 			case D3DERR_NOTAVAILABLE:
; 461  : 				Tracen("IDirect3DDevice.CreateDevice - ERROR D3DERR_NOTAVAILABLE\nThis device does not support the queried technique. ");

  0035f	68 00 00 00 00	 push	 OFFSET ??_C@_0GO@ICOCNPJJ@IDirect3DDevice?4CreateDevice?5?9?5@
  00364	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00369	59		 pop	 ecx

; 462  : 				break;

  0036a	eb 1f		 jmp	 SHORT $LN2@Create
$LN17@Create:

; 463  : 			case D3DERR_OUTOFVIDEOMEMORY:
; 464  : 				Tracen("IDirect3DDevice.CreateDevice - ERROR D3DERR_OUTOFVIDEOMEMORY\nDirect3D does not have enough display memory to perform the operation");

  0036c	68 00 00 00 00	 push	 OFFSET ??_C@_0ID@GFNIEGEI@IDirect3DDevice?4CreateDevice?5?9?5@
  00371	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00376	59		 pop	 ecx

; 465  : 				break;

  00377	eb 12		 jmp	 SHORT $LN2@Create
$LN18@Create:

; 466  : 			default:
; 467  : 				Tracenf("IDirect3DDevice.CreateDevice - ERROR %d", ms_hLastResult);

  00379	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hLastResult@CGraphicBase@@1JA ; CGraphicBase::ms_hLastResult
  0037f	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@IPGGGCFB@IDirect3DDevice?4CreateDevice?5?9?5@
  00384	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00389	59		 pop	 ecx
  0038a	59		 pop	 ecx
$LN2@Create:

; 468  : 				break;
; 469  : 		}
; 470  : 
; 471  : 		if (ErrorCorrection)

  0038b	83 7d 14 00	 cmp	 DWORD PTR _ErrorCorrection$[ebp], 0
  0038f	74 27		 je	 SHORT $LN19@Create

; 472  : 			return CREATE_DEVICE;

  00391	c7 45 e0 10 00
	00 00		 mov	 DWORD PTR $T7[ebp], 16	; 00000010H
  00398	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0039c	8d 4d 2c	 lea	 ecx, DWORD PTR _stModeInfo$[ebp]
  0039f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 472  : 			return CREATE_DEVICE;

  003a4	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  003a8	8d 4d 44	 lea	 ecx, DWORD PTR _stDevList$[ebp]
  003ab	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 472  : 			return CREATE_DEVICE;

  003b0	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  003b3	e9 64 10 00 00	 jmp	 $LN1@Create
$LN19@Create:

; 473  : 	
; 474  : 		// 2004. 1. 9 myevan   ..   
; 475  : 		iReflashRate = 0;

  003b8	83 65 7c 00	 and	 DWORD PTR _iReflashRate$[ebp], 0

; 476  : 		++ErrorCorrection;

  003bc	8b 45 14	 mov	 eax, DWORD PTR _ErrorCorrection$[ebp]
  003bf	40		 inc	 eax
  003c0	89 45 14	 mov	 DWORD PTR _ErrorCorrection$[ebp], eax

; 477  : 		iRet = CREATE_REFRESHRATE;

  003c3	c7 45 1c 20 00
	00 00		 mov	 DWORD PTR _iRet$[ebp], 32 ; 00000020H

; 478  : 		goto RETRY;

  003ca	e9 83 fe ff ff	 jmp	 $RETRY$241
$LN14@Create:

; 479  : 	}
; 480  : 
; 481  : 	// Check DXT Support Info
; 482  : 	if(ms_lpd3d->CheckDeviceFormat(
; 483  : 				ms_iD3DAdapterInfo, 
; 484  : 				D3DDEVTYPE_HAL,
; 485  : 				ms_d3dPresentParameter.BackBufferFormat,
; 486  : 				0,
; 487  : 				D3DRTYPE_TEXTURE,
; 488  : 				D3DFMT_DXT1) == D3DERR_NOTAVAILABLE)

  003cf	68 44 58 54 31	 push	 827611204		; 31545844H
  003d4	6a 03		 push	 3
  003d6	6a 00		 push	 0
  003d8	ff 35 08 00 00
	00		 push	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+8
  003de	6a 01		 push	 1
  003e0	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_iD3DAdapterInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DAdapterInfo
  003e6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A ; CGraphicBase::ms_lpd3d
  003eb	8b 00		 mov	 eax, DWORD PTR [eax]
  003ed	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A ; CGraphicBase::ms_lpd3d
  003f3	ff 50 28	 call	 DWORD PTR [eax+40]
  003f6	3d 6a 08 76 88	 cmp	 eax, -2005530518	; 8876086aH
  003fb	75 07		 jne	 SHORT $LN20@Create

; 489  : 	{
; 490  : 		ms_bSupportDXT = false;

  003fd	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bSupportDXT@CGraphicBase@@1_NA, 0 ; CGraphicBase::ms_bSupportDXT
$LN20@Create:

; 491  : 	}
; 492  : 
; 493  : 	if(ms_lpd3d->CheckDeviceFormat(
; 494  : 				ms_iD3DAdapterInfo, 
; 495  : 				D3DDEVTYPE_HAL,
; 496  : 				ms_d3dPresentParameter.BackBufferFormat,
; 497  : 				0,
; 498  : 				D3DRTYPE_TEXTURE,
; 499  : 				D3DFMT_DXT3) == D3DERR_NOTAVAILABLE)

  00404	68 44 58 54 33	 push	 861165636		; 33545844H
  00409	6a 03		 push	 3
  0040b	6a 00		 push	 0
  0040d	ff 35 08 00 00
	00		 push	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+8
  00413	6a 01		 push	 1
  00415	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_iD3DAdapterInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DAdapterInfo
  0041b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A ; CGraphicBase::ms_lpd3d
  00420	8b 00		 mov	 eax, DWORD PTR [eax]
  00422	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A ; CGraphicBase::ms_lpd3d
  00428	ff 50 28	 call	 DWORD PTR [eax+40]
  0042b	3d 6a 08 76 88	 cmp	 eax, -2005530518	; 8876086aH
  00430	75 07		 jne	 SHORT $LN21@Create

; 500  : 	{
; 501  : 		ms_bSupportDXT = false;

  00432	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bSupportDXT@CGraphicBase@@1_NA, 0 ; CGraphicBase::ms_bSupportDXT
$LN21@Create:

; 502  : 	}
; 503  : 
; 504  : 	if(ms_lpd3d->CheckDeviceFormat(
; 505  : 				ms_iD3DAdapterInfo, 
; 506  : 				D3DDEVTYPE_HAL,
; 507  : 				ms_d3dPresentParameter.BackBufferFormat,
; 508  : 				0,
; 509  : 				D3DRTYPE_TEXTURE,
; 510  : 				D3DFMT_DXT5) == D3DERR_NOTAVAILABLE)

  00439	68 44 58 54 35	 push	 894720068		; 35545844H
  0043e	6a 03		 push	 3
  00440	6a 00		 push	 0
  00442	ff 35 08 00 00
	00		 push	 DWORD PTR ?ms_d3dPresentParameter@CGraphicBase@@1U_D3DPRESENT_PARAMETERS_@@A+8
  00448	6a 01		 push	 1
  0044a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_iD3DAdapterInfo@CGraphicBase@@1IA ; CGraphicBase::ms_iD3DAdapterInfo
  00450	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A ; CGraphicBase::ms_lpd3d
  00455	8b 00		 mov	 eax, DWORD PTR [eax]
  00457	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A ; CGraphicBase::ms_lpd3d
  0045d	ff 50 28	 call	 DWORD PTR [eax+40]
  00460	3d 6a 08 76 88	 cmp	 eax, -2005530518	; 8876086aH
  00465	75 07		 jne	 SHORT $LN22@Create

; 511  : 	{
; 512  : 		ms_bSupportDXT = false;

  00467	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bSupportDXT@CGraphicBase@@1_NA, 0 ; CGraphicBase::ms_bSupportDXT
$LN22@Create:

; 513  : 	}	
; 514  : 
; 515  : 	if (FAILED((ms_hLastResult = ms_lpd3dDevice->GetDeviceCaps(&ms_d3dCaps))))

  0046e	68 00 00 00 00	 push	 OFFSET ?ms_d3dCaps@CGraphicBase@@1U_D3DCAPS8@@A ; CGraphicBase::ms_d3dCaps
  00473	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00478	8b 00		 mov	 eax, DWORD PTR [eax]
  0047a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00480	ff 50 1c	 call	 DWORD PTR [eax+28]
  00483	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hLastResult@CGraphicBase@@1JA, eax ; CGraphicBase::ms_hLastResult
  00488	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_hLastResult@CGraphicBase@@1JA, 0 ; CGraphicBase::ms_hLastResult
  0048f	7d 39		 jge	 SHORT $LN23@Create

; 516  : 	{
; 517  : 		Tracenf("IDirect3DDevice.GetDeviceCaps - ERROR %d", ms_hLastResult);

  00491	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hLastResult@CGraphicBase@@1JA ; CGraphicBase::ms_hLastResult
  00497	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@PKDINAHJ@IDirect3DDevice?4GetDeviceCaps?5?9@
  0049c	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  004a1	59		 pop	 ecx
  004a2	59		 pop	 ecx

; 518  : 		return CREATE_GET_DEVICE_CAPS2;

  004a3	c7 45 dc 08 00
	00 00		 mov	 DWORD PTR $T6[ebp], 8
  004aa	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  004ae	8d 4d 2c	 lea	 ecx, DWORD PTR _stModeInfo$[ebp]
  004b1	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 518  : 		return CREATE_GET_DEVICE_CAPS2;

  004b6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  004ba	8d 4d 44	 lea	 ecx, DWORD PTR _stDevList$[ebp]
  004bd	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 518  : 		return CREATE_GET_DEVICE_CAPS2;

  004c2	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  004c5	e9 52 0f 00 00	 jmp	 $LN1@Create
$LN23@Create:

; 519  : 	}
; 520  : 
; 521  : 	if (!Windowed)

  004ca	0f b6 45 74	 movzx	 eax, BYTE PTR _Windowed$[ebp]
  004ce	85 c0		 test	 eax, eax
  004d0	75 17		 jne	 SHORT $LN24@Create

; 522  : 		SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, iHres, iVres, SWP_SHOWWINDOW);

  004d2	6a 40		 push	 64			; 00000040H
  004d4	ff 75 70	 push	 DWORD PTR _iVres$[ebp]
  004d7	ff 75 6c	 push	 DWORD PTR _iHres$[ebp]
  004da	6a 00		 push	 0
  004dc	6a 00		 push	 0
  004de	6a ff		 push	 -1
  004e0	ff 75 68	 push	 DWORD PTR _hWnd$[ebp]
  004e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
$LN24@Create:

; 523  : 
; 524  : 	//Tracef("vertex shader version : %X\n",(DWORD)ms_d3dCaps.VertexShaderVersion);
; 525  : 
; 526  : 	ms_lpd3dDevice->GetViewport(&ms_Viewport);

  004e9	68 00 00 00 00	 push	 OFFSET ?ms_Viewport@CGraphicBase@@1U_D3DVIEWPORT8@@A ; CGraphicBase::ms_Viewport
  004ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  004f3	8b 00		 mov	 eax, DWORD PTR [eax]
  004f5	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  004fb	ff 90 a4 00 00
	00		 call	 DWORD PTR [eax+164]

; 527  : 
; 528  : 	m_pStateManager = new CStateManager(ms_lpd3dDevice);

  00501	68 7c 33 01 00	 push	 78716			; 0001337cH
  00506	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0050b	59		 pop	 ecx
  0050c	89 45 0c	 mov	 DWORD PTR $T11[ebp], eax
  0050f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00513	83 7d 0c 00	 cmp	 DWORD PTR $T11[ebp], 0
  00517	74 13		 je	 SHORT $LN37@Create
  00519	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0051f	8b 4d 0c	 mov	 ecx, DWORD PTR $T11[ebp]
  00522	e8 00 00 00 00	 call	 ??0CStateManager@@QAE@PAUIDirect3DDevice8@@@Z ; CStateManager::CStateManager
  00527	89 45 08	 mov	 DWORD PTR tv302[ebp], eax
  0052a	eb 04		 jmp	 SHORT $LN38@Create
$LN37@Create:
  0052c	83 65 08 00	 and	 DWORD PTR tv302[ebp], 0
$LN38@Create:
  00530	8b 45 08	 mov	 eax, DWORD PTR tv302[ebp]
  00533	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
  00536	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0053a	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0053d	8b 4d d8	 mov	 ecx, DWORD PTR $T5[ebp]
  00540	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 529  : 
; 530  : 	D3DXCreateMatrixStack(0, &ms_lpd3dMatStack);

  00543	68 00 00 00 00	 push	 OFFSET ?ms_lpd3dMatStack@CGraphicBase@@1PAUID3DXMatrixStack@@A ; CGraphicBase::ms_lpd3dMatStack
  00548	6a 00		 push	 0
  0054a	e8 00 00 00 00	 call	 _D3DXCreateMatrixStack@8

; 531  : 	ms_lpd3dMatStack->LoadIdentity();

  0054f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dMatStack@CGraphicBase@@1PAUID3DXMatrixStack@@A ; CGraphicBase::ms_lpd3dMatStack
  00554	8b 00		 mov	 eax, DWORD PTR [eax]
  00556	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dMatStack@CGraphicBase@@1PAUID3DXMatrixStack@@A ; CGraphicBase::ms_lpd3dMatStack
  0055c	ff 50 14	 call	 DWORD PTR [eax+20]

; 532  : 
; 533  : 	ms_ptVS	= CreatePTStreamVertexShader();

  0055f	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00562	e8 00 00 00 00	 call	 ?CreatePTStreamVertexShader@CGraphicDevice@@IAEKXZ ; CGraphicDevice::CreatePTStreamVertexShader
  00567	a3 00 00 00 00	 mov	 DWORD PTR ?ms_ptVS@CGraphicBase@@1KA, eax ; CGraphicBase::ms_ptVS

; 534  : 	ms_pntVS = CreatePNTStreamVertexShader();

  0056c	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0056f	e8 00 00 00 00	 call	 ?CreatePNTStreamVertexShader@CGraphicDevice@@IAEKXZ ; CGraphicDevice::CreatePNTStreamVertexShader
  00574	a3 00 00 00 00	 mov	 DWORD PTR ?ms_pntVS@CGraphicBase@@1KA, eax ; CGraphicBase::ms_pntVS

; 535  : 	ms_pnt2VS = CreatePNT2StreamVertexShader();

  00579	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0057c	e8 00 00 00 00	 call	 ?CreatePNT2StreamVertexShader@CGraphicDevice@@IAEKXZ ; CGraphicDevice::CreatePNT2StreamVertexShader
  00581	a3 00 00 00 00	 mov	 DWORD PTR ?ms_pnt2VS@CGraphicBase@@1KA, eax ; CGraphicBase::ms_pnt2VS
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00586	6a 10		 push	 16			; 00000010H
  00588	58		 pop	 eax
  00589	6b c0 03	 imul	 eax, eax, 3
  0058c	6a 04		 push	 4
  0058e	59		 pop	 ecx
  0058f	d1 e1		 shl	 ecx, 1
  00591	0f 57 c0	 xorps	 xmm0, xmm0
  00594	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  0059d	6a 10		 push	 16			; 00000010H
  0059f	58		 pop	 eax
  005a0	6b c0 03	 imul	 eax, eax, 3
  005a3	6a 04		 push	 4
  005a5	59		 pop	 ecx
  005a6	c1 e1 00	 shl	 ecx, 0
  005a9	0f 57 c0	 xorps	 xmm0, xmm0
  005ac	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  005b5	6a 10		 push	 16			; 00000010H
  005b7	58		 pop	 eax
  005b8	6b c0 03	 imul	 eax, eax, 3
  005bb	6a 04		 push	 4
  005bd	59		 pop	 ecx
  005be	6b c9 00	 imul	 ecx, ecx, 0
  005c1	0f 57 c0	 xorps	 xmm0, xmm0
  005c4	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  005cd	6a 10		 push	 16			; 00000010H
  005cf	58		 pop	 eax
  005d0	d1 e0		 shl	 eax, 1
  005d2	6a 04		 push	 4
  005d4	59		 pop	 ecx
  005d5	6b c9 03	 imul	 ecx, ecx, 3
  005d8	0f 57 c0	 xorps	 xmm0, xmm0
  005db	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  005e4	6a 10		 push	 16			; 00000010H
  005e6	58		 pop	 eax
  005e7	d1 e0		 shl	 eax, 1
  005e9	6a 04		 push	 4
  005eb	59		 pop	 ecx
  005ec	c1 e1 00	 shl	 ecx, 0
  005ef	0f 57 c0	 xorps	 xmm0, xmm0
  005f2	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  005fb	6a 10		 push	 16			; 00000010H
  005fd	58		 pop	 eax
  005fe	d1 e0		 shl	 eax, 1
  00600	6a 04		 push	 4
  00602	59		 pop	 ecx
  00603	6b c9 00	 imul	 ecx, ecx, 0
  00606	0f 57 c0	 xorps	 xmm0, xmm0
  00609	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00612	6a 10		 push	 16			; 00000010H
  00614	58		 pop	 eax
  00615	c1 e0 00	 shl	 eax, 0
  00618	6a 04		 push	 4
  0061a	59		 pop	 ecx
  0061b	6b c9 03	 imul	 ecx, ecx, 3
  0061e	0f 57 c0	 xorps	 xmm0, xmm0
  00621	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  0062a	6a 10		 push	 16			; 00000010H
  0062c	58		 pop	 eax
  0062d	c1 e0 00	 shl	 eax, 0
  00630	6a 04		 push	 4
  00632	59		 pop	 ecx
  00633	d1 e1		 shl	 ecx, 1
  00635	0f 57 c0	 xorps	 xmm0, xmm0
  00638	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00641	6a 10		 push	 16			; 00000010H
  00643	58		 pop	 eax
  00644	c1 e0 00	 shl	 eax, 0
  00647	6a 04		 push	 4
  00649	59		 pop	 ecx
  0064a	6b c9 00	 imul	 ecx, ecx, 0
  0064d	0f 57 c0	 xorps	 xmm0, xmm0
  00650	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00659	6a 10		 push	 16			; 00000010H
  0065b	58		 pop	 eax
  0065c	6b c0 00	 imul	 eax, eax, 0
  0065f	6a 04		 push	 4
  00661	59		 pop	 ecx
  00662	6b c9 03	 imul	 ecx, ecx, 3
  00665	0f 57 c0	 xorps	 xmm0, xmm0
  00668	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00671	6a 10		 push	 16			; 00000010H
  00673	58		 pop	 eax
  00674	6b c0 00	 imul	 eax, eax, 0
  00677	6a 04		 push	 4
  00679	59		 pop	 ecx
  0067a	d1 e1		 shl	 ecx, 1
  0067c	0f 57 c0	 xorps	 xmm0, xmm0
  0067f	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00688	6a 10		 push	 16			; 00000010H
  0068a	58		 pop	 eax
  0068b	6b c0 00	 imul	 eax, eax, 0
  0068e	6a 04		 push	 4
  00690	59		 pop	 ecx
  00691	c1 e1 00	 shl	 ecx, 0
  00694	0f 57 c0	 xorps	 xmm0, xmm0
  00697	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  006a0	6a 10		 push	 16			; 00000010H
  006a2	58		 pop	 eax
  006a3	6b c0 03	 imul	 eax, eax, 3
  006a6	6a 04		 push	 4
  006a8	59		 pop	 ecx
  006a9	6b c9 03	 imul	 ecx, ecx, 3
  006ac	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006b4	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  006bd	6a 10		 push	 16			; 00000010H
  006bf	58		 pop	 eax
  006c0	d1 e0		 shl	 eax, 1
  006c2	6a 04		 push	 4
  006c4	59		 pop	 ecx
  006c5	d1 e1		 shl	 ecx, 1
  006c7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006cf	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  006d8	6a 10		 push	 16			; 00000010H
  006da	58		 pop	 eax
  006db	c1 e0 00	 shl	 eax, 0
  006de	6a 04		 push	 4
  006e0	59		 pop	 ecx
  006e1	c1 e1 00	 shl	 ecx, 0
  006e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  006ec	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  006f5	6a 10		 push	 16			; 00000010H
  006f7	58		 pop	 eax
  006f8	6b c0 00	 imul	 eax, eax, 0
  006fb	6a 04		 push	 4
  006fd	59		 pop	 ecx
  006fe	6b c9 00	 imul	 ecx, ecx, 0
  00701	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00709	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00712	6a 10		 push	 16			; 00000010H
  00714	58		 pop	 eax
  00715	6b c0 03	 imul	 eax, eax, 3
  00718	6a 04		 push	 4
  0071a	59		 pop	 ecx
  0071b	d1 e1		 shl	 ecx, 1
  0071d	0f 57 c0	 xorps	 xmm0, xmm0
  00720	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00729	6a 10		 push	 16			; 00000010H
  0072b	58		 pop	 eax
  0072c	6b c0 03	 imul	 eax, eax, 3
  0072f	6a 04		 push	 4
  00731	59		 pop	 ecx
  00732	c1 e1 00	 shl	 ecx, 0
  00735	0f 57 c0	 xorps	 xmm0, xmm0
  00738	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00741	6a 10		 push	 16			; 00000010H
  00743	58		 pop	 eax
  00744	6b c0 03	 imul	 eax, eax, 3
  00747	6a 04		 push	 4
  00749	59		 pop	 ecx
  0074a	6b c9 00	 imul	 ecx, ecx, 0
  0074d	0f 57 c0	 xorps	 xmm0, xmm0
  00750	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00759	6a 10		 push	 16			; 00000010H
  0075b	58		 pop	 eax
  0075c	d1 e0		 shl	 eax, 1
  0075e	6a 04		 push	 4
  00760	59		 pop	 ecx
  00761	6b c9 03	 imul	 ecx, ecx, 3
  00764	0f 57 c0	 xorps	 xmm0, xmm0
  00767	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00770	6a 10		 push	 16			; 00000010H
  00772	58		 pop	 eax
  00773	d1 e0		 shl	 eax, 1
  00775	6a 04		 push	 4
  00777	59		 pop	 ecx
  00778	c1 e1 00	 shl	 ecx, 0
  0077b	0f 57 c0	 xorps	 xmm0, xmm0
  0077e	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00787	6a 10		 push	 16			; 00000010H
  00789	58		 pop	 eax
  0078a	d1 e0		 shl	 eax, 1
  0078c	6a 04		 push	 4
  0078e	59		 pop	 ecx
  0078f	6b c9 00	 imul	 ecx, ecx, 0
  00792	0f 57 c0	 xorps	 xmm0, xmm0
  00795	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  0079e	6a 10		 push	 16			; 00000010H
  007a0	58		 pop	 eax
  007a1	c1 e0 00	 shl	 eax, 0
  007a4	6a 04		 push	 4
  007a6	59		 pop	 ecx
  007a7	6b c9 03	 imul	 ecx, ecx, 3
  007aa	0f 57 c0	 xorps	 xmm0, xmm0
  007ad	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  007b6	6a 10		 push	 16			; 00000010H
  007b8	58		 pop	 eax
  007b9	c1 e0 00	 shl	 eax, 0
  007bc	6a 04		 push	 4
  007be	59		 pop	 ecx
  007bf	d1 e1		 shl	 ecx, 1
  007c1	0f 57 c0	 xorps	 xmm0, xmm0
  007c4	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  007cd	6a 10		 push	 16			; 00000010H
  007cf	58		 pop	 eax
  007d0	c1 e0 00	 shl	 eax, 0
  007d3	6a 04		 push	 4
  007d5	59		 pop	 ecx
  007d6	6b c9 00	 imul	 ecx, ecx, 0
  007d9	0f 57 c0	 xorps	 xmm0, xmm0
  007dc	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  007e5	6a 10		 push	 16			; 00000010H
  007e7	58		 pop	 eax
  007e8	6b c0 00	 imul	 eax, eax, 0
  007eb	6a 04		 push	 4
  007ed	59		 pop	 ecx
  007ee	6b c9 03	 imul	 ecx, ecx, 3
  007f1	0f 57 c0	 xorps	 xmm0, xmm0
  007f4	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  007fd	6a 10		 push	 16			; 00000010H
  007ff	58		 pop	 eax
  00800	6b c0 00	 imul	 eax, eax, 0
  00803	6a 04		 push	 4
  00805	59		 pop	 ecx
  00806	d1 e1		 shl	 ecx, 1
  00808	0f 57 c0	 xorps	 xmm0, xmm0
  0080b	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00814	6a 10		 push	 16			; 00000010H
  00816	58		 pop	 eax
  00817	6b c0 00	 imul	 eax, eax, 0
  0081a	6a 04		 push	 4
  0081c	59		 pop	 ecx
  0081d	c1 e1 00	 shl	 ecx, 0
  00820	0f 57 c0	 xorps	 xmm0, xmm0
  00823	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  0082c	6a 10		 push	 16			; 00000010H
  0082e	58		 pop	 eax
  0082f	6b c0 03	 imul	 eax, eax, 3
  00832	6a 04		 push	 4
  00834	59		 pop	 ecx
  00835	6b c9 03	 imul	 ecx, ecx, 3
  00838	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00840	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00849	6a 10		 push	 16			; 00000010H
  0084b	58		 pop	 eax
  0084c	d1 e0		 shl	 eax, 1
  0084e	6a 04		 push	 4
  00850	59		 pop	 ecx
  00851	d1 e1		 shl	 ecx, 1
  00853	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0085b	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00864	6a 10		 push	 16			; 00000010H
  00866	58		 pop	 eax
  00867	c1 e0 00	 shl	 eax, 0
  0086a	6a 04		 push	 4
  0086c	59		 pop	 ecx
  0086d	c1 e1 00	 shl	 ecx, 0
  00870	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00878	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00881	6a 10		 push	 16			; 00000010H
  00883	58		 pop	 eax
  00884	6b c0 00	 imul	 eax, eax, 0
  00887	6a 04		 push	 4
  00889	59		 pop	 ecx
  0088a	6b c9 00	 imul	 ecx, ecx, 0
  0088d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00895	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  0089e	6a 10		 push	 16			; 00000010H
  008a0	58		 pop	 eax
  008a1	6b c0 03	 imul	 eax, eax, 3
  008a4	6a 04		 push	 4
  008a6	59		 pop	 ecx
  008a7	d1 e1		 shl	 ecx, 1
  008a9	0f 57 c0	 xorps	 xmm0, xmm0
  008ac	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  008b5	6a 10		 push	 16			; 00000010H
  008b7	58		 pop	 eax
  008b8	6b c0 03	 imul	 eax, eax, 3
  008bb	6a 04		 push	 4
  008bd	59		 pop	 ecx
  008be	c1 e1 00	 shl	 ecx, 0
  008c1	0f 57 c0	 xorps	 xmm0, xmm0
  008c4	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  008cd	6a 10		 push	 16			; 00000010H
  008cf	58		 pop	 eax
  008d0	6b c0 03	 imul	 eax, eax, 3
  008d3	6a 04		 push	 4
  008d5	59		 pop	 ecx
  008d6	6b c9 00	 imul	 ecx, ecx, 0
  008d9	0f 57 c0	 xorps	 xmm0, xmm0
  008dc	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  008e5	6a 10		 push	 16			; 00000010H
  008e7	58		 pop	 eax
  008e8	d1 e0		 shl	 eax, 1
  008ea	6a 04		 push	 4
  008ec	59		 pop	 ecx
  008ed	6b c9 03	 imul	 ecx, ecx, 3
  008f0	0f 57 c0	 xorps	 xmm0, xmm0
  008f3	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  008fc	6a 10		 push	 16			; 00000010H
  008fe	58		 pop	 eax
  008ff	d1 e0		 shl	 eax, 1
  00901	6a 04		 push	 4
  00903	59		 pop	 ecx
  00904	c1 e1 00	 shl	 ecx, 0
  00907	0f 57 c0	 xorps	 xmm0, xmm0
  0090a	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00913	6a 10		 push	 16			; 00000010H
  00915	58		 pop	 eax
  00916	d1 e0		 shl	 eax, 1
  00918	6a 04		 push	 4
  0091a	59		 pop	 ecx
  0091b	6b c9 00	 imul	 ecx, ecx, 0
  0091e	0f 57 c0	 xorps	 xmm0, xmm0
  00921	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  0092a	6a 10		 push	 16			; 00000010H
  0092c	58		 pop	 eax
  0092d	c1 e0 00	 shl	 eax, 0
  00930	6a 04		 push	 4
  00932	59		 pop	 ecx
  00933	6b c9 03	 imul	 ecx, ecx, 3
  00936	0f 57 c0	 xorps	 xmm0, xmm0
  00939	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00942	6a 10		 push	 16			; 00000010H
  00944	58		 pop	 eax
  00945	c1 e0 00	 shl	 eax, 0
  00948	6a 04		 push	 4
  0094a	59		 pop	 ecx
  0094b	d1 e1		 shl	 ecx, 1
  0094d	0f 57 c0	 xorps	 xmm0, xmm0
  00950	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00959	6a 10		 push	 16			; 00000010H
  0095b	58		 pop	 eax
  0095c	c1 e0 00	 shl	 eax, 0
  0095f	6a 04		 push	 4
  00961	59		 pop	 ecx
  00962	6b c9 00	 imul	 ecx, ecx, 0
  00965	0f 57 c0	 xorps	 xmm0, xmm0
  00968	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00971	6a 10		 push	 16			; 00000010H
  00973	58		 pop	 eax
  00974	6b c0 00	 imul	 eax, eax, 0
  00977	6a 04		 push	 4
  00979	59		 pop	 ecx
  0097a	6b c9 03	 imul	 ecx, ecx, 3
  0097d	0f 57 c0	 xorps	 xmm0, xmm0
  00980	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00989	6a 10		 push	 16			; 00000010H
  0098b	58		 pop	 eax
  0098c	6b c0 00	 imul	 eax, eax, 0
  0098f	6a 04		 push	 4
  00991	59		 pop	 ecx
  00992	d1 e1		 shl	 ecx, 1
  00994	0f 57 c0	 xorps	 xmm0, xmm0
  00997	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  009a0	6a 10		 push	 16			; 00000010H
  009a2	58		 pop	 eax
  009a3	6b c0 00	 imul	 eax, eax, 0
  009a6	6a 04		 push	 4
  009a8	59		 pop	 ecx
  009a9	c1 e1 00	 shl	 ecx, 0
  009ac	0f 57 c0	 xorps	 xmm0, xmm0
  009af	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  009b8	6a 10		 push	 16			; 00000010H
  009ba	58		 pop	 eax
  009bb	6b c0 03	 imul	 eax, eax, 3
  009be	6a 04		 push	 4
  009c0	59		 pop	 ecx
  009c1	6b c9 03	 imul	 ecx, ecx, 3
  009c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  009cc	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  009d5	6a 10		 push	 16			; 00000010H
  009d7	58		 pop	 eax
  009d8	d1 e0		 shl	 eax, 1
  009da	6a 04		 push	 4
  009dc	59		 pop	 ecx
  009dd	d1 e1		 shl	 ecx, 1
  009df	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  009e7	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  009f0	6a 10		 push	 16			; 00000010H
  009f2	58		 pop	 eax
  009f3	c1 e0 00	 shl	 eax, 0
  009f6	6a 04		 push	 4
  009f8	59		 pop	 ecx
  009f9	c1 e1 00	 shl	 ecx, 0
  009fc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a04	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00a0d	6a 10		 push	 16			; 00000010H
  00a0f	58		 pop	 eax
  00a10	6b c0 00	 imul	 eax, eax, 0
  00a13	6a 04		 push	 4
  00a15	59		 pop	 ecx
  00a16	6b c9 00	 imul	 ecx, ecx, 0
  00a19	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a21	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00a2a	6a 10		 push	 16			; 00000010H
  00a2c	58		 pop	 eax
  00a2d	6b c0 03	 imul	 eax, eax, 3
  00a30	6a 04		 push	 4
  00a32	59		 pop	 ecx
  00a33	d1 e1		 shl	 ecx, 1
  00a35	0f 57 c0	 xorps	 xmm0, xmm0
  00a38	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00a41	6a 10		 push	 16			; 00000010H
  00a43	58		 pop	 eax
  00a44	6b c0 03	 imul	 eax, eax, 3
  00a47	6a 04		 push	 4
  00a49	59		 pop	 ecx
  00a4a	c1 e1 00	 shl	 ecx, 0
  00a4d	0f 57 c0	 xorps	 xmm0, xmm0
  00a50	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00a59	6a 10		 push	 16			; 00000010H
  00a5b	58		 pop	 eax
  00a5c	6b c0 03	 imul	 eax, eax, 3
  00a5f	6a 04		 push	 4
  00a61	59		 pop	 ecx
  00a62	6b c9 00	 imul	 ecx, ecx, 0
  00a65	0f 57 c0	 xorps	 xmm0, xmm0
  00a68	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00a71	6a 10		 push	 16			; 00000010H
  00a73	58		 pop	 eax
  00a74	d1 e0		 shl	 eax, 1
  00a76	6a 04		 push	 4
  00a78	59		 pop	 ecx
  00a79	6b c9 03	 imul	 ecx, ecx, 3
  00a7c	0f 57 c0	 xorps	 xmm0, xmm0
  00a7f	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00a88	6a 10		 push	 16			; 00000010H
  00a8a	58		 pop	 eax
  00a8b	d1 e0		 shl	 eax, 1
  00a8d	6a 04		 push	 4
  00a8f	59		 pop	 ecx
  00a90	c1 e1 00	 shl	 ecx, 0
  00a93	0f 57 c0	 xorps	 xmm0, xmm0
  00a96	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00a9f	6a 10		 push	 16			; 00000010H
  00aa1	58		 pop	 eax
  00aa2	d1 e0		 shl	 eax, 1
  00aa4	6a 04		 push	 4
  00aa6	59		 pop	 ecx
  00aa7	6b c9 00	 imul	 ecx, ecx, 0
  00aaa	0f 57 c0	 xorps	 xmm0, xmm0
  00aad	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00ab6	6a 10		 push	 16			; 00000010H
  00ab8	58		 pop	 eax
  00ab9	c1 e0 00	 shl	 eax, 0
  00abc	6a 04		 push	 4
  00abe	59		 pop	 ecx
  00abf	6b c9 03	 imul	 ecx, ecx, 3
  00ac2	0f 57 c0	 xorps	 xmm0, xmm0
  00ac5	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00ace	6a 10		 push	 16			; 00000010H
  00ad0	58		 pop	 eax
  00ad1	c1 e0 00	 shl	 eax, 0
  00ad4	6a 04		 push	 4
  00ad6	59		 pop	 ecx
  00ad7	d1 e1		 shl	 ecx, 1
  00ad9	0f 57 c0	 xorps	 xmm0, xmm0
  00adc	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00ae5	6a 10		 push	 16			; 00000010H
  00ae7	58		 pop	 eax
  00ae8	c1 e0 00	 shl	 eax, 0
  00aeb	6a 04		 push	 4
  00aed	59		 pop	 ecx
  00aee	6b c9 00	 imul	 ecx, ecx, 0
  00af1	0f 57 c0	 xorps	 xmm0, xmm0
  00af4	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00afd	6a 10		 push	 16			; 00000010H
  00aff	58		 pop	 eax
  00b00	6b c0 00	 imul	 eax, eax, 0
  00b03	6a 04		 push	 4
  00b05	59		 pop	 ecx
  00b06	6b c9 03	 imul	 ecx, ecx, 3
  00b09	0f 57 c0	 xorps	 xmm0, xmm0
  00b0c	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00b15	6a 10		 push	 16			; 00000010H
  00b17	58		 pop	 eax
  00b18	6b c0 00	 imul	 eax, eax, 0
  00b1b	6a 04		 push	 4
  00b1d	59		 pop	 ecx
  00b1e	d1 e1		 shl	 ecx, 1
  00b20	0f 57 c0	 xorps	 xmm0, xmm0
  00b23	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00b2c	6a 10		 push	 16			; 00000010H
  00b2e	58		 pop	 eax
  00b2f	6b c0 00	 imul	 eax, eax, 0
  00b32	6a 04		 push	 4
  00b34	59		 pop	 ecx
  00b35	c1 e1 00	 shl	 ecx, 0
  00b38	0f 57 c0	 xorps	 xmm0, xmm0
  00b3b	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00b44	6a 10		 push	 16			; 00000010H
  00b46	58		 pop	 eax
  00b47	6b c0 03	 imul	 eax, eax, 3
  00b4a	6a 04		 push	 4
  00b4c	59		 pop	 ecx
  00b4d	6b c9 03	 imul	 ecx, ecx, 3
  00b50	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b58	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00b61	6a 10		 push	 16			; 00000010H
  00b63	58		 pop	 eax
  00b64	d1 e0		 shl	 eax, 1
  00b66	6a 04		 push	 4
  00b68	59		 pop	 ecx
  00b69	d1 e1		 shl	 ecx, 1
  00b6b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b73	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00b7c	6a 10		 push	 16			; 00000010H
  00b7e	58		 pop	 eax
  00b7f	c1 e0 00	 shl	 eax, 0
  00b82	6a 04		 push	 4
  00b84	59		 pop	 ecx
  00b85	c1 e1 00	 shl	 ecx, 0
  00b88	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b90	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00b99	6a 10		 push	 16			; 00000010H
  00b9b	58		 pop	 eax
  00b9c	6b c0 00	 imul	 eax, eax, 0
  00b9f	6a 04		 push	 4
  00ba1	59		 pop	 ecx
  00ba2	6b c9 00	 imul	 ecx, ecx, 0
  00ba5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00bad	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseView@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00bb6	6a 10		 push	 16			; 00000010H
  00bb8	58		 pop	 eax
  00bb9	6b c0 03	 imul	 eax, eax, 3
  00bbc	6a 04		 push	 4
  00bbe	59		 pop	 ecx
  00bbf	d1 e1		 shl	 ecx, 1
  00bc1	0f 57 c0	 xorps	 xmm0, xmm0
  00bc4	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00bcd	6a 10		 push	 16			; 00000010H
  00bcf	58		 pop	 eax
  00bd0	6b c0 03	 imul	 eax, eax, 3
  00bd3	6a 04		 push	 4
  00bd5	59		 pop	 ecx
  00bd6	c1 e1 00	 shl	 ecx, 0
  00bd9	0f 57 c0	 xorps	 xmm0, xmm0
  00bdc	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00be5	6a 10		 push	 16			; 00000010H
  00be7	58		 pop	 eax
  00be8	6b c0 03	 imul	 eax, eax, 3
  00beb	6a 04		 push	 4
  00bed	59		 pop	 ecx
  00bee	6b c9 00	 imul	 ecx, ecx, 0
  00bf1	0f 57 c0	 xorps	 xmm0, xmm0
  00bf4	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00bfd	6a 10		 push	 16			; 00000010H
  00bff	58		 pop	 eax
  00c00	d1 e0		 shl	 eax, 1
  00c02	6a 04		 push	 4
  00c04	59		 pop	 ecx
  00c05	6b c9 03	 imul	 ecx, ecx, 3
  00c08	0f 57 c0	 xorps	 xmm0, xmm0
  00c0b	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00c14	6a 10		 push	 16			; 00000010H
  00c16	58		 pop	 eax
  00c17	d1 e0		 shl	 eax, 1
  00c19	6a 04		 push	 4
  00c1b	59		 pop	 ecx
  00c1c	c1 e1 00	 shl	 ecx, 0
  00c1f	0f 57 c0	 xorps	 xmm0, xmm0
  00c22	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00c2b	6a 10		 push	 16			; 00000010H
  00c2d	58		 pop	 eax
  00c2e	d1 e0		 shl	 eax, 1
  00c30	6a 04		 push	 4
  00c32	59		 pop	 ecx
  00c33	6b c9 00	 imul	 ecx, ecx, 0
  00c36	0f 57 c0	 xorps	 xmm0, xmm0
  00c39	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00c42	6a 10		 push	 16			; 00000010H
  00c44	58		 pop	 eax
  00c45	c1 e0 00	 shl	 eax, 0
  00c48	6a 04		 push	 4
  00c4a	59		 pop	 ecx
  00c4b	6b c9 03	 imul	 ecx, ecx, 3
  00c4e	0f 57 c0	 xorps	 xmm0, xmm0
  00c51	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00c5a	6a 10		 push	 16			; 00000010H
  00c5c	58		 pop	 eax
  00c5d	c1 e0 00	 shl	 eax, 0
  00c60	6a 04		 push	 4
  00c62	59		 pop	 ecx
  00c63	d1 e1		 shl	 ecx, 1
  00c65	0f 57 c0	 xorps	 xmm0, xmm0
  00c68	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00c71	6a 10		 push	 16			; 00000010H
  00c73	58		 pop	 eax
  00c74	c1 e0 00	 shl	 eax, 0
  00c77	6a 04		 push	 4
  00c79	59		 pop	 ecx
  00c7a	6b c9 00	 imul	 ecx, ecx, 0
  00c7d	0f 57 c0	 xorps	 xmm0, xmm0
  00c80	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00c89	6a 10		 push	 16			; 00000010H
  00c8b	58		 pop	 eax
  00c8c	6b c0 00	 imul	 eax, eax, 0
  00c8f	6a 04		 push	 4
  00c91	59		 pop	 ecx
  00c92	6b c9 03	 imul	 ecx, ecx, 3
  00c95	0f 57 c0	 xorps	 xmm0, xmm0
  00c98	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00ca1	6a 10		 push	 16			; 00000010H
  00ca3	58		 pop	 eax
  00ca4	6b c0 00	 imul	 eax, eax, 0
  00ca7	6a 04		 push	 4
  00ca9	59		 pop	 ecx
  00caa	d1 e1		 shl	 ecx, 1
  00cac	0f 57 c0	 xorps	 xmm0, xmm0
  00caf	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00cb8	6a 10		 push	 16			; 00000010H
  00cba	58		 pop	 eax
  00cbb	6b c0 00	 imul	 eax, eax, 0
  00cbe	6a 04		 push	 4
  00cc0	59		 pop	 ecx
  00cc1	c1 e1 00	 shl	 ecx, 0
  00cc4	0f 57 c0	 xorps	 xmm0, xmm0
  00cc7	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00cd0	6a 10		 push	 16			; 00000010H
  00cd2	58		 pop	 eax
  00cd3	6b c0 03	 imul	 eax, eax, 3
  00cd6	6a 04		 push	 4
  00cd8	59		 pop	 ecx
  00cd9	6b c9 03	 imul	 ecx, ecx, 3
  00cdc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ce4	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00ced	6a 10		 push	 16			; 00000010H
  00cef	58		 pop	 eax
  00cf0	d1 e0		 shl	 eax, 1
  00cf2	6a 04		 push	 4
  00cf4	59		 pop	 ecx
  00cf5	d1 e1		 shl	 ecx, 1
  00cf7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00cff	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00d08	6a 10		 push	 16			; 00000010H
  00d0a	58		 pop	 eax
  00d0b	c1 e0 00	 shl	 eax, 0
  00d0e	6a 04		 push	 4
  00d10	59		 pop	 ecx
  00d11	c1 e1 00	 shl	 ecx, 0
  00d14	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00d1c	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00d25	6a 10		 push	 16			; 00000010H
  00d27	58		 pop	 eax
  00d28	6b c0 00	 imul	 eax, eax, 0
  00d2b	6a 04		 push	 4
  00d2d	59		 pop	 ecx
  00d2e	6b c9 00	 imul	 ecx, ecx, 0
  00d31	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00d39	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matInverseViewYAxis@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00d42	6a 10		 push	 16			; 00000010H
  00d44	58		 pop	 eax
  00d45	6b c0 03	 imul	 eax, eax, 3
  00d48	6a 04		 push	 4
  00d4a	59		 pop	 ecx
  00d4b	d1 e1		 shl	 ecx, 1
  00d4d	0f 57 c0	 xorps	 xmm0, xmm0
  00d50	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00d59	6a 10		 push	 16			; 00000010H
  00d5b	58		 pop	 eax
  00d5c	6b c0 03	 imul	 eax, eax, 3
  00d5f	6a 04		 push	 4
  00d61	59		 pop	 ecx
  00d62	c1 e1 00	 shl	 ecx, 0
  00d65	0f 57 c0	 xorps	 xmm0, xmm0
  00d68	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00d71	6a 10		 push	 16			; 00000010H
  00d73	58		 pop	 eax
  00d74	6b c0 03	 imul	 eax, eax, 3
  00d77	6a 04		 push	 4
  00d79	59		 pop	 ecx
  00d7a	6b c9 00	 imul	 ecx, ecx, 0
  00d7d	0f 57 c0	 xorps	 xmm0, xmm0
  00d80	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00d89	6a 10		 push	 16			; 00000010H
  00d8b	58		 pop	 eax
  00d8c	d1 e0		 shl	 eax, 1
  00d8e	6a 04		 push	 4
  00d90	59		 pop	 ecx
  00d91	6b c9 03	 imul	 ecx, ecx, 3
  00d94	0f 57 c0	 xorps	 xmm0, xmm0
  00d97	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00da0	6a 10		 push	 16			; 00000010H
  00da2	58		 pop	 eax
  00da3	d1 e0		 shl	 eax, 1
  00da5	6a 04		 push	 4
  00da7	59		 pop	 ecx
  00da8	c1 e1 00	 shl	 ecx, 0
  00dab	0f 57 c0	 xorps	 xmm0, xmm0
  00dae	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00db7	6a 10		 push	 16			; 00000010H
  00db9	58		 pop	 eax
  00dba	d1 e0		 shl	 eax, 1
  00dbc	6a 04		 push	 4
  00dbe	59		 pop	 ecx
  00dbf	6b c9 00	 imul	 ecx, ecx, 0
  00dc2	0f 57 c0	 xorps	 xmm0, xmm0
  00dc5	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00dce	6a 10		 push	 16			; 00000010H
  00dd0	58		 pop	 eax
  00dd1	c1 e0 00	 shl	 eax, 0
  00dd4	6a 04		 push	 4
  00dd6	59		 pop	 ecx
  00dd7	6b c9 03	 imul	 ecx, ecx, 3
  00dda	0f 57 c0	 xorps	 xmm0, xmm0
  00ddd	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00de6	6a 10		 push	 16			; 00000010H
  00de8	58		 pop	 eax
  00de9	c1 e0 00	 shl	 eax, 0
  00dec	6a 04		 push	 4
  00dee	59		 pop	 ecx
  00def	d1 e1		 shl	 ecx, 1
  00df1	0f 57 c0	 xorps	 xmm0, xmm0
  00df4	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00dfd	6a 10		 push	 16			; 00000010H
  00dff	58		 pop	 eax
  00e00	c1 e0 00	 shl	 eax, 0
  00e03	6a 04		 push	 4
  00e05	59		 pop	 ecx
  00e06	6b c9 00	 imul	 ecx, ecx, 0
  00e09	0f 57 c0	 xorps	 xmm0, xmm0
  00e0c	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00e15	6a 10		 push	 16			; 00000010H
  00e17	58		 pop	 eax
  00e18	6b c0 00	 imul	 eax, eax, 0
  00e1b	6a 04		 push	 4
  00e1d	59		 pop	 ecx
  00e1e	6b c9 03	 imul	 ecx, ecx, 3
  00e21	0f 57 c0	 xorps	 xmm0, xmm0
  00e24	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00e2d	6a 10		 push	 16			; 00000010H
  00e2f	58		 pop	 eax
  00e30	6b c0 00	 imul	 eax, eax, 0
  00e33	6a 04		 push	 4
  00e35	59		 pop	 ecx
  00e36	d1 e1		 shl	 ecx, 1
  00e38	0f 57 c0	 xorps	 xmm0, xmm0
  00e3b	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00e44	6a 10		 push	 16			; 00000010H
  00e46	58		 pop	 eax
  00e47	6b c0 00	 imul	 eax, eax, 0
  00e4a	6a 04		 push	 4
  00e4c	59		 pop	 ecx
  00e4d	c1 e1 00	 shl	 ecx, 0
  00e50	0f 57 c0	 xorps	 xmm0, xmm0
  00e53	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00e5c	6a 10		 push	 16			; 00000010H
  00e5e	58		 pop	 eax
  00e5f	6b c0 03	 imul	 eax, eax, 3
  00e62	6a 04		 push	 4
  00e64	59		 pop	 ecx
  00e65	6b c9 03	 imul	 ecx, ecx, 3
  00e68	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e70	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00e79	6a 10		 push	 16			; 00000010H
  00e7b	58		 pop	 eax
  00e7c	d1 e0		 shl	 eax, 1
  00e7e	6a 04		 push	 4
  00e80	59		 pop	 ecx
  00e81	d1 e1		 shl	 ecx, 1
  00e83	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e8b	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00e94	6a 10		 push	 16			; 00000010H
  00e96	58		 pop	 eax
  00e97	c1 e0 00	 shl	 eax, 0
  00e9a	6a 04		 push	 4
  00e9c	59		 pop	 ecx
  00e9d	c1 e1 00	 shl	 ecx, 0
  00ea0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ea8	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00eb1	6a 10		 push	 16			; 00000010H
  00eb3	58		 pop	 eax
  00eb4	6b c0 00	 imul	 eax, eax, 0
  00eb7	6a 04		 push	 4
  00eb9	59		 pop	 ecx
  00eba	6b c9 00	 imul	 ecx, ecx, 0
  00ebd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ec5	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00ece	6a 10		 push	 16			; 00000010H
  00ed0	58		 pop	 eax
  00ed1	6b c0 03	 imul	 eax, eax, 3
  00ed4	6a 04		 push	 4
  00ed6	59		 pop	 ecx
  00ed7	d1 e1		 shl	 ecx, 1
  00ed9	0f 57 c0	 xorps	 xmm0, xmm0
  00edc	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00ee5	6a 10		 push	 16			; 00000010H
  00ee7	58		 pop	 eax
  00ee8	6b c0 03	 imul	 eax, eax, 3
  00eeb	6a 04		 push	 4
  00eed	59		 pop	 ecx
  00eee	c1 e1 00	 shl	 ecx, 0
  00ef1	0f 57 c0	 xorps	 xmm0, xmm0
  00ef4	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00efd	6a 10		 push	 16			; 00000010H
  00eff	58		 pop	 eax
  00f00	6b c0 03	 imul	 eax, eax, 3
  00f03	6a 04		 push	 4
  00f05	59		 pop	 ecx
  00f06	6b c9 00	 imul	 ecx, ecx, 0
  00f09	0f 57 c0	 xorps	 xmm0, xmm0
  00f0c	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00f15	6a 10		 push	 16			; 00000010H
  00f17	58		 pop	 eax
  00f18	d1 e0		 shl	 eax, 1
  00f1a	6a 04		 push	 4
  00f1c	59		 pop	 ecx
  00f1d	6b c9 03	 imul	 ecx, ecx, 3
  00f20	0f 57 c0	 xorps	 xmm0, xmm0
  00f23	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00f2c	6a 10		 push	 16			; 00000010H
  00f2e	58		 pop	 eax
  00f2f	d1 e0		 shl	 eax, 1
  00f31	6a 04		 push	 4
  00f33	59		 pop	 ecx
  00f34	c1 e1 00	 shl	 ecx, 0
  00f37	0f 57 c0	 xorps	 xmm0, xmm0
  00f3a	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00f43	6a 10		 push	 16			; 00000010H
  00f45	58		 pop	 eax
  00f46	d1 e0		 shl	 eax, 1
  00f48	6a 04		 push	 4
  00f4a	59		 pop	 ecx
  00f4b	6b c9 00	 imul	 ecx, ecx, 0
  00f4e	0f 57 c0	 xorps	 xmm0, xmm0
  00f51	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00f5a	6a 10		 push	 16			; 00000010H
  00f5c	58		 pop	 eax
  00f5d	c1 e0 00	 shl	 eax, 0
  00f60	6a 04		 push	 4
  00f62	59		 pop	 ecx
  00f63	6b c9 03	 imul	 ecx, ecx, 3
  00f66	0f 57 c0	 xorps	 xmm0, xmm0
  00f69	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00f72	6a 10		 push	 16			; 00000010H
  00f74	58		 pop	 eax
  00f75	c1 e0 00	 shl	 eax, 0
  00f78	6a 04		 push	 4
  00f7a	59		 pop	 ecx
  00f7b	d1 e1		 shl	 ecx, 1
  00f7d	0f 57 c0	 xorps	 xmm0, xmm0
  00f80	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00f89	6a 10		 push	 16			; 00000010H
  00f8b	58		 pop	 eax
  00f8c	c1 e0 00	 shl	 eax, 0
  00f8f	6a 04		 push	 4
  00f91	59		 pop	 ecx
  00f92	6b c9 00	 imul	 ecx, ecx, 0
  00f95	0f 57 c0	 xorps	 xmm0, xmm0
  00f98	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00fa1	6a 10		 push	 16			; 00000010H
  00fa3	58		 pop	 eax
  00fa4	6b c0 00	 imul	 eax, eax, 0
  00fa7	6a 04		 push	 4
  00fa9	59		 pop	 ecx
  00faa	6b c9 03	 imul	 ecx, ecx, 3
  00fad	0f 57 c0	 xorps	 xmm0, xmm0
  00fb0	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00fb9	6a 10		 push	 16			; 00000010H
  00fbb	58		 pop	 eax
  00fbc	6b c0 00	 imul	 eax, eax, 0
  00fbf	6a 04		 push	 4
  00fc1	59		 pop	 ecx
  00fc2	d1 e1		 shl	 ecx, 1
  00fc4	0f 57 c0	 xorps	 xmm0, xmm0
  00fc7	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  00fd0	6a 10		 push	 16			; 00000010H
  00fd2	58		 pop	 eax
  00fd3	6b c0 00	 imul	 eax, eax, 0
  00fd6	6a 04		 push	 4
  00fd8	59		 pop	 ecx
  00fd9	c1 e1 00	 shl	 ecx, 0
  00fdc	0f 57 c0	 xorps	 xmm0, xmm0
  00fdf	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00fe8	6a 10		 push	 16			; 00000010H
  00fea	58		 pop	 eax
  00feb	6b c0 03	 imul	 eax, eax, 3
  00fee	6a 04		 push	 4
  00ff0	59		 pop	 ecx
  00ff1	6b c9 03	 imul	 ecx, ecx, 3
  00ff4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00ffc	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  01005	6a 10		 push	 16			; 00000010H
  01007	58		 pop	 eax
  01008	d1 e0		 shl	 eax, 1
  0100a	6a 04		 push	 4
  0100c	59		 pop	 ecx
  0100d	d1 e1		 shl	 ecx, 1
  0100f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01017	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  01020	6a 10		 push	 16			; 00000010H
  01022	58		 pop	 eax
  01023	c1 e0 00	 shl	 eax, 0
  01026	6a 04		 push	 4
  01028	59		 pop	 ecx
  01029	c1 e1 00	 shl	 ecx, 0
  0102c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01034	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  0103d	6a 10		 push	 16			; 00000010H
  0103f	58		 pop	 eax
  01040	6b c0 00	 imul	 eax, eax, 0
  01043	6a 04		 push	 4
  01045	59		 pop	 ecx
  01046	6b c9 00	 imul	 ecx, ecx, 0
  01049	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01051	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  0105a	6a 10		 push	 16			; 00000010H
  0105c	58		 pop	 eax
  0105d	6b c0 03	 imul	 eax, eax, 3
  01060	6a 04		 push	 4
  01062	59		 pop	 ecx
  01063	d1 e1		 shl	 ecx, 1
  01065	0f 57 c0	 xorps	 xmm0, xmm0
  01068	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  01071	6a 10		 push	 16			; 00000010H
  01073	58		 pop	 eax
  01074	6b c0 03	 imul	 eax, eax, 3
  01077	6a 04		 push	 4
  01079	59		 pop	 ecx
  0107a	c1 e1 00	 shl	 ecx, 0
  0107d	0f 57 c0	 xorps	 xmm0, xmm0
  01080	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  01089	6a 10		 push	 16			; 00000010H
  0108b	58		 pop	 eax
  0108c	6b c0 03	 imul	 eax, eax, 3
  0108f	6a 04		 push	 4
  01091	59		 pop	 ecx
  01092	6b c9 00	 imul	 ecx, ecx, 0
  01095	0f 57 c0	 xorps	 xmm0, xmm0
  01098	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  010a1	6a 10		 push	 16			; 00000010H
  010a3	58		 pop	 eax
  010a4	d1 e0		 shl	 eax, 1
  010a6	6a 04		 push	 4
  010a8	59		 pop	 ecx
  010a9	6b c9 03	 imul	 ecx, ecx, 3
  010ac	0f 57 c0	 xorps	 xmm0, xmm0
  010af	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  010b8	6a 10		 push	 16			; 00000010H
  010ba	58		 pop	 eax
  010bb	d1 e0		 shl	 eax, 1
  010bd	6a 04		 push	 4
  010bf	59		 pop	 ecx
  010c0	c1 e1 00	 shl	 ecx, 0
  010c3	0f 57 c0	 xorps	 xmm0, xmm0
  010c6	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  010cf	6a 10		 push	 16			; 00000010H
  010d1	58		 pop	 eax
  010d2	d1 e0		 shl	 eax, 1
  010d4	6a 04		 push	 4
  010d6	59		 pop	 ecx
  010d7	6b c9 00	 imul	 ecx, ecx, 0
  010da	0f 57 c0	 xorps	 xmm0, xmm0
  010dd	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  010e6	6a 10		 push	 16			; 00000010H
  010e8	58		 pop	 eax
  010e9	c1 e0 00	 shl	 eax, 0
  010ec	6a 04		 push	 4
  010ee	59		 pop	 ecx
  010ef	6b c9 03	 imul	 ecx, ecx, 3
  010f2	0f 57 c0	 xorps	 xmm0, xmm0
  010f5	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  010fe	6a 10		 push	 16			; 00000010H
  01100	58		 pop	 eax
  01101	c1 e0 00	 shl	 eax, 0
  01104	6a 04		 push	 4
  01106	59		 pop	 ecx
  01107	d1 e1		 shl	 ecx, 1
  01109	0f 57 c0	 xorps	 xmm0, xmm0
  0110c	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  01115	6a 10		 push	 16			; 00000010H
  01117	58		 pop	 eax
  01118	c1 e0 00	 shl	 eax, 0
  0111b	6a 04		 push	 4
  0111d	59		 pop	 ecx
  0111e	6b c9 00	 imul	 ecx, ecx, 0
  01121	0f 57 c0	 xorps	 xmm0, xmm0
  01124	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  0112d	6a 10		 push	 16			; 00000010H
  0112f	58		 pop	 eax
  01130	6b c0 00	 imul	 eax, eax, 0
  01133	6a 04		 push	 4
  01135	59		 pop	 ecx
  01136	6b c9 03	 imul	 ecx, ecx, 3
  01139	0f 57 c0	 xorps	 xmm0, xmm0
  0113c	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  01145	6a 10		 push	 16			; 00000010H
  01147	58		 pop	 eax
  01148	6b c0 00	 imul	 eax, eax, 0
  0114b	6a 04		 push	 4
  0114d	59		 pop	 ecx
  0114e	d1 e1		 shl	 ecx, 1
  01150	0f 57 c0	 xorps	 xmm0, xmm0
  01153	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  0115c	6a 10		 push	 16			; 00000010H
  0115e	58		 pop	 eax
  0115f	6b c0 00	 imul	 eax, eax, 0
  01162	6a 04		 push	 4
  01164	59		 pop	 ecx
  01165	c1 e1 00	 shl	 ecx, 0
  01168	0f 57 c0	 xorps	 xmm0, xmm0
  0116b	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  01174	6a 10		 push	 16			; 00000010H
  01176	58		 pop	 eax
  01177	6b c0 03	 imul	 eax, eax, 3
  0117a	6a 04		 push	 4
  0117c	59		 pop	 ecx
  0117d	6b c9 03	 imul	 ecx, ecx, 3
  01180	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01188	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  01191	6a 10		 push	 16			; 00000010H
  01193	58		 pop	 eax
  01194	d1 e0		 shl	 eax, 1
  01196	6a 04		 push	 4
  01198	59		 pop	 ecx
  01199	d1 e1		 shl	 ecx, 1
  0119b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  011a3	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  011ac	6a 10		 push	 16			; 00000010H
  011ae	58		 pop	 eax
  011af	c1 e0 00	 shl	 eax, 0
  011b2	6a 04		 push	 4
  011b4	59		 pop	 ecx
  011b5	c1 e1 00	 shl	 ecx, 0
  011b8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  011c0	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
  011c9	6a 10		 push	 16			; 00000010H
  011cb	58		 pop	 eax
  011cc	6b c0 00	 imul	 eax, eax, 0
  011cf	6a 04		 push	 4
  011d1	59		 pop	 ecx
  011d2	6b c9 00	 imul	 ecx, ecx, 0
  011d5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  011dd	f3 0f 11 84 08
	00 00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A[eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 546  : 	ms_matScreen0._11 = 1;

  011e6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  011ee	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A, xmm0

; 547  : 	ms_matScreen0._22 = -1;	

  011f6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  011fe	f3 0f 11 05 14
	00 00 00	 movss	 DWORD PTR ?ms_matScreen0@CGraphicBase@@1UD3DXMATRIX@@A+20, xmm0

; 548  : 
; 549  : 	ms_matScreen1._41 = 1;

  01206	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0120e	f3 0f 11 05 30
	00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A+48, xmm0

; 550  : 	ms_matScreen1._42 = 1;

  01216	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0121e	f3 0f 11 05 34
	00 00 00	 movss	 DWORD PTR ?ms_matScreen1@CGraphicBase@@1UD3DXMATRIX@@A+52, xmm0

; 551  : 
; 552  : 	ms_matScreen2._11 = (float) iHres / 2;

  01226	f3 0f 2a 45 6c	 cvtsi2ss xmm0, DWORD PTR _iHres$[ebp]
  0122b	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  01233	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A, xmm0

; 553  : 	ms_matScreen2._22 = (float) iVres / 2;

  0123b	f3 0f 2a 45 70	 cvtsi2ss xmm0, DWORD PTR _iVres$[ebp]
  01240	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  01248	f3 0f 11 05 14
	00 00 00	 movss	 DWORD PTR ?ms_matScreen2@CGraphicBase@@1UD3DXMATRIX@@A+20, xmm0

; 554  : 	
; 555  : 	D3DXCreateSphere(ms_lpd3dDevice, 1.0f, 32, 32, &ms_lpSphereMesh, NULL);

  01250	6a 00		 push	 0
  01252	68 00 00 00 00	 push	 OFFSET ?ms_lpSphereMesh@CGraphicBase@@1PAUID3DXMesh@@A ; CGraphicBase::ms_lpSphereMesh
  01257	6a 20		 push	 32			; 00000020H
  01259	6a 20		 push	 32			; 00000020H
  0125b	51		 push	 ecx
  0125c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01264	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  01269	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0126f	e8 00 00 00 00	 call	 _D3DXCreateSphere@24

; 556  : 	D3DXCreateCylinder(ms_lpd3dDevice, 1.0f, 1.0f, 1.0f, 8, 8, &ms_lpCylinderMesh, NULL);

  01274	6a 00		 push	 0
  01276	68 00 00 00 00	 push	 OFFSET ?ms_lpCylinderMesh@CGraphicBase@@1PAUID3DXMesh@@A ; CGraphicBase::ms_lpCylinderMesh
  0127b	6a 08		 push	 8
  0127d	6a 08		 push	 8
  0127f	51		 push	 ecx
  01280	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01288	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0128d	51		 push	 ecx
  0128e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  01296	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0129b	51		 push	 ecx
  0129c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  012a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  012a9	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  012af	e8 00 00 00 00	 call	 _D3DXCreateCylinder@32

; 557  : 
; 558  : 	ms_lpd3dDevice->Clear(0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xff000000, 1.0f, 0);

  012b4	6a 00		 push	 0
  012b6	51		 push	 ecx
  012b7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  012bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  012c4	68 00 00 00 ff	 push	 -16777216		; ff000000H
  012c9	6a 03		 push	 3
  012cb	6a 00		 push	 0
  012cd	6a 00		 push	 0
  012cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  012d4	8b 00		 mov	 eax, DWORD PTR [eax]
  012d6	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  012dc	ff 90 90 00 00
	00		 call	 DWORD PTR [eax+144]

; 559  : 
; 560  : 	if (!__CreateDefaultIndexBufferList())

  012e2	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  012e5	e8 00 00 00 00	 call	 ?__CreateDefaultIndexBufferList@CGraphicDevice@@IAE_NXZ ; CGraphicDevice::__CreateDefaultIndexBufferList
  012ea	0f b6 c0	 movzx	 eax, al
  012ed	85 c0		 test	 eax, eax
  012ef	75 24		 jne	 SHORT $LN25@Create

; 561  : 		return false;

  012f1	83 65 d4 00	 and	 DWORD PTR $T4[ebp], 0
  012f5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  012f9	8d 4d 2c	 lea	 ecx, DWORD PTR _stModeInfo$[ebp]
  012fc	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 561  : 		return false;

  01301	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  01305	8d 4d 44	 lea	 ecx, DWORD PTR _stDevList$[ebp]
  01308	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 561  : 		return false;

  0130d	8b 45 d4	 mov	 eax, DWORD PTR $T4[ebp]
  01310	e9 07 01 00 00	 jmp	 $LN1@Create
$LN25@Create:

; 562  : 
; 563  : 	if (!__CreatePDTVertexBufferList())

  01315	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  01318	e8 00 00 00 00	 call	 ?__CreatePDTVertexBufferList@CGraphicDevice@@IAE_NXZ ; CGraphicDevice::__CreatePDTVertexBufferList
  0131d	0f b6 c0	 movzx	 eax, al
  01320	85 c0		 test	 eax, eax
  01322	75 24		 jne	 SHORT $LN26@Create

; 564  : 		return false;

  01324	83 65 d0 00	 and	 DWORD PTR $T3[ebp], 0
  01328	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0132c	8d 4d 2c	 lea	 ecx, DWORD PTR _stModeInfo$[ebp]
  0132f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 564  : 		return false;

  01334	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  01338	8d 4d 44	 lea	 ecx, DWORD PTR _stDevList$[ebp]
  0133b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 564  : 		return false;

  01340	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  01343	e9 d4 00 00 00	 jmp	 $LN1@Create
$LN26@Create:

; 565  : 	
; 566  : 	DWORD dwTexMemSize = GetAvailableTextureMemory();

  01348	e8 00 00 00 00	 call	 ?GetAvailableTextureMemory@CGraphicBase@@SAKXZ ; CGraphicBase::GetAvailableTextureMemory
  0134d	89 45 04	 mov	 DWORD PTR _dwTexMemSize$[ebp], eax

; 567  : 
; 568  : 	if (dwTexMemSize < 64 * 1024 * 1024)

  01350	81 7d 04 00 00
	00 04		 cmp	 DWORD PTR _dwTexMemSize$[ebp], 67108864 ; 04000000H
  01357	73 09		 jae	 SHORT $LN27@Create

; 569  : 		ms_isLowTextureMemory = true;

  01359	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_isLowTextureMemory@CGraphicBase@@1_NA, 1 ; CGraphicBase::ms_isLowTextureMemory
  01360	eb 07		 jmp	 SHORT $LN28@Create
$LN27@Create:

; 570  : 	else
; 571  : 		ms_isLowTextureMemory = false;

  01362	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_isLowTextureMemory@CGraphicBase@@1_NA, 0 ; CGraphicBase::ms_isLowTextureMemory
$LN28@Create:

; 572  : 
; 573  : 	if (dwTexMemSize > 100 * 1024 * 1024)

  01369	81 7d 04 00 00
	40 06		 cmp	 DWORD PTR _dwTexMemSize$[ebp], 104857600 ; 06400000H
  01370	76 09		 jbe	 SHORT $LN29@Create

; 574  : 		ms_isHighTextureMemory = true;

  01372	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_isHighTextureMemory@CGraphicBase@@1_NA, 1 ; CGraphicBase::ms_isHighTextureMemory
  01379	eb 07		 jmp	 SHORT $LN30@Create
$LN29@Create:

; 575  : 	else
; 576  : 		ms_isHighTextureMemory = false;

  0137b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_isHighTextureMemory@CGraphicBase@@1_NA, 0 ; CGraphicBase::ms_isHighTextureMemory
$LN30@Create:

; 577  : 
; 578  : 	if (ms_d3dCaps.TextureAddressCaps & D3DPTADDRESSCAPS_BORDER)

  01382	a1 4c 00 00 00	 mov	 eax, DWORD PTR ?ms_d3dCaps@CGraphicBase@@1U_D3DCAPS8@@A+76
  01387	83 e0 08	 and	 eax, 8
  0138a	74 09		 je	 SHORT $LN31@Create

; 579  : 		GRAPHICS_CAPS_CAN_NOT_TEXTURE_ADDRESS_BORDER=false;

  0138c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?GRAPHICS_CAPS_CAN_NOT_TEXTURE_ADDRESS_BORDER@@3_NA, 0 ; GRAPHICS_CAPS_CAN_NOT_TEXTURE_ADDRESS_BORDER
  01393	eb 07		 jmp	 SHORT $LN32@Create
$LN31@Create:

; 580  : 	else
; 581  : 		GRAPHICS_CAPS_CAN_NOT_TEXTURE_ADDRESS_BORDER=true;

  01395	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?GRAPHICS_CAPS_CAN_NOT_TEXTURE_ADDRESS_BORDER@@3_NA, 1 ; GRAPHICS_CAPS_CAN_NOT_TEXTURE_ADDRESS_BORDER
$LN32@Create:

; 582  : 
; 583  : 	//D3DADAPTER_IDENTIFIER8& rkD3DAdapterId=pkD3DAdapterInfo->GetIdentifier();
; 584  : 	if (strnicmp(rkD3DAdapterId.Driver, "SIS", 3) == 0)

  0139c	6a 03		 push	 3
  0139e	68 00 00 00 00	 push	 OFFSET ??_C@_03OJNODIHH@SIS@
  013a3	ff 75 10	 push	 DWORD PTR _rkD3DAdapterId$[ebp]
  013a6	e8 00 00 00 00	 call	 __strnicmp
  013ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  013ae	85 c0		 test	 eax, eax
  013b0	75 1e		 jne	 SHORT $LN33@Create

; 585  : 	{
; 586  : 		GRAPHICS_CAPS_CAN_NOT_DRAW_LINE = true;

  013b2	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?GRAPHICS_CAPS_CAN_NOT_DRAW_LINE@@3_NA, 1 ; GRAPHICS_CAPS_CAN_NOT_DRAW_LINE

; 587  : 		GRAPHICS_CAPS_CAN_NOT_DRAW_SHADOW = true;

  013b9	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?GRAPHICS_CAPS_CAN_NOT_DRAW_SHADOW@@3_NA, 1 ; GRAPHICS_CAPS_CAN_NOT_DRAW_SHADOW

; 588  : 		GRAPHICS_CAPS_HALF_SIZE_IMAGE = true;

  013c0	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?GRAPHICS_CAPS_HALF_SIZE_IMAGE@@3_NA, 1 ; GRAPHICS_CAPS_HALF_SIZE_IMAGE

; 589  : 		ms_isLowTextureMemory = true;

  013c7	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_isLowTextureMemory@CGraphicBase@@1_NA, 1 ; CGraphicBase::ms_isLowTextureMemory

; 590  : 	}

  013ce	eb 2b		 jmp	 SHORT $LN35@Create
$LN33@Create:

; 591  : 	else if (strnicmp(rkD3DAdapterId.Driver, "3dfx", 4) == 0)

  013d0	6a 04		 push	 4
  013d2	68 00 00 00 00	 push	 OFFSET ??_C@_04MAKEOOIM@3dfx@
  013d7	ff 75 10	 push	 DWORD PTR _rkD3DAdapterId$[ebp]
  013da	e8 00 00 00 00	 call	 __strnicmp
  013df	83 c4 0c	 add	 esp, 12			; 0000000cH
  013e2	85 c0		 test	 eax, eax
  013e4	75 15		 jne	 SHORT $LN35@Create

; 592  : 	{
; 593  : 		GRAPHICS_CAPS_CAN_NOT_DRAW_SHADOW = true;

  013e6	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?GRAPHICS_CAPS_CAN_NOT_DRAW_SHADOW@@3_NA, 1 ; GRAPHICS_CAPS_CAN_NOT_DRAW_SHADOW

; 594  : 		GRAPHICS_CAPS_HALF_SIZE_IMAGE = true;

  013ed	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?GRAPHICS_CAPS_HALF_SIZE_IMAGE@@3_NA, 1 ; GRAPHICS_CAPS_HALF_SIZE_IMAGE

; 595  : 		ms_isLowTextureMemory = true;

  013f4	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_isLowTextureMemory@CGraphicBase@@1_NA, 1 ; CGraphicBase::ms_isLowTextureMemory
$LN35@Create:

; 598  : 	return (iRet);

  013fb	8b 45 1c	 mov	 eax, DWORD PTR _iRet$[ebp]
  013fe	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
  01401	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  01405	8d 4d 2c	 lea	 ecx, DWORD PTR _stModeInfo$[ebp]
  01408	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 598  : 	return (iRet);

  0140d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  01411	8d 4d 44	 lea	 ecx, DWORD PTR _stDevList$[ebp]
  01414	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 598  : 	return (iRet);

  01419	8b 45 cc	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@Create:

; 599  : }

  0141c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0141f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01426	59		 pop	 ecx
  01427	8b 4d 5c	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0142a	33 cd		 xor	 ecx, ebp
  0142c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01431	83 c5 60	 add	 ebp, 96			; 00000060H
  01434	c9		 leave
  01435	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z$0:
  00000	8d 4d 44	 lea	 ecx, DWORD PTR _stDevList$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z$1:
  00008	8d 4d 2c	 lea	 ecx, DWORD PTR _stModeInfo$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z$2:
  00010	68 7c 33 01 00	 push	 78716			; 0001337cH
  00015	ff 75 0c	 push	 DWORD PTR $T11[ebp]
  00018	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001d	59		 pop	 ecx
  0001e	59		 pop	 ecx
  0001f	c3		 ret	 0
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
__ehhandler$?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z:
  00025	90		 npad	 1
  00026	90		 npad	 1
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	8b 4a 68	 mov	 ecx, DWORD PTR [edx+104]
  0003b	33 c8		 xor	 ecx, eax
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z
  00047	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Create@CGraphicDevice@@QAEHPAUHWND__@@HH_NHH@Z ENDP	; CGraphicDevice::Create
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?Destroy@CGraphicDevice@@QAEXXZ
_TEXT	SEGMENT
tv134 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?Destroy@CGraphicDevice@@QAEXXZ PROC			; CGraphicDevice::Destroy, COMDAT
; _this$ = ecx

; 722  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 723  : 	__DestroyPDTVertexBufferList();

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__DestroyPDTVertexBufferList@CGraphicDevice@@IAEXXZ ; CGraphicDevice::__DestroyPDTVertexBufferList

; 724  : 	__DestroyDefaultIndexBufferList();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?__DestroyDefaultIndexBufferList@CGraphicDevice@@IAEXXZ ; CGraphicDevice::__DestroyDefaultIndexBufferList

; 725  : 
; 726  : 	if (ms_hDC)

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_hDC@CGraphicBase@@1PAUHDC__@@A, 0 ; CGraphicBase::ms_hDC
  00020	74 19		 je	 SHORT $LN2@Destroy

; 727  : 	{
; 728  : 		ReleaseDC(ms_hWnd, ms_hDC);

  00022	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hDC@CGraphicBase@@1PAUHDC__@@A ; CGraphicBase::ms_hDC
  00028	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CGraphicBase@@1PAUHWND__@@A ; CGraphicBase::ms_hWnd
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 729  : 		ms_hDC = NULL;

  00034	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_hDC@CGraphicBase@@1PAUHDC__@@A, 0 ; CGraphicBase::ms_hDC
$LN2@Destroy:

; 730  : 	}
; 731  : 
; 732  : 	if (ms_ptVS)

  0003b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_ptVS@CGraphicBase@@1KA, 0 ; CGraphicBase::ms_ptVS
  00042	74 20		 je	 SHORT $LN3@Destroy

; 733  : 	{	
; 734  : 		ms_lpd3dDevice->DeleteVertexShader(ms_ptVS);

  00044	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_ptVS@CGraphicBase@@1KA ; CGraphicBase::ms_ptVS
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
  00051	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00057	ff 90 38 01 00
	00		 call	 DWORD PTR [eax+312]

; 735  : 		ms_ptVS = 0;;

  0005d	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_ptVS@CGraphicBase@@1KA, 0 ; CGraphicBase::ms_ptVS
$LN3@Destroy:

; 736  : 	}
; 737  : 
; 738  : 	if (ms_pntVS)

  00064	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pntVS@CGraphicBase@@1KA, 0 ; CGraphicBase::ms_pntVS
  0006b	74 20		 je	 SHORT $LN4@Destroy

; 739  : 	{	
; 740  : 		ms_lpd3dDevice->DeleteVertexShader(ms_pntVS);

  0006d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_pntVS@CGraphicBase@@1KA ; CGraphicBase::ms_pntVS
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00080	ff 90 38 01 00
	00		 call	 DWORD PTR [eax+312]

; 741  : 		ms_pntVS = 0;

  00086	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_pntVS@CGraphicBase@@1KA, 0 ; CGraphicBase::ms_pntVS
$LN4@Destroy:

; 742  : 	}
; 743  : 
; 744  : 	if (ms_pnt2VS)

  0008d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_pnt2VS@CGraphicBase@@1KA, 0 ; CGraphicBase::ms_pnt2VS
  00094	74 20		 je	 SHORT $LN5@Destroy

; 745  : 	{	
; 746  : 		ms_lpd3dDevice->DeleteVertexShader(ms_pnt2VS);

  00096	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_pnt2VS@CGraphicBase@@1KA ; CGraphicBase::ms_pnt2VS
  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  000a9	ff 90 38 01 00
	00		 call	 DWORD PTR [eax+312]

; 747  : 		ms_pnt2VS = 0;

  000af	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_pnt2VS@CGraphicBase@@1KA, 0 ; CGraphicBase::ms_pnt2VS
$LN5@Destroy:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h

; 138  : 	if (!rpObject)

  000b6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_lpSphereMesh@CGraphicBase@@1PAUID3DXMesh@@A, 0 ; CGraphicBase::ms_lpSphereMesh
  000bd	75 02		 jne	 SHORT $LN11@Destroy

; 139  : 		return;

  000bf	eb 17		 jmp	 SHORT $LN10@Destroy
$LN11@Destroy:

; 140  : 	
; 141  : 	rpObject->Release();

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpSphereMesh@CGraphicBase@@1PAUID3DXMesh@@A ; CGraphicBase::ms_lpSphereMesh
  000c6	8b 00		 mov	 eax, DWORD PTR [eax]
  000c8	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpSphereMesh@CGraphicBase@@1PAUID3DXMesh@@A ; CGraphicBase::ms_lpSphereMesh
  000ce	ff 50 08	 call	 DWORD PTR [eax+8]

; 142  : 	rpObject = NULL;

  000d1	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_lpSphereMesh@CGraphicBase@@1PAUID3DXMesh@@A, 0 ; CGraphicBase::ms_lpSphereMesh
$LN10@Destroy:

; 138  : 	if (!rpObject)

  000d8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_lpCylinderMesh@CGraphicBase@@1PAUID3DXMesh@@A, 0 ; CGraphicBase::ms_lpCylinderMesh
  000df	75 02		 jne	 SHORT $LN14@Destroy

; 139  : 		return;

  000e1	eb 17		 jmp	 SHORT $LN13@Destroy
$LN14@Destroy:

; 140  : 	
; 141  : 	rpObject->Release();

  000e3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpCylinderMesh@CGraphicBase@@1PAUID3DXMesh@@A ; CGraphicBase::ms_lpCylinderMesh
  000e8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ea	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpCylinderMesh@CGraphicBase@@1PAUID3DXMesh@@A ; CGraphicBase::ms_lpCylinderMesh
  000f0	ff 50 08	 call	 DWORD PTR [eax+8]

; 142  : 	rpObject = NULL;

  000f3	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_lpCylinderMesh@CGraphicBase@@1PAUID3DXMesh@@A, 0 ; CGraphicBase::ms_lpCylinderMesh
$LN13@Destroy:

; 138  : 	if (!rpObject)

  000fa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_lpd3dMatStack@CGraphicBase@@1PAUID3DXMatrixStack@@A, 0 ; CGraphicBase::ms_lpd3dMatStack
  00101	75 02		 jne	 SHORT $LN17@Destroy

; 139  : 		return;

  00103	eb 17		 jmp	 SHORT $LN16@Destroy
$LN17@Destroy:

; 140  : 	
; 141  : 	rpObject->Release();

  00105	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dMatStack@CGraphicBase@@1PAUID3DXMatrixStack@@A ; CGraphicBase::ms_lpd3dMatStack
  0010a	8b 00		 mov	 eax, DWORD PTR [eax]
  0010c	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dMatStack@CGraphicBase@@1PAUID3DXMatrixStack@@A ; CGraphicBase::ms_lpd3dMatStack
  00112	ff 50 08	 call	 DWORD PTR [eax+8]

; 142  : 	rpObject = NULL;

  00115	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_lpd3dMatStack@CGraphicBase@@1PAUID3DXMatrixStack@@A, 0 ; CGraphicBase::ms_lpd3dMatStack
$LN16@Destroy:

; 138  : 	if (!rpObject)

  0011c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A, 0 ; CGraphicBase::ms_lpd3dDevice
  00123	75 02		 jne	 SHORT $LN20@Destroy

; 139  : 		return;

  00125	eb 17		 jmp	 SHORT $LN19@Destroy
$LN20@Destroy:

; 140  : 	
; 141  : 	rpObject->Release();

  00127	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0012c	8b 00		 mov	 eax, DWORD PTR [eax]
  0012e	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00134	ff 50 08	 call	 DWORD PTR [eax+8]

; 142  : 	rpObject = NULL;

  00137	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A, 0 ; CGraphicBase::ms_lpd3dDevice
$LN19@Destroy:

; 138  : 	if (!rpObject)

  0013e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A, 0 ; CGraphicBase::ms_lpd3d
  00145	75 02		 jne	 SHORT $LN23@Destroy

; 139  : 		return;

  00147	eb 17		 jmp	 SHORT $LN22@Destroy
$LN23@Destroy:

; 140  : 	
; 141  : 	rpObject->Release();

  00149	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A ; CGraphicBase::ms_lpd3d
  0014e	8b 00		 mov	 eax, DWORD PTR [eax]
  00150	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A ; CGraphicBase::ms_lpd3d
  00156	ff 50 08	 call	 DWORD PTR [eax+8]

; 142  : 	rpObject = NULL;

  00159	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_lpd3d@CGraphicBase@@1PAUIDirect3D8@@A, 0 ; CGraphicBase::ms_lpd3d
$LN22@Destroy:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 757  : 	if (m_pStateManager)

  00160	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00163	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00167	74 2b		 je	 SHORT $LN6@Destroy

; 758  : 	{
; 759  : 		delete m_pStateManager;

  00169	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0016c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0016f	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00172	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00176	74 11		 je	 SHORT $LN8@Destroy
  00178	6a 01		 push	 1
  0017a	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0017d	8b 00		 mov	 eax, DWORD PTR [eax]
  0017f	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00182	ff 10		 call	 DWORD PTR [eax]
  00184	89 45 f4	 mov	 DWORD PTR tv134[ebp], eax
  00187	eb 04		 jmp	 SHORT $LN9@Destroy
$LN8@Destroy:
  00189	83 65 f4 00	 and	 DWORD PTR tv134[ebp], 0
$LN9@Destroy:

; 760  : 		m_pStateManager = NULL;

  0018d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00190	83 60 10 00	 and	 DWORD PTR [eax+16], 0
$LN6@Destroy:

; 761  : 	}
; 762  : 
; 763  : 	__Initialize();

  00194	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00197	e8 00 00 00 00	 call	 ?__Initialize@CGraphicDevice@@IAEXXZ ; CGraphicDevice::__Initialize

; 764  : }

  0019c	c9		 leave
  0019d	c3		 ret	 0
?Destroy@CGraphicDevice@@QAEXXZ ENDP			; CGraphicDevice::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ?InitBackBufferCount@CGraphicDevice@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_uBackBufferCount$ = 8					; size = 4
?InitBackBufferCount@CGraphicDevice@@QAEXI@Z PROC	; CGraphicDevice::InitBackBufferCount, COMDAT
; _this$ = ecx

; 717  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 718  : 	m_uBackBufferCount=uBackBufferCount;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _uBackBufferCount$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 719  : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?InitBackBufferCount@CGraphicDevice@@QAEXI@Z ENDP	; CGraphicDevice::InitBackBufferCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ??1CGraphicDevice@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CGraphicDevice@@UAE@XZ PROC				; CGraphicDevice::~CGraphicDevice, COMDAT
; _this$ = ecx

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGraphicDevice@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGraphicDevice@@6B@

; 24   : 	Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@CGraphicDevice@@QAEXXZ ; CGraphicDevice::Destroy

; 25   : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 08	 add	 ecx, 8
  0003d	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??1CGraphicBase@@UAE@XZ	; CGraphicBase::~CGraphicBase
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	c9		 leave
  00056	c3		 ret	 0
  00057	cc		 int	 3
  00058	cc		 int	 3
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CGraphicDevice@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CGraphicDevice@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CGraphicDevice@@UAE@XZ ENDP				; CGraphicDevice::~CGraphicDevice
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp
;	COMDAT ??0CGraphicDevice@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0CGraphicDevice@@QAE@XZ PROC				; CGraphicDevice::CGraphicDevice, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CGraphicDevice@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0CGraphicBase@@QAE@XZ	; CGraphicBase::CGraphicBase
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGraphicDevice@@6B@

; 17   : : m_uBackBufferCount(0)

  0003d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 18   : {

  00044	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00047	83 c0 08	 add	 eax, 8
  0004a	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 107  :     map() : _Mybase(key_compare()) {}

  0004d	8d 45 f3	 lea	 eax, DWORD PTR $T2[ebp]
  00050	50		 push	 eax
  00051	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpDevice.cpp

; 18   : {

  00059	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 19   : 	__Initialize();

  0005d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?__Initialize@CGraphicDevice@@IAEXXZ ; CGraphicDevice::__Initialize

; 20   : }

  00065	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00069	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00076	59		 pop	 ecx
  00077	c9		 leave
  00078	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CGraphicDevice@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CGraphicBase@@UAE@XZ	; CGraphicBase::~CGraphicBase
__unwindfunclet$??0CGraphicDevice@@QAE@XZ$1:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 08	 add	 ecx, 8
  0000e	e9 00 00 00 00	 jmp	 ??1?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0CGraphicDevice@@QAE@XZ:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CGraphicDevice@@QAE@XZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CGraphicDevice@@QAE@XZ ENDP				; CGraphicDevice::CGraphicDevice
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 414  : [[noreturn]] inline void _Throw_tree_length_error() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 415  :     _Xlength_error("map/set too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Throw_tree:

; 416  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 14 00	 and	 DWORD PTR [eax+20], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c9		 leave
  00019	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Result$ = -12						; size = 4
__Format$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2270 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2271 :         int _Result;
; 2272 :         va_list _ArgList;
; 2273 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax

; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Format$[ebp], eax

; 2176 :         return __stdio_common_vsscanf(

  00012	ff 75 fc	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f8	 push	 DWORD PTR __Format$[ebp]
  0001a	6a ff		 push	 -1
  0001c	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  0001f	e8 00 00 00 00	 call	 ___local_stdio_scanf_options
  00024	ff 70 04	 push	 DWORD PTR [eax+4]
  00027	ff 30		 push	 DWORD PTR [eax]
  00029	e8 00 00 00 00	 call	 ___stdio_common_vsscanf
  0002e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00031	89 45 f4	 mov	 DWORD PTR __Result$[ebp], eax

; 2275 :         __crt_va_end(_ArgList);

  00034	83 65 fc 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 2276 :         return _Result;

  00038	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp]

; 2277 :     }

  0003b	c9		 leave
  0003c	c3		 ret	 0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 96   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 97   :         static unsigned __int64 _OptionsStorage;
; 98   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 99   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
