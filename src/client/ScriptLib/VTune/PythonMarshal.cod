; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadObjectFromFile
PUBLIC	?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadLastObjectFromFile
PUBLIC	?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z	; _PyMarshal_ReadLongFromFile
PUBLIC	?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z	; _PyMarshal_ReadShortFromFile
PUBLIC	?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z ; _PyMarshal_ReadObjectFromString
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@ ; `string'
PUBLIC	??_C@_0BB@DCKILJJE@bad?5marshal?5data@		; `string'
PUBLIC	??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@ ; `string'
PUBLIC	??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@ ; `string'
PUBLIC	??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_atof:PROC
EXTRN	_memcpy:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	__fileno:PROC
EXTRN	_fread:PROC
EXTRN	_getc:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	__fstat64i32:PROC
EXTRN	__imp__PyUnicodeUCS2_DecodeUTF8:PROC
EXTRN	__imp__PyInt_FromLong:PROC
EXTRN	__imp___PyLong_FromByteArray:PROC
EXTRN	__imp__PyFloat_FromDouble:PROC
EXTRN	__imp__PyComplex_FromCComplex:PROC
EXTRN	__imp__PyString_FromStringAndSize:PROC
EXTRN	__imp__PyTuple_New:PROC
EXTRN	__imp__PyList_New:PROC
EXTRN	__imp__PyList_SetItem:PROC
EXTRN	__imp__PyDict_New:PROC
EXTRN	__imp__PyDict_SetItem:PROC
EXTRN	__imp__PyErr_SetString:PROC
EXTRN	__imp__PyErr_Occurred:PROC
EXTRN	__imp__PyErr_NoMemory:PROC
EXTRN	__imp__PyEval_GetRestricted:PROC
EXTRN	__imp__PyCode_New:PROC
EXTRN	__imp__PyMarshal_ReadObjectFromString:PROC
EXTRN	__imp___PyLong_New:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__imp___Py_NoneStruct:QWORD
EXTRN	__imp___Py_EllipsisObject:QWORD
EXTRN	__imp__PyExc_StopIteration:DWORD
EXTRN	__imp__PyExc_EOFError:DWORD
EXTRN	__imp__PyExc_RuntimeError:DWORD
EXTRN	__imp__PyExc_ValueError:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@
CONST	SEGMENT
??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@ DB 'XXX rds_objec'
	DB	't called with exception set', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@
CONST	SEGMENT
??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@ DB 'XXX rd_object '
	DB	'called with exception set', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@
CONST	SEGMENT
??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@ DB 'cannot unmars'
	DB	'hal code objects in restricted execution mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DCKILJJE@bad?5marshal?5data@
CONST	SEGMENT
??_C@_0BB@DCKILJJE@bad?5marshal?5data@ DB 'bad marshal data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
CONST	SEGMENT
??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@ DB 'EOF read where'
	DB	' object expected', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_str$ = 8						; size = 4
_len$ = 12						; size = 4
?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z PROC ; _PyMarshal_ReadObjectFromString, COMDAT

; 467  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 468  : 	RFILE rf;
; 469  : 	if (PyErr_Occurred()) {

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  0000c	85 c0		 test	 eax, eax
  0000e	74 19		 je	 SHORT $LN2@PyMarshal_

; 470  : 		fprintf(stderr, "XXX rds_object called with exception set\n");

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@
  00015	6a 02		 push	 2
  00017	e8 00 00 00 00	 call	 ___acrt_iob_func
  0001c	59		 pop	 ecx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _fprintf
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx

; 471  : 		return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 21		 jmp	 SHORT $LN1@PyMarshal_
$LN2@PyMarshal_:

; 472  : 	}
; 473  : 	rf.fp = NULL;

  00029	83 65 e8 00	 and	 DWORD PTR _rf$[ebp], 0

; 474  : 	rf.str = NULL;

  0002d	83 65 f4 00	 and	 DWORD PTR _rf$[ebp+12], 0

; 475  : 	rf.ptr = str;

  00031	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00034	89 45 f8	 mov	 DWORD PTR _rf$[ebp+16], eax

; 476  : 	rf.end = str + len;

  00037	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0003a	03 45 0c	 add	 eax, DWORD PTR _len$[ebp]
  0003d	89 45 fc	 mov	 DWORD PTR _rf$[ebp+20], eax

; 477  : 	return r_object(&rf);

  00040	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00049	59		 pop	 ecx
$LN1@PyMarshal_:

; 478  : }

  0004a	c9		 leave
  0004b	c3		 ret	 0
?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z ENDP ; _PyMarshal_ReadObjectFromString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\sys\stat.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?getfilesize@@YAJPAU_iobuf@@@Z
_TEXT	SEGMENT
__FileHandle$ = -56					; size = 4
_st$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
?getfilesize@@YAJPAU_iobuf@@@Z PROC			; getfilesize, COMDAT

; 398  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 400  : 	if (fstat(fileno(fp), &st) != 0)

  00010	ff 75 08	 push	 DWORD PTR _fp$[ebp]
  00013	e8 00 00 00 00	 call	 __fileno
  00018	59		 pop	 ecx
  00019	89 45 c8	 mov	 DWORD PTR __FileHandle$[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\sys\stat.h

; 237  :             return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);

  0001c	8d 45 cc	 lea	 eax, DWORD PTR _st$[ebp]
  0001f	50		 push	 eax
  00020	ff 75 c8	 push	 DWORD PTR __FileHandle$[ebp]
  00023	e8 00 00 00 00	 call	 __fstat64i32
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp

; 400  : 	if (fstat(fileno(fp), &st) != 0)

  0002a	85 c0		 test	 eax, eax
  0002c	74 07		 je	 SHORT $LN2@getfilesiz

; 401  : 		return -1;

  0002e	83 c8 ff	 or	 eax, -1
  00031	eb 05		 jmp	 SHORT $LN1@getfilesiz
  00033	eb 03		 jmp	 SHORT $LN1@getfilesiz
$LN2@getfilesiz:

; 402  : 	else
; 403  : 		return st.st_size;

  00035	8b 45 e0	 mov	 eax, DWORD PTR _st$[ebp+20]
$LN1@getfilesiz:

; 404  : }

  00038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003b	33 cd		 xor	 ecx, ebp
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	c9		 leave
  00043	c3		 ret	 0
?getfilesize@@YAJPAU_iobuf@@@Z ENDP			; getfilesize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_fp$ = 8						; size = 4
?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z PROC	; _PyMarshal_ReadShortFromFile, COMDAT

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 384  : 	RFILE rf;
; 385  : 	rf.fp = fp;

  00006	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00009	89 45 e8	 mov	 DWORD PTR _rf$[ebp], eax

; 386  : 	return r_short(&rf);

  0000c	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  00015	59		 pop	 ecx

; 387  : }

  00016	c9		 leave
  00017	c3		 ret	 0
?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z ENDP	; _PyMarshal_ReadShortFromFile
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_object@@YAPAU_object@@PAUWFILE@@@Z
_TEXT	SEGMENT
_dx$1 = -128						; size = 8
_flags$2 = -120						; size = 4
_stacksize$3 = -116					; size = 4
_type$ = -112						; size = 4
_argcount$4 = -108					; size = 4
_nlocals$5 = -104					; size = 4
tv137 = -100						; size = 4
tv79 = -96						; size = 4
tv490 = -92						; size = 4
tv540 = -88						; size = 4
tv530 = -84						; size = 4
tv520 = -80						; size = 4
tv510 = -76						; size = 4
tv500 = -72						; size = 4
tv77 = -68						; size = 4
tv480 = -64						; size = 4
tv470 = -60						; size = 4
tv460 = -56						; size = 4
_firstlineno$6 = -52					; size = 4
tv361 = -48						; size = 4
tv352 = -44						; size = 4
tv330 = -40						; size = 4
tv306 = -36						; size = 4
tv275 = -32						; size = 4
tv274 = -28						; size = 4
tv271 = -24						; size = 4
tv252 = -20						; size = 4
$T7 = -16						; size = 4
tv221 = -12						; size = 4
tv219 = -8						; size = 4
$T8 = -4						; size = 4
tv194 = 0						; size = 4
tv192 = 4						; size = 4
$T9 = 8							; size = 4
tv165 = 12						; size = 4
tv163 = 16						; size = 4
_size$10 = 20						; size = 4
_ob$11 = 24						; size = 4
_v2$ = 28						; size = 4
_buffer$12 = 32						; size = 4
_key$13 = 36						; size = 4
_lnotab$14 = 40						; size = 4
_val$15 = 44						; size = 4
_name$16 = 48						; size = 4
_filename$17 = 52					; size = 4
_cellvars$18 = 56					; size = 4
_freevars$19 = 60					; size = 4
_varnames$20 = 64					; size = 4
_names$21 = 68						; size = 4
_consts$22 = 72						; size = 4
_code$23 = 76						; size = 4
_i$ = 80						; size = 4
tv80 = 84						; size = 4
_v$ = 88						; size = 4
_n$ = 92						; size = 4
_c$24 = 96						; size = 16
_buf$25 = 112						; size = 256
_buf$26 = 368						; size = 256
__$ArrayPad$ = 624					; size = 4
_p$ = 636						; size = 4
?r_object@@YAPAU_object@@PAUWFILE@@@Z PROC		; r_object, COMDAT

; 123  : {

  00000	55		 push	 ebp
  00001	8d ac 24 8c fd
	ff ff		 lea	 ebp, DWORD PTR [esp-628]
  00008	81 ec f4 02 00
	00		 sub	 esp, 756		; 000002f4H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 70 02 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	56		 push	 esi
  0001c	57		 push	 edi

; 124  : 	PyObject *v, *v2;
; 125  : 	long i, n;
; 126  : 	int type = r_byte(p);

  0001d	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  00023	83 38 00	 cmp	 DWORD PTR [eax], 0
  00026	74 13		 je	 SHORT $LN187@r_object
  00028	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  0002e	ff 30		 push	 DWORD PTR [eax]
  00030	e8 00 00 00 00	 call	 _getc
  00035	59		 pop	 ecx
  00036	89 45 a0	 mov	 DWORD PTR tv79[ebp], eax
  00039	eb 42		 jmp	 SHORT $LN188@r_object
$LN187@r_object:
  0003b	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  00041	8b 8d 7c 02 00
	00		 mov	 ecx, DWORD PTR _p$[ebp]
  00047	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0004a	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  0004d	74 24		 je	 SHORT $LN185@r_object
  0004f	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  00055	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00058	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0005b	89 45 bc	 mov	 DWORD PTR tv77[ebp], eax
  0005e	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  00064	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00067	40		 inc	 eax
  00068	8b 8d 7c 02 00
	00		 mov	 ecx, DWORD PTR _p$[ebp]
  0006e	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00071	eb 04		 jmp	 SHORT $LN186@r_object
$LN185@r_object:
  00073	83 4d bc ff	 or	 DWORD PTR tv77[ebp], -1
$LN186@r_object:
  00077	8b 45 bc	 mov	 eax, DWORD PTR tv77[ebp]
  0007a	89 45 a0	 mov	 DWORD PTR tv79[ebp], eax
$LN188@r_object:
  0007d	8b 45 a0	 mov	 eax, DWORD PTR tv79[ebp]
  00080	89 45 90	 mov	 DWORD PTR _type$[ebp], eax

; 127  : 
; 128  : 	switch (type) {

  00083	8b 45 90	 mov	 eax, DWORD PTR _type$[ebp]
  00086	89 45 54	 mov	 DWORD PTR tv80[ebp], eax
  00089	83 7d 54 63	 cmp	 DWORD PTR tv80[ebp], 99	; 00000063H
  0008d	7f 6a		 jg	 SHORT $LN215@r_object
  0008f	83 7d 54 63	 cmp	 DWORD PTR tv80[ebp], 99	; 00000063H
  00093	0f 84 42 08 00
	00		 je	 $LN134@r_object
  00099	83 7d 54 49	 cmp	 DWORD PTR tv80[ebp], 73	; 00000049H
  0009d	7f 37		 jg	 SHORT $LN216@r_object
  0009f	83 7d 54 49	 cmp	 DWORD PTR tv80[ebp], 73	; 00000049H
  000a3	0f 84 2a 01 00
	00		 je	 $LN94@r_object
  000a9	83 7d 54 ff	 cmp	 DWORD PTR tv80[ebp], -1
  000ad	0f 84 91 00 00
	00		 je	 $LN88@r_object
  000b3	83 7d 54 28	 cmp	 DWORD PTR tv80[ebp], 40	; 00000028H
  000b7	0f 84 dd 05 00
	00		 je	 $LN112@r_object
  000bd	83 7d 54 2e	 cmp	 DWORD PTR tv80[ebp], 46	; 0000002eH
  000c1	0f 84 d9 00 00
	00		 je	 $LN92@r_object
  000c7	83 7d 54 30	 cmp	 DWORD PTR tv80[ebp], 48	; 00000030H
  000cb	0f 84 8e 00 00
	00		 je	 $LN89@r_object
  000d1	e9 8a 0b 00 00	 jmp	 $LN183@r_object
$LN216@r_object:
  000d6	83 7d 54 4e	 cmp	 DWORD PTR tv80[ebp], 78	; 0000004eH
  000da	0f 84 86 00 00
	00		 je	 $LN90@r_object
  000e0	83 7d 54 53	 cmp	 DWORD PTR tv80[ebp], 83	; 00000053H
  000e4	0f 84 96 00 00
	00		 je	 $LN91@r_object
  000ea	83 7d 54 5b	 cmp	 DWORD PTR tv80[ebp], 91	; 0000005bH
  000ee	0f 84 62 06 00
	00		 je	 $LN118@r_object
  000f4	e9 67 0b 00 00	 jmp	 $LN183@r_object
$LN215@r_object:
  000f9	83 7d 54 66	 cmp	 DWORD PTR tv80[ebp], 102 ; 00000066H
  000fd	0f 84 65 01 00
	00		 je	 $LN97@r_object
  00103	83 7d 54 69	 cmp	 DWORD PTR tv80[ebp], 105 ; 00000069H
  00107	0f 84 ad 00 00
	00		 je	 $LN93@r_object
  0010d	83 7d 54 6c	 cmp	 DWORD PTR tv80[ebp], 108 ; 0000006cH
  00111	0f 84 cd 00 00
	00		 je	 $LN95@r_object
  00117	83 7d 54 73	 cmp	 DWORD PTR tv80[ebp], 115 ; 00000073H
  0011b	0f 84 de 03 00
	00		 je	 $LN102@r_object
  00121	83 7d 54 75	 cmp	 DWORD PTR tv80[ebp], 117 ; 00000075H
  00125	0f 84 81 04 00
	00		 je	 $LN108@r_object
  0012b	83 7d 54 78	 cmp	 DWORD PTR tv80[ebp], 120 ; 00000078H
  0012f	0f 84 12 02 00
	00		 je	 $LN99@r_object
  00135	83 7d 54 7b	 cmp	 DWORD PTR tv80[ebp], 123 ; 0000007bH
  00139	0f 84 d8 06 00
	00		 je	 $LN124@r_object
  0013f	e9 1c 0b 00 00	 jmp	 $LN183@r_object
$LN88@r_object:

; 129  : 
; 130  : 	case EOF:
; 131  : 		PyErr_SetString(PyExc_EOFError,

  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
  00149	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  0014e	ff 30		 push	 DWORD PTR [eax]
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  00156	59		 pop	 ecx
  00157	59		 pop	 ecx

; 132  : 				"EOF read where object expected");
; 133  : 		return NULL;

  00158	33 c0		 xor	 eax, eax
  0015a	e9 17 0b 00 00	 jmp	 $LN2@r_object
$LN89@r_object:

; 134  : 
; 135  : 	case TYPE_NULL:
; 136  : 		return NULL;

  0015f	33 c0		 xor	 eax, eax
  00161	e9 10 0b 00 00	 jmp	 $LN2@r_object
$LN90@r_object:

; 137  : 
; 138  : 	case TYPE_NONE:
; 139  : 		Py_INCREF(Py_None);

  00166	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct
  0016b	8b 00		 mov	 eax, DWORD PTR [eax]
  0016d	40		 inc	 eax
  0016e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___Py_NoneStruct
  00174	89 01		 mov	 DWORD PTR [ecx], eax

; 140  : 		return Py_None;

  00176	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct
  0017b	e9 f6 0a 00 00	 jmp	 $LN2@r_object
$LN91@r_object:

; 141  : 
; 142  : 	case TYPE_STOPITER:
; 143  : 		Py_INCREF(PyExc_StopIteration);

  00180	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_StopIteration
  00185	8b 00		 mov	 eax, DWORD PTR [eax]
  00187	8b 00		 mov	 eax, DWORD PTR [eax]
  00189	40		 inc	 eax
  0018a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp__PyExc_StopIteration
  00190	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00192	89 01		 mov	 DWORD PTR [ecx], eax

; 144  : 		return PyExc_StopIteration;

  00194	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_StopIteration
  00199	8b 00		 mov	 eax, DWORD PTR [eax]
  0019b	e9 d6 0a 00 00	 jmp	 $LN2@r_object
$LN92@r_object:

; 145  : 
; 146  : 	case TYPE_ELLIPSIS:
; 147  : 		Py_INCREF(Py_Ellipsis);

  001a0	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_EllipsisObject
  001a5	8b 00		 mov	 eax, DWORD PTR [eax]
  001a7	40		 inc	 eax
  001a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___Py_EllipsisObject
  001ae	89 01		 mov	 DWORD PTR [ecx], eax

; 148  : 		return Py_Ellipsis;

  001b0	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_EllipsisObject
  001b5	e9 bc 0a 00 00	 jmp	 $LN2@r_object
$LN93@r_object:

; 149  : 
; 150  : 	case TYPE_INT:
; 151  : 		return PyInt_FromLong(r_long(p));

  001ba	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  001c0	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  001c5	59		 pop	 ecx
  001c6	50		 push	 eax
  001c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyInt_FromLong
  001cd	59		 pop	 ecx
  001ce	e9 a3 0a 00 00	 jmp	 $LN2@r_object
$LN94@r_object:

; 152  : 
; 153  : 	case TYPE_INT64:
; 154  : 		return r_long64(p);

  001d3	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  001d9	e8 00 00 00 00	 call	 ?r_long64@@YAPAU_object@@PAUWFILE@@@Z ; r_long64
  001de	59		 pop	 ecx
  001df	e9 92 0a 00 00	 jmp	 $LN2@r_object
$LN95@r_object:

; 155  : 
; 156  : 	case TYPE_LONG:
; 157  : 		{
; 158  : 			int size;
; 159  : 			PyLongObject* ob;
; 160  : 			n = r_long(p);

  001e4	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  001ea	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  001ef	59		 pop	 ecx
  001f0	89 45 5c	 mov	 DWORD PTR _n$[ebp], eax

; 161  : 			size = n<0 ? -n : n;

  001f3	83 7d 5c 00	 cmp	 DWORD PTR _n$[ebp], 0
  001f7	7d 0a		 jge	 SHORT $LN189@r_object
  001f9	8b 45 5c	 mov	 eax, DWORD PTR _n$[ebp]
  001fc	f7 d8		 neg	 eax
  001fe	89 45 9c	 mov	 DWORD PTR tv137[ebp], eax
  00201	eb 06		 jmp	 SHORT $LN190@r_object
$LN189@r_object:
  00203	8b 45 5c	 mov	 eax, DWORD PTR _n$[ebp]
  00206	89 45 9c	 mov	 DWORD PTR tv137[ebp], eax
$LN190@r_object:
  00209	8b 45 9c	 mov	 eax, DWORD PTR tv137[ebp]
  0020c	89 45 14	 mov	 DWORD PTR _size$10[ebp], eax

; 162  : 			ob = _PyLong_New(size);

  0020f	ff 75 14	 push	 DWORD PTR _size$10[ebp]
  00212	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___PyLong_New
  00218	59		 pop	 ecx
  00219	89 45 18	 mov	 DWORD PTR _ob$11[ebp], eax

; 163  : 			if (ob == NULL)

  0021c	83 7d 18 00	 cmp	 DWORD PTR _ob$11[ebp], 0
  00220	75 07		 jne	 SHORT $LN96@r_object

; 164  : 				return NULL;

  00222	33 c0		 xor	 eax, eax
  00224	e9 4d 0a 00 00	 jmp	 $LN2@r_object
$LN96@r_object:

; 165  : 			ob->ob_size = n;

  00229	8b 45 18	 mov	 eax, DWORD PTR _ob$11[ebp]
  0022c	8b 4d 5c	 mov	 ecx, DWORD PTR _n$[ebp]
  0022f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 166  : 			for (i = 0; i < size; i++)

  00232	83 65 50 00	 and	 DWORD PTR _i$[ebp], 0
  00236	eb 07		 jmp	 SHORT $LN6@r_object
$LN4@r_object:
  00238	8b 45 50	 mov	 eax, DWORD PTR _i$[ebp]
  0023b	40		 inc	 eax
  0023c	89 45 50	 mov	 DWORD PTR _i$[ebp], eax
$LN6@r_object:
  0023f	8b 45 50	 mov	 eax, DWORD PTR _i$[ebp]
  00242	3b 45 14	 cmp	 eax, DWORD PTR _size$10[ebp]
  00245	7d 19		 jge	 SHORT $LN5@r_object

; 167  : 				ob->ob_digit[i] = (short) r_short(p);

  00247	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  0024d	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  00252	59		 pop	 ecx
  00253	8b 4d 50	 mov	 ecx, DWORD PTR _i$[ebp]
  00256	8b 55 18	 mov	 edx, DWORD PTR _ob$11[ebp]
  00259	66 89 44 4a 0c	 mov	 WORD PTR [edx+ecx*2+12], ax
  0025e	eb d8		 jmp	 SHORT $LN4@r_object
$LN5@r_object:

; 168  : 			return (PyObject *) ob;

  00260	8b 45 18	 mov	 eax, DWORD PTR _ob$11[ebp]
  00263	e9 0e 0a 00 00	 jmp	 $LN2@r_object
$LN97@r_object:

; 169  : 		}
; 170  : 
; 171  : 	case TYPE_FLOAT:
; 172  : 		{
; 173  : 			char buf[256];
; 174  : 			double dx;
; 175  : 			n = r_byte(p);

  00268	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  0026e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00271	74 13		 je	 SHORT $LN193@r_object
  00273	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  00279	ff 30		 push	 DWORD PTR [eax]
  0027b	e8 00 00 00 00	 call	 _getc
  00280	59		 pop	 ecx
  00281	89 45 0c	 mov	 DWORD PTR tv165[ebp], eax
  00284	eb 42		 jmp	 SHORT $LN194@r_object
$LN193@r_object:
  00286	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  0028c	8b 8d 7c 02 00
	00		 mov	 ecx, DWORD PTR _p$[ebp]
  00292	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00295	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  00298	74 24		 je	 SHORT $LN191@r_object
  0029a	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  002a0	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  002a3	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  002a6	89 45 10	 mov	 DWORD PTR tv163[ebp], eax
  002a9	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  002af	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  002b2	40		 inc	 eax
  002b3	8b 8d 7c 02 00
	00		 mov	 ecx, DWORD PTR _p$[ebp]
  002b9	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  002bc	eb 04		 jmp	 SHORT $LN192@r_object
$LN191@r_object:
  002be	83 4d 10 ff	 or	 DWORD PTR tv163[ebp], -1
$LN192@r_object:
  002c2	8b 45 10	 mov	 eax, DWORD PTR tv163[ebp]
  002c5	89 45 0c	 mov	 DWORD PTR tv165[ebp], eax
$LN194@r_object:
  002c8	8b 45 0c	 mov	 eax, DWORD PTR tv165[ebp]
  002cb	89 45 5c	 mov	 DWORD PTR _n$[ebp], eax

; 176  : 			if (r_string(buf, (int)n, p) != n) {

  002ce	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  002d4	ff 75 5c	 push	 DWORD PTR _n$[ebp]
  002d7	8d 45 70	 lea	 eax, DWORD PTR _buf$25[ebp]
  002da	50		 push	 eax
  002db	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  002e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e3	3b 45 5c	 cmp	 eax, DWORD PTR _n$[ebp]
  002e6	74 1b		 je	 SHORT $LN98@r_object

; 177  : 				PyErr_SetString(PyExc_EOFError,

  002e8	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
  002ed	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  002f2	ff 30		 push	 DWORD PTR [eax]
  002f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  002fa	59		 pop	 ecx
  002fb	59		 pop	 ecx

; 178  : 					"EOF read where object expected");
; 179  : 				return NULL;

  002fc	33 c0		 xor	 eax, eax
  002fe	e9 73 09 00 00	 jmp	 $LN2@r_object
$LN98@r_object:

; 180  : 			}
; 181  : 			buf[n] = '\0';

  00303	8b 45 5c	 mov	 eax, DWORD PTR _n$[ebp]
  00306	89 45 08	 mov	 DWORD PTR $T9[ebp], eax
  00309	81 7d 08 00 01
	00 00		 cmp	 DWORD PTR $T9[ebp], 256	; 00000100H
  00310	73 02		 jae	 SHORT $LN195@r_object
  00312	eb 05		 jmp	 SHORT $LN196@r_object
$LN195@r_object:
  00314	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN196@r_object:
  00319	8b 45 08	 mov	 eax, DWORD PTR $T9[ebp]
  0031c	c6 44 05 70 00	 mov	 BYTE PTR _buf$25[ebp+eax], 0

; 182  : 			PyFPE_START_PROTECT("atof", return 0)
; 183  : 			dx = atof(buf);

  00321	8d 45 70	 lea	 eax, DWORD PTR _buf$25[ebp]
  00324	50		 push	 eax
  00325	e8 00 00 00 00	 call	 _atof
  0032a	59		 pop	 ecx
  0032b	dd 5d 80	 fstp	 QWORD PTR _dx$1[ebp]

; 184  : 			PyFPE_END_PROTECT(dx)
; 185  : 			return PyFloat_FromDouble(dx);

  0032e	51		 push	 ecx
  0032f	51		 push	 ecx
  00330	f2 0f 10 45 80	 movsd	 xmm0, QWORD PTR _dx$1[ebp]
  00335	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0033a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyFloat_FromDouble
  00340	59		 pop	 ecx
  00341	59		 pop	 ecx
  00342	e9 2f 09 00 00	 jmp	 $LN2@r_object
$LN99@r_object:

; 186  : 		}
; 187  : 
; 188  : #ifndef WITHOUT_COMPLEX
; 189  : 	case TYPE_COMPLEX:
; 190  : 		{
; 191  : 			char buf[256];
; 192  : 			Py_complex c;
; 193  : 			n = r_byte(p);

  00347	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  0034d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00350	74 13		 je	 SHORT $LN199@r_object
  00352	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  00358	ff 30		 push	 DWORD PTR [eax]
  0035a	e8 00 00 00 00	 call	 _getc
  0035f	59		 pop	 ecx
  00360	89 45 00	 mov	 DWORD PTR tv194[ebp], eax
  00363	eb 42		 jmp	 SHORT $LN200@r_object
$LN199@r_object:
  00365	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  0036b	8b 8d 7c 02 00
	00		 mov	 ecx, DWORD PTR _p$[ebp]
  00371	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00374	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  00377	74 24		 je	 SHORT $LN197@r_object
  00379	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  0037f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00382	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00385	89 45 04	 mov	 DWORD PTR tv192[ebp], eax
  00388	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  0038e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00391	40		 inc	 eax
  00392	8b 8d 7c 02 00
	00		 mov	 ecx, DWORD PTR _p$[ebp]
  00398	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0039b	eb 04		 jmp	 SHORT $LN198@r_object
$LN197@r_object:
  0039d	83 4d 04 ff	 or	 DWORD PTR tv192[ebp], -1
$LN198@r_object:
  003a1	8b 45 04	 mov	 eax, DWORD PTR tv192[ebp]
  003a4	89 45 00	 mov	 DWORD PTR tv194[ebp], eax
$LN200@r_object:
  003a7	8b 45 00	 mov	 eax, DWORD PTR tv194[ebp]
  003aa	89 45 5c	 mov	 DWORD PTR _n$[ebp], eax

; 194  : 			if (r_string(buf, (int)n, p) != n) {

  003ad	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  003b3	ff 75 5c	 push	 DWORD PTR _n$[ebp]
  003b6	8d 85 70 01 00
	00		 lea	 eax, DWORD PTR _buf$26[ebp]
  003bc	50		 push	 eax
  003bd	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  003c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c5	3b 45 5c	 cmp	 eax, DWORD PTR _n$[ebp]
  003c8	74 1b		 je	 SHORT $LN100@r_object

; 195  : 				PyErr_SetString(PyExc_EOFError,

  003ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
  003cf	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  003d4	ff 30		 push	 DWORD PTR [eax]
  003d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  003dc	59		 pop	 ecx
  003dd	59		 pop	 ecx

; 196  : 					"EOF read where object expected");
; 197  : 				return NULL;

  003de	33 c0		 xor	 eax, eax
  003e0	e9 91 08 00 00	 jmp	 $LN2@r_object
$LN100@r_object:

; 198  : 			}
; 199  : 			buf[n] = '\0';

  003e5	8b 45 5c	 mov	 eax, DWORD PTR _n$[ebp]
  003e8	89 45 fc	 mov	 DWORD PTR $T8[ebp], eax
  003eb	81 7d fc 00 01
	00 00		 cmp	 DWORD PTR $T8[ebp], 256	; 00000100H
  003f2	73 02		 jae	 SHORT $LN201@r_object
  003f4	eb 05		 jmp	 SHORT $LN202@r_object
$LN201@r_object:
  003f6	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN202@r_object:
  003fb	8b 45 fc	 mov	 eax, DWORD PTR $T8[ebp]
  003fe	c6 84 05 70 01
	00 00 00	 mov	 BYTE PTR _buf$26[ebp+eax], 0

; 200  : 			PyFPE_START_PROTECT("atof", return 0)
; 201  : 			c.real = atof(buf);

  00406	8d 85 70 01 00
	00		 lea	 eax, DWORD PTR _buf$26[ebp]
  0040c	50		 push	 eax
  0040d	e8 00 00 00 00	 call	 _atof
  00412	59		 pop	 ecx
  00413	dd 5d 60	 fstp	 QWORD PTR _c$24[ebp]

; 202  : 			PyFPE_END_PROTECT(c)
; 203  : 			n = r_byte(p);

  00416	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  0041c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0041f	74 13		 je	 SHORT $LN205@r_object
  00421	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  00427	ff 30		 push	 DWORD PTR [eax]
  00429	e8 00 00 00 00	 call	 _getc
  0042e	59		 pop	 ecx
  0042f	89 45 f4	 mov	 DWORD PTR tv221[ebp], eax
  00432	eb 42		 jmp	 SHORT $LN206@r_object
$LN205@r_object:
  00434	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  0043a	8b 8d 7c 02 00
	00		 mov	 ecx, DWORD PTR _p$[ebp]
  00440	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00443	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  00446	74 24		 je	 SHORT $LN203@r_object
  00448	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  0044e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00451	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00454	89 45 f8	 mov	 DWORD PTR tv219[ebp], eax
  00457	8b 85 7c 02 00
	00		 mov	 eax, DWORD PTR _p$[ebp]
  0045d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00460	40		 inc	 eax
  00461	8b 8d 7c 02 00
	00		 mov	 ecx, DWORD PTR _p$[ebp]
  00467	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0046a	eb 04		 jmp	 SHORT $LN204@r_object
$LN203@r_object:
  0046c	83 4d f8 ff	 or	 DWORD PTR tv219[ebp], -1
$LN204@r_object:
  00470	8b 45 f8	 mov	 eax, DWORD PTR tv219[ebp]
  00473	89 45 f4	 mov	 DWORD PTR tv221[ebp], eax
$LN206@r_object:
  00476	8b 45 f4	 mov	 eax, DWORD PTR tv221[ebp]
  00479	89 45 5c	 mov	 DWORD PTR _n$[ebp], eax

; 204  : 			if (r_string(buf, (int)n, p) != n) {

  0047c	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  00482	ff 75 5c	 push	 DWORD PTR _n$[ebp]
  00485	8d 85 70 01 00
	00		 lea	 eax, DWORD PTR _buf$26[ebp]
  0048b	50		 push	 eax
  0048c	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  00491	83 c4 0c	 add	 esp, 12			; 0000000cH
  00494	3b 45 5c	 cmp	 eax, DWORD PTR _n$[ebp]
  00497	74 1b		 je	 SHORT $LN101@r_object

; 205  : 				PyErr_SetString(PyExc_EOFError,

  00499	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
  0049e	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  004a3	ff 30		 push	 DWORD PTR [eax]
  004a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  004ab	59		 pop	 ecx
  004ac	59		 pop	 ecx

; 206  : 					"EOF read where object expected");
; 207  : 				return NULL;

  004ad	33 c0		 xor	 eax, eax
  004af	e9 c2 07 00 00	 jmp	 $LN2@r_object
$LN101@r_object:

; 208  : 			}
; 209  : 			buf[n] = '\0';

  004b4	8b 45 5c	 mov	 eax, DWORD PTR _n$[ebp]
  004b7	89 45 f0	 mov	 DWORD PTR $T7[ebp], eax
  004ba	81 7d f0 00 01
	00 00		 cmp	 DWORD PTR $T7[ebp], 256	; 00000100H
  004c1	73 02		 jae	 SHORT $LN207@r_object
  004c3	eb 05		 jmp	 SHORT $LN208@r_object
$LN207@r_object:
  004c5	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN208@r_object:
  004ca	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  004cd	c6 84 05 70 01
	00 00 00	 mov	 BYTE PTR _buf$26[ebp+eax], 0

; 210  : 			PyFPE_START_PROTECT("atof", return 0)
; 211  : 			c.imag = atof(buf);

  004d5	8d 85 70 01 00
	00		 lea	 eax, DWORD PTR _buf$26[ebp]
  004db	50		 push	 eax
  004dc	e8 00 00 00 00	 call	 _atof
  004e1	59		 pop	 ecx
  004e2	dd 5d 68	 fstp	 QWORD PTR _c$24[ebp+8]

; 212  : 			PyFPE_END_PROTECT(c)
; 213  : 			return PyComplex_FromCComplex(c);

  004e5	83 ec 10	 sub	 esp, 16			; 00000010H
  004e8	8d 75 60	 lea	 esi, DWORD PTR _c$24[ebp]
  004eb	8b fc		 mov	 edi, esp
  004ed	a5		 movsd
  004ee	a5		 movsd
  004ef	a5		 movsd
  004f0	a5		 movsd
  004f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyComplex_FromCComplex
  004f7	83 c4 10	 add	 esp, 16			; 00000010H
  004fa	e9 77 07 00 00	 jmp	 $LN2@r_object
$LN102@r_object:

; 214  : 		}
; 215  : #endif
; 216  : 
; 217  : 	case TYPE_STRING:
; 218  : 		n = r_long(p);

  004ff	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  00505	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  0050a	59		 pop	 ecx
  0050b	89 45 5c	 mov	 DWORD PTR _n$[ebp], eax

; 219  : 		if (n < 0) {

  0050e	83 7d 5c 00	 cmp	 DWORD PTR _n$[ebp], 0
  00512	7d 1b		 jge	 SHORT $LN103@r_object

; 220  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");

  00514	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DCKILJJE@bad?5marshal?5data@
  00519	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_ValueError
  0051e	ff 30		 push	 DWORD PTR [eax]
  00520	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  00526	59		 pop	 ecx
  00527	59		 pop	 ecx

; 221  : 			return NULL;

  00528	33 c0		 xor	 eax, eax
  0052a	e9 47 07 00 00	 jmp	 $LN2@r_object
$LN103@r_object:

; 222  : 		}
; 223  : 		v = PyString_FromStringAndSize((char *)NULL, n);

  0052f	ff 75 5c	 push	 DWORD PTR _n$[ebp]
  00532	6a 00		 push	 0
  00534	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyString_FromStringAndSize
  0053a	59		 pop	 ecx
  0053b	59		 pop	 ecx
  0053c	89 45 58	 mov	 DWORD PTR _v$[ebp], eax

; 224  : 		if (v != NULL) {

  0053f	83 7d 58 00	 cmp	 DWORD PTR _v$[ebp], 0
  00543	74 5f		 je	 SHORT $LN105@r_object

; 225  : 			if (r_string(PyString_AS_STRING(v), (int)n, p) != n) {

  00545	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  0054b	ff 75 5c	 push	 DWORD PTR _n$[ebp]
  0054e	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  00551	83 c0 14	 add	 eax, 20			; 00000014H
  00554	50		 push	 eax
  00555	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  0055a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0055d	3b 45 5c	 cmp	 eax, DWORD PTR _n$[ebp]
  00560	74 42		 je	 SHORT $LN105@r_object
$LN9@r_object:

; 226  : 				Py_DECREF(v);

  00562	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  00565	8b 00		 mov	 eax, DWORD PTR [eax]
  00567	48		 dec	 eax
  00568	89 45 ec	 mov	 DWORD PTR tv252[ebp], eax
  0056b	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  0056e	8b 4d ec	 mov	 ecx, DWORD PTR tv252[ebp]
  00571	89 08		 mov	 DWORD PTR [eax], ecx
  00573	83 7d ec 00	 cmp	 DWORD PTR tv252[ebp], 0
  00577	74 02		 je	 SHORT $LN106@r_object
  00579	eb 0d		 jmp	 SHORT $LN107@r_object
$LN106@r_object:
  0057b	ff 75 58	 push	 DWORD PTR _v$[ebp]
  0057e	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  00581	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00584	ff 50 18	 call	 DWORD PTR [eax+24]
  00587	59		 pop	 ecx
$LN107@r_object:
  00588	33 c0		 xor	 eax, eax
  0058a	75 d6		 jne	 SHORT $LN9@r_object

; 227  : 				v = NULL;

  0058c	83 65 58 00	 and	 DWORD PTR _v$[ebp], 0

; 228  : 				PyErr_SetString(PyExc_EOFError,

  00590	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
  00595	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  0059a	ff 30		 push	 DWORD PTR [eax]
  0059c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  005a2	59		 pop	 ecx
  005a3	59		 pop	 ecx
$LN105@r_object:

; 229  : 					"EOF read where object expected");
; 230  : 			}
; 231  : 		}
; 232  : 		return v;

  005a4	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  005a7	e9 ca 06 00 00	 jmp	 $LN2@r_object
$LN108@r_object:

; 233  : 
; 234  : #ifdef Py_USING_UNICODE
; 235  : 	case TYPE_UNICODE:
; 236  : 	    {
; 237  : 		char *buffer;
; 238  : 
; 239  : 		n = r_long(p);

  005ac	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  005b2	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  005b7	59		 pop	 ecx
  005b8	89 45 5c	 mov	 DWORD PTR _n$[ebp], eax

; 240  : 		if (n < 0) {

  005bb	83 7d 5c 00	 cmp	 DWORD PTR _n$[ebp], 0
  005bf	7d 1b		 jge	 SHORT $LN109@r_object

; 241  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");

  005c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DCKILJJE@bad?5marshal?5data@
  005c6	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_ValueError
  005cb	ff 30		 push	 DWORD PTR [eax]
  005cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  005d3	59		 pop	 ecx
  005d4	59		 pop	 ecx

; 242  : 			return NULL;

  005d5	33 c0		 xor	 eax, eax
  005d7	e9 9a 06 00 00	 jmp	 $LN2@r_object
$LN109@r_object:

; 243  : 		}
; 244  : 		buffer = PyMem_NEW(char, n);

  005dc	81 7d 5c ff ff
	ff 7f		 cmp	 DWORD PTR _n$[ebp], 2147483647 ; 7fffffffH
  005e3	76 06		 jbe	 SHORT $LN213@r_object
  005e5	83 65 e0 00	 and	 DWORD PTR tv275[ebp], 0
  005e9	eb 36		 jmp	 SHORT $LN214@r_object
$LN213@r_object:
  005eb	81 7d 5c ff ff
	ff 7f		 cmp	 DWORD PTR _n$[ebp], 2147483647 ; 7fffffffH
  005f2	76 06		 jbe	 SHORT $LN211@r_object
  005f4	83 65 e4 00	 and	 DWORD PTR tv274[ebp], 0
  005f8	eb 21		 jmp	 SHORT $LN212@r_object
$LN211@r_object:
  005fa	83 7d 5c 00	 cmp	 DWORD PTR _n$[ebp], 0
  005fe	74 08		 je	 SHORT $LN209@r_object
  00600	8b 45 5c	 mov	 eax, DWORD PTR _n$[ebp]
  00603	89 45 e8	 mov	 DWORD PTR tv271[ebp], eax
  00606	eb 07		 jmp	 SHORT $LN210@r_object
$LN209@r_object:
  00608	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv271[ebp], 1
$LN210@r_object:
  0060f	ff 75 e8	 push	 DWORD PTR tv271[ebp]
  00612	e8 00 00 00 00	 call	 _malloc
  00617	59		 pop	 ecx
  00618	89 45 e4	 mov	 DWORD PTR tv274[ebp], eax
$LN212@r_object:
  0061b	8b 45 e4	 mov	 eax, DWORD PTR tv274[ebp]
  0061e	89 45 e0	 mov	 DWORD PTR tv275[ebp], eax
$LN214@r_object:
  00621	8b 45 e0	 mov	 eax, DWORD PTR tv275[ebp]
  00624	89 45 20	 mov	 DWORD PTR _buffer$12[ebp], eax

; 245  : 		if (buffer == NULL)

  00627	83 7d 20 00	 cmp	 DWORD PTR _buffer$12[ebp], 0
  0062b	75 0b		 jne	 SHORT $LN110@r_object

; 246  : 			return PyErr_NoMemory();

  0062d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_NoMemory
  00633	e9 3e 06 00 00	 jmp	 $LN2@r_object
$LN110@r_object:

; 247  : 		if (r_string(buffer, (int)n, p) != n) {

  00638	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  0063e	ff 75 5c	 push	 DWORD PTR _n$[ebp]
  00641	ff 75 20	 push	 DWORD PTR _buffer$12[ebp]
  00644	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUWFILE@@@Z ; r_string
  00649	83 c4 0c	 add	 esp, 12			; 0000000cH
  0064c	3b 45 5c	 cmp	 eax, DWORD PTR _n$[ebp]
  0064f	74 24		 je	 SHORT $LN111@r_object

; 248  : 			PyMem_DEL(buffer);

  00651	ff 75 20	 push	 DWORD PTR _buffer$12[ebp]
  00654	e8 00 00 00 00	 call	 _free
  00659	59		 pop	 ecx

; 249  : 			PyErr_SetString(PyExc_EOFError,

  0065a	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
  0065f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  00664	ff 30		 push	 DWORD PTR [eax]
  00666	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  0066c	59		 pop	 ecx
  0066d	59		 pop	 ecx

; 250  : 				"EOF read where object expected");
; 251  : 			return NULL;

  0066e	33 c0		 xor	 eax, eax
  00670	e9 01 06 00 00	 jmp	 $LN2@r_object
$LN111@r_object:

; 252  : 		}
; 253  : 		v = PyUnicode_DecodeUTF8(buffer, n, NULL);

  00675	6a 00		 push	 0
  00677	ff 75 5c	 push	 DWORD PTR _n$[ebp]
  0067a	ff 75 20	 push	 DWORD PTR _buffer$12[ebp]
  0067d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyUnicodeUCS2_DecodeUTF8
  00683	83 c4 0c	 add	 esp, 12			; 0000000cH
  00686	89 45 58	 mov	 DWORD PTR _v$[ebp], eax

; 254  : 		PyMem_DEL(buffer);

  00689	ff 75 20	 push	 DWORD PTR _buffer$12[ebp]
  0068c	e8 00 00 00 00	 call	 _free
  00691	59		 pop	 ecx

; 255  : 		return v;

  00692	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  00695	e9 dc 05 00 00	 jmp	 $LN2@r_object
$LN112@r_object:

; 256  : 	    }
; 257  : #endif
; 258  : 
; 259  : 	case TYPE_TUPLE:
; 260  : 		n = r_long(p);

  0069a	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  006a0	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  006a5	59		 pop	 ecx
  006a6	89 45 5c	 mov	 DWORD PTR _n$[ebp], eax

; 261  : 		if (n < 0) {

  006a9	83 7d 5c 00	 cmp	 DWORD PTR _n$[ebp], 0
  006ad	7d 1b		 jge	 SHORT $LN113@r_object

; 262  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");

  006af	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DCKILJJE@bad?5marshal?5data@
  006b4	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_ValueError
  006b9	ff 30		 push	 DWORD PTR [eax]
  006bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  006c1	59		 pop	 ecx
  006c2	59		 pop	 ecx

; 263  : 			return NULL;

  006c3	33 c0		 xor	 eax, eax
  006c5	e9 ac 05 00 00	 jmp	 $LN2@r_object
$LN113@r_object:

; 264  : 		}
; 265  : 		v = PyTuple_New((int)n);

  006ca	ff 75 5c	 push	 DWORD PTR _n$[ebp]
  006cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_New
  006d3	59		 pop	 ecx
  006d4	89 45 58	 mov	 DWORD PTR _v$[ebp], eax

; 266  : 		if (v == NULL)

  006d7	83 7d 58 00	 cmp	 DWORD PTR _v$[ebp], 0
  006db	75 08		 jne	 SHORT $LN114@r_object

; 267  : 			return v;

  006dd	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  006e0	e9 91 05 00 00	 jmp	 $LN2@r_object
$LN114@r_object:

; 268  : 		for (i = 0; i < n; i++) {

  006e5	83 65 50 00	 and	 DWORD PTR _i$[ebp], 0
  006e9	eb 07		 jmp	 SHORT $LN12@r_object
$LN10@r_object:
  006eb	8b 45 50	 mov	 eax, DWORD PTR _i$[ebp]
  006ee	40		 inc	 eax
  006ef	89 45 50	 mov	 DWORD PTR _i$[ebp], eax
$LN12@r_object:
  006f2	8b 45 50	 mov	 eax, DWORD PTR _i$[ebp]
  006f5	3b 45 5c	 cmp	 eax, DWORD PTR _n$[ebp]
  006f8	7d 54		 jge	 SHORT $LN11@r_object

; 269  : 			v2 = r_object(p);

  006fa	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  00700	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00705	59		 pop	 ecx
  00706	89 45 1c	 mov	 DWORD PTR _v2$[ebp], eax

; 270  : 			if ( v2 == NULL ) {

  00709	83 7d 1c 00	 cmp	 DWORD PTR _v2$[ebp], 0
  0070d	75 30		 jne	 SHORT $LN115@r_object
$LN15@r_object:

; 271  : 				Py_DECREF(v);

  0070f	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  00712	8b 00		 mov	 eax, DWORD PTR [eax]
  00714	48		 dec	 eax
  00715	89 45 dc	 mov	 DWORD PTR tv306[ebp], eax
  00718	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  0071b	8b 4d dc	 mov	 ecx, DWORD PTR tv306[ebp]
  0071e	89 08		 mov	 DWORD PTR [eax], ecx
  00720	83 7d dc 00	 cmp	 DWORD PTR tv306[ebp], 0
  00724	74 02		 je	 SHORT $LN116@r_object
  00726	eb 0d		 jmp	 SHORT $LN117@r_object
$LN116@r_object:
  00728	ff 75 58	 push	 DWORD PTR _v$[ebp]
  0072b	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  0072e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00731	ff 50 18	 call	 DWORD PTR [eax+24]
  00734	59		 pop	 ecx
$LN117@r_object:
  00735	33 c0		 xor	 eax, eax
  00737	75 d6		 jne	 SHORT $LN15@r_object

; 272  : 				v = NULL;

  00739	83 65 58 00	 and	 DWORD PTR _v$[ebp], 0

; 273  : 				break;

  0073d	eb 0f		 jmp	 SHORT $LN11@r_object
$LN115@r_object:

; 274  : 			}
; 275  : 			PyTuple_SET_ITEM(v, (int)i, v2);

  0073f	8b 45 50	 mov	 eax, DWORD PTR _i$[ebp]
  00742	8b 4d 58	 mov	 ecx, DWORD PTR _v$[ebp]
  00745	8b 55 1c	 mov	 edx, DWORD PTR _v2$[ebp]
  00748	89 54 81 0c	 mov	 DWORD PTR [ecx+eax*4+12], edx

; 276  : 		}

  0074c	eb 9d		 jmp	 SHORT $LN10@r_object
$LN11@r_object:

; 277  : 		return v;

  0074e	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  00751	e9 20 05 00 00	 jmp	 $LN2@r_object
$LN118@r_object:

; 278  : 
; 279  : 	case TYPE_LIST:
; 280  : 		n = r_long(p);

  00756	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  0075c	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  00761	59		 pop	 ecx
  00762	89 45 5c	 mov	 DWORD PTR _n$[ebp], eax

; 281  : 		if (n < 0) {

  00765	83 7d 5c 00	 cmp	 DWORD PTR _n$[ebp], 0
  00769	7d 1b		 jge	 SHORT $LN119@r_object

; 282  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");

  0076b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DCKILJJE@bad?5marshal?5data@
  00770	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_ValueError
  00775	ff 30		 push	 DWORD PTR [eax]
  00777	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  0077d	59		 pop	 ecx
  0077e	59		 pop	 ecx

; 283  : 			return NULL;

  0077f	33 c0		 xor	 eax, eax
  00781	e9 f0 04 00 00	 jmp	 $LN2@r_object
$LN119@r_object:

; 284  : 		}
; 285  : 		v = PyList_New((int)n);

  00786	ff 75 5c	 push	 DWORD PTR _n$[ebp]
  00789	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyList_New
  0078f	59		 pop	 ecx
  00790	89 45 58	 mov	 DWORD PTR _v$[ebp], eax

; 286  : 		if (v == NULL)

  00793	83 7d 58 00	 cmp	 DWORD PTR _v$[ebp], 0
  00797	75 08		 jne	 SHORT $LN120@r_object

; 287  : 			return v;

  00799	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  0079c	e9 d5 04 00 00	 jmp	 $LN2@r_object
$LN120@r_object:

; 288  : 		for (i = 0; i < n; i++) {

  007a1	83 65 50 00	 and	 DWORD PTR _i$[ebp], 0
  007a5	eb 07		 jmp	 SHORT $LN18@r_object
$LN16@r_object:
  007a7	8b 45 50	 mov	 eax, DWORD PTR _i$[ebp]
  007aa	40		 inc	 eax
  007ab	89 45 50	 mov	 DWORD PTR _i$[ebp], eax
$LN18@r_object:
  007ae	8b 45 50	 mov	 eax, DWORD PTR _i$[ebp]
  007b1	3b 45 5c	 cmp	 eax, DWORD PTR _n$[ebp]
  007b4	7d 59		 jge	 SHORT $LN17@r_object

; 289  : 			v2 = r_object(p);

  007b6	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  007bc	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  007c1	59		 pop	 ecx
  007c2	89 45 1c	 mov	 DWORD PTR _v2$[ebp], eax

; 290  : 			if ( v2 == NULL ) {

  007c5	83 7d 1c 00	 cmp	 DWORD PTR _v2$[ebp], 0
  007c9	75 30		 jne	 SHORT $LN121@r_object
$LN21@r_object:

; 291  : 				Py_DECREF(v);

  007cb	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  007ce	8b 00		 mov	 eax, DWORD PTR [eax]
  007d0	48		 dec	 eax
  007d1	89 45 d8	 mov	 DWORD PTR tv330[ebp], eax
  007d4	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  007d7	8b 4d d8	 mov	 ecx, DWORD PTR tv330[ebp]
  007da	89 08		 mov	 DWORD PTR [eax], ecx
  007dc	83 7d d8 00	 cmp	 DWORD PTR tv330[ebp], 0
  007e0	74 02		 je	 SHORT $LN122@r_object
  007e2	eb 0d		 jmp	 SHORT $LN123@r_object
$LN122@r_object:
  007e4	ff 75 58	 push	 DWORD PTR _v$[ebp]
  007e7	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  007ea	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  007ed	ff 50 18	 call	 DWORD PTR [eax+24]
  007f0	59		 pop	 ecx
$LN123@r_object:
  007f1	33 c0		 xor	 eax, eax
  007f3	75 d6		 jne	 SHORT $LN21@r_object

; 292  : 				v = NULL;

  007f5	83 65 58 00	 and	 DWORD PTR _v$[ebp], 0

; 293  : 				break;

  007f9	eb 14		 jmp	 SHORT $LN17@r_object
$LN121@r_object:

; 294  : 			}
; 295  : 			PyList_SetItem(v, (int)i, v2);

  007fb	ff 75 1c	 push	 DWORD PTR _v2$[ebp]
  007fe	ff 75 50	 push	 DWORD PTR _i$[ebp]
  00801	ff 75 58	 push	 DWORD PTR _v$[ebp]
  00804	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyList_SetItem
  0080a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 296  : 		}

  0080d	eb 98		 jmp	 SHORT $LN16@r_object
$LN17@r_object:

; 297  : 		return v;

  0080f	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  00812	e9 5f 04 00 00	 jmp	 $LN2@r_object
$LN124@r_object:

; 298  : 
; 299  : 	case TYPE_DICT:
; 300  : 		v = PyDict_New();

  00817	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyDict_New
  0081d	89 45 58	 mov	 DWORD PTR _v$[ebp], eax

; 301  : 		if (v == NULL)

  00820	83 7d 58 00	 cmp	 DWORD PTR _v$[ebp], 0
  00824	75 07		 jne	 SHORT $LN125@r_object

; 302  : 			return NULL;

  00826	33 c0		 xor	 eax, eax
  00828	e9 49 04 00 00	 jmp	 $LN2@r_object
$LN125@r_object:
$LN22@r_object:

; 303  : 		for (;;) {
; 304  : 			PyObject *key, *val;
; 305  : 			key = r_object(p);

  0082d	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  00833	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00838	59		 pop	 ecx
  00839	89 45 24	 mov	 DWORD PTR _key$13[ebp], eax

; 306  : 			if (key == NULL)

  0083c	83 7d 24 00	 cmp	 DWORD PTR _key$13[ebp], 0
  00840	75 05		 jne	 SHORT $LN126@r_object

; 307  : 				break; /* XXX Assume TYPE_NULL, not an error */

  00842	e9 8c 00 00 00	 jmp	 $LN23@r_object
$LN126@r_object:

; 308  : 			val = r_object(p);

  00847	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  0084d	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00852	59		 pop	 ecx
  00853	89 45 2c	 mov	 DWORD PTR _val$15[ebp], eax

; 309  : 			if (val != NULL)

  00856	83 7d 2c 00	 cmp	 DWORD PTR _val$15[ebp], 0
  0085a	74 12		 je	 SHORT $LN127@r_object

; 310  : 				PyDict_SetItem(v, key, val);

  0085c	ff 75 2c	 push	 DWORD PTR _val$15[ebp]
  0085f	ff 75 24	 push	 DWORD PTR _key$13[ebp]
  00862	ff 75 58	 push	 DWORD PTR _v$[ebp]
  00865	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyDict_SetItem
  0086b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN127@r_object:

; 311  : 			Py_DECREF(key);

  0086e	8b 45 24	 mov	 eax, DWORD PTR _key$13[ebp]
  00871	8b 00		 mov	 eax, DWORD PTR [eax]
  00873	48		 dec	 eax
  00874	89 45 d4	 mov	 DWORD PTR tv352[ebp], eax
  00877	8b 45 24	 mov	 eax, DWORD PTR _key$13[ebp]
  0087a	8b 4d d4	 mov	 ecx, DWORD PTR tv352[ebp]
  0087d	89 08		 mov	 DWORD PTR [eax], ecx
  0087f	83 7d d4 00	 cmp	 DWORD PTR tv352[ebp], 0
  00883	74 02		 je	 SHORT $LN128@r_object
  00885	eb 0d		 jmp	 SHORT $LN129@r_object
$LN128@r_object:
  00887	ff 75 24	 push	 DWORD PTR _key$13[ebp]
  0088a	8b 45 24	 mov	 eax, DWORD PTR _key$13[ebp]
  0088d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00890	ff 50 18	 call	 DWORD PTR [eax+24]
  00893	59		 pop	 ecx
$LN129@r_object:
  00894	33 c0		 xor	 eax, eax
  00896	75 d6		 jne	 SHORT $LN127@r_object
$LN26@r_object:

; 312  : 			Py_XDECREF(val);

  00898	83 7d 2c 00	 cmp	 DWORD PTR _val$15[ebp], 0
  0089c	75 02		 jne	 SHORT $LN130@r_object
  0089e	eb 2a		 jmp	 SHORT $LN32@r_object
$LN130@r_object:
  008a0	8b 45 2c	 mov	 eax, DWORD PTR _val$15[ebp]
  008a3	8b 00		 mov	 eax, DWORD PTR [eax]
  008a5	48		 dec	 eax
  008a6	89 45 d0	 mov	 DWORD PTR tv361[ebp], eax
  008a9	8b 45 2c	 mov	 eax, DWORD PTR _val$15[ebp]
  008ac	8b 4d d0	 mov	 ecx, DWORD PTR tv361[ebp]
  008af	89 08		 mov	 DWORD PTR [eax], ecx
  008b1	83 7d d0 00	 cmp	 DWORD PTR tv361[ebp], 0
  008b5	74 02		 je	 SHORT $LN132@r_object
  008b7	eb 0d		 jmp	 SHORT $LN133@r_object
$LN132@r_object:
  008b9	ff 75 2c	 push	 DWORD PTR _val$15[ebp]
  008bc	8b 45 2c	 mov	 eax, DWORD PTR _val$15[ebp]
  008bf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  008c2	ff 50 18	 call	 DWORD PTR [eax+24]
  008c5	59		 pop	 ecx
$LN133@r_object:
  008c6	33 c0		 xor	 eax, eax
  008c8	75 d6		 jne	 SHORT $LN130@r_object
$LN32@r_object:
  008ca	33 c0		 xor	 eax, eax
  008cc	75 ca		 jne	 SHORT $LN26@r_object

; 313  : 		}

  008ce	e9 5a ff ff ff	 jmp	 $LN22@r_object
$LN23@r_object:

; 314  : 		return v;

  008d3	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  008d6	e9 9b 03 00 00	 jmp	 $LN2@r_object
$LN134@r_object:

; 315  : 
; 316  : 	case TYPE_CODE:
; 317  : 		if (PyEval_GetRestricted()) {

  008db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyEval_GetRestricted
  008e1	85 c0		 test	 eax, eax
  008e3	74 20		 je	 SHORT $LN135@r_object

; 318  : 			PyErr_SetString(PyExc_RuntimeError,

  008e5	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@
  008ea	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  008ef	ff 30		 push	 DWORD PTR [eax]
  008f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  008f7	59		 pop	 ecx
  008f8	59		 pop	 ecx

; 319  : 				"cannot unmarshal code objects in "
; 320  : 				"restricted execution mode");
; 321  : 			return NULL;

  008f9	33 c0		 xor	 eax, eax
  008fb	e9 76 03 00 00	 jmp	 $LN2@r_object

; 322  : 		}

  00900	e9 56 03 00 00	 jmp	 $LN83@r_object
$LN135@r_object:

; 323  : 		else {
; 324  : 			int argcount = r_short(p);

  00905	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  0090b	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  00910	59		 pop	 ecx
  00911	89 45 94	 mov	 DWORD PTR _argcount$4[ebp], eax

; 325  : 			int nlocals = r_short(p);

  00914	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  0091a	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  0091f	59		 pop	 ecx
  00920	89 45 98	 mov	 DWORD PTR _nlocals$5[ebp], eax

; 326  : 			int stacksize = r_short(p);

  00923	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  00929	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  0092e	59		 pop	 ecx
  0092f	89 45 8c	 mov	 DWORD PTR _stacksize$3[ebp], eax

; 327  : 			int flags = r_short(p);

  00932	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  00938	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  0093d	59		 pop	 ecx
  0093e	89 45 88	 mov	 DWORD PTR _flags$2[ebp], eax

; 328  : 			PyObject *code = NULL;

  00941	83 65 4c 00	 and	 DWORD PTR _code$23[ebp], 0

; 329  : 			PyObject *consts = NULL;

  00945	83 65 48 00	 and	 DWORD PTR _consts$22[ebp], 0

; 330  : 			PyObject *names = NULL;

  00949	83 65 44 00	 and	 DWORD PTR _names$21[ebp], 0

; 331  : 			PyObject *varnames = NULL;

  0094d	83 65 40 00	 and	 DWORD PTR _varnames$20[ebp], 0

; 332  : 			PyObject *freevars = NULL;

  00951	83 65 3c 00	 and	 DWORD PTR _freevars$19[ebp], 0

; 333  : 			PyObject *cellvars = NULL;

  00955	83 65 38 00	 and	 DWORD PTR _cellvars$18[ebp], 0

; 334  : 			PyObject *filename = NULL;

  00959	83 65 34 00	 and	 DWORD PTR _filename$17[ebp], 0

; 335  : 			PyObject *name = NULL;

  0095d	83 65 30 00	 and	 DWORD PTR _name$16[ebp], 0

; 336  : 			int firstlineno = 0;

  00961	83 65 cc 00	 and	 DWORD PTR _firstlineno$6[ebp], 0

; 337  : 			PyObject *lnotab = NULL;

  00965	83 65 28 00	 and	 DWORD PTR _lnotab$14[ebp], 0

; 338  : 
; 339  : 			code = r_object(p);

  00969	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  0096f	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00974	59		 pop	 ecx
  00975	89 45 4c	 mov	 DWORD PTR _code$23[ebp], eax

; 340  : 			if (code) consts = r_object(p);

  00978	83 7d 4c 00	 cmp	 DWORD PTR _code$23[ebp], 0
  0097c	74 0f		 je	 SHORT $LN137@r_object
  0097e	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  00984	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00989	59		 pop	 ecx
  0098a	89 45 48	 mov	 DWORD PTR _consts$22[ebp], eax
$LN137@r_object:

; 341  : 			if (consts) names = r_object(p);

  0098d	83 7d 48 00	 cmp	 DWORD PTR _consts$22[ebp], 0
  00991	74 0f		 je	 SHORT $LN138@r_object
  00993	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  00999	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  0099e	59		 pop	 ecx
  0099f	89 45 44	 mov	 DWORD PTR _names$21[ebp], eax
$LN138@r_object:

; 342  : 			if (names) varnames = r_object(p);

  009a2	83 7d 44 00	 cmp	 DWORD PTR _names$21[ebp], 0
  009a6	74 0f		 je	 SHORT $LN139@r_object
  009a8	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  009ae	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  009b3	59		 pop	 ecx
  009b4	89 45 40	 mov	 DWORD PTR _varnames$20[ebp], eax
$LN139@r_object:

; 343  : 			if (varnames) freevars = r_object(p);

  009b7	83 7d 40 00	 cmp	 DWORD PTR _varnames$20[ebp], 0
  009bb	74 0f		 je	 SHORT $LN140@r_object
  009bd	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  009c3	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  009c8	59		 pop	 ecx
  009c9	89 45 3c	 mov	 DWORD PTR _freevars$19[ebp], eax
$LN140@r_object:

; 344  : 			if (freevars) cellvars = r_object(p);

  009cc	83 7d 3c 00	 cmp	 DWORD PTR _freevars$19[ebp], 0
  009d0	74 0f		 je	 SHORT $LN141@r_object
  009d2	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  009d8	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  009dd	59		 pop	 ecx
  009de	89 45 38	 mov	 DWORD PTR _cellvars$18[ebp], eax
$LN141@r_object:

; 345  : 			if (cellvars) filename = r_object(p);

  009e1	83 7d 38 00	 cmp	 DWORD PTR _cellvars$18[ebp], 0
  009e5	74 0f		 je	 SHORT $LN142@r_object
  009e7	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  009ed	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  009f2	59		 pop	 ecx
  009f3	89 45 34	 mov	 DWORD PTR _filename$17[ebp], eax
$LN142@r_object:

; 346  : 			if (filename) name = r_object(p);

  009f6	83 7d 34 00	 cmp	 DWORD PTR _filename$17[ebp], 0
  009fa	74 0f		 je	 SHORT $LN143@r_object
  009fc	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  00a02	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00a07	59		 pop	 ecx
  00a08	89 45 30	 mov	 DWORD PTR _name$16[ebp], eax
$LN143@r_object:

; 347  : 			if (name) {

  00a0b	83 7d 30 00	 cmp	 DWORD PTR _name$16[ebp], 0
  00a0f	74 1e		 je	 SHORT $LN144@r_object

; 348  : 				firstlineno = r_short(p);

  00a11	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  00a17	e8 00 00 00 00	 call	 ?r_short@@YAHPAUWFILE@@@Z ; r_short
  00a1c	59		 pop	 ecx
  00a1d	89 45 cc	 mov	 DWORD PTR _firstlineno$6[ebp], eax

; 349  : 				lnotab = r_object(p);

  00a20	ff b5 7c 02 00
	00		 push	 DWORD PTR _p$[ebp]
  00a26	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00a2b	59		 pop	 ecx
  00a2c	89 45 28	 mov	 DWORD PTR _lnotab$14[ebp], eax
$LN144@r_object:

; 350  : 			}
; 351  : 
; 352  : 			if (!PyErr_Occurred()) {

  00a2f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  00a35	85 c0		 test	 eax, eax
  00a37	75 38		 jne	 SHORT $LN145@r_object

; 353  : 				v = (PyObject *) PyCode_New(

  00a39	ff 75 28	 push	 DWORD PTR _lnotab$14[ebp]
  00a3c	ff 75 cc	 push	 DWORD PTR _firstlineno$6[ebp]
  00a3f	ff 75 30	 push	 DWORD PTR _name$16[ebp]
  00a42	ff 75 34	 push	 DWORD PTR _filename$17[ebp]
  00a45	ff 75 38	 push	 DWORD PTR _cellvars$18[ebp]
  00a48	ff 75 3c	 push	 DWORD PTR _freevars$19[ebp]
  00a4b	ff 75 40	 push	 DWORD PTR _varnames$20[ebp]
  00a4e	ff 75 44	 push	 DWORD PTR _names$21[ebp]
  00a51	ff 75 48	 push	 DWORD PTR _consts$22[ebp]
  00a54	ff 75 4c	 push	 DWORD PTR _code$23[ebp]
  00a57	ff 75 88	 push	 DWORD PTR _flags$2[ebp]
  00a5a	ff 75 8c	 push	 DWORD PTR _stacksize$3[ebp]
  00a5d	ff 75 98	 push	 DWORD PTR _nlocals$5[ebp]
  00a60	ff 75 94	 push	 DWORD PTR _argcount$4[ebp]
  00a63	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyCode_New
  00a69	83 c4 38	 add	 esp, 56			; 00000038H
  00a6c	89 45 58	 mov	 DWORD PTR _v$[ebp], eax

; 354  : 					argcount, nlocals, stacksize, flags,
; 355  : 					code, consts, names, varnames,
; 356  : 					freevars, cellvars, filename, name,
; 357  : 					firstlineno, lnotab);
; 358  : 			}

  00a6f	eb 04		 jmp	 SHORT $LN146@r_object
$LN145@r_object:

; 359  : 			else
; 360  : 				v = NULL;

  00a71	83 65 58 00	 and	 DWORD PTR _v$[ebp], 0
$LN146@r_object:

; 361  : 			Py_XDECREF(code);

  00a75	83 7d 4c 00	 cmp	 DWORD PTR _code$23[ebp], 0
  00a79	75 02		 jne	 SHORT $LN147@r_object
  00a7b	eb 2a		 jmp	 SHORT $LN38@r_object
$LN147@r_object:
  00a7d	8b 45 4c	 mov	 eax, DWORD PTR _code$23[ebp]
  00a80	8b 00		 mov	 eax, DWORD PTR [eax]
  00a82	48		 dec	 eax
  00a83	89 45 c8	 mov	 DWORD PTR tv460[ebp], eax
  00a86	8b 45 4c	 mov	 eax, DWORD PTR _code$23[ebp]
  00a89	8b 4d c8	 mov	 ecx, DWORD PTR tv460[ebp]
  00a8c	89 08		 mov	 DWORD PTR [eax], ecx
  00a8e	83 7d c8 00	 cmp	 DWORD PTR tv460[ebp], 0
  00a92	74 02		 je	 SHORT $LN149@r_object
  00a94	eb 0d		 jmp	 SHORT $LN150@r_object
$LN149@r_object:
  00a96	ff 75 4c	 push	 DWORD PTR _code$23[ebp]
  00a99	8b 45 4c	 mov	 eax, DWORD PTR _code$23[ebp]
  00a9c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00a9f	ff 50 18	 call	 DWORD PTR [eax+24]
  00aa2	59		 pop	 ecx
$LN150@r_object:
  00aa3	33 c0		 xor	 eax, eax
  00aa5	75 d6		 jne	 SHORT $LN147@r_object
$LN38@r_object:
  00aa7	33 c0		 xor	 eax, eax
  00aa9	75 ca		 jne	 SHORT $LN146@r_object
$LN35@r_object:

; 362  : 			Py_XDECREF(consts);

  00aab	83 7d 48 00	 cmp	 DWORD PTR _consts$22[ebp], 0
  00aaf	75 02		 jne	 SHORT $LN151@r_object
  00ab1	eb 2a		 jmp	 SHORT $LN44@r_object
$LN151@r_object:
  00ab3	8b 45 48	 mov	 eax, DWORD PTR _consts$22[ebp]
  00ab6	8b 00		 mov	 eax, DWORD PTR [eax]
  00ab8	48		 dec	 eax
  00ab9	89 45 c4	 mov	 DWORD PTR tv470[ebp], eax
  00abc	8b 45 48	 mov	 eax, DWORD PTR _consts$22[ebp]
  00abf	8b 4d c4	 mov	 ecx, DWORD PTR tv470[ebp]
  00ac2	89 08		 mov	 DWORD PTR [eax], ecx
  00ac4	83 7d c4 00	 cmp	 DWORD PTR tv470[ebp], 0
  00ac8	74 02		 je	 SHORT $LN153@r_object
  00aca	eb 0d		 jmp	 SHORT $LN154@r_object
$LN153@r_object:
  00acc	ff 75 48	 push	 DWORD PTR _consts$22[ebp]
  00acf	8b 45 48	 mov	 eax, DWORD PTR _consts$22[ebp]
  00ad2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00ad5	ff 50 18	 call	 DWORD PTR [eax+24]
  00ad8	59		 pop	 ecx
$LN154@r_object:
  00ad9	33 c0		 xor	 eax, eax
  00adb	75 d6		 jne	 SHORT $LN151@r_object
$LN44@r_object:
  00add	33 c0		 xor	 eax, eax
  00adf	75 ca		 jne	 SHORT $LN35@r_object
$LN41@r_object:

; 363  : 			Py_XDECREF(names);

  00ae1	83 7d 44 00	 cmp	 DWORD PTR _names$21[ebp], 0
  00ae5	75 02		 jne	 SHORT $LN155@r_object
  00ae7	eb 2a		 jmp	 SHORT $LN50@r_object
$LN155@r_object:
  00ae9	8b 45 44	 mov	 eax, DWORD PTR _names$21[ebp]
  00aec	8b 00		 mov	 eax, DWORD PTR [eax]
  00aee	48		 dec	 eax
  00aef	89 45 c0	 mov	 DWORD PTR tv480[ebp], eax
  00af2	8b 45 44	 mov	 eax, DWORD PTR _names$21[ebp]
  00af5	8b 4d c0	 mov	 ecx, DWORD PTR tv480[ebp]
  00af8	89 08		 mov	 DWORD PTR [eax], ecx
  00afa	83 7d c0 00	 cmp	 DWORD PTR tv480[ebp], 0
  00afe	74 02		 je	 SHORT $LN157@r_object
  00b00	eb 0d		 jmp	 SHORT $LN158@r_object
$LN157@r_object:
  00b02	ff 75 44	 push	 DWORD PTR _names$21[ebp]
  00b05	8b 45 44	 mov	 eax, DWORD PTR _names$21[ebp]
  00b08	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00b0b	ff 50 18	 call	 DWORD PTR [eax+24]
  00b0e	59		 pop	 ecx
$LN158@r_object:
  00b0f	33 c0		 xor	 eax, eax
  00b11	75 d6		 jne	 SHORT $LN155@r_object
$LN50@r_object:
  00b13	33 c0		 xor	 eax, eax
  00b15	75 ca		 jne	 SHORT $LN41@r_object
$LN47@r_object:

; 364  : 			Py_XDECREF(varnames);

  00b17	83 7d 40 00	 cmp	 DWORD PTR _varnames$20[ebp], 0
  00b1b	75 02		 jne	 SHORT $LN159@r_object
  00b1d	eb 2a		 jmp	 SHORT $LN56@r_object
$LN159@r_object:
  00b1f	8b 45 40	 mov	 eax, DWORD PTR _varnames$20[ebp]
  00b22	8b 00		 mov	 eax, DWORD PTR [eax]
  00b24	48		 dec	 eax
  00b25	89 45 a4	 mov	 DWORD PTR tv490[ebp], eax
  00b28	8b 45 40	 mov	 eax, DWORD PTR _varnames$20[ebp]
  00b2b	8b 4d a4	 mov	 ecx, DWORD PTR tv490[ebp]
  00b2e	89 08		 mov	 DWORD PTR [eax], ecx
  00b30	83 7d a4 00	 cmp	 DWORD PTR tv490[ebp], 0
  00b34	74 02		 je	 SHORT $LN161@r_object
  00b36	eb 0d		 jmp	 SHORT $LN162@r_object
$LN161@r_object:
  00b38	ff 75 40	 push	 DWORD PTR _varnames$20[ebp]
  00b3b	8b 45 40	 mov	 eax, DWORD PTR _varnames$20[ebp]
  00b3e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00b41	ff 50 18	 call	 DWORD PTR [eax+24]
  00b44	59		 pop	 ecx
$LN162@r_object:
  00b45	33 c0		 xor	 eax, eax
  00b47	75 d6		 jne	 SHORT $LN159@r_object
$LN56@r_object:
  00b49	33 c0		 xor	 eax, eax
  00b4b	75 ca		 jne	 SHORT $LN47@r_object
$LN53@r_object:

; 365  : 			Py_XDECREF(freevars);

  00b4d	83 7d 3c 00	 cmp	 DWORD PTR _freevars$19[ebp], 0
  00b51	75 02		 jne	 SHORT $LN163@r_object
  00b53	eb 2a		 jmp	 SHORT $LN62@r_object
$LN163@r_object:
  00b55	8b 45 3c	 mov	 eax, DWORD PTR _freevars$19[ebp]
  00b58	8b 00		 mov	 eax, DWORD PTR [eax]
  00b5a	48		 dec	 eax
  00b5b	89 45 b8	 mov	 DWORD PTR tv500[ebp], eax
  00b5e	8b 45 3c	 mov	 eax, DWORD PTR _freevars$19[ebp]
  00b61	8b 4d b8	 mov	 ecx, DWORD PTR tv500[ebp]
  00b64	89 08		 mov	 DWORD PTR [eax], ecx
  00b66	83 7d b8 00	 cmp	 DWORD PTR tv500[ebp], 0
  00b6a	74 02		 je	 SHORT $LN165@r_object
  00b6c	eb 0d		 jmp	 SHORT $LN166@r_object
$LN165@r_object:
  00b6e	ff 75 3c	 push	 DWORD PTR _freevars$19[ebp]
  00b71	8b 45 3c	 mov	 eax, DWORD PTR _freevars$19[ebp]
  00b74	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00b77	ff 50 18	 call	 DWORD PTR [eax+24]
  00b7a	59		 pop	 ecx
$LN166@r_object:
  00b7b	33 c0		 xor	 eax, eax
  00b7d	75 d6		 jne	 SHORT $LN163@r_object
$LN62@r_object:
  00b7f	33 c0		 xor	 eax, eax
  00b81	75 ca		 jne	 SHORT $LN53@r_object
$LN59@r_object:

; 366  : 			Py_XDECREF(cellvars);

  00b83	83 7d 38 00	 cmp	 DWORD PTR _cellvars$18[ebp], 0
  00b87	75 02		 jne	 SHORT $LN167@r_object
  00b89	eb 2a		 jmp	 SHORT $LN68@r_object
$LN167@r_object:
  00b8b	8b 45 38	 mov	 eax, DWORD PTR _cellvars$18[ebp]
  00b8e	8b 00		 mov	 eax, DWORD PTR [eax]
  00b90	48		 dec	 eax
  00b91	89 45 b4	 mov	 DWORD PTR tv510[ebp], eax
  00b94	8b 45 38	 mov	 eax, DWORD PTR _cellvars$18[ebp]
  00b97	8b 4d b4	 mov	 ecx, DWORD PTR tv510[ebp]
  00b9a	89 08		 mov	 DWORD PTR [eax], ecx
  00b9c	83 7d b4 00	 cmp	 DWORD PTR tv510[ebp], 0
  00ba0	74 02		 je	 SHORT $LN169@r_object
  00ba2	eb 0d		 jmp	 SHORT $LN170@r_object
$LN169@r_object:
  00ba4	ff 75 38	 push	 DWORD PTR _cellvars$18[ebp]
  00ba7	8b 45 38	 mov	 eax, DWORD PTR _cellvars$18[ebp]
  00baa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00bad	ff 50 18	 call	 DWORD PTR [eax+24]
  00bb0	59		 pop	 ecx
$LN170@r_object:
  00bb1	33 c0		 xor	 eax, eax
  00bb3	75 d6		 jne	 SHORT $LN167@r_object
$LN68@r_object:
  00bb5	33 c0		 xor	 eax, eax
  00bb7	75 ca		 jne	 SHORT $LN59@r_object
$LN65@r_object:

; 367  : 			Py_XDECREF(filename);

  00bb9	83 7d 34 00	 cmp	 DWORD PTR _filename$17[ebp], 0
  00bbd	75 02		 jne	 SHORT $LN171@r_object
  00bbf	eb 2a		 jmp	 SHORT $LN74@r_object
$LN171@r_object:
  00bc1	8b 45 34	 mov	 eax, DWORD PTR _filename$17[ebp]
  00bc4	8b 00		 mov	 eax, DWORD PTR [eax]
  00bc6	48		 dec	 eax
  00bc7	89 45 b0	 mov	 DWORD PTR tv520[ebp], eax
  00bca	8b 45 34	 mov	 eax, DWORD PTR _filename$17[ebp]
  00bcd	8b 4d b0	 mov	 ecx, DWORD PTR tv520[ebp]
  00bd0	89 08		 mov	 DWORD PTR [eax], ecx
  00bd2	83 7d b0 00	 cmp	 DWORD PTR tv520[ebp], 0
  00bd6	74 02		 je	 SHORT $LN173@r_object
  00bd8	eb 0d		 jmp	 SHORT $LN174@r_object
$LN173@r_object:
  00bda	ff 75 34	 push	 DWORD PTR _filename$17[ebp]
  00bdd	8b 45 34	 mov	 eax, DWORD PTR _filename$17[ebp]
  00be0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00be3	ff 50 18	 call	 DWORD PTR [eax+24]
  00be6	59		 pop	 ecx
$LN174@r_object:
  00be7	33 c0		 xor	 eax, eax
  00be9	75 d6		 jne	 SHORT $LN171@r_object
$LN74@r_object:
  00beb	33 c0		 xor	 eax, eax
  00bed	75 ca		 jne	 SHORT $LN65@r_object
$LN71@r_object:

; 368  : 			Py_XDECREF(name);

  00bef	83 7d 30 00	 cmp	 DWORD PTR _name$16[ebp], 0
  00bf3	75 02		 jne	 SHORT $LN175@r_object
  00bf5	eb 2a		 jmp	 SHORT $LN80@r_object
$LN175@r_object:
  00bf7	8b 45 30	 mov	 eax, DWORD PTR _name$16[ebp]
  00bfa	8b 00		 mov	 eax, DWORD PTR [eax]
  00bfc	48		 dec	 eax
  00bfd	89 45 ac	 mov	 DWORD PTR tv530[ebp], eax
  00c00	8b 45 30	 mov	 eax, DWORD PTR _name$16[ebp]
  00c03	8b 4d ac	 mov	 ecx, DWORD PTR tv530[ebp]
  00c06	89 08		 mov	 DWORD PTR [eax], ecx
  00c08	83 7d ac 00	 cmp	 DWORD PTR tv530[ebp], 0
  00c0c	74 02		 je	 SHORT $LN177@r_object
  00c0e	eb 0d		 jmp	 SHORT $LN178@r_object
$LN177@r_object:
  00c10	ff 75 30	 push	 DWORD PTR _name$16[ebp]
  00c13	8b 45 30	 mov	 eax, DWORD PTR _name$16[ebp]
  00c16	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00c19	ff 50 18	 call	 DWORD PTR [eax+24]
  00c1c	59		 pop	 ecx
$LN178@r_object:
  00c1d	33 c0		 xor	 eax, eax
  00c1f	75 d6		 jne	 SHORT $LN175@r_object
$LN80@r_object:
  00c21	33 c0		 xor	 eax, eax
  00c23	75 ca		 jne	 SHORT $LN71@r_object
$LN77@r_object:

; 369  : 			Py_XDECREF(lnotab);

  00c25	83 7d 28 00	 cmp	 DWORD PTR _lnotab$14[ebp], 0
  00c29	75 02		 jne	 SHORT $LN179@r_object
  00c2b	eb 2a		 jmp	 SHORT $LN86@r_object
$LN179@r_object:
  00c2d	8b 45 28	 mov	 eax, DWORD PTR _lnotab$14[ebp]
  00c30	8b 00		 mov	 eax, DWORD PTR [eax]
  00c32	48		 dec	 eax
  00c33	89 45 a8	 mov	 DWORD PTR tv540[ebp], eax
  00c36	8b 45 28	 mov	 eax, DWORD PTR _lnotab$14[ebp]
  00c39	8b 4d a8	 mov	 ecx, DWORD PTR tv540[ebp]
  00c3c	89 08		 mov	 DWORD PTR [eax], ecx
  00c3e	83 7d a8 00	 cmp	 DWORD PTR tv540[ebp], 0
  00c42	74 02		 je	 SHORT $LN181@r_object
  00c44	eb 0d		 jmp	 SHORT $LN182@r_object
$LN181@r_object:
  00c46	ff 75 28	 push	 DWORD PTR _lnotab$14[ebp]
  00c49	8b 45 28	 mov	 eax, DWORD PTR _lnotab$14[ebp]
  00c4c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00c4f	ff 50 18	 call	 DWORD PTR [eax+24]
  00c52	59		 pop	 ecx
$LN182@r_object:
  00c53	33 c0		 xor	 eax, eax
  00c55	75 d6		 jne	 SHORT $LN179@r_object
$LN86@r_object:
  00c57	33 c0		 xor	 eax, eax
  00c59	75 ca		 jne	 SHORT $LN77@r_object
$LN83@r_object:

; 370  : 
; 371  : 		}
; 372  : 		return v;

  00c5b	8b 45 58	 mov	 eax, DWORD PTR _v$[ebp]
  00c5e	eb 16		 jmp	 SHORT $LN2@r_object
$LN183@r_object:

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");

  00c60	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DCKILJJE@bad?5marshal?5data@
  00c65	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_ValueError
  00c6a	ff 30		 push	 DWORD PTR [eax]
  00c6c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  00c72	59		 pop	 ecx
  00c73	59		 pop	 ecx

; 378  : 		return NULL;

  00c74	33 c0		 xor	 eax, eax
$LN2@r_object:

; 379  : 	}
; 380  : }

  00c76	5f		 pop	 edi
  00c77	5e		 pop	 esi
  00c78	8b 8d 70 02 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c7e	33 cd		 xor	 ecx, ebp
  00c80	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c85	81 c5 74 02 00
	00		 add	 ebp, 628		; 00000274H
  00c8b	c9		 leave
  00c8c	c3		 ret	 0
?r_object@@YAPAU_object@@PAUWFILE@@@Z ENDP		; r_object
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_long64@@YAPAU_object@@PAUWFILE@@@Z
_TEXT	SEGMENT
_one$ = -28						; size = 4
_is_little_endian$ = -24				; size = 4
_lo4$ = -20						; size = 4
_hi4$ = -16						; size = 4
_buf$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
?r_long64@@YAPAU_object@@PAUWFILE@@@Z PROC		; r_long64, COMDAT

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 101  : 	long lo4 = r_long(p);

  00010	ff 75 08	 push	 DWORD PTR _p$[ebp]
  00013	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  00018	59		 pop	 ecx
  00019	89 45 ec	 mov	 DWORD PTR _lo4$[ebp], eax

; 102  : 	long hi4 = r_long(p);

  0001c	ff 75 08	 push	 DWORD PTR _p$[ebp]
  0001f	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  00024	59		 pop	 ecx
  00025	89 45 f0	 mov	 DWORD PTR _hi4$[ebp], eax

; 103  : #if SIZEOF_LONG > 4
; 104  : 	long x = (hi4 << 32) | (lo4 & 0xFFFFFFFFL);
; 105  : 	return PyInt_FromLong(x);
; 106  : #else
; 107  : 	unsigned char buf[8];
; 108  : 	int one = 1;

  00028	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _one$[ebp], 1

; 109  : 	int is_little_endian = (int)*(char*)&one;

  0002f	0f be 45 e4	 movsx	 eax, BYTE PTR _one$[ebp]
  00033	89 45 e8	 mov	 DWORD PTR _is_little_endian$[ebp], eax

; 110  : 	if (is_little_endian) {

  00036	83 7d e8 00	 cmp	 DWORD PTR _is_little_endian$[ebp], 0
  0003a	74 26		 je	 SHORT $LN2@r_long64

; 111  : 		memcpy(buf, &lo4, 4);

  0003c	6a 04		 push	 4
  0003e	8d 45 ec	 lea	 eax, DWORD PTR _lo4$[ebp]
  00041	50		 push	 eax
  00042	8d 45 f4	 lea	 eax, DWORD PTR _buf$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _memcpy
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 112  : 		memcpy(buf+4, &hi4, 4);

  0004e	6a 04		 push	 4
  00050	8d 45 f0	 lea	 eax, DWORD PTR _hi4$[ebp]
  00053	50		 push	 eax
  00054	8d 45 f8	 lea	 eax, DWORD PTR _buf$[ebp+4]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _memcpy
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 113  : 	}

  00060	eb 24		 jmp	 SHORT $LN3@r_long64
$LN2@r_long64:

; 114  : 	else {
; 115  : 		memcpy(buf, &hi4, 4);

  00062	6a 04		 push	 4
  00064	8d 45 f0	 lea	 eax, DWORD PTR _hi4$[ebp]
  00067	50		 push	 eax
  00068	8d 45 f4	 lea	 eax, DWORD PTR _buf$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _memcpy
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 116  : 		memcpy(buf+4, &lo4, 4);

  00074	6a 04		 push	 4
  00076	8d 45 ec	 lea	 eax, DWORD PTR _lo4$[ebp]
  00079	50		 push	 eax
  0007a	8d 45 f8	 lea	 eax, DWORD PTR _buf$[ebp+4]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _memcpy
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@r_long64:

; 117  : 	}
; 118  : 	return _PyLong_FromByteArray(buf, 8, is_little_endian, 1);

  00086	6a 01		 push	 1
  00088	ff 75 e8	 push	 DWORD PTR _is_little_endian$[ebp]
  0008b	6a 08		 push	 8
  0008d	8d 45 f4	 lea	 eax, DWORD PTR _buf$[ebp]
  00090	50		 push	 eax
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___PyLong_FromByteArray
  00097	83 c4 10	 add	 esp, 16			; 00000010H

; 119  : #endif
; 120  : }

  0009a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009d	33 cd		 xor	 ecx, ebp
  0009f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a4	c9		 leave
  000a5	c3		 ret	 0
?r_long64@@YAPAU_object@@PAUWFILE@@@Z ENDP		; r_long64
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_long@@YAJPAUWFILE@@@Z
_TEXT	SEGMENT
tv155 = -24						; size = 4
tv143 = -20						; size = 4
tv131 = -16						; size = 4
tv89 = -12						; size = 4
_fp$ = -8						; size = 4
_x$ = -4						; size = 4
_p$ = 8							; size = 4
?r_long@@YAJPAUWFILE@@@Z PROC				; r_long, COMDAT

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 71   : 	register long x;
; 72   : 	register FILE *fp = p->fp;

  00006	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	89 45 f8	 mov	 DWORD PTR _fp$[ebp], eax

; 73   : 	if (fp) {

  0000e	83 7d f8 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00012	74 47		 je	 SHORT $LN2@r_long

; 74   : 		x = getc(fp);

  00014	ff 75 f8	 push	 DWORD PTR _fp$[ebp]
  00017	e8 00 00 00 00	 call	 _getc
  0001c	59		 pop	 ecx
  0001d	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 75   : 		x |= (long)getc(fp) << 8;

  00020	ff 75 f8	 push	 DWORD PTR _fp$[ebp]
  00023	e8 00 00 00 00	 call	 _getc
  00028	59		 pop	 ecx
  00029	c1 e0 08	 shl	 eax, 8
  0002c	0b 45 fc	 or	 eax, DWORD PTR _x$[ebp]
  0002f	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 76   : 		x |= (long)getc(fp) << 16;

  00032	ff 75 f8	 push	 DWORD PTR _fp$[ebp]
  00035	e8 00 00 00 00	 call	 _getc
  0003a	59		 pop	 ecx
  0003b	c1 e0 10	 shl	 eax, 16			; 00000010H
  0003e	0b 45 fc	 or	 eax, DWORD PTR _x$[ebp]
  00041	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 77   : 		x |= (long)getc(fp) << 24;

  00044	ff 75 f8	 push	 DWORD PTR _fp$[ebp]
  00047	e8 00 00 00 00	 call	 _getc
  0004c	59		 pop	 ecx
  0004d	c1 e0 18	 shl	 eax, 24			; 00000018H
  00050	0b 45 fc	 or	 eax, DWORD PTR _x$[ebp]
  00053	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 78   : 	}

  00056	e9 de 00 00 00	 jmp	 $LN3@r_long
$LN2@r_long:

; 79   : 	else {
; 80   : 		x = rs_byte(p);

  0005b	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00061	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00064	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  00067	74 1b		 je	 SHORT $LN5@r_long
  00069	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0006c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0006f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00072	89 45 f4	 mov	 DWORD PTR tv89[ebp], eax
  00075	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00078	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0007b	40		 inc	 eax
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0007f	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00082	eb 04		 jmp	 SHORT $LN6@r_long
$LN5@r_long:
  00084	83 4d f4 ff	 or	 DWORD PTR tv89[ebp], -1
$LN6@r_long:
  00088	8b 45 f4	 mov	 eax, DWORD PTR tv89[ebp]
  0008b	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 81   : 		x |= (long)rs_byte(p) << 8;

  0008e	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00091	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00094	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00097	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  0009a	74 1b		 je	 SHORT $LN7@r_long
  0009c	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0009f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000a2	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000a5	89 45 f0	 mov	 DWORD PTR tv131[ebp], eax
  000a8	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000ab	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000ae	40		 inc	 eax
  000af	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  000b2	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  000b5	eb 04		 jmp	 SHORT $LN8@r_long
$LN7@r_long:
  000b7	83 4d f0 ff	 or	 DWORD PTR tv131[ebp], -1
$LN8@r_long:
  000bb	8b 45 f0	 mov	 eax, DWORD PTR tv131[ebp]
  000be	c1 e0 08	 shl	 eax, 8
  000c1	0b 45 fc	 or	 eax, DWORD PTR _x$[ebp]
  000c4	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 82   : 		x |= (long)rs_byte(p) << 16;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  000cd	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000d0	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  000d3	74 1b		 je	 SHORT $LN9@r_long
  000d5	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000d8	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000db	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000de	89 45 ec	 mov	 DWORD PTR tv143[ebp], eax
  000e1	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000e4	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000e7	40		 inc	 eax
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  000eb	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  000ee	eb 04		 jmp	 SHORT $LN10@r_long
$LN9@r_long:
  000f0	83 4d ec ff	 or	 DWORD PTR tv143[ebp], -1
$LN10@r_long:
  000f4	8b 45 ec	 mov	 eax, DWORD PTR tv143[ebp]
  000f7	c1 e0 10	 shl	 eax, 16			; 00000010H
  000fa	0b 45 fc	 or	 eax, DWORD PTR _x$[ebp]
  000fd	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 83   : 		x |= (long)rs_byte(p) << 24;

  00100	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00103	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00106	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00109	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  0010c	74 1b		 je	 SHORT $LN11@r_long
  0010e	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00111	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00114	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00117	89 45 e8	 mov	 DWORD PTR tv155[ebp], eax
  0011a	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0011d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00120	40		 inc	 eax
  00121	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00124	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00127	eb 04		 jmp	 SHORT $LN12@r_long
$LN11@r_long:
  00129	83 4d e8 ff	 or	 DWORD PTR tv155[ebp], -1
$LN12@r_long:
  0012d	8b 45 e8	 mov	 eax, DWORD PTR tv155[ebp]
  00130	c1 e0 18	 shl	 eax, 24			; 00000018H
  00133	0b 45 fc	 or	 eax, DWORD PTR _x$[ebp]
  00136	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN3@r_long:

; 84   : 	}
; 85   : #if SIZEOF_LONG > 4
; 86   : 	/* Sign extension for 64-bit machines */
; 87   : 	x |= -(x & 0x80000000L);
; 88   : #endif
; 89   : 	return x;

  00139	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]

; 90   : }

  0013c	c9		 leave
  0013d	c3		 ret	 0
?r_long@@YAJPAUWFILE@@@Z ENDP				; r_long
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_short@@YAHPAUWFILE@@@Z
_TEXT	SEGMENT
tv128 = -20						; size = 4
tv94 = -16						; size = 4
tv79 = -12						; size = 4
tv77 = -8						; size = 4
_x$ = -4						; size = 2
_p$ = 8							; size = 4
?r_short@@YAHPAUWFILE@@@Z PROC				; r_short, COMDAT

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 61   : 	register short x;
; 62   : 	x = (short) r_byte(p);

  00006	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00009	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000c	74 10		 je	 SHORT $LN5@r_short
  0000e	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00011	ff 30		 push	 DWORD PTR [eax]
  00013	e8 00 00 00 00	 call	 _getc
  00018	59		 pop	 ecx
  00019	89 45 f4	 mov	 DWORD PTR tv79[ebp], eax
  0001c	eb 33		 jmp	 SHORT $LN6@r_short
$LN5@r_short:
  0001e	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00024	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00027	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  0002a	74 1b		 je	 SHORT $LN3@r_short
  0002c	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0002f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00032	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00035	89 45 f8	 mov	 DWORD PTR tv77[ebp], eax
  00038	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0003b	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0003e	40		 inc	 eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00042	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00045	eb 04		 jmp	 SHORT $LN4@r_short
$LN3@r_short:
  00047	83 4d f8 ff	 or	 DWORD PTR tv77[ebp], -1
$LN4@r_short:
  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]
  0004e	89 45 f4	 mov	 DWORD PTR tv79[ebp], eax
$LN6@r_short:
  00051	66 8b 45 f4	 mov	 ax, WORD PTR tv79[ebp]
  00055	66 89 45 fc	 mov	 WORD PTR _x$[ebp], ax

; 63   : 	x |= (short) r_byte(p) << 8;

  00059	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0005c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005f	74 10		 je	 SHORT $LN9@r_short
  00061	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00064	ff 30		 push	 DWORD PTR [eax]
  00066	e8 00 00 00 00	 call	 _getc
  0006b	59		 pop	 ecx
  0006c	89 45 ec	 mov	 DWORD PTR tv128[ebp], eax
  0006f	eb 33		 jmp	 SHORT $LN10@r_short
$LN9@r_short:
  00071	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00077	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0007a	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  0007d	74 1b		 je	 SHORT $LN7@r_short
  0007f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00082	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00085	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00088	89 45 f0	 mov	 DWORD PTR tv94[ebp], eax
  0008b	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0008e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00091	40		 inc	 eax
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00095	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00098	eb 04		 jmp	 SHORT $LN8@r_short
$LN7@r_short:
  0009a	83 4d f0 ff	 or	 DWORD PTR tv94[ebp], -1
$LN8@r_short:
  0009e	8b 45 f0	 mov	 eax, DWORD PTR tv94[ebp]
  000a1	89 45 ec	 mov	 DWORD PTR tv128[ebp], eax
$LN10@r_short:
  000a4	0f bf 45 ec	 movsx	 eax, WORD PTR tv128[ebp]
  000a8	c1 e0 08	 shl	 eax, 8
  000ab	0f bf 4d fc	 movsx	 ecx, WORD PTR _x$[ebp]
  000af	0b c8		 or	 ecx, eax
  000b1	66 89 4d fc	 mov	 WORD PTR _x$[ebp], cx

; 64   : 	/* Sign-extension, in case short greater than 16 bits */
; 65   : 	x |= -(x & 0x8000);

  000b5	0f bf 45 fc	 movsx	 eax, WORD PTR _x$[ebp]
  000b9	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  000be	f7 d8		 neg	 eax
  000c0	0f bf 4d fc	 movsx	 ecx, WORD PTR _x$[ebp]
  000c4	0b c8		 or	 ecx, eax
  000c6	66 89 4d fc	 mov	 WORD PTR _x$[ebp], cx

; 66   : 	return x;

  000ca	0f bf 45 fc	 movsx	 eax, WORD PTR _x$[ebp]

; 67   : }

  000ce	c9		 leave
  000cf	c3		 ret	 0
?r_short@@YAHPAUWFILE@@@Z ENDP				; r_short
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_string@@YAHPADHPAUWFILE@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_p$ = 16						; size = 4
?r_string@@YAHPADHPAUWFILE@@@Z PROC			; r_string, COMDAT

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 50   : 	if (p->fp != NULL)

  00003	8b 45 10	 mov	 eax, DWORD PTR _p$[ebp]
  00006	83 38 00	 cmp	 DWORD PTR [eax], 0
  00009	74 17		 je	 SHORT $LN2@r_string

; 51   : 		return fread(s, 1, n, p->fp);

  0000b	8b 45 10	 mov	 eax, DWORD PTR _p$[ebp]
  0000e	ff 30		 push	 DWORD PTR [eax]
  00010	ff 75 0c	 push	 DWORD PTR _n$[ebp]
  00013	6a 01		 push	 1
  00015	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00018	e8 00 00 00 00	 call	 _fread
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
  00020	eb 46		 jmp	 SHORT $LN1@r_string
$LN2@r_string:

; 52   : 	if (p->end - p->ptr < n)

  00022	8b 45 10	 mov	 eax, DWORD PTR _p$[ebp]
  00025	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  00028	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0002b	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]
  0002e	3b 45 0c	 cmp	 eax, DWORD PTR _n$[ebp]
  00031	7d 0f		 jge	 SHORT $LN3@r_string

; 53   : 		n = p->end - p->ptr;

  00033	8b 45 10	 mov	 eax, DWORD PTR _p$[ebp]
  00036	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]
  0003f	89 45 0c	 mov	 DWORD PTR _n$[ebp], eax
$LN3@r_string:

; 54   : 	memcpy(s, p->ptr, n);

  00042	ff 75 0c	 push	 DWORD PTR _n$[ebp]
  00045	8b 45 10	 mov	 eax, DWORD PTR _p$[ebp]
  00048	ff 70 10	 push	 DWORD PTR [eax+16]
  0004b	ff 75 08	 push	 DWORD PTR _s$[ebp]
  0004e	e8 00 00 00 00	 call	 _memcpy
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 	p->ptr += n;

  00056	8b 45 10	 mov	 eax, DWORD PTR _p$[ebp]
  00059	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005c	03 45 0c	 add	 eax, DWORD PTR _n$[ebp]
  0005f	8b 4d 10	 mov	 ecx, DWORD PTR _p$[ebp]
  00062	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 56   : 	return n;

  00065	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
$LN1@r_string:

; 57   : }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?r_string@@YAHPADHPAUWFILE@@@Z ENDP			; r_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_fp$ = 8						; size = 4
?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z PROC	; _PyMarshal_ReadLongFromFile, COMDAT

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 391  : 	RFILE rf;
; 392  : 	rf.fp = fp;

  00006	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00009	89 45 e8	 mov	 DWORD PTR _rf$[ebp], eax

; 393  : 	return r_long(&rf);

  0000c	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?r_long@@YAJPAUWFILE@@@Z ; r_long
  00015	59		 pop	 ecx

; 394  : }

  00016	c9		 leave
  00017	c3		 ret	 0
?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z ENDP	; _PyMarshal_ReadLongFromFile
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z
_TEXT	SEGMENT
_v$1 = -128						; size = 4
_n$2 = -124						; size = 4
tv83 = -120						; size = 4
tv80 = -116						; size = 4
_pBuf$3 = -112						; size = 4
_filesize$ = -108					; size = 4
_buf$4 = -104						; size = 16384
__$ArrayPad$ = 16280					; size = 4
_fp$ = 16292						; size = 4
?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z PROC ; _PyMarshal_ReadLastObjectFromFile, COMDAT

; 413  : {

  00000	55		 push	 ebp
  00001	8d ac 24 64 c0
	ff ff		 lea	 ebp, DWORD PTR [esp-16284]
  00008	b8 1c 40 00 00	 mov	 eax, 16412		; 0000401cH
  0000d	e8 00 00 00 00	 call	 __chkstk
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	89 85 98 3f 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 414  : 	/* 75% of 2.1's .pyc files can exploit SMALL_FILE_LIMIT.
; 415  : 	 * REASONABLE_FILE_LIMIT is by defn something big enough for Tkinter.pyc.
; 416  : 	 */
; 417  : #define SMALL_FILE_LIMIT (1L << 14)
; 418  : #define REASONABLE_FILE_LIMIT (1L << 18)
; 419  : 
; 420  : 	off_t filesize;
; 421  : 
; 422  : 	if (PyErr_Occurred())

  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  00025	85 c0		 test	 eax, eax
  00027	74 1c		 je	 SHORT $LN2@PyMarshal_

; 423  : 	{
; 424  : 		fprintf(stderr, "XXX rd_object called with exception set\n");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@
  0002e	6a 02		 push	 2
  00030	e8 00 00 00 00	 call	 ___acrt_iob_func
  00035	59		 pop	 ecx
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _fprintf
  0003c	59		 pop	 ecx
  0003d	59		 pop	 ecx

; 425  : 		return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	e9 bf 00 00 00	 jmp	 $LN1@PyMarshal_
$LN2@PyMarshal_:

; 426  : 	}
; 427  : 
; 428  : 	filesize = getfilesize(fp);

  00045	ff b5 a4 3f 00
	00		 push	 DWORD PTR _fp$[ebp]
  0004b	e8 00 00 00 00	 call	 ?getfilesize@@YAJPAU_iobuf@@@Z ; getfilesize
  00050	59		 pop	 ecx
  00051	89 45 94	 mov	 DWORD PTR _filesize$[ebp], eax

; 429  : 	if (filesize > 0) {

  00054	83 7d 94 00	 cmp	 DWORD PTR _filesize$[ebp], 0
  00058	0f 8e 9a 00 00
	00		 jle	 $LN3@PyMarshal_

; 430  : 		char buf[SMALL_FILE_LIMIT];
; 431  : 		char* pBuf = NULL;

  0005e	83 65 90 00	 and	 DWORD PTR _pBuf$3[ebp], 0

; 432  : 		if (filesize <= SMALL_FILE_LIMIT)

  00062	81 7d 94 00 40
	00 00		 cmp	 DWORD PTR _filesize$[ebp], 16384 ; 00004000H
  00069	7f 08		 jg	 SHORT $LN4@PyMarshal_

; 433  : 			pBuf = buf;

  0006b	8d 45 98	 lea	 eax, DWORD PTR _buf$4[ebp]
  0006e	89 45 90	 mov	 DWORD PTR _pBuf$3[ebp], eax
  00071	eb 3f		 jmp	 SHORT $LN5@PyMarshal_
$LN4@PyMarshal_:

; 434  : 		else if (filesize <= REASONABLE_FILE_LIMIT)

  00073	81 7d 94 00 00
	04 00		 cmp	 DWORD PTR _filesize$[ebp], 262144 ; 00040000H
  0007a	7f 36		 jg	 SHORT $LN5@PyMarshal_

; 435  : 			pBuf = (char *)PyMem_MALLOC(filesize);

  0007c	81 7d 94 ff ff
	ff 7f		 cmp	 DWORD PTR _filesize$[ebp], 2147483647 ; 7fffffffH
  00083	76 06		 jbe	 SHORT $LN12@PyMarshal_
  00085	83 65 88 00	 and	 DWORD PTR tv83[ebp], 0
  00089	eb 21		 jmp	 SHORT $LN13@PyMarshal_
$LN12@PyMarshal_:
  0008b	83 7d 94 00	 cmp	 DWORD PTR _filesize$[ebp], 0
  0008f	74 08		 je	 SHORT $LN10@PyMarshal_
  00091	8b 45 94	 mov	 eax, DWORD PTR _filesize$[ebp]
  00094	89 45 8c	 mov	 DWORD PTR tv80[ebp], eax
  00097	eb 07		 jmp	 SHORT $LN11@PyMarshal_
$LN10@PyMarshal_:
  00099	c7 45 8c 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
$LN11@PyMarshal_:
  000a0	ff 75 8c	 push	 DWORD PTR tv80[ebp]
  000a3	e8 00 00 00 00	 call	 _malloc
  000a8	59		 pop	 ecx
  000a9	89 45 88	 mov	 DWORD PTR tv83[ebp], eax
$LN13@PyMarshal_:
  000ac	8b 45 88	 mov	 eax, DWORD PTR tv83[ebp]
  000af	89 45 90	 mov	 DWORD PTR _pBuf$3[ebp], eax
$LN5@PyMarshal_:

; 436  : 		if (pBuf != NULL) {

  000b2	83 7d 90 00	 cmp	 DWORD PTR _pBuf$3[ebp], 0
  000b6	74 40		 je	 SHORT $LN3@PyMarshal_

; 437  : 			PyObject* v;
; 438  : 			size_t n = fread(pBuf, 1, filesize, fp);

  000b8	ff b5 a4 3f 00
	00		 push	 DWORD PTR _fp$[ebp]
  000be	ff 75 94	 push	 DWORD PTR _filesize$[ebp]
  000c1	6a 01		 push	 1
  000c3	ff 75 90	 push	 DWORD PTR _pBuf$3[ebp]
  000c6	e8 00 00 00 00	 call	 _fread
  000cb	83 c4 10	 add	 esp, 16			; 00000010H
  000ce	89 45 84	 mov	 DWORD PTR _n$2[ebp], eax

; 439  : 			v = PyMarshal_ReadObjectFromString(pBuf, n);

  000d1	ff 75 84	 push	 DWORD PTR _n$2[ebp]
  000d4	ff 75 90	 push	 DWORD PTR _pBuf$3[ebp]
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyMarshal_ReadObjectFromString
  000dd	59		 pop	 ecx
  000de	59		 pop	 ecx
  000df	89 45 80	 mov	 DWORD PTR _v$1[ebp], eax

; 440  : 			if (pBuf != buf)

  000e2	8d 45 98	 lea	 eax, DWORD PTR _buf$4[ebp]
  000e5	39 45 90	 cmp	 DWORD PTR _pBuf$3[ebp], eax
  000e8	74 09		 je	 SHORT $LN8@PyMarshal_

; 441  : 				PyMem_FREE(pBuf);

  000ea	ff 75 90	 push	 DWORD PTR _pBuf$3[ebp]
  000ed	e8 00 00 00 00	 call	 _free
  000f2	59		 pop	 ecx
$LN8@PyMarshal_:

; 442  : 			return v;

  000f3	8b 45 80	 mov	 eax, DWORD PTR _v$1[ebp]
  000f6	eb 0c		 jmp	 SHORT $LN1@PyMarshal_
$LN3@PyMarshal_:

; 443  : 		}
; 444  : 
; 445  : 	}
; 446  : 
; 447  : 	/* We don't have fstat, or we do but the file is larger than
; 448  : 	 * REASONABLE_FILE_LIMIT or malloc failed -- read a byte at a time.
; 449  : 	 */
; 450  : 	return _PyMarshal_ReadObjectFromFile(fp);

  000f8	ff b5 a4 3f 00
	00		 push	 DWORD PTR _fp$[ebp]
  000fe	e8 00 00 00 00	 call	 ?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadObjectFromFile
  00103	59		 pop	 ecx
$LN1@PyMarshal_:

; 451  : #undef SMALL_FILE_LIMIT
; 452  : #undef REASONABLE_FILE_LIMIT
; 453  : }

  00104	8b 8d 98 3f 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	33 cd		 xor	 ecx, ebp
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	81 c5 9c 3f 00
	00		 add	 ebp, 16284		; 00003f9cH
  00117	c9		 leave
  00118	c3		 ret	 0
?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ENDP ; _PyMarshal_ReadLastObjectFromFile
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_fp$ = 8						; size = 4
?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z PROC ; _PyMarshal_ReadObjectFromFile, COMDAT

; 456  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 457  : 	RFILE rf;
; 458  : 	if (PyErr_Occurred()) {

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  0000c	85 c0		 test	 eax, eax
  0000e	74 19		 je	 SHORT $LN2@PyMarshal_

; 459  : 		fprintf(stderr, "XXX rd_object called with exception set\n");

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@
  00015	6a 02		 push	 2
  00017	e8 00 00 00 00	 call	 ___acrt_iob_func
  0001c	59		 pop	 ecx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _fprintf
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx

; 460  : 		return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 10		 jmp	 SHORT $LN1@PyMarshal_
$LN2@PyMarshal_:

; 461  : 	}
; 462  : 	rf.fp = fp;

  00029	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  0002c	89 45 e8	 mov	 DWORD PTR _rf$[ebp], eax

; 463  : 	return r_object(&rf);

  0002f	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUWFILE@@@Z ; r_object
  00038	59		 pop	 ecx
$LN1@PyMarshal_:

; 464  : }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ENDP ; _PyMarshal_ReadObjectFromFile
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Result$ = -12						; size = 4
__Format$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Format$[ebp], eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00012	ff 75 fc	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f8	 push	 DWORD PTR __Format$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	ff 70 04	 push	 DWORD PTR [eax+4]
  00025	ff 30		 push	 DWORD PTR [eax]
  00027	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0002c	83 c4 18	 add	 esp, 24			; 00000018H

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0002f	89 45 f4	 mov	 DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

  00032	83 65 fc 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp]

; 842  :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
