; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_nCurTraceN@@3HA				; g_nCurTraceN
_BSS	SEGMENT
?g_nCurTraceN@@3HA DD 01H DUP (?)			; g_nCurTraceN
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??_G?$CSingleton@VCPythonLauncher@@@@UAEPAXI@Z	; CSingleton<CPythonLauncher>::`scalar deleting destructor'
PUBLIC	??0CPythonLauncher@@QAE@XZ			; CPythonLauncher::CPythonLauncher
PUBLIC	??1CPythonLauncher@@UAE@XZ			; CPythonLauncher::~CPythonLauncher
PUBLIC	?Clear@CPythonLauncher@@QAEXXZ			; CPythonLauncher::Clear
PUBLIC	?Create@CPythonLauncher@@QAE_NPBD@Z		; CPythonLauncher::Create
PUBLIC	?SetTraceFunc@CPythonLauncher@@QAEXP6AHPAU_object@@PAU_frame@@H0@Z@Z ; CPythonLauncher::SetTraceFunc
PUBLIC	?RunLine@CPythonLauncher@@QAE_NPBD@Z		; CPythonLauncher::RunLine
PUBLIC	?RunFile@CPythonLauncher@@QAE_NPBD@Z		; CPythonLauncher::RunFile
PUBLIC	?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z ; CPythonLauncher::RunMemoryTextFile
PUBLIC	?RunCompiledFile@CPythonLauncher@@QAE_NPBD@Z	; CPythonLauncher::RunCompiledFile
PUBLIC	?GetError@CPythonLauncher@@QAEPBDXZ		; CPythonLauncher::GetError
PUBLIC	??_GCPythonLauncher@@UAEPAXI@Z			; CPythonLauncher::`scalar deleting destructor'
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?Traceback@@YAXXZ				; Traceback
PUBLIC	?TraceFunc@@YAHPAU_object@@PAU_frame@@H0@Z	; TraceFunc
PUBLIC	??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
PUBLIC	??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	?ms_singleton@?$CSingleton@VCPythonLauncher@@@@0PAVCPythonLauncher@@A ; CSingleton<CPythonLauncher>::ms_singleton
PUBLIC	??_7?$CSingleton@VCPythonLauncher@@@@6B@	; CSingleton<CPythonLauncher>::`vftable'
PUBLIC	??_7CPythonLauncher@@6B@			; CPythonLauncher::`vftable'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CSingleton@VCPythonLauncher@@@@6B@	; CSingleton<CPythonLauncher>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CSingleton@VCPythonLauncher@@@@@8	; CSingleton<CPythonLauncher> `RTTI Type Descriptor'
PUBLIC	??_R3?$CSingleton@VCPythonLauncher@@@@8		; CSingleton<CPythonLauncher>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CSingleton@VCPythonLauncher@@@@8		; CSingleton<CPythonLauncher>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCPythonLauncher@@@@8 ; CSingleton<CPythonLauncher>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
PUBLIC	?g_stTraceBuffer@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_stTraceBuffer
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_07KAJBENLI@Error?3?5@			; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0BA@LBJCHJMM@Traceback?3?6?6?$CFs?6@	; `string'
PUBLIC	??_C@_0CA@HECLBDLP@Call?3?5File?5?$CC?$CFs?$CC?0?5line?5?$CFd?0?5in?5?$CFs@ ; `string'
PUBLIC	??_C@_0CF@NOKLAJHH@Exception?3?5File?5?$CC?$CFs?$CC?0?5line?5?$CFd?0?5@ ; `string'
PUBLIC	??_C@_08EMKMIFM@__main__@			; `string'
PUBLIC	??_C@_0M@EILMOIBE@__builtin__@			; `string'
PUBLIC	??_C@_04HCDDPBNL@TRUE@				; `string'
PUBLIC	??_C@_05MAJJAKPI@FALSE@				; `string'
PUBLIC	??_C@_0N@MNFFDJII@__builtins__@			; `string'
PUBLIC	??_C@_0BA@FOEJKCPF@import?5__main__@		; `string'
PUBLIC	??_C@_0L@GOKNMPOF@import?5sys@			; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BO@NCBNDPKB@Bad?5magic?5number?5in?5?4pyc?5file@ ; `string'
PUBLIC	??_C@_0BN@HFJPDIJP@Bad?5code?5object?5in?5?4pyc?5file@ ; `string'
PUBLIC	??_C@_0BB@MNBENCCN@exec?$CIcompile?$CI?8?8?8@	; `string'
PUBLIC	??_C@_05LOEDJEGH@?8?8?8?0?5@			; `string'
PUBLIC	??_C@_01GEODFPGF@?8@				; `string'
PUBLIC	??_C@_03EHINCMEC@?8?0?5@			; `string'
PUBLIC	??_C@_08HAHONCNP@?8exec?8?$CJ?$CJ@		; `string'
PUBLIC	??_R4CPythonLauncher@@6B@			; CPythonLauncher::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPythonLauncher@@@8			; CPythonLauncher `RTTI Type Descriptor'
PUBLIC	??_R3CPythonLauncher@@8				; CPythonLauncher::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPythonLauncher@@8				; CPythonLauncher::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CPythonLauncher@@8		; CPythonLauncher::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_strlen:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Tracef@@YAXPBDZZ:PROC				; Tracef
EXTRN	?LogBoxf@@YAXPBDZZ:PROC				; LogBoxf
EXTRN	__imp__PyString_AsString:PROC
EXTRN	__imp__PyDict_SetItemString:PROC
EXTRN	__imp__PyModule_GetDict:PROC
EXTRN	__imp__PyErr_SetString:PROC
EXTRN	__imp__PyErr_Clear:PROC
EXTRN	__imp__PyErr_Fetch:PROC
EXTRN	__imp__PyModule_AddIntConstant:PROC
EXTRN	__imp__Py_SetProgramName:PROC
EXTRN	__imp__Py_Initialize:PROC
EXTRN	__imp__Py_Finalize:PROC
EXTRN	__imp__PyRun_StringFlags:PROC
EXTRN	__imp__PyEval_SetTrace:PROC
EXTRN	__imp__Py_FlushLine:PROC
EXTRN	__imp__PyImport_GetMagicNumber:PROC
EXTRN	__imp__PyImport_AddModule:PROC
EXTRN	__imp__PyImport_ImportModule:PROC
EXTRN	__imp__PyObject_AsCharBuffer:PROC
EXTRN	__imp__PyCode_Addr2Line:PROC
EXTRN	__imp__PyEval_EvalCode:PROC
EXTRN	?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z:PROC ; PyTuple_GetObject
EXTRN	??_E?$CSingleton@VCPythonLauncher@@@@UAEPAXI@Z:PROC ; CSingleton<CPythonLauncher>::`vector deleting destructor'
EXTRN	??_ECPythonLauncher@@UAEPAXI@Z:PROC		; CPythonLauncher::`vector deleting destructor'
EXTRN	?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z:PROC ; _PyMarshal_ReadLastObjectFromFile
EXTRN	?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z:PROC ; _PyMarshal_ReadLongFromFile
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z:PROC ; CEterPackManager::Get
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp__Py_OptimizeFlag:DWORD
EXTRN	__imp__PyExc_RuntimeError:DWORD
EXTRN	__imp__PyCode_Type:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonLauncher@@@@0PAVCPythonLauncher@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonLauncher@@@@0PAVCPythonLauncher@@A DD 01H DUP (?) ; CSingleton<CPythonLauncher>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A DD 01H DUP (?) ; CSingleton<CEterPackManager>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?g_stTraceBuffer@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 03000H DUP (?) ; g_stTraceBuffer
_BSS	ENDS
CRT$XCU	SEGMENT
?g_stTraceBuffer$initializer$@@3P6AXXZA DD FLAT:??__Eg_stTraceBuffer@@YAXXZ ; g_stTraceBuffer$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CPythonLauncher@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPythonLauncher@@8 DD FLAT:??_R0?AVCPythonLauncher@@@8 ; CPythonLauncher::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPythonLauncher@@8
rdata$r	ENDS
;	COMDAT ??_R2CPythonLauncher@@8
rdata$r	SEGMENT
??_R2CPythonLauncher@@8 DD FLAT:??_R1A@?0A@EA@CPythonLauncher@@8 ; CPythonLauncher::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VCPythonLauncher@@@@8
rdata$r	ENDS
;	COMDAT ??_R3CPythonLauncher@@8
rdata$r	SEGMENT
??_R3CPythonLauncher@@8 DD 00H				; CPythonLauncher::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CPythonLauncher@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPythonLauncher@@@8
data$rs	SEGMENT
??_R0?AVCPythonLauncher@@@8 DD FLAT:??_7type_info@@6B@	; CPythonLauncher `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPythonLauncher@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CPythonLauncher@@6B@
rdata$r	SEGMENT
??_R4CPythonLauncher@@6B@ DD 00H			; CPythonLauncher::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPythonLauncher@@@8
	DD	FLAT:??_R3CPythonLauncher@@8
rdata$r	ENDS
;	COMDAT ??_C@_08HAHONCNP@?8exec?8?$CJ?$CJ@
CONST	SEGMENT
??_C@_08HAHONCNP@?8exec?8?$CJ?$CJ@ DB '''exec''))', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03EHINCMEC@?8?0?5@
CONST	SEGMENT
??_C@_03EHINCMEC@?8?0?5@ DB ''', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8@
CONST	SEGMENT
??_C@_01GEODFPGF@?8@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LOEDJEGH@?8?8?8?0?5@
CONST	SEGMENT
??_C@_05LOEDJEGH@?8?8?8?0?5@ DB ''''''', ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MNBENCCN@exec?$CIcompile?$CI?8?8?8@
CONST	SEGMENT
??_C@_0BB@MNBENCCN@exec?$CIcompile?$CI?8?8?8@ DB 'exec(compile(''''''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HFJPDIJP@Bad?5code?5object?5in?5?4pyc?5file@
CONST	SEGMENT
??_C@_0BN@HFJPDIJP@Bad?5code?5object?5in?5?4pyc?5file@ DB 'Bad code objec'
	DB	't in .pyc file', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NCBNDPKB@Bad?5magic?5number?5in?5?4pyc?5file@
CONST	SEGMENT
??_C@_0BO@NCBNDPKB@Bad?5magic?5number?5in?5?4pyc?5file@ DB 'Bad magic num'
	DB	'ber in .pyc file', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GOKNMPOF@import?5sys@
CONST	SEGMENT
??_C@_0L@GOKNMPOF@import?5sys@ DB 'import sys', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOEJKCPF@import?5__main__@
CONST	SEGMENT
??_C@_0BA@FOEJKCPF@import?5__main__@ DB 'import __main__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MNFFDJII@__builtins__@
CONST	SEGMENT
??_C@_0N@MNFFDJII@__builtins__@ DB '__builtins__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAJJAKPI@FALSE@
CONST	SEGMENT
??_C@_05MAJJAKPI@FALSE@ DB 'FALSE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HCDDPBNL@TRUE@
CONST	SEGMENT
??_C@_04HCDDPBNL@TRUE@ DB 'TRUE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EILMOIBE@__builtin__@
CONST	SEGMENT
??_C@_0M@EILMOIBE@__builtin__@ DB '__builtin__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMKMIFM@__main__@
CONST	SEGMENT
??_C@_08EMKMIFM@__main__@ DB '__main__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NOKLAJHH@Exception?3?5File?5?$CC?$CFs?$CC?0?5line?5?$CFd?0?5@
CONST	SEGMENT
??_C@_0CF@NOKLAJHH@Exception?3?5File?5?$CC?$CFs?$CC?0?5line?5?$CFd?0?5@ DB 'E'
	DB	'xception: File "%s", line %d, in %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HECLBDLP@Call?3?5File?5?$CC?$CFs?$CC?0?5line?5?$CFd?0?5in?5?$CFs@
CONST	SEGMENT
??_C@_0CA@HECLBDLP@Call?3?5File?5?$CC?$CFs?$CC?0?5line?5?$CFd?0?5in?5?$CFs@ DB 'C'
	DB	'all: File "%s", line %d, in %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LBJCHJMM@Traceback?3?6?6?$CFs?6@
CONST	SEGMENT
??_C@_0BA@LBJCHJMM@Traceback?3?6?6?$CFs?6@ DB 'Traceback:', 0aH, 0aH, '%s'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KAJBENLI@Error?3?5@
CONST	SEGMENT
??_C@_07KAJBENLI@Error?3?5@ DB 'Error: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCPythonLauncher@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCPythonLauncher@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCPythonLauncher@@@@@8 ; CSingleton<CPythonLauncher>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCPythonLauncher@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCPythonLauncher@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCPythonLauncher@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCPythonLauncher@@@@8 ; CSingleton<CPythonLauncher>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCPythonLauncher@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCPythonLauncher@@@@8 DD 00H		; CSingleton<CPythonLauncher>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCPythonLauncher@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCPythonLauncher@@@@@8
data$rs	SEGMENT
??_R0?AV?$CSingleton@VCPythonLauncher@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CPythonLauncher> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCPythonLauncher@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CSingleton@VCPythonLauncher@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCPythonLauncher@@@@6B@ DD 00H	; CSingleton<CPythonLauncher>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCPythonLauncher@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCPythonLauncher@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7CPythonLauncher@@6B@
CONST	SEGMENT
??_7CPythonLauncher@@6B@ DD FLAT:??_R4CPythonLauncher@@6B@ ; CPythonLauncher::`vftable'
	DD	FLAT:??_ECPythonLauncher@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VCPythonLauncher@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCPythonLauncher@@@@6B@ DD FLAT:??_R4?$CSingleton@VCPythonLauncher@@@@6B@ ; CSingleton<CPythonLauncher>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCPythonLauncher@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Traceback@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Traceback@@YAXXZ$0
__ehfuncinfo$?Traceback@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Traceback@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z$0
__ehfuncinfo$?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RunFile@CPythonLauncher@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RunFile@CPythonLauncher@@QAE_NPBD@Z$0
__ehfuncinfo$?RunFile@CPythonLauncher@@QAE_NPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RunFile@CPythonLauncher@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CPythonLauncher@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z
_TEXT	SEGMENT
__Al$ = -68						; size = 4
$T1 = -64						; size = 4
__Ptr$ = -60						; size = 4
$T2 = -56						; size = 4
__Old_ptr$3 = -52					; size = 4
__Old_capacity$ = -48					; size = 4
__New_capacity$ = -44					; size = 4
__New_size$ = -40					; size = 4
__New_ptr$ = -36					; size = 4
_this$ = -32						; size = 4
__Raw_new$ = -28					; size = 4
__My_data$ = -24					; size = 4
__Old_size$ = -20					; size = 4
__Overflow_is_possible$4 = -14				; size = 1
$T5 = -13						; size = 1
__Ch$ = -12						; size = 1
$T6 = -5						; size = 1
__Ch$ = -4						; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 ec	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 ec	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 ec	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 d8	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 d0	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 d8	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 d4	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 bc	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 f2 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 d4	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 dc	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d d8	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d d4	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 dc	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 c4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 c4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 e4	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d d0 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 59		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 cc	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 cc	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 c0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000ac	8a 45 10	 mov	 al, BYTE PTR _<_Args_0>$[ebp]
  000af	88 45 fc	 mov	 BYTE PTR __Ch$[ebp], al

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b2	ff 75 ec	 push	 DWORD PTR __Old_size$[ebp]
  000b5	ff 75 c0	 push	 DWORD PTR $T1[ebp]
  000b8	ff 75 e4	 push	 DWORD PTR __Raw_new$[ebp]
  000bb	e8 00 00 00 00	 call	 _memcpy
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  :         _Left = _Right;

  000c3	8b 45 e4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c6	03 45 ec	 add	 eax, DWORD PTR __Old_size$[ebp]
  000c9	8a 4d fc	 mov	 cl, BYTE PTR __Ch$[ebp]
  000cc	88 08		 mov	 BYTE PTR [eax], cl

; 3706 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  000ce	c6 45 fb 00	 mov	 BYTE PTR $T6[ebp], 0

; 428  :         _Left = _Right;

  000d2	8b 45 e4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000d5	03 45 ec	 add	 eax, DWORD PTR __Old_size$[ebp]
  000d8	8a 4d fb	 mov	 cl, BYTE PTR $T6[ebp]
  000db	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000de	8b 45 d0	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000e1	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e2	50		 push	 eax
  000e3	ff 75 cc	 push	 DWORD PTR __Old_ptr$3[ebp]
  000e6	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000eb	59		 pop	 ecx
  000ec	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000ed	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000f0	8b 4d dc	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000f3	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  000f5	eb 40		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000f7	8a 45 10	 mov	 al, BYTE PTR _<_Args_0>$[ebp]
  000fa	88 45 f4	 mov	 BYTE PTR __Ch$[ebp], al

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000fd	ff 75 ec	 push	 DWORD PTR __Old_size$[ebp]
  00100	ff 75 e8	 push	 DWORD PTR __My_data$[ebp]
  00103	ff 75 e4	 push	 DWORD PTR __Raw_new$[ebp]
  00106	e8 00 00 00 00	 call	 _memcpy
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  :         _Left = _Right;

  0010e	8b 45 e4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00111	03 45 ec	 add	 eax, DWORD PTR __Old_size$[ebp]
  00114	8a 4d f4	 mov	 cl, BYTE PTR __Ch$[ebp]
  00117	88 08		 mov	 BYTE PTR [eax], cl

; 3706 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00119	c6 45 f3 00	 mov	 BYTE PTR $T5[ebp], 0

; 428  :         _Left = _Right;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00120	03 45 ec	 add	 eax, DWORD PTR __Old_size$[ebp]
  00123	8a 4d f3	 mov	 cl, BYTE PTR $T5[ebp]
  00126	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00129	8d 45 dc	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  0012c	50		 push	 eax
  0012d	ff 75 e8	 push	 DWORD PTR __My_data$[ebp]
  00130	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00135	59		 pop	 ecx
  00136	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  00137	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  0013a	c9		 leave
  0013b	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z
_TEXT	SEGMENT
__Al$ = -56						; size = 4
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T2 = -44						; size = 4
__Raw_new$ = -40					; size = 4
__Old_ptr$3 = -36					; size = 4
__Old_capacity$ = -32					; size = 4
__New_capacity$ = -28					; size = 4
__New_size$ = -24					; size = 4
__New_ptr$ = -20					; size = 4
__Old_size$ = -16					; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f0	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f0	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f0	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 e8	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 e0	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 e8	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 e4	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 c8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 e4	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 ec	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d e8	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d e4	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 ec	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d e0 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 3a		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 dc	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 dc	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3830 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  000ac	8b 45 f0	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000af	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b0	50		 push	 eax
  000b1	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  000b4	ff 75 d8	 push	 DWORD PTR __Raw_new$[ebp]
  000b7	e8 00 00 00 00	 call	 _memcpy
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000bf	8b 45 e0	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000c2	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c3	50		 push	 eax
  000c4	ff 75 dc	 push	 DWORD PTR __Old_ptr$3[ebp]
  000c7	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000cc	59		 pop	 ecx
  000cd	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000ce	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000d1	8b 4d ec	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000d4	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  000d6	eb 21		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3830 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  000d8	8b 45 f0	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000db	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000dc	50		 push	 eax
  000dd	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  000e0	ff 75 d8	 push	 DWORD PTR __Raw_new$[ebp]
  000e3	e8 00 00 00 00	 call	 _memcpy
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000eb	8d 45 ec	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000ee	50		 push	 eax
  000ef	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  000f2	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000f7	59		 pop	 ecx
  000f8	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  000fc	c9		 leave
  000fd	c2 08 00	 ret	 8
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ?TraceFunc@@YAHPAU_object@@PAU_frame@@H0@Z
_TEXT	SEGMENT
_exc_str$1 = -80					; size = 4
_len$2 = -76						; size = 4
_exc_traceback$3 = -72					; size = 4
_exc_value$4 = -68					; size = 4
$T5 = -64						; size = 4
$T6 = -60						; size = 4
$T7 = -56						; size = 4
_exc_type$8 = -52					; size = 4
$T9 = -48						; size = 4
$T10 = -44						; size = 4
$T11 = -40						; size = 4
_funcname$ = -36					; size = 4
tv64 = -32						; size = 4
_szTraceBuffer$ = -28					; size = 128
__$ArrayPad$ = 100					; size = 4
_obj$ = 112						; size = 4
_f$ = 116						; size = 4
_what$ = 120						; size = 4
_arg$ = 124						; size = 4
?TraceFunc@@YAHPAU_object@@PAU_frame@@H0@Z PROC		; TraceFunc, COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 98	 lea	 ebp, DWORD PTR [esp-104]
  00005	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 64	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 58   : 	const char * funcname;
; 59   : 	char szTraceBuffer[128];
; 60   : 
; 61   : 	switch (what)

  00015	8b 45 78	 mov	 eax, DWORD PTR _what$[ebp]
  00018	89 45 e0	 mov	 DWORD PTR tv64[ebp], eax
  0001b	83 7d e0 00	 cmp	 DWORD PTR tv64[ebp], 0
  0001f	74 19		 je	 SHORT $LN4@TraceFunc
  00021	83 7d e0 01	 cmp	 DWORD PTR tv64[ebp], 1
  00025	0f 84 e3 00 00
	00		 je	 $LN9@TraceFunc
  0002b	83 7d e0 03	 cmp	 DWORD PTR tv64[ebp], 3
  0002f	0f 84 c0 00 00
	00		 je	 $LN7@TraceFunc
  00035	e9 a0 01 00 00	 jmp	 $LN2@TraceFunc
$LN4@TraceFunc:

; 62   : 	{
; 63   : 		case PyTrace_CALL:
; 64   : 			if (g_nCurTraceN >= 512)

  0003a	81 3d 00 00 00
	00 00 02 00 00	 cmp	 DWORD PTR ?g_nCurTraceN@@3HA, 512 ; g_nCurTraceN, 00000200H
  00044	7c 07		 jl	 SHORT $LN5@TraceFunc

; 65   : 				return 0;

  00046	33 c0		 xor	 eax, eax
  00048	e9 8f 01 00 00	 jmp	 $LN1@TraceFunc
$LN5@TraceFunc:

; 66   : 
; 67   : 			if (Py_OptimizeFlag)

  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__Py_OptimizeFlag
  00052	83 38 00	 cmp	 DWORD PTR [eax], 0
  00055	74 1a		 je	 SHORT $LN6@TraceFunc

; 68   : 				f->f_lineno = PyCode_Addr2Line(f->f_code, f->f_lasti);

  00057	8b 45 74	 mov	 eax, DWORD PTR _f$[ebp]
  0005a	ff 70 3c	 push	 DWORD PTR [eax+60]
  0005d	8b 45 74	 mov	 eax, DWORD PTR _f$[ebp]
  00060	ff 70 10	 push	 DWORD PTR [eax+16]
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyCode_Addr2Line
  00069	59		 pop	 ecx
  0006a	59		 pop	 ecx
  0006b	8b 4d 74	 mov	 ecx, DWORD PTR _f$[ebp]
  0006e	89 41 40	 mov	 DWORD PTR [ecx+64], eax
$LN6@TraceFunc:

; 69   : 
; 70   : 			funcname = PyString_AsString(f->f_code->co_name);

  00071	8b 45 74	 mov	 eax, DWORD PTR _f$[ebp]
  00074	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00077	ff 70 34	 push	 DWORD PTR [eax+52]
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyString_AsString
  00080	59		 pop	 ecx
  00081	89 45 dc	 mov	 DWORD PTR _funcname$[ebp], eax

; 71   : 
; 72   : 			_snprintf(szTraceBuffer, sizeof(szTraceBuffer), "Call: File \"%s\", line %d, in %s", 

  00084	ff 75 dc	 push	 DWORD PTR _funcname$[ebp]
  00087	8b 45 74	 mov	 eax, DWORD PTR _f$[ebp]
  0008a	ff 70 40	 push	 DWORD PTR [eax+64]
  0008d	8b 45 74	 mov	 eax, DWORD PTR _f$[ebp]
  00090	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00093	ff 70 30	 push	 DWORD PTR [eax+48]
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyString_AsString
  0009c	59		 pop	 ecx
  0009d	50		 push	 eax
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HECLBDLP@Call?3?5File?5?$CC?$CFs?$CC?0?5line?5?$CFd?0?5in?5?$CFs@
  000a3	68 80 00 00 00	 push	 128			; 00000080H
  000a8	8d 45 e4	 lea	 eax, DWORD PTR _szTraceBuffer$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 __snprintf
  000b1	83 c4 18	 add	 esp, 24			; 00000018H

; 73   : 					  PyString_AsString(f->f_code->co_filename), 
; 74   : 					  f->f_lineno,
; 75   : 					  funcname);
; 76   : 
; 77   : 			g_stTraceBuffer[g_nCurTraceN++]=szTraceBuffer;			

  000b4	6b 05 00 00 00
	00 18		 imul	 eax, DWORD PTR ?g_nCurTraceN@@3HA, 24 ; g_nCurTraceN
  000bb	05 00 00 00 00	 add	 eax, OFFSET ?g_stTraceBuffer@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_stTraceBuffer
  000c0	89 45 d0	 mov	 DWORD PTR $T9[ebp], eax
  000c3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_nCurTraceN@@3HA ; g_nCurTraceN
  000c8	40		 inc	 eax
  000c9	a3 00 00 00 00	 mov	 DWORD PTR ?g_nCurTraceN@@3HA, eax ; g_nCurTraceN
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000ce	8d 45 e4	 lea	 eax, DWORD PTR _szTraceBuffer$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 _strlen
  000d7	59		 pop	 ecx
  000d8	89 45 d8	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000db	8b 45 d8	 mov	 eax, DWORD PTR $T11[ebp]
  000de	89 45 d4	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000e1	ff 75 d4	 push	 DWORD PTR $T10[ebp]
  000e4	8d 45 e4	 lea	 eax, DWORD PTR _szTraceBuffer$[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d d0	 mov	 ecx, DWORD PTR $T9[ebp]
  000eb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 78   : 			break;

  000f0	e9 e5 00 00 00	 jmp	 $LN2@TraceFunc
$LN7@TraceFunc:

; 79   : 
; 80   : 		case PyTrace_RETURN:
; 81   : 			if (g_nCurTraceN > 0)

  000f5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_nCurTraceN@@3HA, 0 ; g_nCurTraceN
  000fc	7e 0b		 jle	 SHORT $LN8@TraceFunc

; 82   : 				--g_nCurTraceN;

  000fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_nCurTraceN@@3HA ; g_nCurTraceN
  00103	48		 dec	 eax
  00104	a3 00 00 00 00	 mov	 DWORD PTR ?g_nCurTraceN@@3HA, eax ; g_nCurTraceN
$LN8@TraceFunc:

; 83   : 			break;

  00109	e9 cc 00 00 00	 jmp	 $LN2@TraceFunc
$LN9@TraceFunc:

; 84   : 
; 85   : 		case PyTrace_EXCEPTION:
; 86   : 			if (g_nCurTraceN >= 512)

  0010e	81 3d 00 00 00
	00 00 02 00 00	 cmp	 DWORD PTR ?g_nCurTraceN@@3HA, 512 ; g_nCurTraceN, 00000200H
  00118	7c 07		 jl	 SHORT $LN10@TraceFunc

; 87   : 				return 0;

  0011a	33 c0		 xor	 eax, eax
  0011c	e9 bb 00 00 00	 jmp	 $LN1@TraceFunc
$LN10@TraceFunc:

; 88   : 			
; 89   : 			PyObject * exc_type, * exc_value, * exc_traceback;
; 90   : 
; 91   : 			PyTuple_GetObject(arg, 0, &exc_type);

  00121	8d 45 cc	 lea	 eax, DWORD PTR _exc_type$8[ebp]
  00124	50		 push	 eax
  00125	6a 00		 push	 0
  00127	ff 75 7c	 push	 DWORD PTR _arg$[ebp]
  0012a	e8 00 00 00 00	 call	 ?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z ; PyTuple_GetObject
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 92   : 			PyTuple_GetObject(arg, 1, &exc_value);

  00132	8d 45 bc	 lea	 eax, DWORD PTR _exc_value$4[ebp]
  00135	50		 push	 eax
  00136	6a 01		 push	 1
  00138	ff 75 7c	 push	 DWORD PTR _arg$[ebp]
  0013b	e8 00 00 00 00	 call	 ?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z ; PyTuple_GetObject
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH

; 93   : 			PyTuple_GetObject(arg, 2, &exc_traceback);

  00143	8d 45 b8	 lea	 eax, DWORD PTR _exc_traceback$3[ebp]
  00146	50		 push	 eax
  00147	6a 02		 push	 2
  00149	ff 75 7c	 push	 DWORD PTR _arg$[ebp]
  0014c	e8 00 00 00 00	 call	 ?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z ; PyTuple_GetObject
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH

; 94   : 
; 95   : 			int len;
; 96   : 			const char * exc_str;
; 97   : 			PyObject_AsCharBuffer(exc_type, &exc_str, &len);

  00154	8d 45 b4	 lea	 eax, DWORD PTR _len$2[ebp]
  00157	50		 push	 eax
  00158	8d 45 b0	 lea	 eax, DWORD PTR _exc_str$1[ebp]
  0015b	50		 push	 eax
  0015c	ff 75 cc	 push	 DWORD PTR _exc_type$8[ebp]
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyObject_AsCharBuffer
  00165	83 c4 0c	 add	 esp, 12			; 0000000cH

; 98   : 			
; 99   : 			_snprintf(szTraceBuffer, sizeof(szTraceBuffer), "Exception: File \"%s\", line %d, in %s", 

  00168	8b 45 74	 mov	 eax, DWORD PTR _f$[ebp]
  0016b	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0016e	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00171	83 c0 14	 add	 eax, 20			; 00000014H
  00174	50		 push	 eax
  00175	8b 45 74	 mov	 eax, DWORD PTR _f$[ebp]
  00178	ff 70 40	 push	 DWORD PTR [eax+64]
  0017b	8b 45 74	 mov	 eax, DWORD PTR _f$[ebp]
  0017e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00181	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  00184	83 c0 14	 add	 eax, 20			; 00000014H
  00187	50		 push	 eax
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@NOKLAJHH@Exception?3?5File?5?$CC?$CFs?$CC?0?5line?5?$CFd?0?5@
  0018d	68 80 00 00 00	 push	 128			; 00000080H
  00192	8d 45 e4	 lea	 eax, DWORD PTR _szTraceBuffer$[ebp]
  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 __snprintf
  0019b	83 c4 18	 add	 esp, 24			; 00000018H

; 100  : 					  PyString_AS_STRING(f->f_code->co_filename), 
; 101  : 					  f->f_lineno,
; 102  : 					  PyString_AS_STRING(f->f_code->co_name));
; 103  : 
; 104  : 			g_stTraceBuffer[g_nCurTraceN++]=szTraceBuffer;

  0019e	6b 05 00 00 00
	00 18		 imul	 eax, DWORD PTR ?g_nCurTraceN@@3HA, 24 ; g_nCurTraceN
  001a5	05 00 00 00 00	 add	 eax, OFFSET ?g_stTraceBuffer@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_stTraceBuffer
  001aa	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax
  001ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_nCurTraceN@@3HA ; g_nCurTraceN
  001b2	40		 inc	 eax
  001b3	a3 00 00 00 00	 mov	 DWORD PTR ?g_nCurTraceN@@3HA, eax ; g_nCurTraceN
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  001b8	8d 45 e4	 lea	 eax, DWORD PTR _szTraceBuffer$[ebp]
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 _strlen
  001c1	59		 pop	 ecx
  001c2	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  001c5	8b 45 c8	 mov	 eax, DWORD PTR $T7[ebp]
  001c8	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  001cb	ff 75 c4	 push	 DWORD PTR $T6[ebp]
  001ce	8d 45 e4	 lea	 eax, DWORD PTR _szTraceBuffer$[ebp]
  001d1	50		 push	 eax
  001d2	8b 4d c0	 mov	 ecx, DWORD PTR $T5[ebp]
  001d5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@TraceFunc:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 108  : 	return 0;

  001da	33 c0		 xor	 eax, eax
$LN1@TraceFunc:

; 109  : }

  001dc	8b 4d 64	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001df	33 cd		 xor	 ecx, ebp
  001e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e6	83 c5 68	 add	 ebp, 104		; 00000068H
  001e9	c9		 leave
  001ea	c3		 ret	 0
?TraceFunc@@YAHPAU_object@@PAU_frame@@H0@Z ENDP		; TraceFunc
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ?Traceback@@YAXXZ
_TEXT	SEGMENT
$T2 = -100						; size = 4
$T3 = -96						; size = 4
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
$T7 = -80						; size = 4
_this$ = -76						; size = 4
tv139 = -72						; size = 4
tv131 = -68						; size = 4
tv91 = -64						; size = 4
_errStr$ = -60						; size = 4
_tb$ = -56						; size = 4
_exc$ = -52						; size = 4
_i$8 = -48						; size = 4
_v$ = -44						; size = 4
_str$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Traceback@@YAXXZ PROC					; Traceback, COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Traceback@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00028	8d 45 d8	 lea	 eax, DWORD PTR _str$[ebp]
  0002b	89 45 b4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  00036	8d 4d d8	 lea	 ecx, DWORD PTR _str$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 27   : 	std::string str;

  0003e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 28   : 
; 29   : 	for (int i = 0; i < g_nCurTraceN; ++i)

  00042	83 65 d0 00	 and	 DWORD PTR _i$8[ebp], 0
  00046	eb 07		 jmp	 SHORT $LN4@Traceback
$LN2@Traceback:
  00048	8b 45 d0	 mov	 eax, DWORD PTR _i$8[ebp]
  0004b	40		 inc	 eax
  0004c	89 45 d0	 mov	 DWORD PTR _i$8[ebp], eax
$LN4@Traceback:
  0004f	8b 45 d0	 mov	 eax, DWORD PTR _i$8[ebp]
  00052	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_nCurTraceN@@3HA ; g_nCurTraceN
  00058	7d 38		 jge	 SHORT $LN3@Traceback

; 30   : 	{
; 31   : 		str.append(g_stTraceBuffer[i]);

  0005a	6b 45 d0 18	 imul	 eax, DWORD PTR _i$8[ebp], 24
  0005e	05 00 00 00 00	 add	 eax, OFFSET ?g_stTraceBuffer@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_stTraceBuffer
  00063	50		 push	 eax
  00064	8d 4d d8	 lea	 ecx, DWORD PTR _str$[ebp]
  00067	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00071	e8 00 00 00 00	 call	 _strlen
  00076	59		 pop	 ecx
  00077	89 45 b0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0007a	8b 45 b0	 mov	 eax, DWORD PTR $T7[ebp]
  0007d	89 45 ac	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00080	ff 75 ac	 push	 DWORD PTR $T6[ebp]
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00088	8d 4d d8	 lea	 ecx, DWORD PTR _str$[ebp]
  0008b	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 33   : 	}

  00090	eb b6		 jmp	 SHORT $LN2@Traceback
$LN3@Traceback:

; 34   : 	
; 35   : 	PyObject * exc;
; 36   : 	PyObject * v;
; 37   : 	PyObject * tb;
; 38   : 	const char * errStr;
; 39   : 
; 40   : 	PyErr_Fetch(&exc, &v, &tb);

  00092	8d 45 c8	 lea	 eax, DWORD PTR _tb$[ebp]
  00095	50		 push	 eax
  00096	8d 45 d4	 lea	 eax, DWORD PTR _v$[ebp]
  00099	50		 push	 eax
  0009a	8d 45 cc	 lea	 eax, DWORD PTR _exc$[ebp]
  0009d	50		 push	 eax
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Fetch
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 41   : 
; 42   : 	if (PyString_Check(v))

  000a7	8b 45 d4	 mov	 eax, DWORD PTR _v$[ebp]
  000aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ad	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  000b0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000b5	74 5c		 je	 SHORT $LN7@Traceback

; 43   : 	{
; 44   : 		errStr = PyString_AS_STRING(v);

  000b7	8b 45 d4	 mov	 eax, DWORD PTR _v$[ebp]
  000ba	83 c0 14	 add	 eax, 20			; 00000014H
  000bd	89 45 c4	 mov	 DWORD PTR _errStr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_07KAJBENLI@Error?3?5@
  000c5	e8 00 00 00 00	 call	 _strlen
  000ca	59		 pop	 ecx
  000cb	89 45 a8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000ce	8b 45 a8	 mov	 eax, DWORD PTR $T5[ebp]
  000d1	89 45 a4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000d4	ff 75 a4	 push	 DWORD PTR $T4[ebp]
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_07KAJBENLI@Error?3?5@
  000dc	8d 4d d8	 lea	 ecx, DWORD PTR _str$[ebp]
  000df	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000e4	ff 75 c4	 push	 DWORD PTR _errStr$[ebp]
  000e7	e8 00 00 00 00	 call	 _strlen
  000ec	59		 pop	 ecx
  000ed	89 45 a0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000f0	8b 45 a0	 mov	 eax, DWORD PTR $T3[ebp]
  000f3	89 45 9c	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000f6	ff 75 9c	 push	 DWORD PTR $T2[ebp]
  000f9	ff 75 c4	 push	 DWORD PTR _errStr$[ebp]
  000fc	8d 4d d8	 lea	 ecx, DWORD PTR _str$[ebp]
  000ff	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 48   : 		Tracef("%s\n", errStr);

  00104	ff 75 c4	 push	 DWORD PTR _errStr$[ebp]
  00107	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
  0010c	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00111	59		 pop	 ecx
  00112	59		 pop	 ecx
$LN7@Traceback:

; 49   : 	}
; 50   : 	Py_DECREF(exc);

  00113	8b 45 cc	 mov	 eax, DWORD PTR _exc$[ebp]
  00116	8b 00		 mov	 eax, DWORD PTR [eax]
  00118	48		 dec	 eax
  00119	89 45 c0	 mov	 DWORD PTR tv91[ebp], eax
  0011c	8b 45 cc	 mov	 eax, DWORD PTR _exc$[ebp]
  0011f	8b 4d c0	 mov	 ecx, DWORD PTR tv91[ebp]
  00122	89 08		 mov	 DWORD PTR [eax], ecx
  00124	83 7d c0 00	 cmp	 DWORD PTR tv91[ebp], 0
  00128	74 02		 je	 SHORT $LN15@Traceback
  0012a	eb 0d		 jmp	 SHORT $LN5@Traceback
$LN15@Traceback:
  0012c	ff 75 cc	 push	 DWORD PTR _exc$[ebp]
  0012f	8b 45 cc	 mov	 eax, DWORD PTR _exc$[ebp]
  00132	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00135	ff 50 18	 call	 DWORD PTR [eax+24]
  00138	59		 pop	 ecx
$LN5@Traceback:
  00139	33 c0		 xor	 eax, eax
  0013b	75 d6		 jne	 SHORT $LN7@Traceback
$LN10@Traceback:

; 51   : 	Py_DECREF(v);

  0013d	8b 45 d4	 mov	 eax, DWORD PTR _v$[ebp]
  00140	8b 00		 mov	 eax, DWORD PTR [eax]
  00142	48		 dec	 eax
  00143	89 45 bc	 mov	 DWORD PTR tv131[ebp], eax
  00146	8b 45 d4	 mov	 eax, DWORD PTR _v$[ebp]
  00149	8b 4d bc	 mov	 ecx, DWORD PTR tv131[ebp]
  0014c	89 08		 mov	 DWORD PTR [eax], ecx
  0014e	83 7d bc 00	 cmp	 DWORD PTR tv131[ebp], 0
  00152	74 02		 je	 SHORT $LN17@Traceback
  00154	eb 0d		 jmp	 SHORT $LN8@Traceback
$LN17@Traceback:
  00156	ff 75 d4	 push	 DWORD PTR _v$[ebp]
  00159	8b 45 d4	 mov	 eax, DWORD PTR _v$[ebp]
  0015c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0015f	ff 50 18	 call	 DWORD PTR [eax+24]
  00162	59		 pop	 ecx
$LN8@Traceback:
  00163	33 c0		 xor	 eax, eax
  00165	75 d6		 jne	 SHORT $LN10@Traceback
$LN13@Traceback:

; 52   : 	Py_DECREF(tb);

  00167	8b 45 c8	 mov	 eax, DWORD PTR _tb$[ebp]
  0016a	8b 00		 mov	 eax, DWORD PTR [eax]
  0016c	48		 dec	 eax
  0016d	89 45 b8	 mov	 DWORD PTR tv139[ebp], eax
  00170	8b 45 c8	 mov	 eax, DWORD PTR _tb$[ebp]
  00173	8b 4d b8	 mov	 ecx, DWORD PTR tv139[ebp]
  00176	89 08		 mov	 DWORD PTR [eax], ecx
  00178	83 7d b8 00	 cmp	 DWORD PTR tv139[ebp], 0
  0017c	74 02		 je	 SHORT $LN19@Traceback
  0017e	eb 0d		 jmp	 SHORT $LN11@Traceback
$LN19@Traceback:
  00180	ff 75 c8	 push	 DWORD PTR _tb$[ebp]
  00183	8b 45 c8	 mov	 eax, DWORD PTR _tb$[ebp]
  00186	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00189	ff 50 18	 call	 DWORD PTR [eax+24]
  0018c	59		 pop	 ecx
$LN11@Traceback:
  0018d	33 c0		 xor	 eax, eax
  0018f	75 d6		 jne	 SHORT $LN13@Traceback

; 53   : 	LogBoxf("Traceback:\n\n%s\n", str.c_str());

  00191	8d 4d d8	 lea	 ecx, DWORD PTR _str$[ebp]
  00194	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00199	50		 push	 eax
  0019a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LBJCHJMM@Traceback?3?6?6?$CFs?6@
  0019f	e8 00 00 00 00	 call	 ?LogBoxf@@YAXPBDZZ	; LogBoxf
  001a4	59		 pop	 ecx
  001a5	59		 pop	 ecx

; 54   : }

  001a6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  001aa	8d 4d d8	 lea	 ecx, DWORD PTR _str$[ebp]
  001ad	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 54   : }

  001b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bc	59		 pop	 ecx
  001bd	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c0	33 cd		 xor	 ecx, ebp
  001c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c7	c9		 leave
  001c8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Traceback@@YAXXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _str$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?Traceback@@YAXXZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Traceback@@YAXXZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Traceback@@YAXXZ ENDP					; Traceback
; Function compile flags: /Odspy
;	COMDAT ??__Fg_stTraceBuffer@@YAXXZ
text$yd	SEGMENT
??__Fg_stTraceBuffer@@YAXXZ PROC			; `dynamic atexit destructor for 'g_stTraceBuffer'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	68 00 02 00 00	 push	 512			; 00000200H
  0000d	6a 18		 push	 24			; 00000018H
  0000f	68 00 00 00 00	 push	 OFFSET ?g_stTraceBuffer@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_stTraceBuffer
  00014	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??__Fg_stTraceBuffer@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_stTraceBuffer''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ??__Eg_stTraceBuffer@@YAXXZ
text$di	SEGMENT
??__Eg_stTraceBuffer@@YAXXZ PROC			; `dynamic initializer for 'g_stTraceBuffer'', COMDAT

; 22   : std::string g_stTraceBuffer[512];

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	68 00 00 00 00	 push	 OFFSET ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0000d	68 00 02 00 00	 push	 512			; 00000200H
  00012	6a 18		 push	 24			; 00000018H
  00014	68 00 00 00 00	 push	 OFFSET ?g_stTraceBuffer@@3PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_stTraceBuffer
  00019	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  0001e	68 00 00 00 00	 push	 OFFSET ??__Fg_stTraceBuffer@@YAXXZ ; `dynamic atexit destructor for 'g_stTraceBuffer''
  00023	e8 00 00 00 00	 call	 _atexit
  00028	59		 pop	 ecx
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??__Eg_stTraceBuffer@@YAXXZ ENDP			; `dynamic initializer for 'g_stTraceBuffer''
text$di	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Al$ = -64						; size = 4
__First1$ = -60						; size = 4
__First1$ = -56						; size = 4
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T2 = -44						; size = 4
__Old_ptr$3 = -40					; size = 4
__Old_capacity$ = -36					; size = 4
__New_capacity$ = -32					; size = 4
__New_size$ = -28					; size = 4
__New_ptr$ = -24					; size = 4
_this$ = -20						; size = 4
__Raw_new$ = -16					; size = 4
__My_data$ = -12					; size = 4
__Old_size$ = -8					; size = 4
__Overflow_is_possible$4 = -3				; size = 1
$T5 = -2						; size = 1
$T6 = -1						; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 e4	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 dc	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 e4	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 e0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 c0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 fd 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 e0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 e8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d e4	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 e8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d dc 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 65		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 d8	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 d8	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ac	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  000af	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  000b2	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  000bd	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c0	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c6	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000c9	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000cc	ff 75 c8	 push	 DWORD PTR __First1$[ebp]
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000d7	c6 45 ff 00	 mov	 BYTE PTR $T6[ebp], 0
  000db	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000de	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  000e1	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000e4	8a 55 ff	 mov	 dl, BYTE PTR $T6[ebp]
  000e7	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ea	8b 45 dc	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000ed	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ee	50		 push	 eax
  000ef	ff 75 d8	 push	 DWORD PTR __Old_ptr$3[ebp]
  000f2	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000f7	59		 pop	 ecx
  000f8	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000fc	8b 4d e8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000ff	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  00101	eb 4c		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00103	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  00106	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00109	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  0010c	e8 00 00 00 00	 call	 _memcpy
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00114	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00117	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  0011a	89 45 c4	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00120	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00123	ff 75 c4	 push	 DWORD PTR __First1$[ebp]
  00126	e8 00 00 00 00	 call	 _memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0012e	c6 45 fe 00	 mov	 BYTE PTR $T5[ebp], 0
  00132	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00135	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  00138	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  0013b	8a 55 fe	 mov	 dl, BYTE PTR $T5[ebp]
  0013e	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00141	8d 45 e8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00144	50		 push	 eax
  00145	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00148	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0014d	59		 pop	 ecx
  0014e	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  0014f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  00152	c9		 leave
  00153	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCPythonLauncher@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCPythonLauncher@@UAEPAXI@Z PROC			; CPythonLauncher::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CPythonLauncher@@UAE@XZ ; CPythonLauncher::~CPythonLauncher
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GCPythonLauncher@@UAEPAXI@Z ENDP			; CPythonLauncher::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ?GetError@CPythonLauncher@@QAEPBDXZ
_TEXT	SEGMENT
_exc$ = -16						; size = 4
_tb$ = -12						; size = 4
_this$ = -8						; size = 4
_v$ = -4						; size = 4
?GetError@CPythonLauncher@@QAEPBDXZ PROC		; CPythonLauncher::GetError, COMDAT
; _this$ = ecx

; 271  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 272  : 	PyObject* exc;
; 273  : 	PyObject* v;
; 274  : 	PyObject* tb;
; 275  : 
; 276  : 	PyErr_Fetch(&exc, &v, &tb);        

  00009	8d 45 f4	 lea	 eax, DWORD PTR _tb$[ebp]
  0000c	50		 push	 eax
  0000d	8d 45 fc	 lea	 eax, DWORD PTR _v$[ebp]
  00010	50		 push	 eax
  00011	8d 45 f0	 lea	 eax, DWORD PTR _exc$[ebp]
  00014	50		 push	 eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Fetch
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 277  : 
; 278  : 	if (PyString_Check(v))

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  00027	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0002c	74 08		 je	 SHORT $LN2@GetError

; 279  : 		return PyString_AS_STRING(v);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00031	83 c0 14	 add	 eax, 20			; 00000014H
  00034	eb 05		 jmp	 SHORT $LN1@GetError
$LN2@GetError:

; 280  : 	
; 281  : 	return "";

  00036	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@@
$LN1@GetError:

; 282  : }

  0003b	c9		 leave
  0003c	c3		 ret	 0
?GetError@CPythonLauncher@@QAEPBDXZ ENDP		; CPythonLauncher::GetError
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ?RunCompiledFile@CPythonLauncher@@QAE_NPBD@Z
_TEXT	SEGMENT
_magic$ = -32						; size = 4
tv143 = -28						; size = 4
tv134 = -24						; size = 4
_this$ = -20						; size = 4
tv85 = -16						; size = 4
_co$ = -12						; size = 4
_fp$ = -8						; size = 4
_v$ = -4						; size = 4
_c_szFileName$ = 8					; size = 4
?RunCompiledFile@CPythonLauncher@@QAE_NPBD@Z PROC	; CPythonLauncher::RunCompiledFile, COMDAT
; _this$ = ecx

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 148  : 	NANOBEGIN

  0000c	eb		 DB	 -21			; ffffffebH
  0000d	03		 DB	 3
  0000e	d6		 DB	 -42			; ffffffd6H
  0000f	d7		 DB	 -41			; ffffffd7H
  00010	01		 DB	 1
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00016	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00019	e8 00 00 00 00	 call	 _fopen
  0001e	59		 pop	 ecx
  0001f	59		 pop	 ecx
  00020	89 45 f8	 mov	 DWORD PTR _fp$[ebp], eax

; 149  : 	FILE * fp = fopen(c_szFileName, "rb");
; 150  : 
; 151  : 	if (!fp)

  00023	83 7d f8 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00027	75 07		 jne	 SHORT $LN14@RunCompile

; 152  : 		return false;

  00029	32 c0		 xor	 al, al
  0002b	e9 59 01 00 00	 jmp	 $LN1@RunCompile
$LN14@RunCompile:

; 153  : 
; 154  : 	PyCodeObject *co;
; 155  : 	PyObject *v;
; 156  : 	long magic;
; 157  : 	long PyImport_GetMagicNumber(void);
; 158  : 
; 159  : 	magic = _PyMarshal_ReadLongFromFile(fp);

  00030	ff 75 f8	 push	 DWORD PTR _fp$[ebp]
  00033	e8 00 00 00 00	 call	 ?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z ; _PyMarshal_ReadLongFromFile
  00038	59		 pop	 ecx
  00039	89 45 e0	 mov	 DWORD PTR _magic$[ebp], eax

; 160  : 
; 161  : 	if (magic != PyImport_GetMagicNumber())

  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyImport_GetMagicNumber
  00042	39 45 e0	 cmp	 DWORD PTR _magic$[ebp], eax
  00045	74 24		 je	 SHORT $LN15@RunCompile

; 162  : 	{
; 163  : 		PyErr_SetString(PyExc_RuntimeError, "Bad magic number in .pyc file");

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NCBNDPKB@Bad?5magic?5number?5in?5?4pyc?5file@
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  00051	ff 30		 push	 DWORD PTR [eax]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 164  : 		fclose(fp);

  0005b	ff 75 f8	 push	 DWORD PTR _fp$[ebp]
  0005e	e8 00 00 00 00	 call	 _fclose
  00063	59		 pop	 ecx

; 165  : 		return false;

  00064	32 c0		 xor	 al, al
  00066	e9 1e 01 00 00	 jmp	 $LN1@RunCompile
$LN15@RunCompile:

; 166  : 	}
; 167  : 
; 168  : 	_PyMarshal_ReadLongFromFile(fp);

  0006b	ff 75 f8	 push	 DWORD PTR _fp$[ebp]
  0006e	e8 00 00 00 00	 call	 ?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z ; _PyMarshal_ReadLongFromFile
  00073	59		 pop	 ecx

; 169  : 	v = _PyMarshal_ReadLastObjectFromFile(fp);

  00074	ff 75 f8	 push	 DWORD PTR _fp$[ebp]
  00077	e8 00 00 00 00	 call	 ?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadLastObjectFromFile
  0007c	59		 pop	 ecx
  0007d	89 45 fc	 mov	 DWORD PTR _v$[ebp], eax

; 170  : 
; 171  : 	fclose(fp);

  00080	ff 75 f8	 push	 DWORD PTR _fp$[ebp]
  00083	e8 00 00 00 00	 call	 _fclose
  00088	59		 pop	 ecx

; 172  : 
; 173  : 	if (!v || !PyCode_Check(v))

  00089	83 7d fc 00	 cmp	 DWORD PTR _v$[ebp], 0
  0008d	74 0e		 je	 SHORT $LN4@RunCompile
  0008f	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00092	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00095	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR __imp__PyCode_Type
  0009b	74 51		 je	 SHORT $LN16@RunCompile
$LN4@RunCompile:

; 174  : 	{
; 175  : 		Py_XDECREF(v);

  0009d	83 7d fc 00	 cmp	 DWORD PTR _v$[ebp], 0
  000a1	75 02		 jne	 SHORT $LN7@RunCompile
  000a3	eb 2a		 jmp	 SHORT $LN2@RunCompile
$LN7@RunCompile:
  000a5	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  000a8	8b 00		 mov	 eax, DWORD PTR [eax]
  000aa	48		 dec	 eax
  000ab	89 45 f0	 mov	 DWORD PTR tv85[ebp], eax
  000ae	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  000b1	8b 4d f0	 mov	 ecx, DWORD PTR tv85[ebp]
  000b4	89 08		 mov	 DWORD PTR [eax], ecx
  000b6	83 7d f0 00	 cmp	 DWORD PTR tv85[ebp], 0
  000ba	74 02		 je	 SHORT $LN20@RunCompile
  000bc	eb 0d		 jmp	 SHORT $LN5@RunCompile
$LN20@RunCompile:
  000be	ff 75 fc	 push	 DWORD PTR _v$[ebp]
  000c1	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  000c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c7	ff 50 18	 call	 DWORD PTR [eax+24]
  000ca	59		 pop	 ecx
$LN5@RunCompile:
  000cb	33 c0		 xor	 eax, eax
  000cd	75 d6		 jne	 SHORT $LN7@RunCompile
$LN2@RunCompile:
  000cf	33 c0		 xor	 eax, eax
  000d1	75 ca		 jne	 SHORT $LN4@RunCompile

; 176  : 		PyErr_SetString(PyExc_RuntimeError, "Bad code object in .pyc file");

  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@HFJPDIJP@Bad?5code?5object?5in?5?4pyc?5file@
  000d8	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  000dd	ff 30		 push	 DWORD PTR [eax]
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  000e5	59		 pop	 ecx
  000e6	59		 pop	 ecx

; 177  : 		return false;

  000e7	32 c0		 xor	 al, al
  000e9	e9 9b 00 00 00	 jmp	 $LN1@RunCompile
$LN16@RunCompile:

; 178  : 	}
; 179  : 
; 180  : 	co = (PyCodeObject *) v;

  000ee	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  000f1	89 45 f4	 mov	 DWORD PTR _co$[ebp], eax

; 181  : 	v = PyEval_EvalCode(co, m_poDic, m_poDic);

  000f4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	ff 70 08	 push	 DWORD PTR [eax+8]
  000fa	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	ff 70 08	 push	 DWORD PTR [eax+8]
  00100	ff 75 f4	 push	 DWORD PTR _co$[ebp]
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyEval_EvalCode
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010c	89 45 fc	 mov	 DWORD PTR _v$[ebp], eax
$LN10@RunCompile:

; 182  : /*	if (v && flags)
; 183  : 		flags->cf_flags |= (co->co_flags & PyCF_MASK);*/
; 184  : 	Py_DECREF(co);

  0010f	8b 45 f4	 mov	 eax, DWORD PTR _co$[ebp]
  00112	8b 00		 mov	 eax, DWORD PTR [eax]
  00114	48		 dec	 eax
  00115	89 45 e8	 mov	 DWORD PTR tv134[ebp], eax
  00118	8b 45 f4	 mov	 eax, DWORD PTR _co$[ebp]
  0011b	8b 4d e8	 mov	 ecx, DWORD PTR tv134[ebp]
  0011e	89 08		 mov	 DWORD PTR [eax], ecx
  00120	83 7d e8 00	 cmp	 DWORD PTR tv134[ebp], 0
  00124	74 02		 je	 SHORT $LN22@RunCompile
  00126	eb 0d		 jmp	 SHORT $LN8@RunCompile
$LN22@RunCompile:
  00128	ff 75 f4	 push	 DWORD PTR _co$[ebp]
  0012b	8b 45 f4	 mov	 eax, DWORD PTR _co$[ebp]
  0012e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00131	ff 50 18	 call	 DWORD PTR [eax+24]
  00134	59		 pop	 ecx
$LN8@RunCompile:
  00135	33 c0		 xor	 eax, eax
  00137	75 d6		 jne	 SHORT $LN10@RunCompile

; 185  : 	if (!v)

  00139	83 7d fc 00	 cmp	 DWORD PTR _v$[ebp], 0
  0013d	75 09		 jne	 SHORT $LN13@RunCompile

; 186  : 	{
; 187  : 		Traceback();

  0013f	e8 00 00 00 00	 call	 ?Traceback@@YAXXZ	; Traceback

; 188  : 		return false;

  00144	32 c0		 xor	 al, al
  00146	eb 41		 jmp	 SHORT $LN1@RunCompile
$LN13@RunCompile:

; 189  : 	}
; 190  : 
; 191  : 	Py_DECREF(v);

  00148	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  0014b	8b 00		 mov	 eax, DWORD PTR [eax]
  0014d	48		 dec	 eax
  0014e	89 45 e4	 mov	 DWORD PTR tv143[ebp], eax
  00151	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00154	8b 4d e4	 mov	 ecx, DWORD PTR tv143[ebp]
  00157	89 08		 mov	 DWORD PTR [eax], ecx
  00159	83 7d e4 00	 cmp	 DWORD PTR tv143[ebp], 0
  0015d	74 02		 je	 SHORT $LN25@RunCompile
  0015f	eb 0d		 jmp	 SHORT $LN11@RunCompile
$LN25@RunCompile:
  00161	ff 75 fc	 push	 DWORD PTR _v$[ebp]
  00164	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00167	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016a	ff 50 18	 call	 DWORD PTR [eax+24]
  0016d	59		 pop	 ecx
$LN11@RunCompile:
  0016e	33 c0		 xor	 eax, eax
  00170	75 d6		 jne	 SHORT $LN13@RunCompile

; 192  : 	if (Py_FlushLine()) 

  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_FlushLine
  00178	85 c0		 test	 eax, eax
  0017a	74 06		 je	 SHORT $LN27@RunCompile

; 193  : 		PyErr_Clear();

  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Clear
$LN27@RunCompile:

; 194  : 
; 195  : 	NANOEND

  00182	eb		 DB	 -21			; ffffffebH
  00183	03		 DB	 3
  00184	d6		 DB	 -42			; ffffffd6H
  00185	d7		 DB	 -41			; ffffffd7H
  00186	00		 DB	 0
  00187	b0 01		 mov	 al, 1
$LN1@RunCompile:

; 196  : 	return true;
; 197  : }

  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	5b		 pop	 ebx
  0018c	c9		 leave
  0018d	c2 04 00	 ret	 4
?RunCompiledFile@CPythonLauncher@@QAE_NPBD@Z ENDP	; CPythonLauncher::RunCompiledFile
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z
_TEXT	SEGMENT
_this$ = -116						; size = 4
_c_pcConvFileData$ = -112				; size = 4
$T2 = -108						; size = 4
$T3 = -104						; size = 4
$T4 = -100						; size = 4
$T5 = -96						; size = 4
$T6 = -92						; size = 4
$T7 = -88						; size = 4
$T8 = -84						; size = 4
$T9 = -80						; size = 4
$T10 = -76						; size = 4
$T11 = -72						; size = 4
__Ch$ = -68						; size = 1
$T12 = -64						; size = 4
$T13 = -60						; size = 4
_this$ = -56						; size = 4
_c_pcFileData$ = -52					; size = 4
_i$14 = -48						; size = 4
$T15 = -41						; size = 1
_stConvFileData$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szFileName$ = 8					; size = 4
_uFileSize$ = 12					; size = 4
_c_pvFileData$ = 16					; size = 4
?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z PROC	; CPythonLauncher::RunMemoryTextFile, COMDAT
; _this$ = ecx

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 68	 sub	 esp, 104		; 00000068H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d 8c	 mov	 DWORD PTR _this$[ebp], ecx

; 202  : 	NANOBEGIN

  0002e	eb		 DB	 -21			; ffffffebH
  0002f	03		 DB	 3
  00030	d6		 DB	 -42			; ffffffd6H
  00031	d7		 DB	 -41			; ffffffd7H
  00032	01		 DB	 1
  00033	8b 45 10	 mov	 eax, DWORD PTR _c_pvFileData$[ebp]
  00036	89 45 cc	 mov	 DWORD PTR _c_pcFileData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00039	8d 45 d8	 lea	 eax, DWORD PTR _stConvFileData$[ebp]
  0003c	89 45 c8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003f	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  00047	8d 4d d8	 lea	 ecx, DWORD PTR _stConvFileData$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 205  : 	std::string stConvFileData;

  0004f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 206  : 	stConvFileData.reserve(uFileSize);

  00053	ff 75 0c	 push	 DWORD PTR _uFileSize$[ebp]
  00056	8d 4d d8	 lea	 ecx, DWORD PTR _stConvFileData$[ebp]
  00059	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MNBENCCN@exec?$CIcompile?$CI?8?8?8@
  00063	e8 00 00 00 00	 call	 _strlen
  00068	59		 pop	 ecx
  00069	89 45 c4	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0006c	8b 45 c4	 mov	 eax, DWORD PTR $T13[ebp]
  0006f	89 45 c0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00072	ff 75 c0	 push	 DWORD PTR $T12[ebp]
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MNBENCCN@exec?$CIcompile?$CI?8?8?8@
  0007a	8d 4d d8	 lea	 ecx, DWORD PTR _stConvFileData$[ebp]
  0007d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 211  : 		for (UINT i=0; i<uFileSize; ++i)

  00082	83 65 d0 00	 and	 DWORD PTR _i$14[ebp], 0
  00086	eb 07		 jmp	 SHORT $LN4@RunMemoryT
$LN2@RunMemoryT:
  00088	8b 45 d0	 mov	 eax, DWORD PTR _i$14[ebp]
  0008b	40		 inc	 eax
  0008c	89 45 d0	 mov	 DWORD PTR _i$14[ebp], eax
$LN4@RunMemoryT:
  0008f	8b 45 d0	 mov	 eax, DWORD PTR _i$14[ebp]
  00092	3b 45 0c	 cmp	 eax, DWORD PTR _uFileSize$[ebp]
  00095	73 26		 jae	 SHORT $LN3@RunMemoryT

; 212  : 		{
; 213  : 			if (c_pcFileData[i]!=13)

  00097	8b 45 cc	 mov	 eax, DWORD PTR _c_pcFileData$[ebp]
  0009a	03 45 d0	 add	 eax, DWORD PTR _i$14[ebp]
  0009d	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000a0	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  000a3	74 16		 je	 SHORT $LN5@RunMemoryT

; 214  : 				stConvFileData+=c_pcFileData[i];

  000a5	8b 45 cc	 mov	 eax, DWORD PTR _c_pcFileData$[ebp]
  000a8	03 45 d0	 add	 eax, DWORD PTR _i$14[ebp]
  000ab	8a 00		 mov	 al, BYTE PTR [eax]
  000ad	88 45 bc	 mov	 BYTE PTR __Ch$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2905 :         push_back(_Ch);

  000b0	ff 75 bc	 push	 DWORD PTR __Ch$[ebp]
  000b3	8d 4d d8	 lea	 ecx, DWORD PTR _stConvFileData$[ebp]
  000b6	e8 00 00 00 00	 call	 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
$LN5@RunMemoryT:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 215  : 		}

  000bb	eb cb		 jmp	 SHORT $LN2@RunMemoryT
$LN3@RunMemoryT:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_05LOEDJEGH@?8?8?8?0?5@
  000c2	e8 00 00 00 00	 call	 _strlen
  000c7	59		 pop	 ecx
  000c8	89 45 b8	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000cb	8b 45 b8	 mov	 eax, DWORD PTR $T11[ebp]
  000ce	89 45 b4	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000d1	ff 75 b4	 push	 DWORD PTR $T10[ebp]
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_05LOEDJEGH@?8?8?8?0?5@
  000d9	8d 4d d8	 lea	 ecx, DWORD PTR _stConvFileData$[ebp]
  000dc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_01GEODFPGF@?8@
  000e6	e8 00 00 00 00	 call	 _strlen
  000eb	59		 pop	 ecx
  000ec	89 45 b0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000ef	8b 45 b0	 mov	 eax, DWORD PTR $T9[ebp]
  000f2	89 45 ac	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000f5	ff 75 ac	 push	 DWORD PTR $T8[ebp]
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_01GEODFPGF@?8@
  000fd	8d 4d d8	 lea	 ecx, DWORD PTR _stConvFileData$[ebp]
  00100	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00105	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00108	e8 00 00 00 00	 call	 _strlen
  0010d	59		 pop	 ecx
  0010e	89 45 a8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00111	8b 45 a8	 mov	 eax, DWORD PTR $T7[ebp]
  00114	89 45 a4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00117	ff 75 a4	 push	 DWORD PTR $T6[ebp]
  0011a	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  0011d	8d 4d d8	 lea	 ecx, DWORD PTR _stConvFileData$[ebp]
  00120	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00125	68 00 00 00 00	 push	 OFFSET ??_C@_03EHINCMEC@?8?0?5@
  0012a	e8 00 00 00 00	 call	 _strlen
  0012f	59		 pop	 ecx
  00130	89 45 a0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00133	8b 45 a0	 mov	 eax, DWORD PTR $T5[ebp]
  00136	89 45 9c	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00139	ff 75 9c	 push	 DWORD PTR $T4[ebp]
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_03EHINCMEC@?8?0?5@
  00141	8d 4d d8	 lea	 ecx, DWORD PTR _stConvFileData$[ebp]
  00144	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00149	68 00 00 00 00	 push	 OFFSET ??_C@_08HAHONCNP@?8exec?8?$CJ?$CJ@
  0014e	e8 00 00 00 00	 call	 _strlen
  00153	59		 pop	 ecx
  00154	89 45 98	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00157	8b 45 98	 mov	 eax, DWORD PTR $T3[ebp]
  0015a	89 45 94	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0015d	ff 75 94	 push	 DWORD PTR $T2[ebp]
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_08HAHONCNP@?8exec?8?$CJ?$CJ@
  00165	8d 4d d8	 lea	 ecx, DWORD PTR _stConvFileData$[ebp]
  00168	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 224  : 	const CHAR* c_pcConvFileData=stConvFileData.c_str();

  0016d	8d 4d d8	 lea	 ecx, DWORD PTR _stConvFileData$[ebp]
  00170	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00175	89 45 90	 mov	 DWORD PTR _c_pcConvFileData$[ebp], eax

; 225  : 	NANOEND

  00178	eb		 DB	 -21			; ffffffebH
  00179	03		 DB	 3
  0017a	d6		 DB	 -42			; ffffffd6H
  0017b	d7		 DB	 -41			; ffffffd7H
  0017c	00		 DB	 0
  0017d	ff 75 90	 push	 DWORD PTR _c_pcConvFileData$[ebp]
  00180	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00183	e8 00 00 00 00	 call	 ?RunLine@CPythonLauncher@@QAE_NPBD@Z ; CPythonLauncher::RunLine
  00188	88 45 d7	 mov	 BYTE PTR $T15[ebp], al
  0018b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0018f	8d 4d d8	 lea	 ecx, DWORD PTR _stConvFileData$[ebp]
  00192	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 225  : 	NANOEND

  00197	8a 45 d7	 mov	 al, BYTE PTR $T15[ebp]

; 226  : 	return RunLine(c_pcConvFileData);
; 227  : }

  0019a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0019d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a4	59		 pop	 ecx
  001a5	5f		 pop	 edi
  001a6	5e		 pop	 esi
  001a7	5b		 pop	 ebx
  001a8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ab	33 cd		 xor	 ecx, ebp
  001ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b2	c9		 leave
  001b3	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _stConvFileData$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z ENDP	; CPythonLauncher::RunMemoryTextFile
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ?RunFile@CPythonLauncher@@QAE_NPBD@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
_this$ = -36						; size = 4
_pvData$3 = -32						; size = 4
$T4 = -28						; size = 4
_acBufData$ = -24					; size = 4
_dwBufSize$ = -20					; size = 4
$T5 = -14						; size = 1
_ret$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
_file$6 = 0						; size = 324
__$ArrayPad$ = 324					; size = 4
_c_szFileName$ = 336					; size = 4
?RunFile@CPythonLauncher@@QAE_NPBD@Z PROC		; CPythonLauncher::RunFile, COMDAT
; _this$ = ecx

; 230  : {

  00000	55		 push	 ebp
  00001	8d ac 24 b8 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-328]
  00008	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?RunFile@CPythonLauncher@@QAE_NPBD@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 44 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  : 	char* acBufData=NULL;

  00039	83 65 e8 00	 and	 DWORD PTR _acBufData$[ebp], 0

; 232  : 	DWORD dwBufSize=0;

  0003d	83 65 ec 00	 and	 DWORD PTR _dwBufSize$[ebp], 0

; 233  : 	
; 234  : 	{
; 235  : 		CMappedFile file;

  00041	8d 4d 00	 lea	 ecx, DWORD PTR _file$6[ebp]
  00044	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile
  00049	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 236  : 		const VOID* pvData;
; 237  : 		CEterPackManager::Instance().Get(file, c_szFileName, &pvData);

  0004d	8d 45 e0	 lea	 eax, DWORD PTR _pvData$3[ebp]
  00050	50		 push	 eax
  00051	ff b5 50 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  00057	8d 45 00	 lea	 eax, DWORD PTR _file$6[ebp]
  0005a	50		 push	 eax
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00061	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get

; 238  : 		
; 239  : 		dwBufSize=file.Size();

  00066	8d 4d 00	 lea	 ecx, DWORD PTR _file$6[ebp]
  00069	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  0006e	89 45 ec	 mov	 DWORD PTR _dwBufSize$[ebp], eax

; 240  : 		if (dwBufSize==0)

  00071	83 7d ec 00	 cmp	 DWORD PTR _dwBufSize$[ebp], 0
  00075	75 15		 jne	 SHORT $LN2@RunFile

; 241  : 			return false;

  00077	c6 45 f2 00	 mov	 BYTE PTR $T5[ebp], 0
  0007b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007f	8d 4d 00	 lea	 ecx, DWORD PTR _file$6[ebp]
  00082	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00087	8a 45 f2	 mov	 al, BYTE PTR $T5[ebp]
  0008a	eb 5c		 jmp	 SHORT $LN1@RunFile
$LN2@RunFile:

; 242  : 		
; 243  : 		acBufData=new char[dwBufSize];

  0008c	ff 75 ec	 push	 DWORD PTR _dwBufSize$[ebp]
  0008f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00094	59		 pop	 ecx
  00095	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
  00098	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0009b	89 45 e8	 mov	 DWORD PTR _acBufData$[ebp], eax

; 244  : 		memcpy(acBufData, pvData, dwBufSize);	

  0009e	ff 75 ec	 push	 DWORD PTR _dwBufSize$[ebp]
  000a1	ff 75 e0	 push	 DWORD PTR _pvData$3[ebp]
  000a4	ff 75 e8	 push	 DWORD PTR _acBufData$[ebp]
  000a7	e8 00 00 00 00	 call	 _memcpy
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 245  : 	}

  000af	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000b3	8d 4d 00	 lea	 ecx, DWORD PTR _file$6[ebp]
  000b6	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile

; 246  : 
; 247  : 	bool ret=false;

  000bb	c6 45 f3 00	 mov	 BYTE PTR _ret$[ebp], 0

; 248  : 	
; 249  : 	ret=RunMemoryTextFile(c_szFileName, dwBufSize, acBufData);

  000bf	ff 75 e8	 push	 DWORD PTR _acBufData$[ebp]
  000c2	ff 75 ec	 push	 DWORD PTR _dwBufSize$[ebp]
  000c5	ff b5 50 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  000cb	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?RunMemoryTextFile@CPythonLauncher@@QAE_NPBDIPBX@Z ; CPythonLauncher::RunMemoryTextFile
  000d3	88 45 f3	 mov	 BYTE PTR _ret$[ebp], al

; 250  : 
; 251  : 	delete [] acBufData;

  000d6	8b 45 e8	 mov	 eax, DWORD PTR _acBufData$[ebp]
  000d9	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
  000dc	ff 75 d8	 push	 DWORD PTR $T2[ebp]
  000df	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000e4	59		 pop	 ecx

; 252  : 	
; 253  : 	return ret;

  000e5	8a 45 f3	 mov	 al, BYTE PTR _ret$[ebp]
$LN1@RunFile:

; 254  : }

  000e8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000eb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f2	59		 pop	 ecx
  000f3	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f9	33 cd		 xor	 ecx, ebp
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	81 c5 48 01 00
	00		 add	 ebp, 328		; 00000148H
  00106	c9		 leave
  00107	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RunFile@CPythonLauncher@@QAE_NPBD@Z$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _file$6[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?RunFile@CPythonLauncher@@QAE_NPBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 8a 50 01 00
	00		 mov	 ecx, DWORD PTR [edx+336]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RunFile@CPythonLauncher@@QAE_NPBD@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RunFile@CPythonLauncher@@QAE_NPBD@Z ENDP		; CPythonLauncher::RunFile
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ?RunLine@CPythonLauncher@@QAE_NPBD@Z
_TEXT	SEGMENT
tv75 = -12						; size = 4
_this$ = -8						; size = 4
_v$ = -4						; size = 4
_c_szSrc$ = 8						; size = 4
?RunLine@CPythonLauncher@@QAE_NPBD@Z PROC		; CPythonLauncher::RunLine, COMDAT
; _this$ = ecx

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 258  : 	PyObject * v = PyRun_String((char *) c_szSrc, Py_file_input, m_poDic, m_poDic);

  00009	6a 00		 push	 0
  0000b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	ff 70 08	 push	 DWORD PTR [eax+8]
  00011	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00014	ff 70 08	 push	 DWORD PTR [eax+8]
  00017	68 01 01 00 00	 push	 257			; 00000101H
  0001c	ff 75 08	 push	 DWORD PTR _c_szSrc$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyRun_StringFlags
  00025	83 c4 14	 add	 esp, 20			; 00000014H
  00028	89 45 fc	 mov	 DWORD PTR _v$[ebp], eax

; 259  : 
; 260  : 	if (!v)

  0002b	83 7d fc 00	 cmp	 DWORD PTR _v$[ebp], 0
  0002f	75 09		 jne	 SHORT $LN4@RunLine

; 261  : 	{
; 262  : 		Traceback();

  00031	e8 00 00 00 00	 call	 ?Traceback@@YAXXZ	; Traceback

; 263  : 		return false;

  00036	32 c0		 xor	 al, al
  00038	eb 2c		 jmp	 SHORT $LN1@RunLine
$LN4@RunLine:

; 264  : 	}
; 265  : 
; 266  : 	Py_DECREF(v);

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  0003d	8b 00		 mov	 eax, DWORD PTR [eax]
  0003f	48		 dec	 eax
  00040	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00043	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00046	8b 4d f4	 mov	 ecx, DWORD PTR tv75[ebp]
  00049	89 08		 mov	 DWORD PTR [eax], ecx
  0004b	83 7d f4 00	 cmp	 DWORD PTR tv75[ebp], 0
  0004f	74 02		 je	 SHORT $LN6@RunLine
  00051	eb 0d		 jmp	 SHORT $LN2@RunLine
$LN6@RunLine:
  00053	ff 75 fc	 push	 DWORD PTR _v$[ebp]
  00056	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	ff 50 18	 call	 DWORD PTR [eax+24]
  0005f	59		 pop	 ecx
$LN2@RunLine:
  00060	33 c0		 xor	 eax, eax
  00062	75 d6		 jne	 SHORT $LN4@RunLine

; 267  : 	return true;

  00064	b0 01		 mov	 al, 1
$LN1@RunLine:

; 268  : }

  00066	c9		 leave
  00067	c2 04 00	 ret	 4
?RunLine@CPythonLauncher@@QAE_NPBD@Z ENDP		; CPythonLauncher::RunLine
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ?SetTraceFunc@CPythonLauncher@@QAEXP6AHPAU_object@@PAU_frame@@H0@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pFunc$ = 8						; size = 4
?SetTraceFunc@CPythonLauncher@@QAEXP6AHPAU_object@@PAU_frame@@H0@Z@Z PROC ; CPythonLauncher::SetTraceFunc, COMDAT
; _this$ = ecx

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 	PyEval_SetTrace(pFunc, NULL);

  00007	6a 00		 push	 0
  00009	ff 75 08	 push	 DWORD PTR _pFunc$[ebp]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyEval_SetTrace
  00012	59		 pop	 ecx
  00013	59		 pop	 ecx

; 114  : }

  00014	c9		 leave
  00015	c2 04 00	 ret	 4
?SetTraceFunc@CPythonLauncher@@QAEXP6AHPAU_object@@PAU_frame@@H0@Z@Z ENDP ; CPythonLauncher::SetTraceFunc
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ?Create@CPythonLauncher@@QAE_NPBD@Z
_TEXT	SEGMENT
tv88 = -12						; size = 4
_this$ = -8						; size = 4
_builtins$ = -4						; size = 4
_c_szProgramName$ = 8					; size = 4
?Create@CPythonLauncher@@QAE_NPBD@Z PROC		; CPythonLauncher::Create, COMDAT
; _this$ = ecx

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	NANOBEGIN

  0000c	eb		 DB	 -21			; ffffffebH
  0000d	03		 DB	 3
  0000e	d6		 DB	 -42			; ffffffd6H
  0000f	d7		 DB	 -41			; ffffffd7H
  00010	01		 DB	 1
  00011	ff 75 08	 push	 DWORD PTR _c_szProgramName$[ebp]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_SetProgramName
  0001a	59		 pop	 ecx

; 119  : 	Py_SetProgramName((char*)c_szProgramName);
; 120  : #ifdef _DEBUG
; 121  : 	PyEval_SetTrace(TraceFunc, NULL);
; 122  : #endif
; 123  : 	m_poModule = PyImport_AddModule((char *) "__main__");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_08EMKMIFM@__main__@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyImport_AddModule
  00026	59		 pop	 ecx
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 124  : 
; 125  : 	if (!m_poModule)

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00034	75 07		 jne	 SHORT $LN5@Create

; 126  : 		return false;

  00036	32 c0		 xor	 al, al
  00038	e9 c0 00 00 00	 jmp	 $LN1@Create
$LN5@Create:

; 127  : 	
; 128  : 	m_poDic = PyModule_GetDict(m_poModule);

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	ff 70 04	 push	 DWORD PTR [eax+4]
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyModule_GetDict
  00049	59		 pop	 ecx
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 129  : 
; 130  :     PyObject * builtins = PyImport_ImportModule("__builtin__");

  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EILMOIBE@__builtin__@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyImport_ImportModule
  0005b	59		 pop	 ecx
  0005c	89 45 fc	 mov	 DWORD PTR _builtins$[ebp], eax

; 131  : 	PyModule_AddIntConstant(builtins, "TRUE", 1);

  0005f	6a 01		 push	 1
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_04HCDDPBNL@TRUE@
  00066	ff 75 fc	 push	 DWORD PTR _builtins$[ebp]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyModule_AddIntConstant
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 132  : 	PyModule_AddIntConstant(builtins, "FALSE", 0);

  00072	6a 00		 push	 0
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_05MAJJAKPI@FALSE@
  00079	ff 75 fc	 push	 DWORD PTR _builtins$[ebp]
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyModule_AddIntConstant
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH

; 133  :     PyDict_SetItemString(m_poDic, "__builtins__", builtins);

  00085	ff 75 fc	 push	 DWORD PTR _builtins$[ebp]
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MNFFDJII@__builtins__@
  0008d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00090	ff 70 08	 push	 DWORD PTR [eax+8]
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyDict_SetItemString
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@Create:

; 134  : 	Py_DECREF(builtins);

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _builtins$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	48		 dec	 eax
  000a2	89 45 f4	 mov	 DWORD PTR tv88[ebp], eax
  000a5	8b 45 fc	 mov	 eax, DWORD PTR _builtins$[ebp]
  000a8	8b 4d f4	 mov	 ecx, DWORD PTR tv88[ebp]
  000ab	89 08		 mov	 DWORD PTR [eax], ecx
  000ad	83 7d f4 00	 cmp	 DWORD PTR tv88[ebp], 0
  000b1	74 02		 je	 SHORT $LN6@Create
  000b3	eb 0d		 jmp	 SHORT $LN2@Create
$LN6@Create:
  000b5	ff 75 fc	 push	 DWORD PTR _builtins$[ebp]
  000b8	8b 45 fc	 mov	 eax, DWORD PTR _builtins$[ebp]
  000bb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000be	ff 50 18	 call	 DWORD PTR [eax+24]
  000c1	59		 pop	 ecx
$LN2@Create:
  000c2	33 c0		 xor	 eax, eax
  000c4	75 d6		 jne	 SHORT $LN4@Create

; 135  : 
; 136  : 	if (!RunLine("import __main__"))

  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOEJKCPF@import?5__main__@
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?RunLine@CPythonLauncher@@QAE_NPBD@Z ; CPythonLauncher::RunLine
  000d3	0f b6 c0	 movzx	 eax, al
  000d6	85 c0		 test	 eax, eax
  000d8	75 04		 jne	 SHORT $LN8@Create

; 137  : 		return false;

  000da	32 c0		 xor	 al, al
  000dc	eb 1f		 jmp	 SHORT $LN1@Create
$LN8@Create:

; 138  : 	
; 139  : 	if (!RunLine("import sys"))

  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GOKNMPOF@import?5sys@
  000e3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	e8 00 00 00 00	 call	 ?RunLine@CPythonLauncher@@QAE_NPBD@Z ; CPythonLauncher::RunLine
  000eb	0f b6 c0	 movzx	 eax, al
  000ee	85 c0		 test	 eax, eax
  000f0	75 04		 jne	 SHORT $LN9@Create

; 140  : 		return false;

  000f2	32 c0		 xor	 al, al
  000f4	eb 07		 jmp	 SHORT $LN1@Create
$LN9@Create:

; 141  : 
; 142  : 	NANOEND

  000f6	eb		 DB	 -21			; ffffffebH
  000f7	03		 DB	 3
  000f8	d6		 DB	 -42			; ffffffd6H
  000f9	d7		 DB	 -41			; ffffffd7H
  000fa	00		 DB	 0
  000fb	b0 01		 mov	 al, 1
$LN1@Create:

; 143  : 	return true;
; 144  : }

  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx
  00100	c9		 leave
  00101	c2 04 00	 ret	 4
?Create@CPythonLauncher@@QAE_NPBD@Z ENDP		; CPythonLauncher::Create
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ?Clear@CPythonLauncher@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@CPythonLauncher@@QAEXXZ PROC			; CPythonLauncher::Clear, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 19   : 	Py_Finalize();

  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_Finalize

; 20   : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?Clear@CPythonLauncher@@QAEXXZ ENDP			; CPythonLauncher::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ??1CPythonLauncher@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CPythonLauncher@@UAE@XZ PROC				; CPythonLauncher::~CPythonLauncher, COMDAT
; _this$ = ecx

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CPythonLauncher@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CPythonLauncher@@6B@

; 14   : 	Clear();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Clear@CPythonLauncher@@QAEXXZ ; CPythonLauncher::Clear
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 19   : 	{ 

  00037	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCPythonLauncher@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00040	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonLauncher@@@@0PAVCPythonLauncher@@A, 0 ; CSingleton<CPythonLauncher>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 15   : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CPythonLauncher@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CPythonLauncher@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CPythonLauncher@@UAE@XZ ENDP				; CPythonLauncher::~CPythonLauncher
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp
;	COMDAT ??0CPythonLauncher@@QAE@XZ
_TEXT	SEGMENT
_offset$1 = -8						; size = 4
_this$ = -4						; size = 4
??0CPythonLauncher@@QAE@XZ PROC				; CPythonLauncher::CPythonLauncher, COMDAT
; _this$ = ecx

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 12   : 	{ 

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCPythonLauncher@@@@6B@

; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 

  00011	33 c0		 xor	 eax, eax
  00013	89 45 f8	 mov	 DWORD PTR _offset$1[ebp], eax

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	03 45 f8	 add	 eax, DWORD PTR _offset$1[ebp]
  0001c	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonLauncher@@@@0PAVCPythonLauncher@@A, eax ; CSingleton<CPythonLauncher>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonLauncher.cpp

; 8    : {

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CPythonLauncher@@6B@

; 9    : 	Py_Initialize();

  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_Initialize

; 10   : }

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c9		 leave
  00034	c3		 ret	 0
??0CPythonLauncher@@QAE@XZ ENDP				; CPythonLauncher::CPythonLauncher
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??_G?$CSingleton@VCPythonLauncher@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CSingleton@VCPythonLauncher@@@@UAEPAXI@Z PROC	; CSingleton<CPythonLauncher>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 19   : 	{ 

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCPythonLauncher@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00010	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonLauncher@@@@0PAVCPythonLauncher@@A, 0 ; CSingleton<CPythonLauncher>::ms_singleton
  00017	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	74 0c		 je	 SHORT $LN2@scalar
  0001f	6a 04		 push	 4
  00021	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	59		 pop	 ecx
  0002a	59		 pop	 ecx
$LN2@scalar:
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c2 04 00	 ret	 4
??_G?$CSingleton@VCPythonLauncher@@@@UAEPAXI@Z ENDP	; CSingleton<CPythonLauncher>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$ = -32						; size = 4
__Count$ = -28						; size = 4
__First1$ = -24						; size = 4
$T1 = -20						; size = 4
__Count$ = -16						; size = 4
$T2 = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small, COMDAT
; _this$ = ecx

; 4359 :     void _Become_small() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4360 :         // release any held storage and return to small string mode
; 4361 :         // pre: *this is in large string mode
; 4362 :         // pre: this is small enough to return to small string mode
; 4363 :         _Mypair._Myval2._Orphan_all();
; 4364 :         const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00014	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00017	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  0001a	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax

; 4365 :         auto& _Al          = _Getal();
; 4366 :         _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  0001d	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4367 :         _Traits::copy(_Mypair._Myval2._Bx._Buf, _Unfancy(_Ptr), _Mypair._Myval2._Mysize + 1);

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00032	40		 inc	 eax
  00033	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	89 45 e8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0003c	ff 75 f0	 push	 DWORD PTR __Count$[ebp]
  0003f	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00042	ff 75 e8	 push	 DWORD PTR __First1$[ebp]
  00045	e8 00 00 00 00	 call	 _memcpy
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4368 :         _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00053	40		 inc	 eax
  00054	89 45 e4	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00057	ff 75 e4	 push	 DWORD PTR __Count$[ebp]
  0005a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00062	59		 pop	 ecx
  00063	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4369 :         _Mypair._Myval2._Myres = _BUF_SIZE - 1;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4370 :     }

  0006e	c9		 leave
  0006f	c3		 ret	 0
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv75 = -12						; size = 4
$T3 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4284 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 0f	 or	 eax, 15			; 0000000fH
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  00012	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4287 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 46		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0001f	d1 e8		 shr	 eax, 1
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4291 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 32		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003e	3b 45 f8	 cmp	 eax, DWORD PTR $T3[ebp]
  00041	73 08		 jae	 SHORT $LN7@Calculate_
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00046	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00049	eb 06		 jmp	 SHORT $LN8@Calculate_
$LN7@Calculate_:
  0004b	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  0004e	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
$LN8@Calculate_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00057	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4295 :     }

  00062	c9		 leave
  00063	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -20						; size = 1
tv131 = -16						; size = 4
__Old_size$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 3817 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap = 0) { // determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3818 :         if (_Mypair._Myval2._Mysize > _Newcap) { // requested capacity is not large enough for current size, ignore

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	3b 45 08	 cmp	 eax, DWORD PTR __Newcap$[ebp]
  00012	76 02		 jbe	 SHORT $LN2@reserve

; 3819 :             return; // nothing to do

  00014	eb 75		 jmp	 SHORT $LN1@reserve
$LN2@reserve:

; 3820 :         }
; 3821 : 
; 3822 :         if (_Mypair._Myval2._Myres == _Newcap) { // we're already at the requested capacity

  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Newcap$[ebp]
  0001f	75 02		 jne	 SHORT $LN3@reserve

; 3823 :             return; // nothing to do

  00021	eb 68		 jmp	 SHORT $LN1@reserve
$LN3@reserve:

; 3824 :         }
; 3825 : 
; 3826 :         if (_Mypair._Myval2._Myres < _Newcap) { // reallocate to grow

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00029	3b 45 08	 cmp	 eax, DWORD PTR __Newcap$[ebp]
  0002c	73 2b		 jae	 SHORT $LN4@reserve

; 3827 :             const size_type _Old_size = _Mypair._Myval2._Mysize;

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00034	89 45 f4	 mov	 DWORD PTR __Old_size$2[ebp], eax

; 3828 :             _Reallocate_grow_by(

  00037	33 c0		 xor	 eax, eax
  00039	88 45 ec	 mov	 BYTE PTR $T1[ebp], al
  0003c	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0003f	8b 45 08	 mov	 eax, DWORD PTR __Newcap$[ebp]
  00042	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$2[ebp]
  00045	50		 push	 eax
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >

; 3829 :                 _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
; 3830 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3831 :                 });
; 3832 : 
; 3833 :             _Mypair._Myval2._Mysize = _Old_size;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$2[ebp]
  00054	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3834 :             return;

  00057	eb 32		 jmp	 SHORT $LN1@reserve
$LN4@reserve:

; 3835 :         }
; 3836 : 
; 3837 :         if (_BUF_SIZE > _Newcap && _Mypair._Myval2._Large_string_engaged()) {

  00059	83 7d 08 10	 cmp	 DWORD PTR __Newcap$[ebp], 16 ; 00000010H
  0005d	73 2c		 jae	 SHORT $LN1@reserve

; 2227 :         return _BUF_SIZE <= _Myres;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00066	72 09		 jb	 SHORT $LN9@reserve
  00068	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  0006f	eb 04		 jmp	 SHORT $LN10@reserve
$LN9@reserve:
  00071	83 65 f0 00	 and	 DWORD PTR tv131[ebp], 0
$LN10@reserve:
  00075	8a 45 f0	 mov	 al, BYTE PTR tv131[ebp]
  00078	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 3835 :         }
; 3836 : 
; 3837 :         if (_BUF_SIZE > _Newcap && _Mypair._Myval2._Large_string_engaged()) {

  0007b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  0007f	85 c0		 test	 eax, eax
  00081	74 08		 je	 SHORT $LN1@reserve

; 3838 :             // deallocate everything; switch back to "small" mode
; 3839 :             _Become_small();

  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
$LN1@reserve:

; 3840 :             return;
; 3841 :         }
; 3842 : 
; 3843 :         // ignore requests to reserve to [_BUF_SIZE, _Myres)
; 3844 :     }

  0008b	c9		 leave
  0008c	c2 04 00	 ret	 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
$T1 = -20						; size = 1
__Ptr$2 = -16						; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 3691 :     void push_back(const _Elem _Ch) { // insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3692 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 3693 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00018	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  0001b	73 32		 jae	 SHORT $LN2@push_back

; 3694 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0001d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00020	40		 inc	 eax
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 3695 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0002f	89 45 f0	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 428  :         _Left = _Right;

  00032	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$2[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]
  00038	8a 4d 08	 mov	 cl, BYTE PTR __Ch$[ebp]
  0003b	88 08		 mov	 BYTE PTR [eax], cl

; 3696 :             _Traits::assign(_Ptr[_Old_size], _Ch);
; 3697 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  0003d	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$2[ebp]
  00044	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]
  00047	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  0004a	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 3698 :             return;

  0004d	eb 15		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 3699 :         }
; 3700 : 
; 3701 :         _Reallocate_grow_by(

  0004f	33 c0		 xor	 eax, eax
  00051	88 45 ec	 mov	 BYTE PTR $T1[ebp], al
  00054	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00057	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0005a	6a 01		 push	 1
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN1@push_back:

; 3702 :             1,
; 3703 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 3704 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3705 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 3706 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 3707 :             },
; 3708 :             _Ch);
; 3709 :     }

  00064	c9		 leave
  00065	c2 04 00	 ret	 4
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -24						; size = 1
__First1$ = -20						; size = 4
__Old_ptr$2 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2935 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2936 :         // append [_Ptr, _Ptr + _Count)
; 2937 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 2938 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 49		 ja	 SHORT $LN2@append

; 2939 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00023	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2940 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 2941 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8b 45 f0	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  0003a	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR __First1$[ebp], eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00046	ff 75 ec	 push	 DWORD PTR __First1$[ebp]
  00049	e8 00 00 00 00	 call	 _memmove
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2942 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00051	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00055	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00058	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]

; 428  :         _Left = _Right;

  0005b	8b 4d f0	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  0005e	8a 55 ff	 mov	 dl, BYTE PTR $T3[ebp]
  00061	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2943 :             return *this;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	eb 19		 jmp	 SHORT $LN1@append
$LN2@append:

; 2944 :         }
; 2945 : 
; 2946 :         return _Reallocate_grow_by(

  00069	33 c0		 xor	 eax, eax
  0006b	88 45 e8	 mov	 BYTE PTR $T1[ebp], al
  0006e	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00071	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00074	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00077	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 2947 :             _Count,
; 2948 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2949 :                 const size_type _Count) {
; 2950 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2953 :             },
; 2954 :             _Ptr, _Count);
; 2955 :     }

  00082	c9		 leave
  00083	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2909 :     basic_string& append(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2910 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	ff 70 10	 push	 DWORD PTR [eax+16]
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2911 :     }

  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 14 00	 and	 DWORD PTR [eax+20], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c9		 leave
  00019	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1969 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1970 :         int _Result;
; 1971 :         va_list _ArgList;
; 1972 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00020	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	83 c9 01	 or	 ecx, 1
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00034	83 c4 1c	 add	 esp, 28			; 0000001cH
  00037	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0003a	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003e	7d 06		 jge	 SHORT $LN7@snprintf
  00040	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN3@snprintf
$LN7@snprintf:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00049	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@snprintf:

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0004c	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004f	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1975 :         __crt_va_end(_ArgList);

  00052	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1976 :         return _Result;

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1977 :     }

  00059	c9		 leave
  0005a	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
