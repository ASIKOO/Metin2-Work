; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pkExceptionSender@@3PAVIPythonExceptionSender@@A ; g_pkExceptionSender
_BSS	SEGMENT
?g_pkExceptionSender@@3PAVIPythonExceptionSender@@A DD 01H DUP (?) ; g_pkExceptionSender
_BSS	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z	; PyTuple_GetString
PUBLIC	?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z	; PyTuple_GetInteger
PUBLIC	?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z	; PyTuple_GetInteger
PUBLIC	?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z	; PyTuple_GetInteger
PUBLIC	?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z	; PyTuple_GetByte
PUBLIC	?PyTuple_GetUnsignedInteger@@YA_NPAU_object@@HPAI@Z ; PyTuple_GetUnsignedInteger
PUBLIC	?PyTuple_GetLong@@YA_NPAU_object@@HPAJ@Z	; PyTuple_GetLong
PUBLIC	?PyTuple_GetUnsignedLong@@YA_NPAU_object@@HPAK@Z ; PyTuple_GetUnsignedLong
PUBLIC	?PyTuple_GetLongLong@@YA_NPAU_object@@HPA_J@Z	; PyTuple_GetLongLong
PUBLIC	?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z	; PyTuple_GetFloat
PUBLIC	?PyTuple_GetDouble@@YA_NPAU_object@@HPAN@Z	; PyTuple_GetDouble
PUBLIC	?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z	; PyTuple_GetObject
PUBLIC	?PyTuple_GetBoolean@@YA_NPAU_object@@HPA_N@Z	; PyTuple_GetBoolean
PUBLIC	?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z	; PyCallClassMemberFunc
PUBLIC	?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0PA_N@Z ; PyCallClassMemberFunc
PUBLIC	?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0PAJ@Z ; PyCallClassMemberFunc
PUBLIC	?PyCallClassMemberFunc_ByPyString@@YA_NPAU_object@@00@Z ; PyCallClassMemberFunc_ByPyString
PUBLIC	?PyCallClassMemberFunc@@YA_NPAU_object@@00@Z	; PyCallClassMemberFunc
PUBLIC	?Py_BuildException@@YAPAU_object@@PBDZZ		; Py_BuildException
PUBLIC	?Py_BadArgument@@YAPAU_object@@XZ		; Py_BadArgument
PUBLIC	?Py_BuildNone@@YAPAU_object@@XZ			; Py_BuildNone
PUBLIC	?Clear@IPythonExceptionSender@@QAEXXZ		; IPythonExceptionSender::Clear
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?__PyCallClassMemberFunc_ByCString@@YA_NPAU_object@@PBD0PAPAU1@@Z ; __PyCallClassMemberFunc_ByCString
PUBLIC	?__PyCallClassMemberFunc_ByPyString@@YA_NPAU_object@@00PAPAU1@@Z ; __PyCallClassMemberFunc_ByPyString
PUBLIC	?__PyCallClassMemberFunc@@YA_NPAU_object@@00PAPAU1@@Z ; __PyCallClassMemberFunc
PUBLIC	?Py_ReleaseNone@@YAXXZ				; Py_ReleaseNone
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_strlen:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	__imp__PyObject_GetAttrString:PROC
EXTRN	__imp__PyObject_GetAttr:PROC
EXTRN	__imp__PyCallable_Check:PROC
EXTRN	__imp__PyLong_AsLongLong:PROC
EXTRN	__imp__PyLong_AsUnsignedLongLong:PROC
EXTRN	__imp__PyFloat_AsDouble:PROC
EXTRN	__imp__PyString_AsString:PROC
EXTRN	__imp__PyTuple_Size:PROC
EXTRN	__imp__PyTuple_GetItem:PROC
EXTRN	__imp__PyErr_SetString:PROC
EXTRN	__imp__PyErr_Clear:PROC
EXTRN	__imp__PyErr_BadArgument:PROC
EXTRN	__imp__PyErr_Print:PROC
EXTRN	__imp__PyObject_CallObject:PROC
EXTRN	__imp__PyNumber_Check:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp___Py_NoneStruct:QWORD
EXTRN	__imp__PyExc_RuntimeError:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?Py_ReleaseNone@@YAXXZ
_TEXT	SEGMENT
tv66 = -4						; size = 4
?Py_ReleaseNone@@YAXXZ PROC				; Py_ReleaseNone, COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN4@Py_Release:

; 46   : 	Py_DECREF(Py_None);

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	48		 dec	 eax
  0000c	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct
  00014	8b 4d fc	 mov	 ecx, DWORD PTR tv66[ebp]
  00017	89 08		 mov	 DWORD PTR [eax], ecx
  00019	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  0001d	74 02		 je	 SHORT $LN5@Py_Release
  0001f	eb 12		 jmp	 SHORT $LN2@Py_Release
$LN5@Py_Release:
  00021	ff 35 00 00 00
	00		 push	 DWORD PTR __imp___Py_NoneStruct
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct
  0002c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002f	ff 50 18	 call	 DWORD PTR [eax+24]
  00032	59		 pop	 ecx
$LN2@Py_Release:
  00033	33 c0		 xor	 eax, eax
  00035	75 cd		 jne	 SHORT $LN4@Py_Release

; 47   : }

  00037	c9		 leave
  00038	c3		 ret	 0
?Py_ReleaseNone@@YAXXZ ENDP				; Py_ReleaseNone
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?__PyCallClassMemberFunc@@YA_NPAU_object@@00PAPAU1@@Z
_TEXT	SEGMENT
tv172 = -36						; size = 4
tv163 = -32						; size = 4
_poRet$ = -28						; size = 4
tv154 = -24						; size = 4
tv145 = -20						; size = 4
tv132 = -16						; size = 4
tv91 = -12						; size = 4
tv79 = -8						; size = 4
tv68 = -4						; size = 4
_poClass$ = 8						; size = 4
_poFunc$ = 12						; size = 4
_poArgs$ = 16						; size = 4
_ppoRet$ = 20						; size = 4
?__PyCallClassMemberFunc@@YA_NPAU_object@@00PAPAU1@@Z PROC ; __PyCallClassMemberFunc, COMDAT

; 407  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 408  : 	if (!poClass) 

  00006	83 7d 08 00	 cmp	 DWORD PTR _poClass$[ebp], 0
  0000a	75 3d		 jne	 SHORT $LN41@PyCallClas
$LN4@PyCallClas:

; 409  : 	{
; 410  : 		Py_XDECREF(poArgs);

  0000c	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  00010	75 02		 jne	 SHORT $LN7@PyCallClas
  00012	eb 2a		 jmp	 SHORT $LN2@PyCallClas
$LN7@PyCallClas:
  00014	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	48		 dec	 eax
  0001a	89 45 fc	 mov	 DWORD PTR tv68[ebp], eax
  0001d	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR tv68[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	83 7d fc 00	 cmp	 DWORD PTR tv68[ebp], 0
  00029	74 02		 je	 SHORT $LN44@PyCallClas
  0002b	eb 0d		 jmp	 SHORT $LN5@PyCallClas
$LN44@PyCallClas:
  0002d	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  00030	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	ff 50 18	 call	 DWORD PTR [eax+24]
  00039	59		 pop	 ecx
$LN5@PyCallClas:
  0003a	33 c0		 xor	 eax, eax
  0003c	75 d6		 jne	 SHORT $LN7@PyCallClas
$LN2@PyCallClas:
  0003e	33 c0		 xor	 eax, eax
  00040	75 ca		 jne	 SHORT $LN4@PyCallClas

; 411  : 		return false;

  00042	32 c0		 xor	 al, al
  00044	e9 a9 01 00 00	 jmp	 $LN1@PyCallClas
$LN41@PyCallClas:

; 412  : 	}
; 413  : 
; 414  : 	if (!poFunc)

  00049	83 7d 0c 00	 cmp	 DWORD PTR _poFunc$[ebp], 0
  0004d	75 43		 jne	 SHORT $LN46@PyCallClas

; 415  : 	{		
; 416  : 		PyErr_Clear();

  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Clear
$LN10@PyCallClas:

; 417  : 		Py_XDECREF(poArgs);

  00055	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  00059	75 02		 jne	 SHORT $LN13@PyCallClas
  0005b	eb 2a		 jmp	 SHORT $LN8@PyCallClas
$LN13@PyCallClas:
  0005d	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	48		 dec	 eax
  00063	89 45 f8	 mov	 DWORD PTR tv79[ebp], eax
  00066	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00069	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  0006c	89 08		 mov	 DWORD PTR [eax], ecx
  0006e	83 7d f8 00	 cmp	 DWORD PTR tv79[ebp], 0
  00072	74 02		 je	 SHORT $LN49@PyCallClas
  00074	eb 0d		 jmp	 SHORT $LN11@PyCallClas
$LN49@PyCallClas:
  00076	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  00079	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  0007c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007f	ff 50 18	 call	 DWORD PTR [eax+24]
  00082	59		 pop	 ecx
$LN11@PyCallClas:
  00083	33 c0		 xor	 eax, eax
  00085	75 d6		 jne	 SHORT $LN13@PyCallClas
$LN8@PyCallClas:
  00087	33 c0		 xor	 eax, eax
  00089	75 ca		 jne	 SHORT $LN10@PyCallClas

; 418  : 		return false;

  0008b	32 c0		 xor	 al, al
  0008d	e9 60 01 00 00	 jmp	 $LN1@PyCallClas
$LN46@PyCallClas:

; 419  : 	}
; 420  : 
; 421  : 	if (!PyCallable_Check(poFunc)) 

  00092	ff 75 0c	 push	 DWORD PTR _poFunc$[ebp]
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyCallable_Check
  0009b	59		 pop	 ecx
  0009c	85 c0		 test	 eax, eax
  0009e	75 67		 jne	 SHORT $LN51@PyCallClas
$LN16@PyCallClas:

; 422  : 	{
; 423  : 		Py_DECREF(poFunc);

  000a0	8b 45 0c	 mov	 eax, DWORD PTR _poFunc$[ebp]
  000a3	8b 00		 mov	 eax, DWORD PTR [eax]
  000a5	48		 dec	 eax
  000a6	89 45 f4	 mov	 DWORD PTR tv91[ebp], eax
  000a9	8b 45 0c	 mov	 eax, DWORD PTR _poFunc$[ebp]
  000ac	8b 4d f4	 mov	 ecx, DWORD PTR tv91[ebp]
  000af	89 08		 mov	 DWORD PTR [eax], ecx
  000b1	83 7d f4 00	 cmp	 DWORD PTR tv91[ebp], 0
  000b5	74 02		 je	 SHORT $LN52@PyCallClas
  000b7	eb 0d		 jmp	 SHORT $LN14@PyCallClas
$LN52@PyCallClas:
  000b9	ff 75 0c	 push	 DWORD PTR _poFunc$[ebp]
  000bc	8b 45 0c	 mov	 eax, DWORD PTR _poFunc$[ebp]
  000bf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c2	ff 50 18	 call	 DWORD PTR [eax+24]
  000c5	59		 pop	 ecx
$LN14@PyCallClas:
  000c6	33 c0		 xor	 eax, eax
  000c8	75 d6		 jne	 SHORT $LN16@PyCallClas
$LN19@PyCallClas:

; 424  : 		Py_XDECREF(poArgs);

  000ca	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  000ce	75 02		 jne	 SHORT $LN22@PyCallClas
  000d0	eb 2a		 jmp	 SHORT $LN17@PyCallClas
$LN22@PyCallClas:
  000d2	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  000d5	8b 00		 mov	 eax, DWORD PTR [eax]
  000d7	48		 dec	 eax
  000d8	89 45 f0	 mov	 DWORD PTR tv132[ebp], eax
  000db	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  000de	8b 4d f0	 mov	 ecx, DWORD PTR tv132[ebp]
  000e1	89 08		 mov	 DWORD PTR [eax], ecx
  000e3	83 7d f0 00	 cmp	 DWORD PTR tv132[ebp], 0
  000e7	74 02		 je	 SHORT $LN56@PyCallClas
  000e9	eb 0d		 jmp	 SHORT $LN20@PyCallClas
$LN56@PyCallClas:
  000eb	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  000ee	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  000f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f4	ff 50 18	 call	 DWORD PTR [eax+24]
  000f7	59		 pop	 ecx
$LN20@PyCallClas:
  000f8	33 c0		 xor	 eax, eax
  000fa	75 d6		 jne	 SHORT $LN22@PyCallClas
$LN17@PyCallClas:
  000fc	33 c0		 xor	 eax, eax
  000fe	75 ca		 jne	 SHORT $LN19@PyCallClas

; 425  : 		return false;

  00100	32 c0		 xor	 al, al
  00102	e9 eb 00 00 00	 jmp	 $LN1@PyCallClas
$LN51@PyCallClas:

; 426  : 	}
; 427  : 
; 428  : 	PyObject * poRet = PyObject_CallObject(poFunc, poArgs);	// New Reference

  00107	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  0010a	ff 75 0c	 push	 DWORD PTR _poFunc$[ebp]
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyObject_CallObject
  00113	59		 pop	 ecx
  00114	59		 pop	 ecx
  00115	89 45 e4	 mov	 DWORD PTR _poRet$[ebp], eax

; 429  : 
; 430  : 	if (!poRet)

  00118	83 7d e4 00	 cmp	 DWORD PTR _poRet$[ebp], 0
  0011c	75 6a		 jne	 SHORT $LN58@PyCallClas

; 431  : 	{
; 432  : 		PyErr_Print();

  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Print
$LN25@PyCallClas:

; 433  : 		Py_DECREF(poFunc);

  00124	8b 45 0c	 mov	 eax, DWORD PTR _poFunc$[ebp]
  00127	8b 00		 mov	 eax, DWORD PTR [eax]
  00129	48		 dec	 eax
  0012a	89 45 ec	 mov	 DWORD PTR tv145[ebp], eax
  0012d	8b 45 0c	 mov	 eax, DWORD PTR _poFunc$[ebp]
  00130	8b 4d ec	 mov	 ecx, DWORD PTR tv145[ebp]
  00133	89 08		 mov	 DWORD PTR [eax], ecx
  00135	83 7d ec 00	 cmp	 DWORD PTR tv145[ebp], 0
  00139	74 02		 je	 SHORT $LN59@PyCallClas
  0013b	eb 0d		 jmp	 SHORT $LN23@PyCallClas
$LN59@PyCallClas:
  0013d	ff 75 0c	 push	 DWORD PTR _poFunc$[ebp]
  00140	8b 45 0c	 mov	 eax, DWORD PTR _poFunc$[ebp]
  00143	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00146	ff 50 18	 call	 DWORD PTR [eax+24]
  00149	59		 pop	 ecx
$LN23@PyCallClas:
  0014a	33 c0		 xor	 eax, eax
  0014c	75 d6		 jne	 SHORT $LN25@PyCallClas
$LN28@PyCallClas:

; 434  : 		Py_XDECREF(poArgs);

  0014e	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  00152	75 02		 jne	 SHORT $LN31@PyCallClas
  00154	eb 2a		 jmp	 SHORT $LN26@PyCallClas
$LN31@PyCallClas:
  00156	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00159	8b 00		 mov	 eax, DWORD PTR [eax]
  0015b	48		 dec	 eax
  0015c	89 45 e8	 mov	 DWORD PTR tv154[ebp], eax
  0015f	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00162	8b 4d e8	 mov	 ecx, DWORD PTR tv154[ebp]
  00165	89 08		 mov	 DWORD PTR [eax], ecx
  00167	83 7d e8 00	 cmp	 DWORD PTR tv154[ebp], 0
  0016b	74 02		 je	 SHORT $LN63@PyCallClas
  0016d	eb 0d		 jmp	 SHORT $LN29@PyCallClas
$LN63@PyCallClas:
  0016f	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  00172	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00175	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00178	ff 50 18	 call	 DWORD PTR [eax+24]
  0017b	59		 pop	 ecx
$LN29@PyCallClas:
  0017c	33 c0		 xor	 eax, eax
  0017e	75 d6		 jne	 SHORT $LN31@PyCallClas
$LN26@PyCallClas:
  00180	33 c0		 xor	 eax, eax
  00182	75 ca		 jne	 SHORT $LN28@PyCallClas

; 435  : 		return false;

  00184	32 c0		 xor	 al, al
  00186	eb 6a		 jmp	 SHORT $LN1@PyCallClas
$LN58@PyCallClas:

; 436  : 	}
; 437  : 
; 438  : 	*ppoRet = poRet;

  00188	8b 45 14	 mov	 eax, DWORD PTR _ppoRet$[ebp]
  0018b	8b 4d e4	 mov	 ecx, DWORD PTR _poRet$[ebp]
  0018e	89 08		 mov	 DWORD PTR [eax], ecx
$LN34@PyCallClas:

; 439  : 
; 440  : 	Py_DECREF(poFunc);

  00190	8b 45 0c	 mov	 eax, DWORD PTR _poFunc$[ebp]
  00193	8b 00		 mov	 eax, DWORD PTR [eax]
  00195	48		 dec	 eax
  00196	89 45 e0	 mov	 DWORD PTR tv163[ebp], eax
  00199	8b 45 0c	 mov	 eax, DWORD PTR _poFunc$[ebp]
  0019c	8b 4d e0	 mov	 ecx, DWORD PTR tv163[ebp]
  0019f	89 08		 mov	 DWORD PTR [eax], ecx
  001a1	83 7d e0 00	 cmp	 DWORD PTR tv163[ebp], 0
  001a5	74 02		 je	 SHORT $LN65@PyCallClas
  001a7	eb 0d		 jmp	 SHORT $LN32@PyCallClas
$LN65@PyCallClas:
  001a9	ff 75 0c	 push	 DWORD PTR _poFunc$[ebp]
  001ac	8b 45 0c	 mov	 eax, DWORD PTR _poFunc$[ebp]
  001af	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b2	ff 50 18	 call	 DWORD PTR [eax+24]
  001b5	59		 pop	 ecx
$LN32@PyCallClas:
  001b6	33 c0		 xor	 eax, eax
  001b8	75 d6		 jne	 SHORT $LN34@PyCallClas
$LN37@PyCallClas:

; 441  : 	Py_XDECREF(poArgs);

  001ba	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  001be	75 02		 jne	 SHORT $LN40@PyCallClas
  001c0	eb 2a		 jmp	 SHORT $LN35@PyCallClas
$LN40@PyCallClas:
  001c2	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  001c5	8b 00		 mov	 eax, DWORD PTR [eax]
  001c7	48		 dec	 eax
  001c8	89 45 dc	 mov	 DWORD PTR tv172[ebp], eax
  001cb	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  001ce	8b 4d dc	 mov	 ecx, DWORD PTR tv172[ebp]
  001d1	89 08		 mov	 DWORD PTR [eax], ecx
  001d3	83 7d dc 00	 cmp	 DWORD PTR tv172[ebp], 0
  001d7	74 02		 je	 SHORT $LN69@PyCallClas
  001d9	eb 0d		 jmp	 SHORT $LN38@PyCallClas
$LN69@PyCallClas:
  001db	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  001de	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  001e1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e4	ff 50 18	 call	 DWORD PTR [eax+24]
  001e7	59		 pop	 ecx
$LN38@PyCallClas:
  001e8	33 c0		 xor	 eax, eax
  001ea	75 d6		 jne	 SHORT $LN40@PyCallClas
$LN35@PyCallClas:
  001ec	33 c0		 xor	 eax, eax
  001ee	75 ca		 jne	 SHORT $LN37@PyCallClas

; 442  : 	return true;

  001f0	b0 01		 mov	 al, 1
$LN1@PyCallClas:

; 443  : }

  001f2	c9		 leave
  001f3	c3		 ret	 0
?__PyCallClassMemberFunc@@YA_NPAU_object@@00PAPAU1@@Z ENDP ; __PyCallClassMemberFunc
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?__PyCallClassMemberFunc_ByPyString@@YA_NPAU_object@@00PAPAU1@@Z
_TEXT	SEGMENT
tv181 = -40						; size = 4
tv172 = -36						; size = 4
_poRet$ = -32						; size = 4
tv163 = -28						; size = 4
tv154 = -24						; size = 4
tv135 = -20						; size = 4
tv94 = -16						; size = 4
tv82 = -12						; size = 4
tv68 = -8						; size = 4
_poFunc$ = -4						; size = 4
_poClass$ = 8						; size = 4
_poFuncName$ = 12					; size = 4
_poArgs$ = 16						; size = 4
_ppoRet$ = 20						; size = 4
?__PyCallClassMemberFunc_ByPyString@@YA_NPAU_object@@00PAPAU1@@Z PROC ; __PyCallClassMemberFunc_ByPyString, COMDAT

; 359  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 360  : 	if (!poClass) 

  00006	83 7d 08 00	 cmp	 DWORD PTR _poClass$[ebp], 0
  0000a	75 3d		 jne	 SHORT $LN41@PyCallClas
$LN4@PyCallClas:

; 361  : 	{
; 362  : 		Py_XDECREF(poArgs);

  0000c	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  00010	75 02		 jne	 SHORT $LN7@PyCallClas
  00012	eb 2a		 jmp	 SHORT $LN2@PyCallClas
$LN7@PyCallClas:
  00014	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	48		 dec	 eax
  0001a	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  0001d	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00020	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	83 7d f8 00	 cmp	 DWORD PTR tv68[ebp], 0
  00029	74 02		 je	 SHORT $LN44@PyCallClas
  0002b	eb 0d		 jmp	 SHORT $LN5@PyCallClas
$LN44@PyCallClas:
  0002d	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  00030	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	ff 50 18	 call	 DWORD PTR [eax+24]
  00039	59		 pop	 ecx
$LN5@PyCallClas:
  0003a	33 c0		 xor	 eax, eax
  0003c	75 d6		 jne	 SHORT $LN7@PyCallClas
$LN2@PyCallClas:
  0003e	33 c0		 xor	 eax, eax
  00040	75 ca		 jne	 SHORT $LN4@PyCallClas

; 363  : 		return false;

  00042	32 c0		 xor	 al, al
  00044	e9 ea 01 00 00	 jmp	 $LN1@PyCallClas
$LN41@PyCallClas:

; 364  : 	}
; 365  : 
; 366  : 	PyObject * poFunc = PyObject_GetAttr(poClass, poFuncName);	// New Reference

  00049	ff 75 0c	 push	 DWORD PTR _poFuncName$[ebp]
  0004c	ff 75 08	 push	 DWORD PTR _poClass$[ebp]
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyObject_GetAttr
  00055	59		 pop	 ecx
  00056	59		 pop	 ecx
  00057	89 45 fc	 mov	 DWORD PTR _poFunc$[ebp], eax

; 367  : 
; 368  : 	if (!poFunc)

  0005a	83 7d fc 00	 cmp	 DWORD PTR _poFunc$[ebp], 0
  0005e	75 43		 jne	 SHORT $LN46@PyCallClas

; 369  : 	{		
; 370  : 		PyErr_Clear();

  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Clear
$LN10@PyCallClas:

; 371  : 		Py_XDECREF(poArgs);

  00066	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  0006a	75 02		 jne	 SHORT $LN13@PyCallClas
  0006c	eb 2a		 jmp	 SHORT $LN8@PyCallClas
$LN13@PyCallClas:
  0006e	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00071	8b 00		 mov	 eax, DWORD PTR [eax]
  00073	48		 dec	 eax
  00074	89 45 f4	 mov	 DWORD PTR tv82[ebp], eax
  00077	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR tv82[ebp]
  0007d	89 08		 mov	 DWORD PTR [eax], ecx
  0007f	83 7d f4 00	 cmp	 DWORD PTR tv82[ebp], 0
  00083	74 02		 je	 SHORT $LN49@PyCallClas
  00085	eb 0d		 jmp	 SHORT $LN11@PyCallClas
$LN49@PyCallClas:
  00087	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  0008a	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  0008d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00090	ff 50 18	 call	 DWORD PTR [eax+24]
  00093	59		 pop	 ecx
$LN11@PyCallClas:
  00094	33 c0		 xor	 eax, eax
  00096	75 d6		 jne	 SHORT $LN13@PyCallClas
$LN8@PyCallClas:
  00098	33 c0		 xor	 eax, eax
  0009a	75 ca		 jne	 SHORT $LN10@PyCallClas

; 372  : 		return false;

  0009c	32 c0		 xor	 al, al
  0009e	e9 90 01 00 00	 jmp	 $LN1@PyCallClas
$LN46@PyCallClas:

; 373  : 	}
; 374  : 
; 375  : 	if (!PyCallable_Check(poFunc)) 

  000a3	ff 75 fc	 push	 DWORD PTR _poFunc$[ebp]
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyCallable_Check
  000ac	59		 pop	 ecx
  000ad	85 c0		 test	 eax, eax
  000af	75 67		 jne	 SHORT $LN51@PyCallClas
$LN16@PyCallClas:

; 376  : 	{
; 377  : 		Py_DECREF(poFunc);

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  000b4	8b 00		 mov	 eax, DWORD PTR [eax]
  000b6	48		 dec	 eax
  000b7	89 45 f0	 mov	 DWORD PTR tv94[ebp], eax
  000ba	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  000bd	8b 4d f0	 mov	 ecx, DWORD PTR tv94[ebp]
  000c0	89 08		 mov	 DWORD PTR [eax], ecx
  000c2	83 7d f0 00	 cmp	 DWORD PTR tv94[ebp], 0
  000c6	74 02		 je	 SHORT $LN52@PyCallClas
  000c8	eb 0d		 jmp	 SHORT $LN14@PyCallClas
$LN52@PyCallClas:
  000ca	ff 75 fc	 push	 DWORD PTR _poFunc$[ebp]
  000cd	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  000d0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d3	ff 50 18	 call	 DWORD PTR [eax+24]
  000d6	59		 pop	 ecx
$LN14@PyCallClas:
  000d7	33 c0		 xor	 eax, eax
  000d9	75 d6		 jne	 SHORT $LN16@PyCallClas
$LN19@PyCallClas:

; 378  : 		Py_XDECREF(poArgs);

  000db	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  000df	75 02		 jne	 SHORT $LN22@PyCallClas
  000e1	eb 2a		 jmp	 SHORT $LN17@PyCallClas
$LN22@PyCallClas:
  000e3	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  000e6	8b 00		 mov	 eax, DWORD PTR [eax]
  000e8	48		 dec	 eax
  000e9	89 45 ec	 mov	 DWORD PTR tv135[ebp], eax
  000ec	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  000ef	8b 4d ec	 mov	 ecx, DWORD PTR tv135[ebp]
  000f2	89 08		 mov	 DWORD PTR [eax], ecx
  000f4	83 7d ec 00	 cmp	 DWORD PTR tv135[ebp], 0
  000f8	74 02		 je	 SHORT $LN56@PyCallClas
  000fa	eb 0d		 jmp	 SHORT $LN20@PyCallClas
$LN56@PyCallClas:
  000fc	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  000ff	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00102	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00105	ff 50 18	 call	 DWORD PTR [eax+24]
  00108	59		 pop	 ecx
$LN20@PyCallClas:
  00109	33 c0		 xor	 eax, eax
  0010b	75 d6		 jne	 SHORT $LN22@PyCallClas
$LN17@PyCallClas:
  0010d	33 c0		 xor	 eax, eax
  0010f	75 ca		 jne	 SHORT $LN19@PyCallClas

; 379  : 		return false;

  00111	32 c0		 xor	 al, al
  00113	e9 1b 01 00 00	 jmp	 $LN1@PyCallClas
$LN51@PyCallClas:

; 380  : 	}
; 381  : 
; 382  : 	PyObject * poRet = PyObject_CallObject(poFunc, poArgs);	// New Reference

  00118	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  0011b	ff 75 fc	 push	 DWORD PTR _poFunc$[ebp]
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyObject_CallObject
  00124	59		 pop	 ecx
  00125	59		 pop	 ecx
  00126	89 45 e0	 mov	 DWORD PTR _poRet$[ebp], eax

; 383  : 
; 384  : 	if (!poRet)

  00129	83 7d e0 00	 cmp	 DWORD PTR _poRet$[ebp], 0
  0012d	0f 85 96 00 00
	00		 jne	 $LN58@PyCallClas

; 385  : 	{
; 386  : 		if (g_pkExceptionSender)

  00133	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pkExceptionSender@@3PAVIPythonExceptionSender@@A, 0 ; g_pkExceptionSender
  0013a	74 0b		 je	 SHORT $LN59@PyCallClas

; 387  : 			g_pkExceptionSender->Clear();

  0013c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pkExceptionSender@@3PAVIPythonExceptionSender@@A ; g_pkExceptionSender
  00142	e8 00 00 00 00	 call	 ?Clear@IPythonExceptionSender@@QAEXXZ ; IPythonExceptionSender::Clear
$LN59@PyCallClas:

; 388  : 
; 389  : 		PyErr_Print();

  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Print

; 390  : 
; 391  : 		if (g_pkExceptionSender)

  0014d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pkExceptionSender@@3PAVIPythonExceptionSender@@A, 0 ; g_pkExceptionSender
  00154	74 0f		 je	 SHORT $LN25@PyCallClas

; 392  : 			g_pkExceptionSender->Send();

  00156	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pkExceptionSender@@3PAVIPythonExceptionSender@@A ; g_pkExceptionSender
  0015b	8b 00		 mov	 eax, DWORD PTR [eax]
  0015d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pkExceptionSender@@3PAVIPythonExceptionSender@@A ; g_pkExceptionSender
  00163	ff 10		 call	 DWORD PTR [eax]
$LN25@PyCallClas:

; 393  : 
; 394  : 		Py_DECREF(poFunc);

  00165	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  00168	8b 00		 mov	 eax, DWORD PTR [eax]
  0016a	48		 dec	 eax
  0016b	89 45 e8	 mov	 DWORD PTR tv154[ebp], eax
  0016e	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  00171	8b 4d e8	 mov	 ecx, DWORD PTR tv154[ebp]
  00174	89 08		 mov	 DWORD PTR [eax], ecx
  00176	83 7d e8 00	 cmp	 DWORD PTR tv154[ebp], 0
  0017a	74 02		 je	 SHORT $LN61@PyCallClas
  0017c	eb 0d		 jmp	 SHORT $LN23@PyCallClas
$LN61@PyCallClas:
  0017e	ff 75 fc	 push	 DWORD PTR _poFunc$[ebp]
  00181	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  00184	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00187	ff 50 18	 call	 DWORD PTR [eax+24]
  0018a	59		 pop	 ecx
$LN23@PyCallClas:
  0018b	33 c0		 xor	 eax, eax
  0018d	75 d6		 jne	 SHORT $LN25@PyCallClas
$LN28@PyCallClas:

; 395  : 		Py_XDECREF(poArgs);

  0018f	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  00193	75 02		 jne	 SHORT $LN31@PyCallClas
  00195	eb 2a		 jmp	 SHORT $LN26@PyCallClas
$LN31@PyCallClas:
  00197	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  0019a	8b 00		 mov	 eax, DWORD PTR [eax]
  0019c	48		 dec	 eax
  0019d	89 45 e4	 mov	 DWORD PTR tv163[ebp], eax
  001a0	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  001a3	8b 4d e4	 mov	 ecx, DWORD PTR tv163[ebp]
  001a6	89 08		 mov	 DWORD PTR [eax], ecx
  001a8	83 7d e4 00	 cmp	 DWORD PTR tv163[ebp], 0
  001ac	74 02		 je	 SHORT $LN65@PyCallClas
  001ae	eb 0d		 jmp	 SHORT $LN29@PyCallClas
$LN65@PyCallClas:
  001b0	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  001b3	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  001b6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b9	ff 50 18	 call	 DWORD PTR [eax+24]
  001bc	59		 pop	 ecx
$LN29@PyCallClas:
  001bd	33 c0		 xor	 eax, eax
  001bf	75 d6		 jne	 SHORT $LN31@PyCallClas
$LN26@PyCallClas:
  001c1	33 c0		 xor	 eax, eax
  001c3	75 ca		 jne	 SHORT $LN28@PyCallClas

; 396  : 		return false;

  001c5	32 c0		 xor	 al, al
  001c7	eb 6a		 jmp	 SHORT $LN1@PyCallClas
$LN58@PyCallClas:

; 397  : 	}
; 398  : 
; 399  : 	*ppoRet = poRet;

  001c9	8b 45 14	 mov	 eax, DWORD PTR _ppoRet$[ebp]
  001cc	8b 4d e0	 mov	 ecx, DWORD PTR _poRet$[ebp]
  001cf	89 08		 mov	 DWORD PTR [eax], ecx
$LN34@PyCallClas:

; 400  : 
; 401  : 	Py_DECREF(poFunc);

  001d1	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  001d4	8b 00		 mov	 eax, DWORD PTR [eax]
  001d6	48		 dec	 eax
  001d7	89 45 dc	 mov	 DWORD PTR tv172[ebp], eax
  001da	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  001dd	8b 4d dc	 mov	 ecx, DWORD PTR tv172[ebp]
  001e0	89 08		 mov	 DWORD PTR [eax], ecx
  001e2	83 7d dc 00	 cmp	 DWORD PTR tv172[ebp], 0
  001e6	74 02		 je	 SHORT $LN67@PyCallClas
  001e8	eb 0d		 jmp	 SHORT $LN32@PyCallClas
$LN67@PyCallClas:
  001ea	ff 75 fc	 push	 DWORD PTR _poFunc$[ebp]
  001ed	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  001f0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f3	ff 50 18	 call	 DWORD PTR [eax+24]
  001f6	59		 pop	 ecx
$LN32@PyCallClas:
  001f7	33 c0		 xor	 eax, eax
  001f9	75 d6		 jne	 SHORT $LN34@PyCallClas
$LN37@PyCallClas:

; 402  : 	Py_XDECREF(poArgs);

  001fb	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  001ff	75 02		 jne	 SHORT $LN40@PyCallClas
  00201	eb 2a		 jmp	 SHORT $LN35@PyCallClas
$LN40@PyCallClas:
  00203	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00206	8b 00		 mov	 eax, DWORD PTR [eax]
  00208	48		 dec	 eax
  00209	89 45 d8	 mov	 DWORD PTR tv181[ebp], eax
  0020c	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  0020f	8b 4d d8	 mov	 ecx, DWORD PTR tv181[ebp]
  00212	89 08		 mov	 DWORD PTR [eax], ecx
  00214	83 7d d8 00	 cmp	 DWORD PTR tv181[ebp], 0
  00218	74 02		 je	 SHORT $LN71@PyCallClas
  0021a	eb 0d		 jmp	 SHORT $LN38@PyCallClas
$LN71@PyCallClas:
  0021c	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  0021f	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00222	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00225	ff 50 18	 call	 DWORD PTR [eax+24]
  00228	59		 pop	 ecx
$LN38@PyCallClas:
  00229	33 c0		 xor	 eax, eax
  0022b	75 d6		 jne	 SHORT $LN40@PyCallClas
$LN35@PyCallClas:
  0022d	33 c0		 xor	 eax, eax
  0022f	75 ca		 jne	 SHORT $LN37@PyCallClas

; 403  : 	return true;

  00231	b0 01		 mov	 al, 1
$LN1@PyCallClas:

; 404  : }

  00233	c9		 leave
  00234	c3		 ret	 0
?__PyCallClassMemberFunc_ByPyString@@YA_NPAU_object@@00PAPAU1@@Z ENDP ; __PyCallClassMemberFunc_ByPyString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?__PyCallClassMemberFunc_ByCString@@YA_NPAU_object@@PBD0PAPAU1@@Z
_TEXT	SEGMENT
tv181 = -40						; size = 4
tv172 = -36						; size = 4
_poRet$ = -32						; size = 4
tv163 = -28						; size = 4
tv154 = -24						; size = 4
tv135 = -20						; size = 4
tv94 = -16						; size = 4
tv82 = -12						; size = 4
tv68 = -8						; size = 4
_poFunc$ = -4						; size = 4
_poClass$ = 8						; size = 4
_c_szFunc$ = 12						; size = 4
_poArgs$ = 16						; size = 4
_ppoRet$ = 20						; size = 4
?__PyCallClassMemberFunc_ByCString@@YA_NPAU_object@@PBD0PAPAU1@@Z PROC ; __PyCallClassMemberFunc_ByCString, COMDAT

; 311  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 312  : 	if (!poClass) 

  00006	83 7d 08 00	 cmp	 DWORD PTR _poClass$[ebp], 0
  0000a	75 3d		 jne	 SHORT $LN41@PyCallClas
$LN4@PyCallClas:

; 313  : 	{
; 314  : 		Py_XDECREF(poArgs);

  0000c	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  00010	75 02		 jne	 SHORT $LN7@PyCallClas
  00012	eb 2a		 jmp	 SHORT $LN2@PyCallClas
$LN7@PyCallClas:
  00014	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	48		 dec	 eax
  0001a	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  0001d	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00020	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	83 7d f8 00	 cmp	 DWORD PTR tv68[ebp], 0
  00029	74 02		 je	 SHORT $LN44@PyCallClas
  0002b	eb 0d		 jmp	 SHORT $LN5@PyCallClas
$LN44@PyCallClas:
  0002d	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  00030	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	ff 50 18	 call	 DWORD PTR [eax+24]
  00039	59		 pop	 ecx
$LN5@PyCallClas:
  0003a	33 c0		 xor	 eax, eax
  0003c	75 d6		 jne	 SHORT $LN7@PyCallClas
$LN2@PyCallClas:
  0003e	33 c0		 xor	 eax, eax
  00040	75 ca		 jne	 SHORT $LN4@PyCallClas

; 315  : 		return false;

  00042	32 c0		 xor	 al, al
  00044	e9 ea 01 00 00	 jmp	 $LN1@PyCallClas
$LN41@PyCallClas:

; 316  : 	}
; 317  : 
; 318  : 	PyObject * poFunc = PyObject_GetAttrString(poClass, (char *)c_szFunc);	// New Reference

  00049	ff 75 0c	 push	 DWORD PTR _c_szFunc$[ebp]
  0004c	ff 75 08	 push	 DWORD PTR _poClass$[ebp]
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyObject_GetAttrString
  00055	59		 pop	 ecx
  00056	59		 pop	 ecx
  00057	89 45 fc	 mov	 DWORD PTR _poFunc$[ebp], eax

; 319  : 
; 320  : 	if (!poFunc)

  0005a	83 7d fc 00	 cmp	 DWORD PTR _poFunc$[ebp], 0
  0005e	75 43		 jne	 SHORT $LN46@PyCallClas

; 321  : 	{		
; 322  : 		PyErr_Clear();

  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Clear
$LN10@PyCallClas:

; 323  : 		Py_XDECREF(poArgs);

  00066	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  0006a	75 02		 jne	 SHORT $LN13@PyCallClas
  0006c	eb 2a		 jmp	 SHORT $LN8@PyCallClas
$LN13@PyCallClas:
  0006e	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00071	8b 00		 mov	 eax, DWORD PTR [eax]
  00073	48		 dec	 eax
  00074	89 45 f4	 mov	 DWORD PTR tv82[ebp], eax
  00077	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR tv82[ebp]
  0007d	89 08		 mov	 DWORD PTR [eax], ecx
  0007f	83 7d f4 00	 cmp	 DWORD PTR tv82[ebp], 0
  00083	74 02		 je	 SHORT $LN49@PyCallClas
  00085	eb 0d		 jmp	 SHORT $LN11@PyCallClas
$LN49@PyCallClas:
  00087	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  0008a	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  0008d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00090	ff 50 18	 call	 DWORD PTR [eax+24]
  00093	59		 pop	 ecx
$LN11@PyCallClas:
  00094	33 c0		 xor	 eax, eax
  00096	75 d6		 jne	 SHORT $LN13@PyCallClas
$LN8@PyCallClas:
  00098	33 c0		 xor	 eax, eax
  0009a	75 ca		 jne	 SHORT $LN10@PyCallClas

; 324  : 		return false;

  0009c	32 c0		 xor	 al, al
  0009e	e9 90 01 00 00	 jmp	 $LN1@PyCallClas
$LN46@PyCallClas:

; 325  : 	}
; 326  : 
; 327  : 	if (!PyCallable_Check(poFunc)) 

  000a3	ff 75 fc	 push	 DWORD PTR _poFunc$[ebp]
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyCallable_Check
  000ac	59		 pop	 ecx
  000ad	85 c0		 test	 eax, eax
  000af	75 67		 jne	 SHORT $LN51@PyCallClas
$LN16@PyCallClas:

; 328  : 	{
; 329  : 		Py_DECREF(poFunc);

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  000b4	8b 00		 mov	 eax, DWORD PTR [eax]
  000b6	48		 dec	 eax
  000b7	89 45 f0	 mov	 DWORD PTR tv94[ebp], eax
  000ba	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  000bd	8b 4d f0	 mov	 ecx, DWORD PTR tv94[ebp]
  000c0	89 08		 mov	 DWORD PTR [eax], ecx
  000c2	83 7d f0 00	 cmp	 DWORD PTR tv94[ebp], 0
  000c6	74 02		 je	 SHORT $LN52@PyCallClas
  000c8	eb 0d		 jmp	 SHORT $LN14@PyCallClas
$LN52@PyCallClas:
  000ca	ff 75 fc	 push	 DWORD PTR _poFunc$[ebp]
  000cd	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  000d0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d3	ff 50 18	 call	 DWORD PTR [eax+24]
  000d6	59		 pop	 ecx
$LN14@PyCallClas:
  000d7	33 c0		 xor	 eax, eax
  000d9	75 d6		 jne	 SHORT $LN16@PyCallClas
$LN19@PyCallClas:

; 330  : 		Py_XDECREF(poArgs);

  000db	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  000df	75 02		 jne	 SHORT $LN22@PyCallClas
  000e1	eb 2a		 jmp	 SHORT $LN17@PyCallClas
$LN22@PyCallClas:
  000e3	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  000e6	8b 00		 mov	 eax, DWORD PTR [eax]
  000e8	48		 dec	 eax
  000e9	89 45 ec	 mov	 DWORD PTR tv135[ebp], eax
  000ec	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  000ef	8b 4d ec	 mov	 ecx, DWORD PTR tv135[ebp]
  000f2	89 08		 mov	 DWORD PTR [eax], ecx
  000f4	83 7d ec 00	 cmp	 DWORD PTR tv135[ebp], 0
  000f8	74 02		 je	 SHORT $LN56@PyCallClas
  000fa	eb 0d		 jmp	 SHORT $LN20@PyCallClas
$LN56@PyCallClas:
  000fc	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  000ff	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00102	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00105	ff 50 18	 call	 DWORD PTR [eax+24]
  00108	59		 pop	 ecx
$LN20@PyCallClas:
  00109	33 c0		 xor	 eax, eax
  0010b	75 d6		 jne	 SHORT $LN22@PyCallClas
$LN17@PyCallClas:
  0010d	33 c0		 xor	 eax, eax
  0010f	75 ca		 jne	 SHORT $LN19@PyCallClas

; 331  : 		return false;

  00111	32 c0		 xor	 al, al
  00113	e9 1b 01 00 00	 jmp	 $LN1@PyCallClas
$LN51@PyCallClas:

; 332  : 	}
; 333  : 
; 334  : 	PyObject * poRet = PyObject_CallObject(poFunc, poArgs);	// New Reference

  00118	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  0011b	ff 75 fc	 push	 DWORD PTR _poFunc$[ebp]
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyObject_CallObject
  00124	59		 pop	 ecx
  00125	59		 pop	 ecx
  00126	89 45 e0	 mov	 DWORD PTR _poRet$[ebp], eax

; 335  : 
; 336  : 	if (!poRet)

  00129	83 7d e0 00	 cmp	 DWORD PTR _poRet$[ebp], 0
  0012d	0f 85 96 00 00
	00		 jne	 $LN58@PyCallClas

; 337  : 	{
; 338  : 		if (g_pkExceptionSender)

  00133	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pkExceptionSender@@3PAVIPythonExceptionSender@@A, 0 ; g_pkExceptionSender
  0013a	74 0b		 je	 SHORT $LN59@PyCallClas

; 339  : 			g_pkExceptionSender->Clear();

  0013c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pkExceptionSender@@3PAVIPythonExceptionSender@@A ; g_pkExceptionSender
  00142	e8 00 00 00 00	 call	 ?Clear@IPythonExceptionSender@@QAEXXZ ; IPythonExceptionSender::Clear
$LN59@PyCallClas:

; 340  : 
; 341  : 		PyErr_Print();

  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Print

; 342  : 
; 343  : 		if (g_pkExceptionSender)

  0014d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pkExceptionSender@@3PAVIPythonExceptionSender@@A, 0 ; g_pkExceptionSender
  00154	74 0f		 je	 SHORT $LN25@PyCallClas

; 344  : 			g_pkExceptionSender->Send();

  00156	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_pkExceptionSender@@3PAVIPythonExceptionSender@@A ; g_pkExceptionSender
  0015b	8b 00		 mov	 eax, DWORD PTR [eax]
  0015d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_pkExceptionSender@@3PAVIPythonExceptionSender@@A ; g_pkExceptionSender
  00163	ff 10		 call	 DWORD PTR [eax]
$LN25@PyCallClas:

; 345  : 
; 346  : 		Py_DECREF(poFunc);

  00165	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  00168	8b 00		 mov	 eax, DWORD PTR [eax]
  0016a	48		 dec	 eax
  0016b	89 45 e8	 mov	 DWORD PTR tv154[ebp], eax
  0016e	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  00171	8b 4d e8	 mov	 ecx, DWORD PTR tv154[ebp]
  00174	89 08		 mov	 DWORD PTR [eax], ecx
  00176	83 7d e8 00	 cmp	 DWORD PTR tv154[ebp], 0
  0017a	74 02		 je	 SHORT $LN61@PyCallClas
  0017c	eb 0d		 jmp	 SHORT $LN23@PyCallClas
$LN61@PyCallClas:
  0017e	ff 75 fc	 push	 DWORD PTR _poFunc$[ebp]
  00181	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  00184	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00187	ff 50 18	 call	 DWORD PTR [eax+24]
  0018a	59		 pop	 ecx
$LN23@PyCallClas:
  0018b	33 c0		 xor	 eax, eax
  0018d	75 d6		 jne	 SHORT $LN25@PyCallClas
$LN28@PyCallClas:

; 347  : 		Py_XDECREF(poArgs);

  0018f	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  00193	75 02		 jne	 SHORT $LN31@PyCallClas
  00195	eb 2a		 jmp	 SHORT $LN26@PyCallClas
$LN31@PyCallClas:
  00197	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  0019a	8b 00		 mov	 eax, DWORD PTR [eax]
  0019c	48		 dec	 eax
  0019d	89 45 e4	 mov	 DWORD PTR tv163[ebp], eax
  001a0	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  001a3	8b 4d e4	 mov	 ecx, DWORD PTR tv163[ebp]
  001a6	89 08		 mov	 DWORD PTR [eax], ecx
  001a8	83 7d e4 00	 cmp	 DWORD PTR tv163[ebp], 0
  001ac	74 02		 je	 SHORT $LN65@PyCallClas
  001ae	eb 0d		 jmp	 SHORT $LN29@PyCallClas
$LN65@PyCallClas:
  001b0	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  001b3	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  001b6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b9	ff 50 18	 call	 DWORD PTR [eax+24]
  001bc	59		 pop	 ecx
$LN29@PyCallClas:
  001bd	33 c0		 xor	 eax, eax
  001bf	75 d6		 jne	 SHORT $LN31@PyCallClas
$LN26@PyCallClas:
  001c1	33 c0		 xor	 eax, eax
  001c3	75 ca		 jne	 SHORT $LN28@PyCallClas

; 348  : 		return false;

  001c5	32 c0		 xor	 al, al
  001c7	eb 6a		 jmp	 SHORT $LN1@PyCallClas
$LN58@PyCallClas:

; 349  : 	}
; 350  : 
; 351  : 	*ppoRet = poRet;

  001c9	8b 45 14	 mov	 eax, DWORD PTR _ppoRet$[ebp]
  001cc	8b 4d e0	 mov	 ecx, DWORD PTR _poRet$[ebp]
  001cf	89 08		 mov	 DWORD PTR [eax], ecx
$LN34@PyCallClas:

; 352  : 
; 353  : 	Py_DECREF(poFunc);

  001d1	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  001d4	8b 00		 mov	 eax, DWORD PTR [eax]
  001d6	48		 dec	 eax
  001d7	89 45 dc	 mov	 DWORD PTR tv172[ebp], eax
  001da	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  001dd	8b 4d dc	 mov	 ecx, DWORD PTR tv172[ebp]
  001e0	89 08		 mov	 DWORD PTR [eax], ecx
  001e2	83 7d dc 00	 cmp	 DWORD PTR tv172[ebp], 0
  001e6	74 02		 je	 SHORT $LN67@PyCallClas
  001e8	eb 0d		 jmp	 SHORT $LN32@PyCallClas
$LN67@PyCallClas:
  001ea	ff 75 fc	 push	 DWORD PTR _poFunc$[ebp]
  001ed	8b 45 fc	 mov	 eax, DWORD PTR _poFunc$[ebp]
  001f0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f3	ff 50 18	 call	 DWORD PTR [eax+24]
  001f6	59		 pop	 ecx
$LN32@PyCallClas:
  001f7	33 c0		 xor	 eax, eax
  001f9	75 d6		 jne	 SHORT $LN34@PyCallClas
$LN37@PyCallClas:

; 354  : 	Py_XDECREF(poArgs);

  001fb	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  001ff	75 02		 jne	 SHORT $LN40@PyCallClas
  00201	eb 2a		 jmp	 SHORT $LN35@PyCallClas
$LN40@PyCallClas:
  00203	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00206	8b 00		 mov	 eax, DWORD PTR [eax]
  00208	48		 dec	 eax
  00209	89 45 d8	 mov	 DWORD PTR tv181[ebp], eax
  0020c	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  0020f	8b 4d d8	 mov	 ecx, DWORD PTR tv181[ebp]
  00212	89 08		 mov	 DWORD PTR [eax], ecx
  00214	83 7d d8 00	 cmp	 DWORD PTR tv181[ebp], 0
  00218	74 02		 je	 SHORT $LN71@PyCallClas
  0021a	eb 0d		 jmp	 SHORT $LN38@PyCallClas
$LN71@PyCallClas:
  0021c	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  0021f	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00222	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00225	ff 50 18	 call	 DWORD PTR [eax+24]
  00228	59		 pop	 ecx
$LN38@PyCallClas:
  00229	33 c0		 xor	 eax, eax
  0022b	75 d6		 jne	 SHORT $LN40@PyCallClas
$LN35@PyCallClas:
  0022d	33 c0		 xor	 eax, eax
  0022f	75 ca		 jne	 SHORT $LN37@PyCallClas

; 355  : 	return true;

  00231	b0 01		 mov	 al, 1
$LN1@PyCallClas:

; 356  : }

  00233	c9		 leave
  00234	c3		 ret	 0
?__PyCallClassMemberFunc_ByCString@@YA_NPAU_object@@PBD0PAPAU1@@Z ENDP ; __PyCallClassMemberFunc_ByCString
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\stdafx.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\stdafx.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\stdafx.h
;	COMDAT ?Clear@IPythonExceptionSender@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
?Clear@IPythonExceptionSender@@QAEXXZ PROC		; IPythonExceptionSender::Clear, COMDAT
; _this$ = ecx

; 39   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0000e	e8 00 00 00 00	 call	 _strlen
  00013	59		 pop	 ecx
  00014	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00017	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  0001a	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001d	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\stdafx.h

; 40   : 			m_strExceptionString = "";

  00025	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\stdafx.h

; 41   : 		}

  00030	c9		 leave
  00031	c3		 ret	 0
?Clear@IPythonExceptionSender@@QAEXXZ ENDP		; IPythonExceptionSender::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?Py_BuildNone@@YAPAU_object@@XZ
_TEXT	SEGMENT
?Py_BuildNone@@YAPAU_object@@XZ PROC			; Py_BuildNone, COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 40   : 	Py_INCREF(Py_None);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	40		 inc	 eax
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___Py_NoneStruct
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 41   : 	return Py_None;

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct

; 42   : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?Py_BuildNone@@YAPAU_object@@XZ ENDP			; Py_BuildNone
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?Py_BadArgument@@YAPAU_object@@XZ
_TEXT	SEGMENT
?Py_BadArgument@@YAPAU_object@@XZ PROC			; Py_BadArgument, COMDAT

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15   : 	PyErr_BadArgument();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_BadArgument

; 16   : 	return NULL;

  00009	33 c0		 xor	 eax, eax

; 17   : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?Py_BadArgument@@YAPAU_object@@XZ ENDP			; Py_BadArgument
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?Py_BuildException@@YAPAU_object@@PBDZZ
_TEXT	SEGMENT
tv89 = -128						; size = 4
__Format$ = -124					; size = 4
_args$1 = -120						; size = 4
__Result$2 = -116					; size = 4
_szErrBuf$3 = -112					; size = 513
__$ArrayPad$ = 404					; size = 4
_c_pszErr$ = 416					; size = 4
?Py_BuildException@@YAPAU_object@@PBDZZ PROC		; Py_BuildException, COMDAT

; 20   : {

  00000	55		 push	 ebp
  00001	8d ac 24 68 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-408]
  00008	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 94 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 21   : 	if (!c_pszErr)

  0001b	83 bd a0 01 00
	00 00		 cmp	 DWORD PTR _c_pszErr$[ebp], 0
  00022	75 08		 jne	 SHORT $LN2@Py_BuildEx

; 22   : 		PyErr_Clear();

  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Clear
  0002a	eb 66		 jmp	 SHORT $LN3@Py_BuildEx
$LN2@Py_BuildEx:

; 23   : 	else
; 24   : 	{
; 25   : 		char szErrBuf[512+1];
; 26   : 		va_list args;
; 27   : 		va_start(args, c_pszErr);

  0002c	8d 85 a4 01 00
	00		 lea	 eax, DWORD PTR _c_pszErr$[ebp+4]
  00032	89 45 88	 mov	 DWORD PTR _args$1[ebp], eax

; 28   : 		vsnprintf(szErrBuf, sizeof(szErrBuf), c_pszErr, args);

  00035	8b 85 a0 01 00
	00		 mov	 eax, DWORD PTR _c_pszErr$[ebp]
  0003b	89 45 84	 mov	 DWORD PTR __Format$[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h

; 1390 :         int const _Result = __stdio_common_vsprintf(

  0003e	ff 75 88	 push	 DWORD PTR _args$1[ebp]
  00041	6a 00		 push	 0
  00043	ff 75 84	 push	 DWORD PTR __Format$[ebp]
  00046	68 01 02 00 00	 push	 513			; 00000201H
  0004b	8d 45 90	 lea	 eax, DWORD PTR _szErrBuf$3[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	83 c9 01	 or	 ecx, 1
  00059	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005c	50		 push	 eax
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00063	83 c4 1c	 add	 esp, 28			; 0000001cH
  00066	89 45 8c	 mov	 DWORD PTR __Result$2[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00069	83 7d 8c 00	 cmp	 DWORD PTR __Result$2[ebp], 0
  0006d	7d 06		 jge	 SHORT $LN9@Py_BuildEx
  0006f	83 4d 80 ff	 or	 DWORD PTR tv89[ebp], -1
  00073	eb 06		 jmp	 SHORT $LN5@Py_BuildEx
$LN9@Py_BuildEx:
  00075	8b 45 8c	 mov	 eax, DWORD PTR __Result$2[ebp]
  00078	89 45 80	 mov	 DWORD PTR tv89[ebp], eax
$LN5@Py_BuildEx:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp

; 29   : 		va_end(args);

  0007b	83 65 88 00	 and	 DWORD PTR _args$1[ebp], 0

; 30   : 
; 31   : 		PyErr_SetString(PyExc_RuntimeError, szErrBuf);

  0007f	8d 45 90	 lea	 eax, DWORD PTR _szErrBuf$3[ebp]
  00082	50		 push	 eax
  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  00088	ff 30		 push	 DWORD PTR [eax]
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN3@Py_BuildEx:

; 32   : 	}
; 33   : 
; 34   : 	return Py_BuildNone();

  00092	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 35   : 	//return NULL;
; 36   : }

  00097	8b 8d 94 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009d	33 cd		 xor	 ecx, ebp
  0009f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a4	81 c5 98 01 00
	00		 add	 ebp, 408		; 00000198H
  000aa	c9		 leave
  000ab	c3		 ret	 0
?Py_BuildException@@YAPAU_object@@PBDZZ ENDP		; Py_BuildException
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyCallClassMemberFunc@@YA_NPAU_object@@00@Z
_TEXT	SEGMENT
tv84 = -12						; size = 4
tv68 = -8						; size = 4
_poRet$ = -4						; size = 4
_poClass$ = 8						; size = 4
_poFunc$ = 12						; size = 4
_poArgs$ = 16						; size = 4
?PyCallClassMemberFunc@@YA_NPAU_object@@00@Z PROC	; PyCallClassMemberFunc, COMDAT

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 219  : 	PyObject* poRet;
; 220  : 
; 221  : 	// NOTE : NULL  .. - [levites]
; 222  : 	if (!poClass)

  00006	83 7d 08 00	 cmp	 DWORD PTR _poClass$[ebp], 0
  0000a	75 3a		 jne	 SHORT $LN11@PyCallClas
$LN4@PyCallClas:

; 223  : 	{
; 224  : 		Py_XDECREF(poArgs);

  0000c	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  00010	75 02		 jne	 SHORT $LN7@PyCallClas
  00012	eb 2a		 jmp	 SHORT $LN2@PyCallClas
$LN7@PyCallClas:
  00014	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	48		 dec	 eax
  0001a	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  0001d	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00020	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	83 7d f8 00	 cmp	 DWORD PTR tv68[ebp], 0
  00029	74 02		 je	 SHORT $LN14@PyCallClas
  0002b	eb 0d		 jmp	 SHORT $LN5@PyCallClas
$LN14@PyCallClas:
  0002d	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  00030	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	ff 50 18	 call	 DWORD PTR [eax+24]
  00039	59		 pop	 ecx
$LN5@PyCallClas:
  0003a	33 c0		 xor	 eax, eax
  0003c	75 d6		 jne	 SHORT $LN7@PyCallClas
$LN2@PyCallClas:
  0003e	33 c0		 xor	 eax, eax
  00040	75 ca		 jne	 SHORT $LN4@PyCallClas

; 225  : 		return false;

  00042	32 c0		 xor	 al, al
  00044	eb 4c		 jmp	 SHORT $LN1@PyCallClas
$LN11@PyCallClas:

; 226  : 	}
; 227  : 
; 228  : 	if (!__PyCallClassMemberFunc(poClass, poFunc, poArgs, &poRet))

  00046	8d 45 fc	 lea	 eax, DWORD PTR _poRet$[ebp]
  00049	50		 push	 eax
  0004a	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  0004d	ff 75 0c	 push	 DWORD PTR _poFunc$[ebp]
  00050	ff 75 08	 push	 DWORD PTR _poClass$[ebp]
  00053	e8 00 00 00 00	 call	 ?__PyCallClassMemberFunc@@YA_NPAU_object@@00PAPAU1@@Z ; __PyCallClassMemberFunc
  00058	83 c4 10	 add	 esp, 16			; 00000010H
  0005b	0f b6 c0	 movzx	 eax, al
  0005e	85 c0		 test	 eax, eax
  00060	75 04		 jne	 SHORT $LN10@PyCallClas

; 229  : 		return false;

  00062	32 c0		 xor	 al, al
  00064	eb 2c		 jmp	 SHORT $LN1@PyCallClas
$LN10@PyCallClas:

; 230  : 
; 231  : 	Py_DECREF(poRet);

  00066	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	48		 dec	 eax
  0006c	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00072	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00075	89 08		 mov	 DWORD PTR [eax], ecx
  00077	83 7d f4 00	 cmp	 DWORD PTR tv84[ebp], 0
  0007b	74 02		 je	 SHORT $LN17@PyCallClas
  0007d	eb 0d		 jmp	 SHORT $LN8@PyCallClas
$LN17@PyCallClas:
  0007f	ff 75 fc	 push	 DWORD PTR _poRet$[ebp]
  00082	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00085	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00088	ff 50 18	 call	 DWORD PTR [eax+24]
  0008b	59		 pop	 ecx
$LN8@PyCallClas:
  0008c	33 c0		 xor	 eax, eax
  0008e	75 d6		 jne	 SHORT $LN10@PyCallClas

; 232  : 	return true;

  00090	b0 01		 mov	 al, 1
$LN1@PyCallClas:

; 233  : }

  00092	c9		 leave
  00093	c3		 ret	 0
?PyCallClassMemberFunc@@YA_NPAU_object@@00@Z ENDP	; PyCallClassMemberFunc
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyCallClassMemberFunc_ByPyString@@YA_NPAU_object@@00@Z
_TEXT	SEGMENT
tv84 = -12						; size = 4
tv68 = -8						; size = 4
_poRet$ = -4						; size = 4
_poClass$ = 8						; size = 4
_poFuncName$ = 12					; size = 4
_poArgs$ = 16						; size = 4
?PyCallClassMemberFunc_ByPyString@@YA_NPAU_object@@00@Z PROC ; PyCallClassMemberFunc_ByPyString, COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 255  : 	PyObject* poRet;
; 256  : 
; 257  : 	// NOTE : NULL  .. - [levites]
; 258  : 	if (!poClass)

  00006	83 7d 08 00	 cmp	 DWORD PTR _poClass$[ebp], 0
  0000a	75 3a		 jne	 SHORT $LN11@PyCallClas
$LN4@PyCallClas:

; 259  : 	{
; 260  : 		Py_XDECREF(poArgs);

  0000c	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  00010	75 02		 jne	 SHORT $LN7@PyCallClas
  00012	eb 2a		 jmp	 SHORT $LN2@PyCallClas
$LN7@PyCallClas:
  00014	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	48		 dec	 eax
  0001a	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  0001d	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00020	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	83 7d f8 00	 cmp	 DWORD PTR tv68[ebp], 0
  00029	74 02		 je	 SHORT $LN14@PyCallClas
  0002b	eb 0d		 jmp	 SHORT $LN5@PyCallClas
$LN14@PyCallClas:
  0002d	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  00030	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	ff 50 18	 call	 DWORD PTR [eax+24]
  00039	59		 pop	 ecx
$LN5@PyCallClas:
  0003a	33 c0		 xor	 eax, eax
  0003c	75 d6		 jne	 SHORT $LN7@PyCallClas
$LN2@PyCallClas:
  0003e	33 c0		 xor	 eax, eax
  00040	75 ca		 jne	 SHORT $LN4@PyCallClas

; 261  : 		return false;

  00042	32 c0		 xor	 al, al
  00044	eb 4c		 jmp	 SHORT $LN1@PyCallClas
$LN11@PyCallClas:

; 262  : 	}
; 263  : 
; 264  : 	if (!__PyCallClassMemberFunc_ByPyString(poClass, poFuncName, poArgs, &poRet))

  00046	8d 45 fc	 lea	 eax, DWORD PTR _poRet$[ebp]
  00049	50		 push	 eax
  0004a	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  0004d	ff 75 0c	 push	 DWORD PTR _poFuncName$[ebp]
  00050	ff 75 08	 push	 DWORD PTR _poClass$[ebp]
  00053	e8 00 00 00 00	 call	 ?__PyCallClassMemberFunc_ByPyString@@YA_NPAU_object@@00PAPAU1@@Z ; __PyCallClassMemberFunc_ByPyString
  00058	83 c4 10	 add	 esp, 16			; 00000010H
  0005b	0f b6 c0	 movzx	 eax, al
  0005e	85 c0		 test	 eax, eax
  00060	75 04		 jne	 SHORT $LN10@PyCallClas

; 265  : 		return false;

  00062	32 c0		 xor	 al, al
  00064	eb 2c		 jmp	 SHORT $LN1@PyCallClas
$LN10@PyCallClas:

; 266  : 	
; 267  : 	Py_DECREF(poRet);

  00066	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	48		 dec	 eax
  0006c	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00072	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00075	89 08		 mov	 DWORD PTR [eax], ecx
  00077	83 7d f4 00	 cmp	 DWORD PTR tv84[ebp], 0
  0007b	74 02		 je	 SHORT $LN17@PyCallClas
  0007d	eb 0d		 jmp	 SHORT $LN8@PyCallClas
$LN17@PyCallClas:
  0007f	ff 75 fc	 push	 DWORD PTR _poRet$[ebp]
  00082	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00085	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00088	ff 50 18	 call	 DWORD PTR [eax+24]
  0008b	59		 pop	 ecx
$LN8@PyCallClas:
  0008c	33 c0		 xor	 eax, eax
  0008e	75 d6		 jne	 SHORT $LN10@PyCallClas

; 268  : 	return true;

  00090	b0 01		 mov	 al, 1
$LN1@PyCallClas:

; 269  : }

  00092	c9		 leave
  00093	c3		 ret	 0
?PyCallClassMemberFunc_ByPyString@@YA_NPAU_object@@00@Z ENDP ; PyCallClassMemberFunc_ByPyString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0PAJ@Z
_TEXT	SEGMENT
tv87 = -12						; size = 4
tv79 = -8						; size = 4
_poRet$ = -4						; size = 4
_poClass$ = 8						; size = 4
_c_szFunc$ = 12						; size = 4
_poArgs$ = 16						; size = 4
_plRetValue$ = 20					; size = 4
?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0PAJ@Z PROC	; PyCallClassMemberFunc, COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 289  : 	PyObject* poRet;
; 290  : 
; 291  : 	if (!__PyCallClassMemberFunc_ByCString(poClass, c_szFunc, poArgs, &poRet))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _poRet$[ebp]
  00009	50		 push	 eax
  0000a	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR _c_szFunc$[ebp]
  00010	ff 75 08	 push	 DWORD PTR _poClass$[ebp]
  00013	e8 00 00 00 00	 call	 ?__PyCallClassMemberFunc_ByCString@@YA_NPAU_object@@PBD0PAPAU1@@Z ; __PyCallClassMemberFunc_ByCString
  00018	83 c4 10	 add	 esp, 16			; 00000010H
  0001b	0f b6 c0	 movzx	 eax, al
  0001e	85 c0		 test	 eax, eax
  00020	75 04		 jne	 SHORT $LN8@PyCallClas

; 292  : 		return false;

  00022	32 c0		 xor	 al, al
  00024	eb 77		 jmp	 SHORT $LN1@PyCallClas
$LN8@PyCallClas:

; 293  : 
; 294  : 	if (PyNumber_Check(poRet))

  00026	ff 75 fc	 push	 DWORD PTR _poRet$[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyNumber_Check
  0002f	59		 pop	 ecx
  00030	85 c0		 test	 eax, eax
  00032	74 3d		 je	 SHORT $LN7@PyCallClas

; 295  : 	{
; 296  : 		*plRetValue = PyLong_AsLong(poRet);

  00034	ff 75 fc	 push	 DWORD PTR _poRet$[ebp]
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyLong_AsLongLong
  0003d	59		 pop	 ecx
  0003e	8b 4d 14	 mov	 ecx, DWORD PTR _plRetValue$[ebp]
  00041	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@PyCallClas:

; 297  : 		Py_DECREF(poRet);

  00043	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	48		 dec	 eax
  00049	89 45 f8	 mov	 DWORD PTR tv79[ebp], eax
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  00052	89 08		 mov	 DWORD PTR [eax], ecx
  00054	83 7d f8 00	 cmp	 DWORD PTR tv79[ebp], 0
  00058	74 02		 je	 SHORT $LN10@PyCallClas
  0005a	eb 0d		 jmp	 SHORT $LN2@PyCallClas
$LN10@PyCallClas:
  0005c	ff 75 fc	 push	 DWORD PTR _poRet$[ebp]
  0005f	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00062	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00065	ff 50 18	 call	 DWORD PTR [eax+24]
  00068	59		 pop	 ecx
$LN2@PyCallClas:
  00069	33 c0		 xor	 eax, eax
  0006b	75 d6		 jne	 SHORT $LN4@PyCallClas

; 298  : 		return true;

  0006d	b0 01		 mov	 al, 1
  0006f	eb 2c		 jmp	 SHORT $LN1@PyCallClas
$LN7@PyCallClas:

; 299  : 	}
; 300  : 
; 301  : 	Py_DECREF(poRet);

  00071	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00074	8b 00		 mov	 eax, DWORD PTR [eax]
  00076	48		 dec	 eax
  00077	89 45 f4	 mov	 DWORD PTR tv87[ebp], eax
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR tv87[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx
  00082	83 7d f4 00	 cmp	 DWORD PTR tv87[ebp], 0
  00086	74 02		 je	 SHORT $LN12@PyCallClas
  00088	eb 0d		 jmp	 SHORT $LN5@PyCallClas
$LN12@PyCallClas:
  0008a	ff 75 fc	 push	 DWORD PTR _poRet$[ebp]
  0008d	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00090	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00093	ff 50 18	 call	 DWORD PTR [eax+24]
  00096	59		 pop	 ecx
$LN5@PyCallClas:
  00097	33 c0		 xor	 eax, eax
  00099	75 d6		 jne	 SHORT $LN7@PyCallClas

; 302  : 	return false;

  0009b	32 c0		 xor	 al, al
$LN1@PyCallClas:

; 303  : }

  0009d	c9		 leave
  0009e	c3		 ret	 0
?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0PAJ@Z ENDP	; PyCallClassMemberFunc
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0PA_N@Z
_TEXT	SEGMENT
tv129 = -20						; size = 8
tv81 = -12						; size = 4
tv77 = -8						; size = 4
_poRet$ = -4						; size = 4
_poClass$ = 8						; size = 4
_c_szFunc$ = 12						; size = 4
_poArgs$ = 16						; size = 4
_pisRet$ = 20						; size = 4
?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0PA_N@Z PROC	; PyCallClassMemberFunc, COMDAT

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 273  : 	PyObject* poRet;
; 274  : 
; 275  : 	if (!__PyCallClassMemberFunc_ByCString(poClass, c_szFunc, poArgs, &poRet))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _poRet$[ebp]
  00009	50		 push	 eax
  0000a	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR _c_szFunc$[ebp]
  00010	ff 75 08	 push	 DWORD PTR _poClass$[ebp]
  00013	e8 00 00 00 00	 call	 ?__PyCallClassMemberFunc_ByCString@@YA_NPAU_object@@PBD0PAPAU1@@Z ; __PyCallClassMemberFunc_ByCString
  00018	83 c4 10	 add	 esp, 16			; 00000010H
  0001b	0f b6 c0	 movzx	 eax, al
  0001e	85 c0		 test	 eax, eax
  00020	75 04		 jne	 SHORT $LN5@PyCallClas

; 276  : 		return false;

  00022	32 c0		 xor	 al, al
  00024	eb 6f		 jmp	 SHORT $LN1@PyCallClas
$LN5@PyCallClas:

; 277  : 
; 278  : 	if (PyNumber_Check(poRet))

  00026	ff 75 fc	 push	 DWORD PTR _poRet$[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyNumber_Check
  0002f	59		 pop	 ecx
  00030	85 c0		 test	 eax, eax
  00032	74 2f		 je	 SHORT $LN6@PyCallClas

; 279  : 		*pisRet = (PyLong_AsLong(poRet) != 0);

  00034	ff 75 fc	 push	 DWORD PTR _poRet$[ebp]
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyLong_AsLongLong
  0003d	59		 pop	 ecx
  0003e	89 45 ec	 mov	 DWORD PTR tv129[ebp], eax
  00041	89 55 f0	 mov	 DWORD PTR tv129[ebp+4], edx
  00044	8b 45 ec	 mov	 eax, DWORD PTR tv129[ebp]
  00047	0b 45 f0	 or	 eax, DWORD PTR tv129[ebp+4]
  0004a	74 09		 je	 SHORT $LN11@PyCallClas
  0004c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  00053	eb 04		 jmp	 SHORT $LN12@PyCallClas
$LN11@PyCallClas:
  00055	83 65 f8 00	 and	 DWORD PTR tv77[ebp], 0
$LN12@PyCallClas:
  00059	8b 45 14	 mov	 eax, DWORD PTR _pisRet$[ebp]
  0005c	8a 4d f8	 mov	 cl, BYTE PTR tv77[ebp]
  0005f	88 08		 mov	 BYTE PTR [eax], cl
  00061	eb 06		 jmp	 SHORT $LN4@PyCallClas
$LN6@PyCallClas:

; 280  : 	else
; 281  : 		*pisRet = true;

  00063	8b 45 14	 mov	 eax, DWORD PTR _pisRet$[ebp]
  00066	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN4@PyCallClas:

; 282  : 
; 283  : 	Py_DECREF(poRet);

  00069	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  0006c	8b 00		 mov	 eax, DWORD PTR [eax]
  0006e	48		 dec	 eax
  0006f	89 45 f4	 mov	 DWORD PTR tv81[ebp], eax
  00072	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00075	8b 4d f4	 mov	 ecx, DWORD PTR tv81[ebp]
  00078	89 08		 mov	 DWORD PTR [eax], ecx
  0007a	83 7d f4 00	 cmp	 DWORD PTR tv81[ebp], 0
  0007e	74 02		 je	 SHORT $LN8@PyCallClas
  00080	eb 0d		 jmp	 SHORT $LN2@PyCallClas
$LN8@PyCallClas:
  00082	ff 75 fc	 push	 DWORD PTR _poRet$[ebp]
  00085	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00088	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008b	ff 50 18	 call	 DWORD PTR [eax+24]
  0008e	59		 pop	 ecx
$LN2@PyCallClas:
  0008f	33 c0		 xor	 eax, eax
  00091	75 d6		 jne	 SHORT $LN4@PyCallClas

; 284  : 	return true;

  00093	b0 01		 mov	 al, 1
$LN1@PyCallClas:

; 285  : }

  00095	c9		 leave
  00096	c3		 ret	 0
?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0PA_N@Z ENDP	; PyCallClassMemberFunc
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z
_TEXT	SEGMENT
tv84 = -12						; size = 4
tv68 = -8						; size = 4
_poRet$ = -4						; size = 4
_poClass$ = 8						; size = 4
_c_szFunc$ = 12						; size = 4
_poArgs$ = 16						; size = 4
?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z PROC	; PyCallClassMemberFunc, COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 237  : 	PyObject* poRet;
; 238  : 
; 239  : 	// NOTE : NULL  .. - [levites]
; 240  : 	if (!poClass)

  00006	83 7d 08 00	 cmp	 DWORD PTR _poClass$[ebp], 0
  0000a	75 3a		 jne	 SHORT $LN11@PyCallClas
$LN4@PyCallClas:

; 241  : 	{
; 242  : 		Py_XDECREF(poArgs);

  0000c	83 7d 10 00	 cmp	 DWORD PTR _poArgs$[ebp], 0
  00010	75 02		 jne	 SHORT $LN7@PyCallClas
  00012	eb 2a		 jmp	 SHORT $LN2@PyCallClas
$LN7@PyCallClas:
  00014	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	48		 dec	 eax
  0001a	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  0001d	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00020	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	83 7d f8 00	 cmp	 DWORD PTR tv68[ebp], 0
  00029	74 02		 je	 SHORT $LN14@PyCallClas
  0002b	eb 0d		 jmp	 SHORT $LN5@PyCallClas
$LN14@PyCallClas:
  0002d	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  00030	8b 45 10	 mov	 eax, DWORD PTR _poArgs$[ebp]
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	ff 50 18	 call	 DWORD PTR [eax+24]
  00039	59		 pop	 ecx
$LN5@PyCallClas:
  0003a	33 c0		 xor	 eax, eax
  0003c	75 d6		 jne	 SHORT $LN7@PyCallClas
$LN2@PyCallClas:
  0003e	33 c0		 xor	 eax, eax
  00040	75 ca		 jne	 SHORT $LN4@PyCallClas

; 243  : 		return false;

  00042	32 c0		 xor	 al, al
  00044	eb 4c		 jmp	 SHORT $LN1@PyCallClas
$LN11@PyCallClas:

; 244  : 	}
; 245  : 
; 246  : 	if (!__PyCallClassMemberFunc_ByCString(poClass, c_szFunc, poArgs, &poRet))

  00046	8d 45 fc	 lea	 eax, DWORD PTR _poRet$[ebp]
  00049	50		 push	 eax
  0004a	ff 75 10	 push	 DWORD PTR _poArgs$[ebp]
  0004d	ff 75 0c	 push	 DWORD PTR _c_szFunc$[ebp]
  00050	ff 75 08	 push	 DWORD PTR _poClass$[ebp]
  00053	e8 00 00 00 00	 call	 ?__PyCallClassMemberFunc_ByCString@@YA_NPAU_object@@PBD0PAPAU1@@Z ; __PyCallClassMemberFunc_ByCString
  00058	83 c4 10	 add	 esp, 16			; 00000010H
  0005b	0f b6 c0	 movzx	 eax, al
  0005e	85 c0		 test	 eax, eax
  00060	75 04		 jne	 SHORT $LN10@PyCallClas

; 247  : 		return false;

  00062	32 c0		 xor	 al, al
  00064	eb 2c		 jmp	 SHORT $LN1@PyCallClas
$LN10@PyCallClas:

; 248  : 
; 249  : 	Py_DECREF(poRet);

  00066	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	48		 dec	 eax
  0006c	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00072	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00075	89 08		 mov	 DWORD PTR [eax], ecx
  00077	83 7d f4 00	 cmp	 DWORD PTR tv84[ebp], 0
  0007b	74 02		 je	 SHORT $LN17@PyCallClas
  0007d	eb 0d		 jmp	 SHORT $LN8@PyCallClas
$LN17@PyCallClas:
  0007f	ff 75 fc	 push	 DWORD PTR _poRet$[ebp]
  00082	8b 45 fc	 mov	 eax, DWORD PTR _poRet$[ebp]
  00085	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00088	ff 50 18	 call	 DWORD PTR [eax+24]
  0008b	59		 pop	 ecx
$LN8@PyCallClas:
  0008c	33 c0		 xor	 eax, eax
  0008e	75 d6		 jne	 SHORT $LN10@PyCallClas

; 250  : 	return true;

  00090	b0 01		 mov	 al, 1
$LN1@PyCallClas:

; 251  : }

  00092	c9		 leave
  00093	c3		 ret	 0
?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ENDP	; PyCallClassMemberFunc
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetBoolean@@YA_NPAU_object@@HPA_N@Z
_TEXT	SEGMENT
tv84 = -16						; size = 8
_poItem$ = -8						; size = 4
tv74 = -1						; size = 1
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetBoolean@@YA_NPAU_object@@HPA_N@Z PROC	; PyTuple_GetBoolean, COMDAT

; 204  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 205  : 	if (pos >= PyTuple_Size(poArgs))

  00006	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0000f	59		 pop	 ecx
  00010	39 45 0c	 cmp	 DWORD PTR _pos$[ebp], eax
  00013	7c 04		 jl	 SHORT $LN2@PyTuple_Ge

; 206  : 		return false;

  00015	32 c0		 xor	 al, al
  00017	eb 47		 jmp	 SHORT $LN1@PyTuple_Ge
$LN2@PyTuple_Ge:

; 207  : 	
; 208  : 	PyObject* poItem = PyTuple_GetItem(poArgs, pos);

  00019	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0001c	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_GetItem
  00025	59		 pop	 ecx
  00026	59		 pop	 ecx
  00027	89 45 f8	 mov	 DWORD PTR _poItem$[ebp], eax

; 209  : 
; 210  : 	if (!poItem)

  0002a	83 7d f8 00	 cmp	 DWORD PTR _poItem$[ebp], 0
  0002e	75 04		 jne	 SHORT $LN3@PyTuple_Ge

; 211  : 		return false;

  00030	32 c0		 xor	 al, al
  00032	eb 2c		 jmp	 SHORT $LN1@PyTuple_Ge
$LN3@PyTuple_Ge:

; 212  : 
; 213  : 	*ret = PyLong_AsLong(poItem) ? true : false;

  00034	ff 75 f8	 push	 DWORD PTR _poItem$[ebp]
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyLong_AsLongLong
  0003d	59		 pop	 ecx
  0003e	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00041	89 55 f4	 mov	 DWORD PTR tv84[ebp+4], edx
  00044	8b 45 f0	 mov	 eax, DWORD PTR tv84[ebp]
  00047	0b 45 f4	 or	 eax, DWORD PTR tv84[ebp+4]
  0004a	74 06		 je	 SHORT $LN5@PyTuple_Ge
  0004c	c6 45 ff 01	 mov	 BYTE PTR tv74[ebp], 1
  00050	eb 04		 jmp	 SHORT $LN6@PyTuple_Ge
$LN5@PyTuple_Ge:
  00052	c6 45 ff 00	 mov	 BYTE PTR tv74[ebp], 0
$LN6@PyTuple_Ge:
  00056	8b 45 10	 mov	 eax, DWORD PTR _ret$[ebp]
  00059	8a 4d ff	 mov	 cl, BYTE PTR tv74[ebp]
  0005c	88 08		 mov	 BYTE PTR [eax], cl

; 214  : 	return true;

  0005e	b0 01		 mov	 al, 1
$LN1@PyTuple_Ge:

; 215  : }

  00060	c9		 leave
  00061	c3		 ret	 0
?PyTuple_GetBoolean@@YA_NPAU_object@@HPA_N@Z ENDP	; PyTuple_GetBoolean
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z
_TEXT	SEGMENT
_poItem$ = -4						; size = 4
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z PROC	; PyTuple_GetObject, COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 51   : 	if (pos >= PyTuple_Size(poArgs))

  00004	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0000d	59		 pop	 ecx
  0000e	39 45 0c	 cmp	 DWORD PTR _pos$[ebp], eax
  00011	7c 04		 jl	 SHORT $LN2@PyTuple_Ge

; 52   : 		return false;

  00013	32 c0		 xor	 al, al
  00015	eb 25		 jmp	 SHORT $LN1@PyTuple_Ge
$LN2@PyTuple_Ge:

; 53   : 
; 54   : 	PyObject * poItem = PyTuple_GetItem(poArgs, pos);

  00017	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_GetItem
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	89 45 fc	 mov	 DWORD PTR _poItem$[ebp], eax

; 55   : 
; 56   : 	if (!poItem)

  00028	83 7d fc 00	 cmp	 DWORD PTR _poItem$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN3@PyTuple_Ge

; 57   : 		return false;

  0002e	32 c0		 xor	 al, al
  00030	eb 0a		 jmp	 SHORT $LN1@PyTuple_Ge
$LN3@PyTuple_Ge:

; 58   : 	
; 59   : 	*ret = poItem;

  00032	8b 45 10	 mov	 eax, DWORD PTR _ret$[ebp]
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _poItem$[ebp]
  00038	89 08		 mov	 DWORD PTR [eax], ecx

; 60   : 	return true;

  0003a	b0 01		 mov	 al, 1
$LN1@PyTuple_Ge:

; 61   : }

  0003c	c9		 leave
  0003d	c3		 ret	 0
?PyTuple_GetObject@@YA_NPAU_object@@HPAPAU1@@Z ENDP	; PyTuple_GetObject
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetDouble@@YA_NPAU_object@@HPAN@Z
_TEXT	SEGMENT
_poItem$ = -4						; size = 4
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetDouble@@YA_NPAU_object@@HPAN@Z PROC		; PyTuple_GetDouble, COMDAT

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 79   : 	if (pos >= PyTuple_Size(poArgs))

  00004	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0000d	59		 pop	 ecx
  0000e	39 45 0c	 cmp	 DWORD PTR _pos$[ebp], eax
  00011	7c 04		 jl	 SHORT $LN2@PyTuple_Ge

; 80   : 		return false;

  00013	32 c0		 xor	 al, al
  00015	eb 2c		 jmp	 SHORT $LN1@PyTuple_Ge
$LN2@PyTuple_Ge:

; 81   : 
; 82   : 	PyObject* poItem = PyTuple_GetItem(poArgs, pos);

  00017	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_GetItem
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	89 45 fc	 mov	 DWORD PTR _poItem$[ebp], eax

; 83   : 
; 84   : 	if (!poItem)

  00028	83 7d fc 00	 cmp	 DWORD PTR _poItem$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN3@PyTuple_Ge

; 85   : 		return false;

  0002e	32 c0		 xor	 al, al
  00030	eb 11		 jmp	 SHORT $LN1@PyTuple_Ge
$LN3@PyTuple_Ge:

; 86   : 
; 87   : 	*ret = PyFloat_AsDouble(poItem);

  00032	ff 75 fc	 push	 DWORD PTR _poItem$[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyFloat_AsDouble
  0003b	59		 pop	 ecx
  0003c	8b 45 10	 mov	 eax, DWORD PTR _ret$[ebp]
  0003f	dd 18		 fstp	 QWORD PTR [eax]

; 88   : 	return true;

  00041	b0 01		 mov	 al, 1
$LN1@PyTuple_Ge:

; 89   : }

  00043	c9		 leave
  00044	c3		 ret	 0
?PyTuple_GetDouble@@YA_NPAU_object@@HPAN@Z ENDP		; PyTuple_GetDouble
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z
_TEXT	SEGMENT
_poItem$ = -4						; size = 4
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z PROC		; PyTuple_GetFloat, COMDAT

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 93   : 	if (pos >= PyTuple_Size(poArgs))

  00004	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0000d	59		 pop	 ecx
  0000e	39 45 0c	 cmp	 DWORD PTR _pos$[ebp], eax
  00011	7c 04		 jl	 SHORT $LN2@PyTuple_Ge

; 94   : 		return false;

  00013	32 c0		 xor	 al, al
  00015	eb 2c		 jmp	 SHORT $LN1@PyTuple_Ge
$LN2@PyTuple_Ge:

; 95   : 
; 96   : 	PyObject * poItem = PyTuple_GetItem(poArgs, pos);

  00017	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_GetItem
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	89 45 fc	 mov	 DWORD PTR _poItem$[ebp], eax

; 97   : 
; 98   : 	if (!poItem)

  00028	83 7d fc 00	 cmp	 DWORD PTR _poItem$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN3@PyTuple_Ge

; 99   : 		return false;

  0002e	32 c0		 xor	 al, al
  00030	eb 11		 jmp	 SHORT $LN1@PyTuple_Ge
$LN3@PyTuple_Ge:

; 100  : 
; 101  : 	*ret = float(PyFloat_AsDouble(poItem));

  00032	ff 75 fc	 push	 DWORD PTR _poItem$[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyFloat_AsDouble
  0003b	59		 pop	 ecx
  0003c	8b 45 10	 mov	 eax, DWORD PTR _ret$[ebp]
  0003f	d9 18		 fstp	 DWORD PTR [eax]

; 102  : 	return true;

  00041	b0 01		 mov	 al, 1
$LN1@PyTuple_Ge:

; 103  : }

  00043	c9		 leave
  00044	c3		 ret	 0
?PyTuple_GetFloat@@YA_NPAU_object@@HPAM@Z ENDP		; PyTuple_GetFloat
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetLongLong@@YA_NPAU_object@@HPA_J@Z
_TEXT	SEGMENT
_poItem$ = -4						; size = 4
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetLongLong@@YA_NPAU_object@@HPA_J@Z PROC	; PyTuple_GetLongLong, COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 160  : 	if (pos >= PyTuple_Size(poArgs))

  00004	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0000d	59		 pop	 ecx
  0000e	39 45 0c	 cmp	 DWORD PTR _pos$[ebp], eax
  00011	7c 04		 jl	 SHORT $LN2@PyTuple_Ge

; 161  : 		return false;

  00013	32 c0		 xor	 al, al
  00015	eb 2f		 jmp	 SHORT $LN1@PyTuple_Ge
$LN2@PyTuple_Ge:

; 162  : 
; 163  : 	PyObject* poItem = PyTuple_GetItem(poArgs, pos);

  00017	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_GetItem
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	89 45 fc	 mov	 DWORD PTR _poItem$[ebp], eax

; 164  : 
; 165  : 	if (!poItem)

  00028	83 7d fc 00	 cmp	 DWORD PTR _poItem$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN3@PyTuple_Ge

; 166  : 		return false;

  0002e	32 c0		 xor	 al, al
  00030	eb 14		 jmp	 SHORT $LN1@PyTuple_Ge
$LN3@PyTuple_Ge:

; 167  : 
; 168  : 	*ret = PyLong_AsLongLong(poItem);

  00032	ff 75 fc	 push	 DWORD PTR _poItem$[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyLong_AsLongLong
  0003b	59		 pop	 ecx
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _ret$[ebp]
  0003f	89 01		 mov	 DWORD PTR [ecx], eax
  00041	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 169  : 	return true;

  00044	b0 01		 mov	 al, 1
$LN1@PyTuple_Ge:

; 170  : }

  00046	c9		 leave
  00047	c3		 ret	 0
?PyTuple_GetLongLong@@YA_NPAU_object@@HPA_J@Z ENDP	; PyTuple_GetLongLong
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetUnsignedLong@@YA_NPAU_object@@HPAK@Z
_TEXT	SEGMENT
_poItem$ = -4						; size = 4
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetUnsignedLong@@YA_NPAU_object@@HPAK@Z PROC	; PyTuple_GetUnsignedLong, COMDAT

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 146  : 	if (pos >= PyTuple_Size(poArgs))

  00004	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0000d	59		 pop	 ecx
  0000e	39 45 0c	 cmp	 DWORD PTR _pos$[ebp], eax
  00011	7c 04		 jl	 SHORT $LN2@PyTuple_Ge

; 147  : 		return false;

  00013	32 c0		 xor	 al, al
  00015	eb 2c		 jmp	 SHORT $LN1@PyTuple_Ge
$LN2@PyTuple_Ge:

; 148  : 
; 149  : 	PyObject * poItem = PyTuple_GetItem(poArgs, pos);

  00017	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_GetItem
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	89 45 fc	 mov	 DWORD PTR _poItem$[ebp], eax

; 150  : 	
; 151  : 	if (!poItem)

  00028	83 7d fc 00	 cmp	 DWORD PTR _poItem$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN3@PyTuple_Ge

; 152  : 		return false;

  0002e	32 c0		 xor	 al, al
  00030	eb 11		 jmp	 SHORT $LN1@PyTuple_Ge
$LN3@PyTuple_Ge:

; 153  : 	
; 154  : 	*ret = PyLong_AsUnsignedLong(poItem);

  00032	ff 75 fc	 push	 DWORD PTR _poItem$[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyLong_AsUnsignedLongLong
  0003b	59		 pop	 ecx
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _ret$[ebp]
  0003f	89 01		 mov	 DWORD PTR [ecx], eax

; 155  : 	return true;

  00041	b0 01		 mov	 al, 1
$LN1@PyTuple_Ge:

; 156  : }

  00043	c9		 leave
  00044	c3		 ret	 0
?PyTuple_GetUnsignedLong@@YA_NPAU_object@@HPAK@Z ENDP	; PyTuple_GetUnsignedLong
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetLong@@YA_NPAU_object@@HPAJ@Z
_TEXT	SEGMENT
_poItem$ = -4						; size = 4
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetLong@@YA_NPAU_object@@HPAJ@Z PROC		; PyTuple_GetLong, COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 65   : 	if (pos >= PyTuple_Size(poArgs))

  00004	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0000d	59		 pop	 ecx
  0000e	39 45 0c	 cmp	 DWORD PTR _pos$[ebp], eax
  00011	7c 04		 jl	 SHORT $LN2@PyTuple_Ge

; 66   : 		return false;

  00013	32 c0		 xor	 al, al
  00015	eb 2c		 jmp	 SHORT $LN1@PyTuple_Ge
$LN2@PyTuple_Ge:

; 67   : 
; 68   : 	PyObject* poItem = PyTuple_GetItem(poArgs, pos);

  00017	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_GetItem
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	89 45 fc	 mov	 DWORD PTR _poItem$[ebp], eax

; 69   : 
; 70   : 	if (!poItem)

  00028	83 7d fc 00	 cmp	 DWORD PTR _poItem$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN3@PyTuple_Ge

; 71   : 		return false;

  0002e	32 c0		 xor	 al, al
  00030	eb 11		 jmp	 SHORT $LN1@PyTuple_Ge
$LN3@PyTuple_Ge:

; 72   : 
; 73   : 	*ret = PyLong_AsLong(poItem);

  00032	ff 75 fc	 push	 DWORD PTR _poItem$[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyLong_AsLongLong
  0003b	59		 pop	 ecx
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _ret$[ebp]
  0003f	89 01		 mov	 DWORD PTR [ecx], eax

; 74   : 	return true;

  00041	b0 01		 mov	 al, 1
$LN1@PyTuple_Ge:

; 75   : }

  00043	c9		 leave
  00044	c3		 ret	 0
?PyTuple_GetLong@@YA_NPAU_object@@HPAJ@Z ENDP		; PyTuple_GetLong
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetUnsignedInteger@@YA_NPAU_object@@HPAI@Z
_TEXT	SEGMENT
_poItem$ = -4						; size = 4
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetUnsignedInteger@@YA_NPAU_object@@HPAI@Z PROC ; PyTuple_GetUnsignedInteger, COMDAT

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 174  : 	if (pos >= PyTuple_Size(poArgs))

  00004	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0000d	59		 pop	 ecx
  0000e	39 45 0c	 cmp	 DWORD PTR _pos$[ebp], eax
  00011	7c 04		 jl	 SHORT $LN2@PyTuple_Ge

; 175  : 		return false;

  00013	32 c0		 xor	 al, al
  00015	eb 2c		 jmp	 SHORT $LN1@PyTuple_Ge
$LN2@PyTuple_Ge:

; 176  : 
; 177  : 	PyObject* poItem = PyTuple_GetItem(poArgs, pos);

  00017	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_GetItem
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	89 45 fc	 mov	 DWORD PTR _poItem$[ebp], eax

; 178  : 	
; 179  : 	if (!poItem)

  00028	83 7d fc 00	 cmp	 DWORD PTR _poItem$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN3@PyTuple_Ge

; 180  : 		return false;

  0002e	32 c0		 xor	 al, al
  00030	eb 11		 jmp	 SHORT $LN1@PyTuple_Ge
$LN3@PyTuple_Ge:

; 181  : 	
; 182  : 	*ret = PyLong_AsUnsignedLong(poItem);

  00032	ff 75 fc	 push	 DWORD PTR _poItem$[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyLong_AsUnsignedLongLong
  0003b	59		 pop	 ecx
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _ret$[ebp]
  0003f	89 01		 mov	 DWORD PTR [ecx], eax

; 183  : 	return true;

  00041	b0 01		 mov	 al, 1
$LN1@PyTuple_Ge:

; 184  : }

  00043	c9		 leave
  00044	c3		 ret	 0
?PyTuple_GetUnsignedInteger@@YA_NPAU_object@@HPAI@Z ENDP ; PyTuple_GetUnsignedInteger
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z
_TEXT	SEGMENT
_val$ = -8						; size = 4
_result$ = -1						; size = 1
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z PROC		; PyTuple_GetByte, COMDAT

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 107  : 	int val;
; 108  : 	bool result = PyTuple_GetInteger(poArgs,pos,&val);

  00005	8d 45 f8	 lea	 eax, DWORD PTR _val$[ebp]
  00008	50		 push	 eax
  00009	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	88 45 ff	 mov	 BYTE PTR _result$[ebp], al

; 109  : 	*ret = unsigned char(val);

  0001a	8b 45 10	 mov	 eax, DWORD PTR _ret$[ebp]
  0001d	8a 4d f8	 mov	 cl, BYTE PTR _val$[ebp]
  00020	88 08		 mov	 BYTE PTR [eax], cl

; 110  : 	return result;

  00022	8a 45 ff	 mov	 al, BYTE PTR _result$[ebp]

; 111  : }

  00025	c9		 leave
  00026	c3		 ret	 0
?PyTuple_GetByte@@YA_NPAU_object@@HPAE@Z ENDP		; PyTuple_GetByte
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z
_TEXT	SEGMENT
_val$ = -8						; size = 4
_result$ = -1						; size = 1
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z PROC	; PyTuple_GetInteger, COMDAT

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 124  : 	int val;
; 125  : 	bool result = PyTuple_GetInteger(poArgs,pos,&val);

  00005	8d 45 f8	 lea	 eax, DWORD PTR _val$[ebp]
  00008	50		 push	 eax
  00009	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	88 45 ff	 mov	 BYTE PTR _result$[ebp], al

; 126  : 	*ret = WORD(val);

  0001a	8b 45 10	 mov	 eax, DWORD PTR _ret$[ebp]
  0001d	66 8b 4d f8	 mov	 cx, WORD PTR _val$[ebp]
  00021	66 89 08	 mov	 WORD PTR [eax], cx

; 127  : 	return result;

  00024	8a 45 ff	 mov	 al, BYTE PTR _result$[ebp]

; 128  : }

  00027	c9		 leave
  00028	c3		 ret	 0
?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ENDP	; PyTuple_GetInteger
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z
_TEXT	SEGMENT
_poItem$ = -4						; size = 4
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z PROC	; PyTuple_GetInteger, COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 132  : 	if (pos >= PyTuple_Size(poArgs))

  00004	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0000d	59		 pop	 ecx
  0000e	39 45 0c	 cmp	 DWORD PTR _pos$[ebp], eax
  00011	7c 04		 jl	 SHORT $LN2@PyTuple_Ge

; 133  : 		return false;

  00013	32 c0		 xor	 al, al
  00015	eb 2c		 jmp	 SHORT $LN1@PyTuple_Ge
$LN2@PyTuple_Ge:

; 134  : 
; 135  : 	PyObject* poItem = PyTuple_GetItem(poArgs, pos);

  00017	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_GetItem
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	89 45 fc	 mov	 DWORD PTR _poItem$[ebp], eax

; 136  : 	
; 137  : 	if (!poItem)

  00028	83 7d fc 00	 cmp	 DWORD PTR _poItem$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN3@PyTuple_Ge

; 138  : 		return false;

  0002e	32 c0		 xor	 al, al
  00030	eb 11		 jmp	 SHORT $LN1@PyTuple_Ge
$LN3@PyTuple_Ge:

; 139  : 	
; 140  : 	*ret = PyLong_AsLong(poItem);

  00032	ff 75 fc	 push	 DWORD PTR _poItem$[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyLong_AsLongLong
  0003b	59		 pop	 ecx
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _ret$[ebp]
  0003f	89 01		 mov	 DWORD PTR [ecx], eax

; 141  : 	return true;

  00041	b0 01		 mov	 al, 1
$LN1@PyTuple_Ge:

; 142  : }

  00043	c9		 leave
  00044	c3		 ret	 0
?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ENDP	; PyTuple_GetInteger
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z
_TEXT	SEGMENT
_val$ = -8						; size = 4
_result$ = -1						; size = 1
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z PROC	; PyTuple_GetInteger, COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 115  : 	int val;
; 116  : 	bool result = PyTuple_GetInteger(poArgs,pos,&val);

  00005	8d 45 f8	 lea	 eax, DWORD PTR _val$[ebp]
  00008	50		 push	 eax
  00009	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	88 45 ff	 mov	 BYTE PTR _result$[ebp], al

; 117  : 	*ret = unsigned char(val);

  0001a	8b 45 10	 mov	 eax, DWORD PTR _ret$[ebp]
  0001d	8a 4d f8	 mov	 cl, BYTE PTR _val$[ebp]
  00020	88 08		 mov	 BYTE PTR [eax], cl

; 118  : 	return result;

  00022	8a 45 ff	 mov	 al, BYTE PTR _result$[ebp]

; 119  : }

  00025	c9		 leave
  00026	c3		 ret	 0
?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ENDP	; PyTuple_GetInteger
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\scriptLib\PythonUtils.cpp
;	COMDAT ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z
_TEXT	SEGMENT
_poItem$ = -4						; size = 4
_poArgs$ = 8						; size = 4
_pos$ = 12						; size = 4
_ret$ = 16						; size = 4
?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z PROC	; PyTuple_GetString, COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 188  : 	if (pos >= PyTuple_Size(poArgs))

  00004	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_Size
  0000d	59		 pop	 ecx
  0000e	39 45 0c	 cmp	 DWORD PTR _pos$[ebp], eax
  00011	7c 04		 jl	 SHORT $LN2@PyTuple_Ge

; 189  : 		return false;

  00013	32 c0		 xor	 al, al
  00015	eb 40		 jmp	 SHORT $LN1@PyTuple_Ge
$LN2@PyTuple_Ge:

; 190  : 
; 191  : 	PyObject* poItem = PyTuple_GetItem(poArgs, pos);

  00017	ff 75 0c	 push	 DWORD PTR _pos$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR _poArgs$[ebp]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_GetItem
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	89 45 fc	 mov	 DWORD PTR _poItem$[ebp], eax

; 192  : 
; 193  : 	if (!poItem)

  00028	83 7d fc 00	 cmp	 DWORD PTR _poItem$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN3@PyTuple_Ge

; 194  : 		return false;

  0002e	32 c0		 xor	 al, al
  00030	eb 25		 jmp	 SHORT $LN1@PyTuple_Ge
$LN3@PyTuple_Ge:

; 195  : 
; 196  : 	if (!PyString_Check(poItem)) 

  00032	8b 45 fc	 mov	 eax, DWORD PTR _poItem$[ebp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  0003b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00040	75 04		 jne	 SHORT $LN4@PyTuple_Ge

; 197  : 		return false;

  00042	32 c0		 xor	 al, al
  00044	eb 11		 jmp	 SHORT $LN1@PyTuple_Ge
$LN4@PyTuple_Ge:

; 198  : 
; 199  : 	*ret = PyString_AsString(poItem);

  00046	ff 75 fc	 push	 DWORD PTR _poItem$[ebp]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyString_AsString
  0004f	59		 pop	 ecx
  00050	8b 4d 10	 mov	 ecx, DWORD PTR _ret$[ebp]
  00053	89 01		 mov	 DWORD PTR [ecx], eax

; 200  : 	return true;

  00055	b0 01		 mov	 al, 1
$LN1@PyTuple_Ge:

; 201  : }

  00057	c9		 leave
  00058	c3		 ret	 0
?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ENDP	; PyTuple_GetString
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
