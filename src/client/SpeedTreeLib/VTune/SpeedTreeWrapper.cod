; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ms_bSelfShadowOn@CSpeedTreeWrapper@@2_NA	; CSpeedTreeWrapper::ms_bSelfShadowOn
PUBLIC	?ms_dwBranchVertexShader@CSpeedTreeWrapper@@0KA	; CSpeedTreeWrapper::ms_dwBranchVertexShader
PUBLIC	?ms_dwLeafVertexShader@CSpeedTreeWrapper@@0KA	; CSpeedTreeWrapper::ms_dwLeafVertexShader
_BSS	SEGMENT
?ms_dwBranchVertexShader@CSpeedTreeWrapper@@0KA DD 01H DUP (?) ; CSpeedTreeWrapper::ms_dwBranchVertexShader
?ms_dwLeafVertexShader@CSpeedTreeWrapper@@0KA DD 01H DUP (?) ; CSpeedTreeWrapper::ms_dwLeafVertexShader
_BSS	ENDS
CONST	SEGMENT
?g_achSimpleVertexProgram@@3QBDB DB 'vs.1.1', 0aH, 'mov', 09H, 09H, 'oT0.'
	DB	'xy,', 09H, 09H, 'v7', 0aH, 'mov', 09H, 09H, 'oT1.xy,', 09H, 09H
	DB	'v8', 0aH, 'mov', 09H, 09H, 'a0.x,', 09H, 'v9.x', 0aH, 'm4x4', 09H
	DB	09H, 'r1,', 09H, 09H, 09H, 'v0,', 09H, 09H, 09H, 'c[54+a0.x]', 0aH
	DB	'sub', 09H, 09H, 'r2,', 09H, 09H, 09H, 'r1,', 09H, 09H, 09H, 'v'
	DB	'0', 0aH, 'mov', 09H, 09H, 'r3.x,', 09H, 09H, 'v9.y', 0aH, 'ma'
	DB	'd', 09H, 09H, 'r1,', 09H, 09H, 09H, 'r2,', 09H, 09H, 09H, 'r3'
	DB	'.x,', 09H, 09H, 'v0', 0aH, 'add', 09H, 09H, 'r2,', 09H, 09H, 09H
	DB	'c[52],', 09H, 09H, 'r1', 0aH, 'm4x4', 09H, 09H, 'oPos,', 09H, 09H
	DB	'r2,', 09H, 09H, 09H, 'c[0]', 0aH, 'dp4', 09H, 09H, 'r1,', 09H
	DB	09H, 09H, 'r2,', 09H, 09H, 09H, 'c[2]', 0aH, 'sub', 09H, 09H, 'r'
	DB	'2.x,', 09H, 09H, 'c[85].y,', 09H, 'r1.z', 0aH, 'mul', 09H, 09H
	DB	'oFog,', 09H, 09H, 'r2.x,', 09H, 09H, 'c[85].z', 0aH, 'mov', 09H
	DB	09H, 'oD0,', 09H, 09H, 'v5', 0aH, 00H	; g_achSimpleVertexProgram
CONST	ENDS
_DATA	SEGMENT
?ms_bSelfShadowOn@CSpeedTreeWrapper@@2_NA DB 01H	; CSpeedTreeWrapper::ms_bSelfShadowOn
_DATA	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??_GCSpeedTreeRT@@QAEPAXI@Z			; CSpeedTreeRT::`scalar deleting destructor'
PUBLIC	??0CSpeedTreeMaterial@@QAE@XZ			; CSpeedTreeMaterial::CSpeedTreeMaterial
PUBLIC	?Set@CSpeedTreeMaterial@@QAEXPBM@Z		; CSpeedTreeMaterial::Set
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	_sprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?GetPath@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; CFileNameHelper::GetPath
PUBLIC	?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; CFileNameHelper::NoExtension
PUBLIC	?OnClear@CGraphicObjectInstance@@UAEXXZ		; CGraphicObjectInstance::OnClear
PUBLIC	?OnUpdate@CGraphicObjectInstance@@UAEXXZ	; CGraphicObjectInstance::OnUpdate
PUBLIC	?OnDeform@CGraphicObjectInstance@@UAEXXZ	; CGraphicObjectInstance::OnDeform
PUBLIC	?GetType@CSpeedTreeWrapper@@EBEHXZ		; CSpeedTreeWrapper::GetType
PUBLIC	?OnUpdateCollisionData@CSpeedTreeWrapper@@MAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z ; CSpeedTreeWrapper::OnUpdateCollisionData
PUBLIC	?OnUpdateHeighInstance@CSpeedTreeWrapper@@MAEXPAVCAttributeInstance@@@Z ; CSpeedTreeWrapper::OnUpdateHeighInstance
PUBLIC	?OnGetObjectHeight@CSpeedTreeWrapper@@MAE_NMMPAM@Z ; CSpeedTreeWrapper::OnGetObjectHeight
PUBLIC	?GetBoundingSphere@CSpeedTreeWrapper@@UAE_NAAUD3DXVECTOR3@@AAM@Z ; CSpeedTreeWrapper::GetBoundingSphere
PUBLIC	?SetPosition@CSpeedTreeWrapper@@UAEXMMM@Z	; CSpeedTreeWrapper::SetPosition
PUBLIC	?CalculateBBox@CSpeedTreeWrapper@@UAEXXZ	; CSpeedTreeWrapper::CalculateBBox
PUBLIC	?OnRender@CSpeedTreeWrapper@@UAEXXZ		; CSpeedTreeWrapper::OnRender
PUBLIC	?OnBlendRender@CSpeedTreeWrapper@@UAEXXZ	; CSpeedTreeWrapper::OnBlendRender
PUBLIC	?OnRenderToShadowMap@CSpeedTreeWrapper@@UAEXXZ	; CSpeedTreeWrapper::OnRenderToShadowMap
PUBLIC	?OnRenderShadow@CSpeedTreeWrapper@@UAEXXZ	; CSpeedTreeWrapper::OnRenderShadow
PUBLIC	?OnRenderPCBlocker@CSpeedTreeWrapper@@UAEXXZ	; CSpeedTreeWrapper::OnRenderPCBlocker
PUBLIC	??0CSpeedTreeWrapper@@QAE@XZ			; CSpeedTreeWrapper::CSpeedTreeWrapper
PUBLIC	??1CSpeedTreeWrapper@@UAE@XZ			; CSpeedTreeWrapper::~CSpeedTreeWrapper
PUBLIC	?GetPosition@CSpeedTreeWrapper@@QAEPBMXZ	; CSpeedTreeWrapper::GetPosition
PUBLIC	?SetVertexShaders@CSpeedTreeWrapper@@SAXKK@Z	; CSpeedTreeWrapper::SetVertexShaders
PUBLIC	?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z	; CSpeedTreeWrapper::LoadTree
PUBLIC	?GetTreeSize@CSpeedTreeWrapper@@QAEXAAM0@Z	; CSpeedTreeWrapper::GetTreeSize
PUBLIC	?GetCollisionObjectCount@CSpeedTreeWrapper@@QAEIXZ ; CSpeedTreeWrapper::GetCollisionObjectCount
PUBLIC	?GetCollisionObject@CSpeedTreeWrapper@@QAEXIAAW4ECollisionObjectType@CSpeedTreeRT@@PAM1@Z ; CSpeedTreeWrapper::GetCollisionObject
PUBLIC	?SetupBranchForTreeType@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::SetupBranchForTreeType
PUBLIC	?SetupFrondForTreeType@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::SetupFrondForTreeType
PUBLIC	?SetupLeafForTreeType@CSpeedTreeWrapper@@QBEXXZ	; CSpeedTreeWrapper::SetupLeafForTreeType
PUBLIC	?EndLeafForTreeType@CSpeedTreeWrapper@@QAEXXZ	; CSpeedTreeWrapper::EndLeafForTreeType
PUBLIC	?RenderBranches@CSpeedTreeWrapper@@QBEXXZ	; CSpeedTreeWrapper::RenderBranches
PUBLIC	?RenderFronds@CSpeedTreeWrapper@@QBEXXZ		; CSpeedTreeWrapper::RenderFronds
PUBLIC	?RenderLeaves@CSpeedTreeWrapper@@QBEXXZ		; CSpeedTreeWrapper::RenderLeaves
PUBLIC	?RenderBillboards@CSpeedTreeWrapper@@QBEXXZ	; CSpeedTreeWrapper::RenderBillboards
PUBLIC	?GetInstances@CSpeedTreeWrapper@@QAEPAPAV1@AAI@Z ; CSpeedTreeWrapper::GetInstances
PUBLIC	?MakeInstance@CSpeedTreeWrapper@@QAEPAV1@XZ	; CSpeedTreeWrapper::MakeInstance
PUBLIC	?DeleteInstance@CSpeedTreeWrapper@@QAEXPAV1@@Z	; CSpeedTreeWrapper::DeleteInstance
PUBLIC	?Advance@CSpeedTreeWrapper@@QAEXXZ		; CSpeedTreeWrapper::Advance
PUBLIC	?CleanUpMemory@CSpeedTreeWrapper@@QAEXXZ	; CSpeedTreeWrapper::CleanUpMemory
PUBLIC	?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ		; CSpeedTreeWrapper::SetupBuffers
PUBLIC	?SetupBranchBuffers@CSpeedTreeWrapper@@AAEXXZ	; CSpeedTreeWrapper::SetupBranchBuffers
PUBLIC	?SetupFrondBuffers@CSpeedTreeWrapper@@AAEXXZ	; CSpeedTreeWrapper::SetupFrondBuffers
PUBLIC	?SetupLeafBuffers@CSpeedTreeWrapper@@AAEXXZ	; CSpeedTreeWrapper::SetupLeafBuffers
PUBLIC	?PositionTree@CSpeedTreeWrapper@@ABEXXZ		; CSpeedTreeWrapper::PositionTree
PUBLIC	?LoadTexture@CSpeedTreeWrapper@@CA_NPBDAAVCGraphicImageInstance@@@Z ; CSpeedTreeWrapper::LoadTexture
PUBLIC	?SetShaderConstants@CSpeedTreeWrapper@@ABEXPBM@Z ; CSpeedTreeWrapper::SetShaderConstants
PUBLIC	?deallocate@?$allocator@PAVCSpeedTreeWrapper@@@std@@QAEXQAPAVCSpeedTreeWrapper@@I@Z ; std::allocator<CSpeedTreeWrapper *>::deallocate
PUBLIC	??1?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::~vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >
PUBLIC	?erase@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::erase
PUBLIC	?_Destroy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXPAPAVCSpeedTreeWrapper@@0@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@ABEII@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXQAPAVCSpeedTreeWrapper@@II@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@CAXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Xlength
PUBLIC	??_GCSpeedTreeWrapper@@UAEPAXI@Z		; CSpeedTreeWrapper::`scalar deleting destructor'
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$emplace_back@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXABQAVCSpeedTreeWrapper@@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::emplace_back<CSpeedTreeWrapper * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXABQAVCSpeedTreeWrapper@@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_back_with_unused_capacity<CSpeedTreeWrapper * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_reallocate<CSpeedTreeWrapper * const &>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Copy_memmove@PAPAVCSpeedTreeWrapper@@PAPAV1@@std@@YAPAPAVCSpeedTreeWrapper@@PAPAV1@00@Z ; std::_Copy_memmove<CSpeedTreeWrapper * *,CSpeedTreeWrapper * *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Uninitialized_move<CSpeedTreeWrapper * *,std::allocator<CSpeedTreeWrapper *> >
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7CSpeedTreeWrapper@@6B@			; CSpeedTreeWrapper::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_C@_0CH@GFOKBLKL@Failed?5to?5create?5branch?5vertex?5@ ; `string'
PUBLIC	??_C@_0BE@MPNPNNCI@Vertex?5Shader?5Error@	; `string'
PUBLIC	??_C@_0EI@ONOKBFD@Failed?5to?5assemble?5branch?5verte@ ; `string'
PUBLIC	??_C@_0BG@FCIIGDPL@SpeedTreeRT?5Error?3?5?$CFs@	; `string'
PUBLIC	??_C@_04LIKELABK@?4dds@				; `string'
PUBLIC	??_C@_0CJ@CEEBAJFC@?6Fatal?5Error?0?5cannot?5compute?5tr@ ; `string'
PUBLIC	??_C@_0BH@NANCELHN@SpeedTreeRT?5Error?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CSpeedTreeWrapper@@6B@			; CSpeedTreeWrapper::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCSpeedTreeWrapper@@@8			; CSpeedTreeWrapper `RTTI Type Descriptor'
PUBLIC	??_R3CSpeedTreeWrapper@@8			; CSpeedTreeWrapper::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CSpeedTreeWrapper@@8			; CSpeedTreeWrapper::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CSpeedTreeWrapper@@8		; CSpeedTreeWrapper::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CGraphicObjectInstance@@8		; CGraphicObjectInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicObjectInstance@@@8		; CGraphicObjectInstance `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicObjectInstance@@8			; CGraphicObjectInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicObjectInstance@@8			; CGraphicObjectInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicCollisionObject@@8	; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicCollisionObject@@@8		; CGraphicCollisionObject `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicBase@@8			; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicBase@@@8			; CGraphicBase `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicBase@@8				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicBase@@8				; CGraphicBase::`RTTI Base Class Array'
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40a00000
PUBLIC	__real@41100000
PUBLIC	__real@447a0000
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	??0SGeometry@CSpeedTreeRT@@QAE@XZ:PROC		; CSpeedTreeRT::SGeometry::SGeometry
EXTRN	??1SGeometry@CSpeedTreeRT@@QAE@XZ:PROC		; CSpeedTreeRT::SGeometry::~SGeometry
EXTRN	??0STextures@CSpeedTreeRT@@QAE@XZ:PROC		; CSpeedTreeRT::STextures::STextures
EXTRN	??1STextures@CSpeedTreeRT@@QAE@XZ:PROC		; CSpeedTreeRT::STextures::~STextures
EXTRN	??0CSpeedTreeRT@@QAE@XZ:PROC			; CSpeedTreeRT::CSpeedTreeRT
EXTRN	??1CSpeedTreeRT@@QAE@XZ:PROC			; CSpeedTreeRT::~CSpeedTreeRT
EXTRN	??2CSpeedTreeRT@@SAPAXI@Z:PROC			; CSpeedTreeRT::operator new
EXTRN	??3CSpeedTreeRT@@SAXPAX@Z:PROC			; CSpeedTreeRT::operator delete
EXTRN	?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z:PROC	; CSpeedTreeRT::Compute
EXTRN	?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ:PROC	; CSpeedTreeRT::MakeInstance
EXTRN	?DeleteTransientData@CSpeedTreeRT@@QAEXXZ:PROC	; CSpeedTreeRT::DeleteTransientData
EXTRN	?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z:PROC		; CSpeedTreeRT::LoadTree
EXTRN	?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z:PROC	; CSpeedTreeRT::LoadTree
EXTRN	?GetTreeSize@CSpeedTreeRT@@QBEXAAM0@Z:PROC	; CSpeedTreeRT::GetTreeSize
EXTRN	?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z:PROC	; CSpeedTreeRT::SetTreeSize
EXTRN	?GetTreePosition@CSpeedTreeRT@@QBEPBMXZ:PROC	; CSpeedTreeRT::GetTreePosition
EXTRN	?SetTreePosition@CSpeedTreeRT@@QAEXMMM@Z:PROC	; CSpeedTreeRT::SetTreePosition
EXTRN	?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z:PROC ; CSpeedTreeRT::SetBranchLightingMethod
EXTRN	?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z:PROC ; CSpeedTreeRT::SetLeafLightingMethod
EXTRN	?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z:PROC ; CSpeedTreeRT::SetFrondLightingMethod
EXTRN	?GetLeafLightingAdjustment@CSpeedTreeRT@@QBEMXZ:PROC ; CSpeedTreeRT::GetLeafLightingAdjustment
EXTRN	?GetBranchMaterial@CSpeedTreeRT@@QBEPBMXZ:PROC	; CSpeedTreeRT::GetBranchMaterial
EXTRN	?GetLeafMaterial@CSpeedTreeRT@@QBEPBMXZ:PROC	; CSpeedTreeRT::GetLeafMaterial
EXTRN	?GetFrondMaterial@CSpeedTreeRT@@QBEPBMXZ:PROC	; CSpeedTreeRT::GetFrondMaterial
EXTRN	?SetLeafRockingState@CSpeedTreeRT@@QAEX_N@Z:PROC ; CSpeedTreeRT::SetLeafRockingState
EXTRN	?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z:PROC ; CSpeedTreeRT::SetNumLeafRockingGroups
EXTRN	?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z:PROC ; CSpeedTreeRT::SetLeafWindMethod
EXTRN	?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z:PROC ; CSpeedTreeRT::SetBranchWindMethod
EXTRN	?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z:PROC ; CSpeedTreeRT::SetFrondWindMethod
EXTRN	?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z:PROC	; CSpeedTreeRT::SetWindStrength
EXTRN	?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z:PROC	; CSpeedTreeRT::SetLocalMatrices
EXTRN	?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ:PROC	; CSpeedTreeRT::ComputeLodLevel
EXTRN	?SetLodLevel@CSpeedTreeRT@@QAEXM@Z:PROC		; CSpeedTreeRT::SetLodLevel
EXTRN	?SetDropToBillboard@CSpeedTreeRT@@SAX_N@Z:PROC	; CSpeedTreeRT::SetDropToBillboard
EXTRN	?SetLodLimits@CSpeedTreeRT@@QAEXMM@Z:PROC	; CSpeedTreeRT::SetLodLimits
EXTRN	?GetNumBranchLodLevels@CSpeedTreeRT@@QBEGXZ:PROC ; CSpeedTreeRT::GetNumBranchLodLevels
EXTRN	?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ:PROC	; CSpeedTreeRT::GetNumLeafLodLevels
EXTRN	?GetNumFrondLodLevels@CSpeedTreeRT@@QBEGXZ:PROC	; CSpeedTreeRT::GetNumFrondLodLevels
EXTRN	?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z:PROC ; CSpeedTreeRT::GetGeometry
EXTRN	?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z:PROC ; CSpeedTreeRT::GetTextures
EXTRN	?SetTextureFlip@CSpeedTreeRT@@SAX_N@Z:PROC	; CSpeedTreeRT::SetTextureFlip
EXTRN	?GetCurrentError@CSpeedTreeRT@@SAPBDXZ:PROC	; CSpeedTreeRT::GetCurrentError
EXTRN	?GetBoundingBox@CSpeedTreeRT@@QBEXPAM@Z:PROC	; CSpeedTreeRT::GetBoundingBox
EXTRN	?GetCollisionObjectCount@CSpeedTreeRT@@QAEIXZ:PROC ; CSpeedTreeRT::GetCollisionObjectCount
EXTRN	?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z:PROC ; CSpeedTreeRT::GetCollisionObject
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	_sqrt:PROC
EXTRN	_D3DXVec4Transform@12:PROC
EXTRN	_D3DXMatrixTranslation@16:PROC
EXTRN	_D3DXAssembleShader@24:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	??0CGraphicObjectInstance@@QAE@XZ:PROC		; CGraphicObjectInstance::CGraphicObjectInstance
EXTRN	??1CGraphicObjectInstance@@UAE@XZ:PROC		; CGraphicObjectInstance::~CGraphicObjectInstance
EXTRN	?SetPosition@CGraphicObjectInstance@@QAEXMMM@Z:PROC ; CGraphicObjectInstance::SetPosition
EXTRN	?Clear@CGraphicObjectInstance@@QAEXXZ:PROC	; CGraphicObjectInstance::Clear
EXTRN	?GetTransform@CGraphicObjectInstance@@QAEAAUD3DXMATRIX@@XZ:PROC ; CGraphicObjectInstance::GetTransform
EXTRN	?OnInitialize@CGraphicObjectInstance@@UAEXXZ:PROC ; CGraphicObjectInstance::OnInitialize
EXTRN	?AddCollision@CGraphicObjectInstance@@QAEXPBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z:PROC ; CGraphicObjectInstance::AddCollision
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	??0CGraphicImageInstance@@QAE@XZ:PROC		; CGraphicImageInstance::CGraphicImageInstance
EXTRN	??1CGraphicImageInstance@@UAE@XZ:PROC		; CGraphicImageInstance::~CGraphicImageInstance
EXTRN	?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::SetImagePointer
EXTRN	?IsEmpty@CGraphicImageInstance@@QBE_NXZ:PROC	; CGraphicImageInstance::IsEmpty
EXTRN	?GetTextureReference@CGraphicImageInstance@@QBEABVCGraphicTexture@@XZ:PROC ; CGraphicImageInstance::GetTextureReference
EXTRN	?GetGraphicImagePointer@CGraphicImageInstance@@QAEPAVCGraphicImage@@XZ:PROC ; CGraphicImageInstance::GetGraphicImagePointer
EXTRN	??_ECSpeedTreeWrapper@@UAEPAXI@Z:PROC		; CSpeedTreeWrapper::`vector deleting destructor'
EXTRN	?UpdateSystem@CSpeedTreeForest@@QAEXM@Z:PROC	; CSpeedTreeForest::UpdateSystem
EXTRN	?UpdateCompundMatrix@CSpeedTreeForestDirectX8@@QAEXABUD3DXVECTOR3@@ABUD3DXMATRIX@@1@Z:PROC ; CSpeedTreeForestDirectX8::UpdateCompundMatrix
EXTRN	?ELTimer_GetMSec@@YAKXZ:PROC			; ELTimer_GetMSec
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ:PROC ; CCameraManager::GetCurrentCamera
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?SetVertexShaderConstant@CStateManager@@QAEXKPBXK@Z:PROC ; CStateManager::SetVertexShaderConstant
EXTRN	?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z:PROC ; CStateManager::SetStreamSource
EXTRN	?SetIndices@CStateManager@@QAEXPAUIDirect3DIndexBuffer8@@I@Z:PROC ; CStateManager::SetIndices
EXTRN	?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z:PROC ; CStateManager::DrawPrimitive
EXTRN	?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z:PROC ; CStateManager::DrawPrimitiveUP
EXTRN	?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z:PROC ; CStateManager::DrawIndexedPrimitive
EXTRN	?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::GetRenderState
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftoui3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A:BYTE	; CGraphicBase::ms_matView
EXTRN	?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A:BYTE	; CGraphicBase::ms_matProj
EXTRN	?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A:DWORD ; CGraphicBase::ms_lpd3dDevice
EXTRN	?ms_faceCount@CGraphicBase@@1KA:DWORD		; CGraphicBase::ms_faceCount
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A DD 01H DUP (?) ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A DD 01H DUP (?) ; CSingleton<CCameraManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R2CGraphicBase@@8
rdata$r	SEGMENT
??_R2CGraphicBase@@8 DD FLAT:??_R1A@?0A@EA@CGraphicBase@@8 ; CGraphicBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicBase@@8
rdata$r	SEGMENT
??_R3CGraphicBase@@8 DD 00H				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicBase@@@8
data$rs	SEGMENT
??_R0?AVCGraphicBase@@@8 DD FLAT:??_7type_info@@6B@	; CGraphicBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicBase@@8 DD FLAT:??_R0?AVCGraphicBase@@@8 ; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R2CGraphicCollisionObject@@8 DD FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8 ; CGraphicCollisionObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R3CGraphicCollisionObject@@8 DD 00H			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicCollisionObject@@@8
data$rs	SEGMENT
??_R0?AVCGraphicCollisionObject@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicCollisionObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicCollisionObject@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicCollisionObject@@8 DD FLAT:??_R0?AVCGraphicCollisionObject@@@8 ; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicObjectInstance@@8
rdata$r	SEGMENT
??_R2CGraphicObjectInstance@@8 DD FLAT:??_R1A@?0A@EA@CGraphicObjectInstance@@8 ; CGraphicObjectInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CGraphicObjectInstance@@8
rdata$r	SEGMENT
??_R3CGraphicObjectInstance@@8 DD 00H			; CGraphicObjectInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CGraphicObjectInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicObjectInstance@@@8
data$rs	SEGMENT
??_R0?AVCGraphicObjectInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicObjectInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicObjectInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicObjectInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicObjectInstance@@8 DD FLAT:??_R0?AVCGraphicObjectInstance@@@8 ; CGraphicObjectInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicObjectInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CSpeedTreeWrapper@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSpeedTreeWrapper@@8 DD FLAT:??_R0?AVCSpeedTreeWrapper@@@8 ; CSpeedTreeWrapper::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CSpeedTreeWrapper@@8
rdata$r	ENDS
;	COMDAT ??_R2CSpeedTreeWrapper@@8
rdata$r	SEGMENT
??_R2CSpeedTreeWrapper@@8 DD FLAT:??_R1A@?0A@EA@CSpeedTreeWrapper@@8 ; CSpeedTreeWrapper::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicObjectInstance@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CSpeedTreeWrapper@@8
rdata$r	SEGMENT
??_R3CSpeedTreeWrapper@@8 DD 00H			; CSpeedTreeWrapper::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CSpeedTreeWrapper@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSpeedTreeWrapper@@@8
data$rs	SEGMENT
??_R0?AVCSpeedTreeWrapper@@@8 DD FLAT:??_7type_info@@6B@ ; CSpeedTreeWrapper `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSpeedTreeWrapper@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CSpeedTreeWrapper@@6B@
rdata$r	SEGMENT
??_R4CSpeedTreeWrapper@@6B@ DD 00H			; CSpeedTreeWrapper::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCSpeedTreeWrapper@@@8
	DD	FLAT:??_R3CSpeedTreeWrapper@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NANCELHN@SpeedTreeRT?5Error?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@NANCELHN@SpeedTreeRT?5Error?3?5?$CFs?6@ DB 'SpeedTreeRT Error: '
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CEEBAJFC@?6Fatal?5Error?0?5cannot?5compute?5tr@
CONST	SEGMENT
??_C@_0CJ@CEEBAJFC@?6Fatal?5Error?0?5cannot?5compute?5tr@ DB 0aH, 'Fatal '
	DB	'Error, cannot compute tree [%s]', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LIKELABK@?4dds@
CONST	SEGMENT
??_C@_04LIKELABK@?4dds@ DB '.dds', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FCIIGDPL@SpeedTreeRT?5Error?3?5?$CFs@
CONST	SEGMENT
??_C@_0BG@FCIIGDPL@SpeedTreeRT?5Error?3?5?$CFs@ DB 'SpeedTreeRT Error: %s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@ONOKBFD@Failed?5to?5assemble?5branch?5verte@
CONST	SEGMENT
??_C@_0EI@ONOKBFD@Failed?5to?5assemble?5branch?5verte@ DB 'Failed to asse'
	DB	'mble branch vertex shader.', 0aH, 'The error reported is [ %s'
	DB	' ].', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MPNPNNCI@Vertex?5Shader?5Error@
CONST	SEGMENT
??_C@_0BE@MPNPNNCI@Vertex?5Shader?5Error@ DB 'Vertex Shader Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GFOKBLKL@Failed?5to?5create?5branch?5vertex?5@
CONST	SEGMENT
??_C@_0CH@GFOKBLKL@Failed?5to?5create?5branch?5vertex?5@ DB 'Failed to cr'
	DB	'eate branch vertex shader.', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
?D3DFVF_SPEEDTREE_BRANCH_VERTEX@@3KA DD 0242H		; D3DFVF_SPEEDTREE_BRANCH_VERTEX
?D3DFVF_SPEEDTREE_LEAF_VERTEX@@3KA DD 0142H		; D3DFVF_SPEEDTREE_LEAF_VERTEX
_DATA	ENDS
;	COMDAT ??_7CSpeedTreeWrapper@@6B@
CONST	SEGMENT
??_7CSpeedTreeWrapper@@6B@ DD FLAT:??_R4CSpeedTreeWrapper@@6B@ ; CSpeedTreeWrapper::`vftable'
	DD	FLAT:??_ECSpeedTreeWrapper@@UAEPAXI@Z
	DD	FLAT:?GetType@CSpeedTreeWrapper@@EBEHXZ
	DD	FLAT:?OnInitialize@CGraphicObjectInstance@@UAEXXZ
	DD	FLAT:?GetBoundingSphere@CSpeedTreeWrapper@@UAE_NAAUD3DXVECTOR3@@AAM@Z
	DD	FLAT:?OnRender@CSpeedTreeWrapper@@UAEXXZ
	DD	FLAT:?OnBlendRender@CSpeedTreeWrapper@@UAEXXZ
	DD	FLAT:?OnRenderToShadowMap@CSpeedTreeWrapper@@UAEXXZ
	DD	FLAT:?OnRenderShadow@CSpeedTreeWrapper@@UAEXXZ
	DD	FLAT:?OnRenderPCBlocker@CSpeedTreeWrapper@@UAEXXZ
	DD	FLAT:?OnClear@CGraphicObjectInstance@@UAEXXZ
	DD	FLAT:?OnUpdate@CGraphicObjectInstance@@UAEXXZ
	DD	FLAT:?OnDeform@CGraphicObjectInstance@@UAEXXZ
	DD	FLAT:?OnUpdateCollisionData@CSpeedTreeWrapper@@MAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z
	DD	FLAT:?OnUpdateHeighInstance@CSpeedTreeWrapper@@MAEXPAVCAttributeInstance@@@Z
	DD	FLAT:?OnGetObjectHeight@CSpeedTreeWrapper@@MAE_NMMPAM@Z
	DD	FLAT:?SetPosition@CSpeedTreeWrapper@@UAEXMMM@Z
	DD	FLAT:?CalculateBBox@CSpeedTreeWrapper@@UAEXXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?erase@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ$0
__ehfuncinfo$?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MakeInstance@CSpeedTreeWrapper@@QAEPAV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MakeInstance@CSpeedTreeWrapper@@QAEPAV1@XZ$0
__ehfuncinfo$?MakeInstance@CSpeedTreeWrapper@@QAEPAV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MakeInstance@CSpeedTreeWrapper@@QAEPAV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z DD 019930522H
	DD	013H
	DD	FLAT:__unwindtable$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$15
	DD	0fH
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$16
	DD	010H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$17
	DD	011H
	DD	FLAT:__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$18
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CSpeedTreeWrapper@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CSpeedTreeWrapper@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0CSpeedTreeWrapper@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CSpeedTreeWrapper@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CSpeedTreeWrapper@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeWrapper@@QAE@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeWrapper@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeWrapper@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeWrapper@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CSpeedTreeWrapper@@QAE@XZ$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z$9
__ehfuncinfo$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Al$ = -64						; size = 4
__First1$ = -60						; size = 4
__First1$ = -56						; size = 4
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T2 = -44						; size = 4
__Old_ptr$3 = -40					; size = 4
__Old_capacity$ = -36					; size = 4
__New_capacity$ = -32					; size = 4
__New_size$ = -28					; size = 4
__New_ptr$ = -24					; size = 4
_this$ = -20						; size = 4
__Raw_new$ = -16					; size = 4
__My_data$ = -12					; size = 4
__Old_size$ = -8					; size = 4
__Overflow_is_possible$4 = -3				; size = 1
$T5 = -2						; size = 1
$T6 = -1						; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 e4	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 dc	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 e4	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 e0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 c0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 fd 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 e0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 e8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d e4	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 e8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d dc 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 65		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 d8	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 d8	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ac	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  000af	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  000b2	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  000bd	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c0	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c6	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000c9	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000cc	ff 75 c8	 push	 DWORD PTR __First1$[ebp]
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000d7	c6 45 ff 00	 mov	 BYTE PTR $T6[ebp], 0
  000db	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000de	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  000e1	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000e4	8a 55 ff	 mov	 dl, BYTE PTR $T6[ebp]
  000e7	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ea	8b 45 dc	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000ed	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ee	50		 push	 eax
  000ef	ff 75 d8	 push	 DWORD PTR __Old_ptr$3[ebp]
  000f2	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000f7	59		 pop	 ecx
  000f8	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000fc	8b 4d e8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000ff	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  00101	eb 4c		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00103	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  00106	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00109	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  0010c	e8 00 00 00 00	 call	 _memcpy
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00114	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00117	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  0011a	89 45 c4	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00120	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00123	ff 75 c4	 push	 DWORD PTR __First1$[ebp]
  00126	e8 00 00 00 00	 call	 _memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0012e	c6 45 fe 00	 mov	 BYTE PTR $T5[ebp], 0
  00132	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00135	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  00138	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  0013b	8a 55 fe	 mov	 dl, BYTE PTR $T5[ebp]
  0013e	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00141	8d 45 e8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00144	50		 push	 eax
  00145	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00148	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0014d	59		 pop	 ecx
  0014e	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  0014f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  00152	c9		 leave
  00153	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z PROC ; std::_Uninitialized_move<CSpeedTreeWrapper * *,std::allocator<CSpeedTreeWrapper *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCSpeedTreeWrapper@@PAPAV1@@std@@YAPAPAVCSpeedTreeWrapper@@PAPAV1@00@Z ; std::_Copy_memmove<CSpeedTreeWrapper * *,CSpeedTreeWrapper * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ENDP ; std::_Uninitialized_move<CSpeedTreeWrapper * *,std::allocator<CSpeedTreeWrapper *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCSpeedTreeWrapper@@PAPAV1@@std@@YAPAPAVCSpeedTreeWrapper@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCSpeedTreeWrapper@@PAPAV1@@std@@YAPAPAVCSpeedTreeWrapper@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CSpeedTreeWrapper * *,CSpeedTreeWrapper * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCSpeedTreeWrapper@@PAPAV1@@std@@YAPAPAVCSpeedTreeWrapper@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CSpeedTreeWrapper * *,CSpeedTreeWrapper * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_reallocate<CSpeedTreeWrapper * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@CAXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@ABEII@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Uninitialized_move<CSpeedTreeWrapper * *,std::allocator<CSpeedTreeWrapper *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Uninitialized_move<CSpeedTreeWrapper * *,std::allocator<CSpeedTreeWrapper *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Uninitialized_move<CSpeedTreeWrapper * *,std::allocator<CSpeedTreeWrapper *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXPAPAVCSpeedTreeWrapper@@0@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCSpeedTreeWrapper@@@std@@QAEXQAPAVCSpeedTreeWrapper@@I@Z ; std::allocator<CSpeedTreeWrapper *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXQAPAVCSpeedTreeWrapper@@II@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_reallocate<CSpeedTreeWrapper * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXABQAVCSpeedTreeWrapper@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXABQAVCSpeedTreeWrapper@@@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_back_with_unused_capacity<CSpeedTreeWrapper * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXABQAVCSpeedTreeWrapper@@@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_back_with_unused_capacity<CSpeedTreeWrapper * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXABQAVCSpeedTreeWrapper@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXABQAVCSpeedTreeWrapper@@@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::emplace_back<CSpeedTreeWrapper * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXABQAVCSpeedTreeWrapper@@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_back_with_unused_capacity<CSpeedTreeWrapper * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_reallocate<CSpeedTreeWrapper * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXABQAVCSpeedTreeWrapper@@@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::emplace_back<CSpeedTreeWrapper * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
$T5 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4541 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	83 65 fc 00	 and	 DWORD PTR $T5[ebp], 0

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000a	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	59		 pop	 ecx
  00013	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00016	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00019	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001c	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0001f	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00025	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0002a	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00030	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4542 :     return _STD move(_Left.append(_Right));

  00033	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003e	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
  00041	83 c8 01	 or	 eax, 1
  00044	89 45 fc	 mov	 DWORD PTR $T5[ebp], eax
  00047	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4543 : }

  0004a	c9		 leave
  0004b	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
$T2 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4516 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	83 65 fc 00	 and	 DWORD PTR $T2[ebp], 0

; 4517 : #if _ITERATOR_DEBUG_LEVEL == 2
; 4518 :     _STL_VERIFY(_STD addressof(_Left) != _STD addressof(_Right),
; 4519 :         "You cannot concatenate the same moved string to itself. See "
; 4520 :         "N4849 [res.on.arguments]/1.3: If a function argument binds to an rvalue reference "
; 4521 :         "parameter, the implementation may assume that this parameter is a unique reference "
; 4522 :         "to this argument");
; 4523 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 4524 :     return {_String_constructor_concat_tag{}, _Left, _Right};

  00009	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  0000f	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001a	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  0001d	83 c8 01	 or	 eax, 1
  00020	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4525 : }

  00026	c9		 leave
  00027	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\VertexShaders.h
;	COMDAT ?LoadLeafShader@@YAKPAUIDirect3DDevice8@@@Z
_TEXT	SEGMENT
_dwShader$ = -4						; size = 4
_pDx$ = 8						; size = 4
?LoadLeafShader@@YAKPAUIDirect3DDevice8@@@Z PROC	; LoadLeafShader, COMDAT

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 277  : 	DWORD dwShader = D3DFVF_SPEEDTREE_LEAF_VERTEX;

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?D3DFVF_SPEEDTREE_LEAF_VERTEX@@3KA
  00009	89 45 fc	 mov	 DWORD PTR _dwShader$[ebp], eax

; 278  : 
; 279  : 	#if defined WRAPPER_USE_GPU_LEAF_PLACEMENT || defined WRAPPER_USE_GPU_WIND
; 280  : 
; 281  : 		// leaf shader declaration
; 282  : 		DWORD pLeafShaderDecl[ ] = 
; 283  : 		{
; 284  : 				D3DVSD_STREAM(0),
; 285  : 				D3DVSD_REG(D3DVSDE_POSITION,        D3DVSDT_FLOAT3),
; 286  : 			#ifdef WRAPPER_USE_DYNAMIC_LIGHTING
; 287  : 				D3DVSD_REG(D3DVSDE_NORMAL,			D3DVSDT_FLOAT3),
; 288  : 			#else
; 289  : 				D3DVSD_REG(D3DVSDE_DIFFUSE,			D3DVSDT_D3DCOLOR),
; 290  : 			#endif
; 291  : 				D3DVSD_REG(D3DVSDE_TEXCOORD0,		D3DVSDT_FLOAT2),
; 292  : 				D3DVSD_REG(D3DVSDE_TEXCOORD2,		D3DVSDT_FLOAT4),
; 293  : 				D3DVSD_END( )
; 294  : 		};
; 295  : 
; 296  : 		// assemble shader
; 297  : 		LPD3DXBUFFER pCode, pError;
; 298  : 
; 299  : 		if (D3DXAssembleShader(g_achLeafVertexProgram, sizeof(g_achLeafVertexProgram) - 1, 0, NULL, &pCode, &pError) == D3D_OK)
; 300  : 		{
; 301  : 			if (pDx->CreateVertexShader(pLeafShaderDecl, (DWORD*) pCode->GetBufferPointer( ), &dwShader, 0) != D3D_OK)
; 302  : 			{
; 303  : 				Tracef("Failed to create leaf vertex shader.");
; 304  : 				/*
; 305  : 				char szError[1024];
; 306  : 				sprintf(szError, "Failed to create leaf vertex shader.");
; 307  : 				MessageBox(NULL, szError, "Vertex Shader Error", MB_ICONSTOP);
; 308  : 				*/
; 309  : 			}
; 310  : 		}
; 311  : 		else
; 312  : 		{
; 313  : 			Tracef("Failed to assemble leaf vertex shader. The error reported is [ %s ].\n", pError->GetBufferPointer( ));
; 314  : 			/*
; 315  : 			char szError[1024];
; 316  : 			sprintf(szError, "Failed to assemble leaf vertex shader. The error reported is [ %s ].\n", pError->GetBufferPointer( ));
; 317  : 			MessageBox(NULL, szError, "Vertex Shader Error", MB_ICONSTOP);
; 318  : 			*/
; 319  : 		}
; 320  : 
; 321  : 		if (pCode)
; 322  :     		pCode->Release( );
; 323  : 
; 324  : 	#else
; 325  : 
; 326  : 		dwShader = D3DFVF_SPEEDTREE_LEAF_VERTEX;

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?D3DFVF_SPEEDTREE_LEAF_VERTEX@@3KA
  00011	89 45 fc	 mov	 DWORD PTR _dwShader$[ebp], eax

; 327  : 
; 328  : 	#endif
; 329  : 
; 330  : 	return dwShader;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _dwShader$[ebp]

; 331  : }

  00017	c9		 leave
  00018	c3		 ret	 0
?LoadLeafShader@@YAKPAUIDirect3DDevice8@@@Z ENDP	; LoadLeafShader
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\VertexShaders.h
;	COMDAT ?LoadBranchShader@@YAKPAUIDirect3DDevice8@@@Z
_TEXT	SEGMENT
_dwShader$ = -128					; size = 4
_pError$ = -124						; size = 4
_pCode$ = -120						; size = 4
_pBranchShaderDecl$ = -116				; size = 24
_szError$1 = -92					; size = 1024
_szError$2 = 932					; size = 1024
__$ArrayPad$ = 1956					; size = 4
_pDx$ = 1968						; size = 4
?LoadBranchShader@@YAKPAUIDirect3DDevice8@@@Z PROC	; LoadBranchShader, COMDAT

; 130  : {

  00000	55		 push	 ebp
  00001	8d ac 24 58 f8
	ff ff		 lea	 ebp, DWORD PTR [esp-1960]
  00008	81 ec 28 08 00
	00		 sub	 esp, 2088		; 00000828H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 a4 07 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 131  : 	#ifndef WRAPPER_USE_GPU_WIND
; 132  : 		return D3DFVF_SPEEDTREE_BRANCH_VERTEX;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?D3DFVF_SPEEDTREE_BRANCH_VERTEX@@3KA
  00020	e9 e3 00 00 00	 jmp	 $LN1@LoadBranch

; 133  : 	#endif
; 134  : 
; 135  : 	// branch shader declaration
; 136  :     DWORD pBranchShaderDecl[] = 
; 137  :     {
; 138  : 			D3DVSD_STREAM(0),

  00025	c7 45 8c 00 00
	00 20		 mov	 DWORD PTR _pBranchShaderDecl$[ebp], 536870912 ; 20000000H

; 139  : 			D3DVSD_REG(D3DVSDE_POSITION,        D3DVSDT_FLOAT3),

  0002c	c7 45 90 00 00
	02 40		 mov	 DWORD PTR _pBranchShaderDecl$[ebp+4], 1073872896 ; 40020000H

; 140  : 		#ifdef WRAPPER_USE_DYNAMIC_LIGHTING
; 141  : 			D3DVSD_REG(D3DVSDE_NORMAL,			D3DVSDT_FLOAT3),
; 142  : 		#else
; 143  : 			D3DVSD_REG(D3DVSDE_DIFFUSE,			D3DVSDT_D3DCOLOR),

  00033	c7 45 94 05 00
	04 40		 mov	 DWORD PTR _pBranchShaderDecl$[ebp+8], 1074003973 ; 40040005H

; 144  : 		#endif
; 145  : 			D3DVSD_REG(D3DVSDE_TEXCOORD0,		D3DVSDT_FLOAT2),

  0003a	c7 45 98 07 00
	01 40		 mov	 DWORD PTR _pBranchShaderDecl$[ebp+12], 1073807367 ; 40010007H

; 146  : 		#ifdef WRAPPER_RENDER_SELF_SHADOWS
; 147  : 			D3DVSD_REG(D3DVSDE_TEXCOORD1,		D3DVSDT_FLOAT2),

  00041	c7 45 9c 08 00
	01 40		 mov	 DWORD PTR _pBranchShaderDecl$[ebp+16], 1073807368 ; 40010008H

; 148  : 		#endif
; 149  : 		#ifdef WRAPPER_USE_GPU_WIND
; 150  : 			D3DVSD_REG(D3DVSDE_TEXCOORD2,		D3DVSDT_FLOAT2),
; 151  : 		#endif
; 152  : 			D3DVSD_END( )

  00048	83 4d a0 ff	 or	 DWORD PTR _pBranchShaderDecl$[ebp+20], -1

; 153  :     };
; 154  : 
; 155  :     // assemble shader
; 156  : 	DWORD dwShader;
; 157  : 	LPD3DXBUFFER pCode, pError;
; 158  : 
; 159  :     if (D3DXAssembleShader(g_achSimpleVertexProgram, sizeof(g_achSimpleVertexProgram) - 1, 0, NULL, &pCode, &pError) == D3D_OK)

  0004c	8d 45 84	 lea	 eax, DWORD PTR _pError$[ebp]
  0004f	50		 push	 eax
  00050	8d 45 88	 lea	 eax, DWORD PTR _pCode$[ebp]
  00053	50		 push	 eax
  00054	6a 00		 push	 0
  00056	6a 00		 push	 0
  00058	68 1d 01 00 00	 push	 285			; 0000011dH
  0005d	68 00 00 00 00	 push	 OFFSET ?g_achSimpleVertexProgram@@3QBDB
  00062	e8 00 00 00 00	 call	 _D3DXAssembleShader@24
  00067	85 c0		 test	 eax, eax
  00069	75 59		 jne	 SHORT $LN2@LoadBranch

; 160  : 	{
; 161  : 		if (pDx->CreateVertexShader(pBranchShaderDecl, (DWORD*) pCode->GetBufferPointer( ), &dwShader, 0) != D3D_OK)

  0006b	6a 00		 push	 0
  0006d	8d 45 80	 lea	 eax, DWORD PTR _dwShader$[ebp]
  00070	50		 push	 eax
  00071	8b 45 88	 mov	 eax, DWORD PTR _pCode$[ebp]
  00074	8b 00		 mov	 eax, DWORD PTR [eax]
  00076	ff 75 88	 push	 DWORD PTR _pCode$[ebp]
  00079	ff 50 0c	 call	 DWORD PTR [eax+12]
  0007c	50		 push	 eax
  0007d	8d 45 8c	 lea	 eax, DWORD PTR _pBranchShaderDecl$[ebp]
  00080	50		 push	 eax
  00081	8b 85 b0 07 00
	00		 mov	 eax, DWORD PTR _pDx$[ebp]
  00087	8b 00		 mov	 eax, DWORD PTR [eax]
  00089	ff b5 b0 07 00
	00		 push	 DWORD PTR _pDx$[ebp]
  0008f	ff 90 2c 01 00
	00		 call	 DWORD PTR [eax+300]
  00095	85 c0		 test	 eax, eax
  00097	74 29		 je	 SHORT $LN4@LoadBranch

; 162  : 		{
; 163  : 			char szError[1024];
; 164  : 			sprintf(szError, "Failed to create branch vertex shader.");

  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GFOKBLKL@Failed?5to?5create?5branch?5vertex?5@
  0009e	8d 85 a4 03 00
	00		 lea	 eax, DWORD PTR _szError$2[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _sprintf
  000aa	59		 pop	 ecx
  000ab	59		 pop	 ecx

; 165  : 			MessageBox(NULL, szError, "Vertex Shader Error", MB_ICONSTOP);

  000ac	6a 10		 push	 16			; 00000010H
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MPNPNNCI@Vertex?5Shader?5Error@
  000b3	8d 85 a4 03 00
	00		 lea	 eax, DWORD PTR _szError$2[ebp]
  000b9	50		 push	 eax
  000ba	6a 00		 push	 0
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN4@LoadBranch:

; 166  : 		}
; 167  : 	}

  000c2	eb 30		 jmp	 SHORT $LN3@LoadBranch
$LN2@LoadBranch:

; 168  : 	else
; 169  :     {
; 170  :         char szError[1024];
; 171  : 	    sprintf(szError, "Failed to assemble branch vertex shader.\nThe error reported is [ %s ].\n", pError->GetBufferPointer( ));

  000c4	8b 45 84	 mov	 eax, DWORD PTR _pError$[ebp]
  000c7	8b 00		 mov	 eax, DWORD PTR [eax]
  000c9	ff 75 84	 push	 DWORD PTR _pError$[ebp]
  000cc	ff 50 0c	 call	 DWORD PTR [eax+12]
  000cf	50		 push	 eax
  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@ONOKBFD@Failed?5to?5assemble?5branch?5verte@
  000d5	8d 45 a4	 lea	 eax, DWORD PTR _szError$1[ebp]
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _sprintf
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 172  : 	    MessageBox(NULL, szError, "Vertex Shader Error", MB_ICONSTOP);

  000e1	6a 10		 push	 16			; 00000010H
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MPNPNNCI@Vertex?5Shader?5Error@
  000e8	8d 45 a4	 lea	 eax, DWORD PTR _szError$1[ebp]
  000eb	50		 push	 eax
  000ec	6a 00		 push	 0
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
$LN3@LoadBranch:

; 173  :     }
; 174  : 
; 175  : 	if (pCode)

  000f4	83 7d 88 00	 cmp	 DWORD PTR _pCode$[ebp], 0
  000f8	74 0b		 je	 SHORT $LN5@LoadBranch

; 176  :     	pCode->Release();

  000fa	8b 45 88	 mov	 eax, DWORD PTR _pCode$[ebp]
  000fd	8b 00		 mov	 eax, DWORD PTR [eax]
  000ff	ff 75 88	 push	 DWORD PTR _pCode$[ebp]
  00102	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@LoadBranch:

; 177  : 
; 178  : 	return dwShader;

  00105	8b 45 80	 mov	 eax, DWORD PTR _dwShader$[ebp]
$LN1@LoadBranch:

; 179  : }

  00108	8b 8d a4 07 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	81 c5 a8 07 00
	00		 add	 ebp, 1960		; 000007a8H
  0011b	c9		 leave
  0011c	c3		 ret	 0
?LoadBranchShader@@YAKPAUIDirect3DDevice8@@@Z ENDP	; LoadBranchShader
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCSpeedTreeWrapper@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCSpeedTreeWrapper@@UAEPAXI@Z PROC			; CSpeedTreeWrapper::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CSpeedTreeWrapper@@UAE@XZ ; CSpeedTreeWrapper::~CSpeedTreeWrapper
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 18 03 00 00	 push	 792			; 00000318H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCSpeedTreeWrapper@@UAEPAXI@Z ENDP			; CSpeedTreeWrapper::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@CAXXZ PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@CAXXZ ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXXZ PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXXZ ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXQAPAVCSpeedTreeWrapper@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXQAPAVCSpeedTreeWrapper@@II@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXQAPAVCSpeedTreeWrapper@@II@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@ABEII@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@ABEII@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXPAPAVCSpeedTreeWrapper@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXPAPAVCSpeedTreeWrapper@@0@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXPAPAVCSpeedTreeWrapper@@0@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?erase@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T6 = -44						; size = 4
__My_data$ = -40					; size = 4
_this$ = -36						; size = 4
__Last$ = -32						; size = 4
__Whereptr$ = -28					; size = 4
__Mylast$ = -24						; size = 4
__Dest$ = -20						; size = 4
__First$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::erase, COMDAT
; _this$ = ecx

; 1341 :     iterator erase(const_iterator _Where) noexcept(is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?erase@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 1342 :         const pointer _Whereptr = _Where._Ptr;

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR __Whereptr$[ebp], eax

; 1343 :         auto& _My_data          = _Mypair._Myval2;

  0002e	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 d8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1344 :         pointer& _Mylast        = _My_data._Mylast;

  00034	8b 45 d8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00037	83 c0 04	 add	 eax, 4
  0003a	89 45 e8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1345 : 
; 1346 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1347 :         _STL_VERIFY(
; 1348 :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Mylast > _Whereptr,
; 1349 :             "vector erase iterator outside range");
; 1350 :         _Orphan_range(_Whereptr, _Mylast);
; 1351 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 
; 1353 :         _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

  0003d	8b 45 e4	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00040	89 45 ec	 mov	 DWORD PTR __Dest$[ebp], eax
  00043	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  0004b	8b 45 e4	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  0004e	83 c0 04	 add	 eax, 4
  00051	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4628 :             return _Copy_memmove(_First, _Last, _Dest);

  00054	ff 75 ec	 push	 DWORD PTR __Dest$[ebp]
  00057	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  0005a	ff 75 f0	 push	 DWORD PTR __First$[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCSpeedTreeWrapper@@PAPAV1@@std@@YAPAPAVCSpeedTreeWrapper@@PAPAV1@00@Z ; std::_Copy_memmove<CSpeedTreeWrapper * *,CSpeedTreeWrapper * *>
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	eb 2e		 jmp	 SHORT $LN3@erase

; 4629 :         }
; 4630 :     }
; 4631 : 
; 4632 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

  00067	eb 12		 jmp	 SHORT $LN6@erase
$LN4@erase:
  00069	8b 45 ec	 mov	 eax, DWORD PTR __Dest$[ebp]
  0006c	83 c0 04	 add	 eax, 4
  0006f	89 45 ec	 mov	 DWORD PTR __Dest$[ebp], eax
  00072	8b 45 f0	 mov	 eax, DWORD PTR __First$[ebp]
  00075	83 c0 04	 add	 eax, 4
  00078	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax
$LN6@erase:
  0007b	8b 45 f0	 mov	 eax, DWORD PTR __First$[ebp]
  0007e	3b 45 e0	 cmp	 eax, DWORD PTR __Last$[ebp]
  00081	74 12		 je	 SHORT $LN3@erase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00083	8b 45 f0	 mov	 eax, DWORD PTR __First$[ebp]
  00086	89 45 d4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4633 :         *_Dest = _STD move(*_First);

  00089	8b 45 ec	 mov	 eax, DWORD PTR __Dest$[ebp]
  0008c	8b 4d d4	 mov	 ecx, DWORD PTR $T6[ebp]
  0008f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00091	89 08		 mov	 DWORD PTR [eax], ecx

; 4634 :     }

  00093	eb d4		 jmp	 SHORT $LN4@erase
$LN3@erase:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1354 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  00095	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00098	8b 00		 mov	 eax, DWORD PTR [eax]
  0009a	83 e8 04	 sub	 eax, 4
  0009d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a0	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000a3	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000a6	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000a9	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000ac	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  000af	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax

; 1355 :         --_Mylast;

  000b2	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000b5	8b 00		 mov	 eax, DWORD PTR [eax]
  000b7	83 e8 04	 sub	 eax, 4
  000ba	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000bd	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000bf	8b 45 d8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000c2	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  000c5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000c8	8b 4d e4	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  000cb	89 08		 mov	 DWORD PTR [eax], ecx

; 1356 :         return iterator(_Whereptr, _STD addressof(_My_data));

  000cd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1357 :     }

  000d0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000da	59		 pop	 ecx
  000db	c9		 leave
  000dc	c2 08 00	 ret	 8
  000df	cc		 int	 3
  000e0	cc		 int	 3
  000e1	cc		 int	 3
  000e2	cc		 int	 3
  000e3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?erase@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?erase@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::erase
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::~vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::~vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCSpeedTreeWrapper@@@std@@QAEXQAPAVCSpeedTreeWrapper@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCSpeedTreeWrapper@@@std@@QAEXQAPAVCSpeedTreeWrapper@@I@Z PROC ; std::allocator<CSpeedTreeWrapper *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCSpeedTreeWrapper@@@std@@QAEXQAPAVCSpeedTreeWrapper@@I@Z ENDP ; std::allocator<CSpeedTreeWrapper *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?SetShaderConstants@CSpeedTreeWrapper@@ABEXPBM@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
_afMaterial$ = -52					; size = 32
_afUsefulConstants$ = -20				; size = 16
__$ArrayPad$ = -4					; size = 4
_pMaterial$ = 8						; size = 4
?SetShaderConstants@CSpeedTreeWrapper@@ABEXPBM@Z PROC	; CSpeedTreeWrapper::SetShaderConstants, COMDAT
; _this$ = ecx

; 1313 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 1314 : 	const float afUsefulConstants[] = 
; 1315 : 	{
; 1316 : 		m_pSpeedTree->GetLeafLightingAdjustment(), 0.0f, 0.0f, 0.0f,

  00013	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  0001c	e8 00 00 00 00	 call	 ?GetLeafLightingAdjustment@CSpeedTreeRT@@QBEMXZ ; CSpeedTreeRT::GetLeafLightingAdjustment
  00021	d9 5d ec	 fstp	 DWORD PTR _afUsefulConstants$[ebp]
  00024	0f 57 c0	 xorps	 xmm0, xmm0
  00027	f3 0f 11 45 f0	 movss	 DWORD PTR _afUsefulConstants$[ebp+4], xmm0
  0002c	0f 57 c0	 xorps	 xmm0, xmm0
  0002f	f3 0f 11 45 f4	 movss	 DWORD PTR _afUsefulConstants$[ebp+8], xmm0
  00034	0f 57 c0	 xorps	 xmm0, xmm0
  00037	f3 0f 11 45 f8	 movss	 DWORD PTR _afUsefulConstants$[ebp+12], xmm0

; 1317 : 	};
; 1318 : 	
; 1319 : 	STATEMANAGER.SetVertexShaderConstant(c_nVertexShader_LeafLightingAdjustment, afUsefulConstants, 1);

  0003c	6a 01		 push	 1
  0003e	8d 45 ec	 lea	 eax, DWORD PTR _afUsefulConstants$[ebp]
  00041	50		 push	 eax
  00042	6a 46		 push	 70			; 00000046H
  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0004a	e8 00 00 00 00	 call	 ?SetVertexShaderConstant@CStateManager@@QAEXKPBXK@Z ; CStateManager::SetVertexShaderConstant

; 1320 : 	
; 1321 : 	const float afMaterial[] = 
; 1322 : 	{
; 1323 : 		pMaterial[0], pMaterial[1], pMaterial[2], 1.0f,

  0004f	6a 04		 push	 4
  00051	58		 pop	 eax
  00052	6b c0 00	 imul	 eax, eax, 0
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pMaterial$[ebp]
  00058	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0005d	f3 0f 11 45 cc	 movss	 DWORD PTR _afMaterial$[ebp], xmm0
  00062	6a 04		 push	 4
  00064	58		 pop	 eax
  00065	c1 e0 00	 shl	 eax, 0
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _pMaterial$[ebp]
  0006b	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00070	f3 0f 11 45 d0	 movss	 DWORD PTR _afMaterial$[ebp+4], xmm0
  00075	6a 04		 push	 4
  00077	58		 pop	 eax
  00078	d1 e0		 shl	 eax, 1
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _pMaterial$[ebp]
  0007d	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00082	f3 0f 11 45 d4	 movss	 DWORD PTR _afMaterial$[ebp+8], xmm0
  00087	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0008f	f3 0f 11 45 d8	 movss	 DWORD PTR _afMaterial$[ebp+12], xmm0

; 1324 : 			pMaterial[3], pMaterial[4], pMaterial[5], 1.0f

  00094	6a 04		 push	 4
  00096	58		 pop	 eax
  00097	6b c0 03	 imul	 eax, eax, 3
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _pMaterial$[ebp]
  0009d	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000a2	f3 0f 11 45 dc	 movss	 DWORD PTR _afMaterial$[ebp+16], xmm0
  000a7	6a 04		 push	 4
  000a9	58		 pop	 eax
  000aa	c1 e0 02	 shl	 eax, 2
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _pMaterial$[ebp]
  000b0	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000b5	f3 0f 11 45 e0	 movss	 DWORD PTR _afMaterial$[ebp+20], xmm0
  000ba	6a 04		 push	 4
  000bc	58		 pop	 eax
  000bd	6b c0 05	 imul	 eax, eax, 5
  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _pMaterial$[ebp]
  000c3	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000c8	f3 0f 11 45 e4	 movss	 DWORD PTR _afMaterial$[ebp+24], xmm0
  000cd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d5	f3 0f 11 45 e8	 movss	 DWORD PTR _afMaterial$[ebp+28], xmm0

; 1325 : 	};
; 1326 : 	
; 1327 : 	STATEMANAGER.SetVertexShaderConstant(c_nVertexShader_Material, afMaterial, 2);

  000da	6a 02		 push	 2
  000dc	8d 45 cc	 lea	 eax, DWORD PTR _afMaterial$[ebp]
  000df	50		 push	 eax
  000e0	6a 4a		 push	 74			; 0000004aH
  000e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000e8	e8 00 00 00 00	 call	 ?SetVertexShaderConstant@CStateManager@@QAEXKPBXK@Z ; CStateManager::SetVertexShaderConstant

; 1328 : }

  000ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f0	33 cd		 xor	 ecx, ebp
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	c9		 leave
  000f8	c2 04 00	 ret	 4
?SetShaderConstants@CSpeedTreeWrapper@@ABEXPBM@Z ENDP	; CSpeedTreeWrapper::SetShaderConstants
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?LoadTexture@CSpeedTreeWrapper@@CA_NPBDAAVCGraphicImageInstance@@@Z
_TEXT	SEGMENT
_pResource$ = -8					; size = 4
$T1 = -4						; size = 4
_pFilename$ = 8						; size = 4
_rImage$ = 12						; size = 4
?LoadTexture@CSpeedTreeWrapper@@CA_NPBDAAVCGraphicImageInstance@@@Z PROC ; CSpeedTreeWrapper::LoadTexture, COMDAT

; 1297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  00005	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  0000a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1298 : 	CResource * pResource = CResourceManager::Instance().GetResourcePointer(pFilename);

  0000d	ff 75 08	 push	 DWORD PTR _pFilename$[ebp]
  00010	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00013	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00018	89 45 f8	 mov	 DWORD PTR _pResource$[ebp], eax

; 1299 : 	rImage.SetImagePointer(static_cast<CGraphicImage *>(pResource));

  0001b	ff 75 f8	 push	 DWORD PTR _pResource$[ebp]
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _rImage$[ebp]
  00021	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 1300 : 
; 1301 : 	if (rImage.IsEmpty())

  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _rImage$[ebp]
  00029	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  0002e	0f b6 c0	 movzx	 eax, al
  00031	85 c0		 test	 eax, eax
  00033	74 04		 je	 SHORT $LN2@LoadTextur

; 1302 : 		return false;

  00035	32 c0		 xor	 al, al
  00037	eb 02		 jmp	 SHORT $LN1@LoadTextur
$LN2@LoadTextur:

; 1303 : 	
; 1304 : 	//TraceError("SpeedTreeWrapper::LoadTexture: %s", pFilename);
; 1305 : 	return true;

  00039	b0 01		 mov	 al, 1
$LN1@LoadTextur:

; 1306 : }

  0003b	c9		 leave
  0003c	c3		 ret	 0
?LoadTexture@CSpeedTreeWrapper@@CA_NPBDAAVCGraphicImageInstance@@@Z ENDP ; CSpeedTreeWrapper::LoadTexture
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?PositionTree@CSpeedTreeWrapper@@ABEXXZ
_TEXT	SEGMENT
_vecConstant$ = -116					; size = 16
_fz$ = -100						; size = 4
_fy$ = -96						; size = 4
_fx$ = -92						; size = 4
_this$ = -88						; size = 4
_pf$ = -84						; size = 4
_matTranslation$ = -80					; size = 64
_vecPosition$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
?PositionTree@CSpeedTreeWrapper@@ABEXXZ PROC		; CSpeedTreeWrapper::PositionTree, COMDAT
; _this$ = ecx

; 1278 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d a8	 mov	 DWORD PTR _this$[ebp], ecx

; 1279 : 	D3DXVECTOR3 vecPosition = m_pSpeedTree->GetTreePosition();

  00013	8b 45 a8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  0001c	e8 00 00 00 00	 call	 ?GetTreePosition@CSpeedTreeRT@@QBEPBMXZ ; CSpeedTreeRT::GetTreePosition
  00021	89 45 ac	 mov	 DWORD PTR _pf$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 164  :     x = pf[0];

  00024	6a 04		 push	 4
  00026	58		 pop	 eax
  00027	6b c0 00	 imul	 eax, eax, 0
  0002a	8b 4d ac	 mov	 ecx, DWORD PTR _pf$[ebp]
  0002d	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00032	f3 0f 11 45 f0	 movss	 DWORD PTR _vecPosition$[ebp], xmm0

; 165  :     y = pf[1];

  00037	6a 04		 push	 4
  00039	58		 pop	 eax
  0003a	c1 e0 00	 shl	 eax, 0
  0003d	8b 4d ac	 mov	 ecx, DWORD PTR _pf$[ebp]
  00040	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00045	f3 0f 11 45 f4	 movss	 DWORD PTR _vecPosition$[ebp+4], xmm0

; 166  :     z = pf[2];

  0004a	6a 04		 push	 4
  0004c	58		 pop	 eax
  0004d	d1 e0		 shl	 eax, 1
  0004f	8b 4d ac	 mov	 ecx, DWORD PTR _pf$[ebp]
  00052	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00057	f3 0f 11 45 f8	 movss	 DWORD PTR _vecPosition$[ebp+8], xmm0

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  0005c	6a 10		 push	 16			; 00000010H
  0005e	58		 pop	 eax
  0005f	6b c0 03	 imul	 eax, eax, 3
  00062	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  00066	6a 04		 push	 4
  00068	59		 pop	 ecx
  00069	d1 e1		 shl	 ecx, 1
  0006b	0f 57 c0	 xorps	 xmm0, xmm0
  0006e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00073	6a 10		 push	 16			; 00000010H
  00075	58		 pop	 eax
  00076	6b c0 03	 imul	 eax, eax, 3
  00079	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  0007d	6a 04		 push	 4
  0007f	59		 pop	 ecx
  00080	c1 e1 00	 shl	 ecx, 0
  00083	0f 57 c0	 xorps	 xmm0, xmm0
  00086	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0008b	6a 10		 push	 16			; 00000010H
  0008d	58		 pop	 eax
  0008e	6b c0 03	 imul	 eax, eax, 3
  00091	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  00095	6a 04		 push	 4
  00097	59		 pop	 ecx
  00098	6b c9 00	 imul	 ecx, ecx, 0
  0009b	0f 57 c0	 xorps	 xmm0, xmm0
  0009e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000a3	6a 10		 push	 16			; 00000010H
  000a5	58		 pop	 eax
  000a6	d1 e0		 shl	 eax, 1
  000a8	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  000ac	6a 04		 push	 4
  000ae	59		 pop	 ecx
  000af	6b c9 03	 imul	 ecx, ecx, 3
  000b2	0f 57 c0	 xorps	 xmm0, xmm0
  000b5	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000ba	6a 10		 push	 16			; 00000010H
  000bc	58		 pop	 eax
  000bd	d1 e0		 shl	 eax, 1
  000bf	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  000c3	6a 04		 push	 4
  000c5	59		 pop	 ecx
  000c6	c1 e1 00	 shl	 ecx, 0
  000c9	0f 57 c0	 xorps	 xmm0, xmm0
  000cc	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000d1	6a 10		 push	 16			; 00000010H
  000d3	58		 pop	 eax
  000d4	d1 e0		 shl	 eax, 1
  000d6	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  000da	6a 04		 push	 4
  000dc	59		 pop	 ecx
  000dd	6b c9 00	 imul	 ecx, ecx, 0
  000e0	0f 57 c0	 xorps	 xmm0, xmm0
  000e3	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000e8	6a 10		 push	 16			; 00000010H
  000ea	58		 pop	 eax
  000eb	c1 e0 00	 shl	 eax, 0
  000ee	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  000f2	6a 04		 push	 4
  000f4	59		 pop	 ecx
  000f5	6b c9 03	 imul	 ecx, ecx, 3
  000f8	0f 57 c0	 xorps	 xmm0, xmm0
  000fb	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00100	6a 10		 push	 16			; 00000010H
  00102	58		 pop	 eax
  00103	c1 e0 00	 shl	 eax, 0
  00106	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  0010a	6a 04		 push	 4
  0010c	59		 pop	 ecx
  0010d	d1 e1		 shl	 ecx, 1
  0010f	0f 57 c0	 xorps	 xmm0, xmm0
  00112	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00117	6a 10		 push	 16			; 00000010H
  00119	58		 pop	 eax
  0011a	c1 e0 00	 shl	 eax, 0
  0011d	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  00121	6a 04		 push	 4
  00123	59		 pop	 ecx
  00124	6b c9 00	 imul	 ecx, ecx, 0
  00127	0f 57 c0	 xorps	 xmm0, xmm0
  0012a	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0012f	6a 10		 push	 16			; 00000010H
  00131	58		 pop	 eax
  00132	6b c0 00	 imul	 eax, eax, 0
  00135	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  00139	6a 04		 push	 4
  0013b	59		 pop	 ecx
  0013c	6b c9 03	 imul	 ecx, ecx, 3
  0013f	0f 57 c0	 xorps	 xmm0, xmm0
  00142	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00147	6a 10		 push	 16			; 00000010H
  00149	58		 pop	 eax
  0014a	6b c0 00	 imul	 eax, eax, 0
  0014d	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  00151	6a 04		 push	 4
  00153	59		 pop	 ecx
  00154	d1 e1		 shl	 ecx, 1
  00156	0f 57 c0	 xorps	 xmm0, xmm0
  00159	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0015e	6a 10		 push	 16			; 00000010H
  00160	58		 pop	 eax
  00161	6b c0 00	 imul	 eax, eax, 0
  00164	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  00168	6a 04		 push	 4
  0016a	59		 pop	 ecx
  0016b	c1 e1 00	 shl	 ecx, 0
  0016e	0f 57 c0	 xorps	 xmm0, xmm0
  00171	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00176	6a 10		 push	 16			; 00000010H
  00178	58		 pop	 eax
  00179	6b c0 03	 imul	 eax, eax, 3
  0017c	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  00180	6a 04		 push	 4
  00182	59		 pop	 ecx
  00183	6b c9 03	 imul	 ecx, ecx, 3
  00186	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0018e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00193	6a 10		 push	 16			; 00000010H
  00195	58		 pop	 eax
  00196	d1 e0		 shl	 eax, 1
  00198	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  0019c	6a 04		 push	 4
  0019e	59		 pop	 ecx
  0019f	d1 e1		 shl	 ecx, 1
  001a1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001a9	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001ae	6a 10		 push	 16			; 00000010H
  001b0	58		 pop	 eax
  001b1	c1 e0 00	 shl	 eax, 0
  001b4	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  001b8	6a 04		 push	 4
  001ba	59		 pop	 ecx
  001bb	c1 e1 00	 shl	 ecx, 0
  001be	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001c6	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001cb	6a 10		 push	 16			; 00000010H
  001cd	58		 pop	 eax
  001ce	6b c0 00	 imul	 eax, eax, 0
  001d1	8d 44 05 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp+eax]
  001d5	6a 04		 push	 4
  001d7	59		 pop	 ecx
  001d8	6b c9 00	 imul	 ecx, ecx, 0
  001db	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001e3	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1282 : 	D3DXMatrixTranslation(&matTranslation, vecPosition.x, vecPosition.y, vecPosition.z);

  001e8	51		 push	 ecx
  001e9	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _vecPosition$[ebp+8]
  001ee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f3	51		 push	 ecx
  001f4	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _vecPosition$[ebp+4]
  001f9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fe	51		 push	 ecx
  001ff	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _vecPosition$[ebp]
  00204	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00209	8d 45 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp]
  0020c	50		 push	 eax
  0020d	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16

; 1283 : 	
; 1284 : 	// store translation for client-side transformation
; 1285 : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &matTranslation);

  00212	8d 45 b0	 lea	 eax, DWORD PTR _matTranslation$[ebp]
  00215	50		 push	 eax
  00216	68 00 01 00 00	 push	 256			; 00000100H
  0021b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00221	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 1286 : 	
; 1287 :     // store translation for use in vertex shader
; 1288 : 	D3DXVECTOR4 vecConstant(vecPosition[0], vecPosition[1], vecPosition[2], 0.0f);

  00226	6a 04		 push	 4
  00228	58		 pop	 eax
  00229	6b c0 00	 imul	 eax, eax, 0
  0022c	f3 0f 10 44 05
	f0		 movss	 xmm0, DWORD PTR _vecPosition$[ebp+eax]
  00232	f3 0f 11 45 a4	 movss	 DWORD PTR _fx$[ebp], xmm0
  00237	6a 04		 push	 4
  00239	58		 pop	 eax
  0023a	c1 e0 00	 shl	 eax, 0
  0023d	f3 0f 10 44 05
	f0		 movss	 xmm0, DWORD PTR _vecPosition$[ebp+eax]
  00243	f3 0f 11 45 a0	 movss	 DWORD PTR _fy$[ebp], xmm0
  00248	6a 04		 push	 4
  0024a	58		 pop	 eax
  0024b	d1 e0		 shl	 eax, 1
  0024d	f3 0f 10 44 05
	f0		 movss	 xmm0, DWORD PTR _vecPosition$[ebp+eax]
  00253	f3 0f 11 45 9c	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 321  :     x = fx;

  00258	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0025d	f3 0f 11 45 8c	 movss	 DWORD PTR _vecConstant$[ebp], xmm0

; 322  :     y = fy;

  00262	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00267	f3 0f 11 45 90	 movss	 DWORD PTR _vecConstant$[ebp+4], xmm0

; 323  :     z = fz;

  0026c	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00271	f3 0f 11 45 94	 movss	 DWORD PTR _vecConstant$[ebp+8], xmm0

; 324  :     w = fw;

  00276	0f 57 c0	 xorps	 xmm0, xmm0
  00279	f3 0f 11 45 98	 movss	 DWORD PTR _vecConstant$[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1289 : 	STATEMANAGER.SetVertexShaderConstant(c_nVertexShader_TreePos, (float*)&vecConstant, 1);

  0027e	6a 01		 push	 1
  00280	8d 45 8c	 lea	 eax, DWORD PTR _vecConstant$[ebp]
  00283	50		 push	 eax
  00284	6a 34		 push	 52			; 00000034H
  00286	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0028c	e8 00 00 00 00	 call	 ?SetVertexShaderConstant@CStateManager@@QAEXKPBXK@Z ; CStateManager::SetVertexShaderConstant

; 1290 : }

  00291	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00294	33 cd		 xor	 ecx, ebp
  00296	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029b	c9		 leave
  0029c	c3		 ret	 0
?PositionTree@CSpeedTreeWrapper@@ABEXXZ ENDP		; CSpeedTreeWrapper::PositionTree
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?SetupLeafBuffers@CSpeedTreeWrapper@@AAEXXZ
_TEXT	SEGMENT
$T1 = -56						; size = 4
$T2 = -52						; size = 4
_pVertexBuffer$3 = -48					; size = 4
_pLeaf$4 = -44						; size = 4
_unVert$5 = -40						; size = 4
_pVertex$6 = -36					; size = 4
_unLeaf$7 = -32						; size = 4
_usLeafCount$8 = -28					; size = 2
_unLod$9 = -24						; size = 4
_this$ = -20						; size = 4
_anVertexIndices$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
?SetupLeafBuffers@CSpeedTreeWrapper@@AAEXXZ PROC	; CSpeedTreeWrapper::SetupLeafBuffers, COMDAT
; _this$ = ecx

; 657  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 658  : 	// set up constants
; 659  : 	const short anVertexIndices[6] = { 0, 1, 2, 0, 2, 3 };

  00013	33 c0		 xor	 eax, eax
  00015	66 89 45 f0	 mov	 WORD PTR _anVertexIndices$[ebp], ax
  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	66 89 45 f2	 mov	 WORD PTR _anVertexIndices$[ebp+2], ax
  00020	6a 02		 push	 2
  00022	58		 pop	 eax
  00023	66 89 45 f4	 mov	 WORD PTR _anVertexIndices$[ebp+4], ax
  00027	33 c0		 xor	 eax, eax
  00029	66 89 45 f6	 mov	 WORD PTR _anVertexIndices$[ebp+6], ax
  0002d	6a 02		 push	 2
  0002f	58		 pop	 eax
  00030	66 89 45 f8	 mov	 WORD PTR _anVertexIndices$[ebp+8], ax
  00034	6a 03		 push	 3
  00036	58		 pop	 eax
  00037	66 89 45 fa	 mov	 WORD PTR _anVertexIndices$[ebp+10], ax

; 660  : 	//const int nNumLeafMaps = m_pTextureInfo->m_uiLeafTextureCount;
; 661  : 	
; 662  : 	// set up the leaf counts for each LOD
; 663  : 	m_usNumLeafLods = m_pSpeedTree->GetNumLeafLodLevels();

  0003b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00044	e8 00 00 00 00	 call	 ?GetNumLeafLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumLeafLodLevels
  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	66 89 81 bc 01
	00 00		 mov	 WORD PTR [ecx+444], ax

; 664  : 	
; 665  : 	// create array of vertex buffers (one for each LOD)
; 666  : 	m_pLeafVertexBuffer = new LPDIRECT3DVERTEXBUFFER8[m_usNumLeafLods];

  00053	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00056	0f b7 80 bc 01
	00 00		 movzx	 eax, WORD PTR [eax+444]
  0005d	33 c9		 xor	 ecx, ecx
  0005f	6a 04		 push	 4
  00061	5a		 pop	 edx
  00062	f7 e2		 mul	 edx
  00064	0f 90 c1	 seto	 cl
  00067	f7 d9		 neg	 ecx
  00069	0b c8		 or	 ecx, eax
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00071	59		 pop	 ecx
  00072	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
  00075	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00078	8b 4d cc	 mov	 ecx, DWORD PTR $T2[ebp]
  0007b	89 88 c0 01 00
	00		 mov	 DWORD PTR [eax+448], ecx

; 667  : 	
; 668  : 	// create array of bools for CPU updating (so we don't update for each instance)
; 669  : 	m_pLeavesUpdatedByCpu = new bool[m_usNumLeafLods];

  00081	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00084	0f b7 80 bc 01
	00 00		 movzx	 eax, WORD PTR [eax+444]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00091	59		 pop	 ecx
  00092	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax
  00095	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00098	8b 4d c8	 mov	 ecx, DWORD PTR $T1[ebp]
  0009b	89 88 c4 01 00
	00		 mov	 DWORD PTR [eax+452], ecx

; 670  : 	
; 671  : 	// cycle through LODs
; 672  : 	for (UINT unLod = 0; unLod < m_usNumLeafLods; ++unLod)

  000a1	83 65 e8 00	 and	 DWORD PTR _unLod$9[ebp], 0
  000a5	eb 07		 jmp	 SHORT $LN4@SetupLeafB
$LN2@SetupLeafB:
  000a7	8b 45 e8	 mov	 eax, DWORD PTR _unLod$9[ebp]
  000aa	40		 inc	 eax
  000ab	89 45 e8	 mov	 DWORD PTR _unLod$9[ebp], eax
$LN4@SetupLeafB:
  000ae	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	0f b7 80 bc 01
	00 00		 movzx	 eax, WORD PTR [eax+444]
  000b8	39 45 e8	 cmp	 DWORD PTR _unLod$9[ebp], eax
  000bb	0f 83 7d 01 00
	00		 jae	 $LN1@SetupLeafB

; 673  : 	{
; 674  : 		m_pLeavesUpdatedByCpu[unLod] = false;

  000c1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 80 c4 01 00
	00		 mov	 eax, DWORD PTR [eax+452]
  000ca	8b 4d e8	 mov	 ecx, DWORD PTR _unLod$9[ebp]
  000cd	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0

; 675  : 		m_pLeafVertexBuffer[unLod] = NULL;

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [eax+448]
  000da	8b 4d e8	 mov	 ecx, DWORD PTR _unLod$9[ebp]
  000dd	83 24 88 00	 and	 DWORD PTR [eax+ecx*4], 0

; 676  : 
; 677  : 		// if this LOD has no leaves, skip it
; 678  : 		unsigned short usLeafCount = m_pGeometryCache->m_sLeaves0.m_usLeafCount;

  000e1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  000ea	66 8b 80 84 00
	00 00		 mov	 ax, WORD PTR [eax+132]
  000f1	66 89 45 e4	 mov	 WORD PTR _usLeafCount$8[ebp], ax

; 679  : 		
; 680  : 		if (usLeafCount < 1)

  000f5	0f b7 45 e4	 movzx	 eax, WORD PTR _usLeafCount$8[ebp]
  000f9	83 f8 01	 cmp	 eax, 1
  000fc	7d 02		 jge	 SHORT $LN11@SetupLeafB

; 681  : 			continue;

  000fe	eb a7		 jmp	 SHORT $LN2@SetupLeafB
$LN11@SetupLeafB:

; 682  : 		
; 683  : 		SFVFLeafVertex* pVertexBuffer = NULL;

  00100	83 65 d0 00	 and	 DWORD PTR _pVertexBuffer$3[ebp], 0

; 684  : 		// create the vertex buffer for storing leaf vertices
; 685  : #ifndef WRAPPER_USE_CPU_LEAF_PLACEMENT
; 686  : 		ms_lpd3dDevice->CreateVertexBuffer(usLeafCount * 6 * sizeof(SFVFLeafVertex), D3DUSAGE_WRITEONLY, D3DFVF_SPEEDTREE_LEAF_VERTEX, D3DPOOL_MANAGED, &m_pLeafVertexBuffer[unLod]);
; 687  : 		// fill the vertex buffer by interleaving SpeedTree data
; 688  : 		m_pLeafVertexBuffer[unLod]->Lock(0, 0, reinterpret_cast<BYTE**>(&pVertexBuffer), 0);
; 689  : #else
; 690  : 		ms_lpd3dDevice->CreateVertexBuffer(usLeafCount * 6 * sizeof(SFVFLeafVertex), D3DUSAGE_DYNAMIC, D3DFVF_SPEEDTREE_LEAF_VERTEX, D3DPOOL_SYSTEMMEM, &m_pLeafVertexBuffer[unLod]);

  00104	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00107	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [eax+448]
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR _unLod$9[ebp]
  00110	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00113	50		 push	 eax
  00114	6a 02		 push	 2
  00116	ff 35 00 00 00
	00		 push	 DWORD PTR ?D3DFVF_SPEEDTREE_LEAF_VERTEX@@3KA
  0011c	68 00 02 00 00	 push	 512			; 00000200H
  00121	0f b7 45 e4	 movzx	 eax, WORD PTR _usLeafCount$8[ebp]
  00125	6b c0 06	 imul	 eax, eax, 6
  00128	6b c0 18	 imul	 eax, eax, 24
  0012b	50		 push	 eax
  0012c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00131	8b 00		 mov	 eax, DWORD PTR [eax]
  00133	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00139	ff 50 5c	 call	 DWORD PTR [eax+92]

; 691  : 		// fill the vertex buffer by interleaving SpeedTree data
; 692  : 		m_pLeafVertexBuffer[unLod]->Lock(0, 0, reinterpret_cast<BYTE**>(&pVertexBuffer), D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK);

  0013c	68 00 28 00 00	 push	 10240			; 00002800H
  00141	8d 45 d0	 lea	 eax, DWORD PTR _pVertexBuffer$3[ebp]
  00144	50		 push	 eax
  00145	6a 00		 push	 0
  00147	6a 00		 push	 0
  00149	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0014c	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [eax+448]
  00152	8b 4d e8	 mov	 ecx, DWORD PTR _unLod$9[ebp]
  00155	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00158	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [ecx+448]
  00161	8b 55 e8	 mov	 edx, DWORD PTR _unLod$9[ebp]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	ff 34 91	 push	 DWORD PTR [ecx+edx*4]
  00169	ff 50 2c	 call	 DWORD PTR [eax+44]

; 693  : #endif
; 694  : 		SFVFLeafVertex* pVertex = pVertexBuffer;

  0016c	8b 45 d0	 mov	 eax, DWORD PTR _pVertexBuffer$3[ebp]
  0016f	89 45 dc	 mov	 DWORD PTR _pVertex$6[ebp], eax

; 695  : 		for (UINT unLeaf = 0; unLeaf < usLeafCount; ++unLeaf)

  00172	83 65 e0 00	 and	 DWORD PTR _unLeaf$7[ebp], 0
  00176	eb 07		 jmp	 SHORT $LN7@SetupLeafB
$LN5@SetupLeafB:
  00178	8b 45 e0	 mov	 eax, DWORD PTR _unLeaf$7[ebp]
  0017b	40		 inc	 eax
  0017c	89 45 e0	 mov	 DWORD PTR _unLeaf$7[ebp], eax
$LN7@SetupLeafB:
  0017f	0f b7 45 e4	 movzx	 eax, WORD PTR _usLeafCount$8[ebp]
  00183	39 45 e0	 cmp	 DWORD PTR _unLeaf$7[ebp], eax
  00186	0f 83 8a 00 00
	00		 jae	 $LN6@SetupLeafB

; 696  : 		{
; 697  : 			const CSpeedTreeRT::SGeometry::SLeaf* pLeaf = &(m_pGeometryCache->m_sLeaves0);

  0018c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0018f	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00195	83 c0 78	 add	 eax, 120		; 00000078H
  00198	89 45 d4	 mov	 DWORD PTR _pLeaf$4[ebp], eax

; 698  : 			for (UINT unVert = 0; unVert < 6; ++unVert)  // 6 verts == 2 triangles

  0019b	83 65 d8 00	 and	 DWORD PTR _unVert$5[ebp], 0
  0019f	eb 07		 jmp	 SHORT $LN10@SetupLeafB
$LN8@SetupLeafB:
  001a1	8b 45 d8	 mov	 eax, DWORD PTR _unVert$5[ebp]
  001a4	40		 inc	 eax
  001a5	89 45 d8	 mov	 DWORD PTR _unVert$5[ebp], eax
$LN10@SetupLeafB:
  001a8	83 7d d8 06	 cmp	 DWORD PTR _unVert$5[ebp], 6
  001ac	73 63		 jae	 SHORT $LN9@SetupLeafB

; 699  : 			{
; 700  : 				// position
; 701  : 				memcpy(pVertex->m_vPosition, &(pLeaf->m_pCenterCoords[unLeaf * 3]), 3 * sizeof(float));

  001ae	6a 0c		 push	 12			; 0000000cH
  001b0	6b 45 e0 03	 imul	 eax, DWORD PTR _unLeaf$7[ebp], 3
  001b4	8b 4d d4	 mov	 ecx, DWORD PTR _pLeaf$4[ebp]
  001b7	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  001ba	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  001bd	50		 push	 eax
  001be	ff 75 dc	 push	 DWORD PTR _pVertex$6[ebp]
  001c1	e8 00 00 00 00	 call	 _memcpy
  001c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 702  : 				
; 703  : #ifdef WRAPPER_USE_DYNAMIC_LIGHTING
; 704  : 				// normal
; 705  : 				memcpy(&pVertex->m_vNormal, &(pLeaf->m_pNormals[unLeaf * 3]), 3 * sizeof(float));
; 706  : #else
; 707  : 				// color
; 708  : 				pVertex->m_dwDiffuseColor = pLeaf->m_pColors[unLeaf];

  001c9	8b 45 d4	 mov	 eax, DWORD PTR _pLeaf$4[ebp]
  001cc	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  001cf	8b 4d dc	 mov	 ecx, DWORD PTR _pVertex$6[ebp]
  001d2	8b 55 e0	 mov	 edx, DWORD PTR _unLeaf$7[ebp]
  001d5	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  001d8	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 709  : #endif
; 710  : 				
; 711  : 				// tex coord
; 712  : 				memcpy(pVertex->m_fTexCoords, &(pLeaf->m_pLeafMapTexCoords[unLeaf][anVertexIndices[unVert] * 2]), 2 * sizeof(float));

  001db	6a 08		 push	 8
  001dd	8b 45 d4	 mov	 eax, DWORD PTR _pLeaf$4[ebp]
  001e0	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  001e3	8b 4d d8	 mov	 ecx, DWORD PTR _unVert$5[ebp]
  001e6	0f bf 4c 4d f0	 movsx	 ecx, WORD PTR _anVertexIndices$[ebp+ecx*2]
  001eb	d1 e1		 shl	 ecx, 1
  001ed	8b 55 e0	 mov	 edx, DWORD PTR _unLeaf$7[ebp]
  001f0	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  001f3	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  001f6	50		 push	 eax
  001f7	8b 45 dc	 mov	 eax, DWORD PTR _pVertex$6[ebp]
  001fa	83 c0 10	 add	 eax, 16			; 00000010H
  001fd	50		 push	 eax
  001fe	e8 00 00 00 00	 call	 _memcpy
  00203	83 c4 0c	 add	 esp, 12			; 0000000cH

; 713  : 				
; 714  : 				// wind weights
; 715  : #ifdef WRAPPER_USE_GPU_WIND
; 716  : 				pVertex->m_fWindIndex = 4.0f * pLeaf->m_pWindMatrixIndices[unLeaf];
; 717  : 				pVertex->m_fWindWeight = pLeaf->m_pWindWeights[unLeaf];
; 718  : #endif
; 719  : 				
; 720  : 				// GPU placement data
; 721  : #ifdef WRAPPER_USE_GPU_LEAF_PLACEMENT
; 722  : 				pVertex->m_fLeafPlacementIndex = c_nVertexShader_LeafTables + pLeaf->m_pLeafClusterIndices[unLeaf] * 4.0f + anVertexIndices[unVert];
; 723  : 				pVertex->m_fLeafScalarValue = m_pSpeedTree->GetLeafLodSizeAdjustments()[unLod];
; 724  : #endif
; 725  : 				
; 726  : 				++pVertex;

  00206	8b 45 dc	 mov	 eax, DWORD PTR _pVertex$6[ebp]
  00209	83 c0 18	 add	 eax, 24			; 00000018H
  0020c	89 45 dc	 mov	 DWORD PTR _pVertex$6[ebp], eax

; 727  : 			}

  0020f	eb 90		 jmp	 SHORT $LN8@SetupLeafB
$LN9@SetupLeafB:

; 728  : 		}

  00211	e9 62 ff ff ff	 jmp	 $LN5@SetupLeafB
$LN6@SetupLeafB:

; 729  : 		m_pLeafVertexBuffer[unLod]->Unlock();

  00216	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00219	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [eax+448]
  0021f	8b 4d e8	 mov	 ecx, DWORD PTR _unLod$9[ebp]
  00222	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00225	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00228	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [ecx+448]
  0022e	8b 55 e8	 mov	 edx, DWORD PTR _unLod$9[ebp]
  00231	8b 00		 mov	 eax, DWORD PTR [eax]
  00233	ff 34 91	 push	 DWORD PTR [ecx+edx*4]
  00236	ff 50 30	 call	 DWORD PTR [eax+48]

; 730  : 	}

  00239	e9 69 fe ff ff	 jmp	 $LN2@SetupLeafB
$LN1@SetupLeafB:

; 731  : }

  0023e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00241	33 cd		 xor	 ecx, ebp
  00243	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00248	c9		 leave
  00249	c3		 ret	 0
?SetupLeafBuffers@CSpeedTreeWrapper@@AAEXXZ ENDP	; CSpeedTreeWrapper::SetupLeafBuffers
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?SetupFrondBuffers@CSpeedTreeWrapper@@AAEXXZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
_pIndexBuffer$2 = -28					; size = 4
_unNumLodLevels$3 = -24					; size = 4
_j$4 = -20						; size = 2
_pVertexBuffer$5 = -16					; size = 4
_i$6 = -12						; size = 4
_pFronds$ = -8						; size = 4
_this$ = -4						; size = 4
?SetupFrondBuffers@CSpeedTreeWrapper@@AAEXXZ PROC	; CSpeedTreeWrapper::SetupFrondBuffers, COMDAT
; _this$ = ecx

; 572  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 573  : 	// reference to frond structure
; 574  : 	CSpeedTreeRT::SGeometry::SIndexed* pFronds = &(m_pGeometryCache->m_sFronds);

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00013	83 c0 3c	 add	 eax, 60			; 0000003cH
  00016	89 45 f8	 mov	 DWORD PTR _pFronds$[ebp], eax

; 575  : 	m_unFrondVertexCount = pFronds->m_usVertexCount; // we asked for a contiguous strip

  00019	8b 45 f8	 mov	 eax, DWORD PTR _pFronds$[ebp]
  0001c	0f b7 40 10	 movzx	 eax, WORD PTR [eax+16]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	89 81 b0 01 00
	00		 mov	 DWORD PTR [ecx+432], eax

; 576  : 	
; 577  : 	// check if tree has fronds
; 578  : 	if (m_unFrondVertexCount > 1)

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 b8 b0 01 00
	00 01		 cmp	 DWORD PTR [eax+432], 1
  00033	0f 86 ac 02 00
	00		 jbe	 $LN8@SetupFrond

; 579  : 	{
; 580  : 		// create the vertex buffer for storing frond vertices
; 581  : 		SFVFBranchVertex * pVertexBuffer = NULL;

  00039	83 65 f0 00	 and	 DWORD PTR _pVertexBuffer$5[ebp], 0

; 582  : #ifndef WRAPPER_USE_CPU_WIND
; 583  : 		ms_lpd3dDevice->CreateVertexBuffer(m_unFrondVertexCount * sizeof(SFVFBranchVertex), D3DUSAGE_WRITEONLY, D3DFVF_SPEEDTREE_BRANCH_VERTEX, D3DPOOL_MANAGED, &m_pFrondVertexBuffer);

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	05 ac 01 00 00	 add	 eax, 428		; 000001acH
  00045	50		 push	 eax
  00046	6a 01		 push	 1
  00048	ff 35 00 00 00
	00		 push	 DWORD PTR ?D3DFVF_SPEEDTREE_BRANCH_VERTEX@@3KA
  0004e	6a 08		 push	 8
  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 80 b0 01 00
	00		 mov	 eax, DWORD PTR [eax+432]
  00059	c1 e0 05	 shl	 eax, 5
  0005c	50		 push	 eax
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0006a	ff 50 5c	 call	 DWORD PTR [eax+92]

; 584  : 		// fill the vertex buffer by interleaving SpeedTree data
; 585  : 		m_pFrondVertexBuffer->Lock(0, 0, reinterpret_cast<BYTE**>(&pVertexBuffer), 0);

  0006d	6a 00		 push	 0
  0006f	8d 45 f0	 lea	 eax, DWORD PTR _pVertexBuffer$5[ebp]
  00072	50		 push	 eax
  00073	6a 00		 push	 0
  00075	6a 00		 push	 0
  00077	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [eax+428]
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]
  00085	ff b1 ac 01 00
	00		 push	 DWORD PTR [ecx+428]
  0008b	ff 50 2c	 call	 DWORD PTR [eax+44]

; 586  : #else
; 587  : 		ms_lpd3dDevice->CreateVertexBuffer(m_unFrondVertexCount * sizeof(SFVFBranchVertex), D3DUSAGE_DYNAMIC, D3DFVF_SPEEDTREE_BRANCH_VERTEX, D3DPOOL_SYSTEMMEM, &m_pFrondVertexBuffer);
; 588  : 		// fill the vertex buffer by interleaving SpeedTree data
; 589  : 		m_pFrondVertexBuffer->Lock(0, 0, reinterpret_cast<BYTE**>(&pVertexBuffer), D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK);
; 590  : #endif		
; 591  : 		for (UINT i = 0; i < m_unFrondVertexCount; ++i)

  0008e	83 65 f4 00	 and	 DWORD PTR _i$6[ebp], 0
  00092	eb 07		 jmp	 SHORT $LN4@SetupFrond
$LN2@SetupFrond:
  00094	8b 45 f4	 mov	 eax, DWORD PTR _i$6[ebp]
  00097	40		 inc	 eax
  00098	89 45 f4	 mov	 DWORD PTR _i$6[ebp], eax
$LN4@SetupFrond:
  0009b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR _i$6[ebp]
  000a1	3b 88 b0 01 00
	00		 cmp	 ecx, DWORD PTR [eax+432]
  000a7	0f 83 a9 00 00
	00		 jae	 $LN3@SetupFrond

; 592  : 		{
; 593  : 			// position
; 594  : 			memcpy(&pVertexBuffer->m_vPosition, &(pFronds->m_pCoords[i * 3]), 3 * sizeof(float));

  000ad	6a 0c		 push	 12			; 0000000cH
  000af	6b 45 f4 03	 imul	 eax, DWORD PTR _i$6[ebp], 3
  000b3	8b 4d f8	 mov	 ecx, DWORD PTR _pFronds$[ebp]
  000b6	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  000b9	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000bc	50		 push	 eax
  000bd	ff 75 f0	 push	 DWORD PTR _pVertexBuffer$5[ebp]
  000c0	e8 00 00 00 00	 call	 _memcpy
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 595  : 			
; 596  : 			// normal or color
; 597  : #ifdef WRAPPER_USE_DYNAMIC_LIGHTING
; 598  : 			memcpy(&pVertexBuffer->m_vNormal, &(pFronds->m_pNormals[i * 3]), 3 * sizeof(float));
; 599  : #else
; 600  : 			pVertexBuffer->m_dwDiffuseColor = pFronds->m_pColors[i];

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _pFronds$[ebp]
  000cb	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000ce	8b 4d f0	 mov	 ecx, DWORD PTR _pVertexBuffer$5[ebp]
  000d1	8b 55 f4	 mov	 edx, DWORD PTR _i$6[ebp]
  000d4	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  000d7	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 601  : #endif
; 602  : 			
; 603  : 			// texcoords for layer 0
; 604  : 			pVertexBuffer->m_fTexCoords[0] = pFronds->m_pTexCoords0[i * 2];

  000da	8b 45 f4	 mov	 eax, DWORD PTR _i$6[ebp]
  000dd	d1 e0		 shl	 eax, 1
  000df	8b 4d f8	 mov	 ecx, DWORD PTR _pFronds$[ebp]
  000e2	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  000e5	6a 04		 push	 4
  000e7	5a		 pop	 edx
  000e8	6b d2 00	 imul	 edx, edx, 0
  000eb	8b 75 f0	 mov	 esi, DWORD PTR _pVertexBuffer$5[ebp]
  000ee	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000f1	89 44 16 10	 mov	 DWORD PTR [esi+edx+16], eax

; 605  : 			pVertexBuffer->m_fTexCoords[1] = pFronds->m_pTexCoords0[i * 2 + 1];

  000f5	8b 45 f4	 mov	 eax, DWORD PTR _i$6[ebp]
  000f8	d1 e0		 shl	 eax, 1
  000fa	8b 4d f8	 mov	 ecx, DWORD PTR _pFronds$[ebp]
  000fd	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  00100	6a 04		 push	 4
  00102	5a		 pop	 edx
  00103	c1 e2 00	 shl	 edx, 0
  00106	8b 75 f0	 mov	 esi, DWORD PTR _pVertexBuffer$5[ebp]
  00109	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  0010d	89 44 16 10	 mov	 DWORD PTR [esi+edx+16], eax

; 606  : 			
; 607  : 			// texcoords for layer 1 (if enabled)
; 608  : #ifdef WRAPPER_RENDER_SELF_SHADOWS
; 609  : 			pVertexBuffer->m_fShadowCoords[0] = pFronds->m_pTexCoords1[i * 2];

  00111	8b 45 f4	 mov	 eax, DWORD PTR _i$6[ebp]
  00114	d1 e0		 shl	 eax, 1
  00116	8b 4d f8	 mov	 ecx, DWORD PTR _pFronds$[ebp]
  00119	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  0011c	6a 04		 push	 4
  0011e	5a		 pop	 edx
  0011f	6b d2 00	 imul	 edx, edx, 0
  00122	8b 75 f0	 mov	 esi, DWORD PTR _pVertexBuffer$5[ebp]
  00125	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00128	89 44 16 18	 mov	 DWORD PTR [esi+edx+24], eax

; 610  : 			pVertexBuffer->m_fShadowCoords[1] = pFronds->m_pTexCoords1[i * 2 + 1];

  0012c	8b 45 f4	 mov	 eax, DWORD PTR _i$6[ebp]
  0012f	d1 e0		 shl	 eax, 1
  00131	8b 4d f8	 mov	 ecx, DWORD PTR _pFronds$[ebp]
  00134	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  00137	6a 04		 push	 4
  00139	5a		 pop	 edx
  0013a	c1 e2 00	 shl	 edx, 0
  0013d	8b 75 f0	 mov	 esi, DWORD PTR _pVertexBuffer$5[ebp]
  00140	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  00144	89 44 16 18	 mov	 DWORD PTR [esi+edx+24], eax

; 611  : #endif
; 612  : 			
; 613  : 			// extra data for gpu wind
; 614  : #ifdef WRAPPER_USE_GPU_WIND
; 615  : 			pVertexBuffer->m_fWindIndex = 4.0f * pFronds->m_pWindMatrixIndices[i];
; 616  : 			pVertexBuffer->m_fWindWeight = pFronds->m_pWindWeights[i];
; 617  : #endif
; 618  : 			
; 619  : 			++pVertexBuffer;

  00148	8b 45 f0	 mov	 eax, DWORD PTR _pVertexBuffer$5[ebp]
  0014b	83 c0 20	 add	 eax, 32			; 00000020H
  0014e	89 45 f0	 mov	 DWORD PTR _pVertexBuffer$5[ebp], eax

; 620  : 		}

  00151	e9 3e ff ff ff	 jmp	 $LN2@SetupFrond
$LN3@SetupFrond:

; 621  : 		m_pFrondVertexBuffer->Unlock();

  00156	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00159	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [eax+428]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	8b 00		 mov	 eax, DWORD PTR [eax]
  00164	ff b1 ac 01 00
	00		 push	 DWORD PTR [ecx+428]
  0016a	ff 50 30	 call	 DWORD PTR [eax+48]

; 622  : 		
; 623  : 		// create and fill the index counts for each LOD
; 624  : 		UINT unNumLodLevels = m_pSpeedTree->GetNumFrondLodLevels();

  0016d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00170	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00176	e8 00 00 00 00	 call	 ?GetNumFrondLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumFrondLodLevels
  0017b	0f b7 c0	 movzx	 eax, ax
  0017e	89 45 e8	 mov	 DWORD PTR _unNumLodLevels$3[ebp], eax

; 625  : 		m_pFrondIndexCounts = new unsigned short[unNumLodLevels];

  00181	33 c9		 xor	 ecx, ecx
  00183	8b 45 e8	 mov	 eax, DWORD PTR _unNumLodLevels$3[ebp]
  00186	6a 02		 push	 2
  00188	5a		 pop	 edx
  00189	f7 e2		 mul	 edx
  0018b	0f 90 c1	 seto	 cl
  0018e	f7 d9		 neg	 ecx
  00190	0b c8		 or	 ecx, eax
  00192	51		 push	 ecx
  00193	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00198	59		 pop	 ecx
  00199	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
  0019c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0019f	8b 4d e0	 mov	 ecx, DWORD PTR $T1[ebp]
  001a2	89 88 b8 01 00
	00		 mov	 DWORD PTR [eax+440], ecx

; 626  : 		for (WORD j = 0; j < unNumLodLevels; ++j)

  001a8	33 c0		 xor	 eax, eax
  001aa	66 89 45 ec	 mov	 WORD PTR _j$4[ebp], ax
  001ae	eb 0c		 jmp	 SHORT $LN7@SetupFrond
$LN5@SetupFrond:
  001b0	66 8b 45 ec	 mov	 ax, WORD PTR _j$4[ebp]
  001b4	66 83 c0 01	 add	 ax, 1
  001b8	66 89 45 ec	 mov	 WORD PTR _j$4[ebp], ax
$LN7@SetupFrond:
  001bc	0f b7 45 ec	 movzx	 eax, WORD PTR _j$4[ebp]
  001c0	3b 45 e8	 cmp	 eax, DWORD PTR _unNumLodLevels$3[ebp]
  001c3	73 63		 jae	 SHORT $LN6@SetupFrond

; 627  : 		{
; 628  : 			// force update for this LOD
; 629  : 			m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_FrondGeometry, -1, j);

  001c5	6a ff		 push	 -1
  001c7	ff 75 ec	 push	 DWORD PTR _j$4[ebp]
  001ca	6a ff		 push	 -1
  001cc	6a 02		 push	 2
  001ce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001d1	ff b0 98 01 00
	00		 push	 DWORD PTR [eax+408]
  001d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001da	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  001e0	e8 00 00 00 00	 call	 ?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z ; CSpeedTreeRT::GetGeometry

; 630  : 			
; 631  : 			// check if this LOD has fronds
; 632  : 			if (pFronds->m_usNumStrips > 0)

  001e5	8b 45 f8	 mov	 eax, DWORD PTR _pFronds$[ebp]
  001e8	0f b7 40 04	 movzx	 eax, WORD PTR [eax+4]
  001ec	85 c0		 test	 eax, eax
  001ee	7e 23		 jle	 SHORT $LN9@SetupFrond

; 633  : 				m_pFrondIndexCounts[j] = pFronds->m_pStripLengths[0];

  001f0	6a 02		 push	 2
  001f2	58		 pop	 eax
  001f3	6b c0 00	 imul	 eax, eax, 0
  001f6	8b 4d f8	 mov	 ecx, DWORD PTR _pFronds$[ebp]
  001f9	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  001fc	0f b7 55 ec	 movzx	 edx, WORD PTR _j$4[ebp]
  00200	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00203	8b b6 b8 01 00
	00		 mov	 esi, DWORD PTR [esi+440]
  00209	66 8b 04 08	 mov	 ax, WORD PTR [eax+ecx]
  0020d	66 89 04 56	 mov	 WORD PTR [esi+edx*2], ax
  00211	eb 13		 jmp	 SHORT $LN10@SetupFrond
$LN9@SetupFrond:

; 634  : 			else
; 635  : 				m_pFrondIndexCounts[j] = 0;

  00213	0f b7 45 ec	 movzx	 eax, WORD PTR _j$4[ebp]
  00217	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021a	8b 89 b8 01 00
	00		 mov	 ecx, DWORD PTR [ecx+440]
  00220	33 d2		 xor	 edx, edx
  00222	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN10@SetupFrond:

; 636  : 		}

  00226	eb 88		 jmp	 SHORT $LN5@SetupFrond
$LN6@SetupFrond:

; 637  : 		// go back to highest LOD
; 638  : 		m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_FrondGeometry, -1, 0);

  00228	6a ff		 push	 -1
  0022a	6a 00		 push	 0
  0022c	6a ff		 push	 -1
  0022e	6a 02		 push	 2
  00230	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00233	ff b0 98 01 00
	00		 push	 DWORD PTR [eax+408]
  00239	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0023c	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00242	e8 00 00 00 00	 call	 ?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z ; CSpeedTreeRT::GetGeometry

; 639  : 		
; 640  : 		// the first LOD level contains the most indices of all the levels, so
; 641  : 		// we use its size to allocate the index buffer
; 642  : 		ms_lpd3dDevice->CreateIndexBuffer(m_pFrondIndexCounts[0] * sizeof(unsigned short), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED, &m_pFrondIndexBuffer);

  00247	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0024a	05 b4 01 00 00	 add	 eax, 436		; 000001b4H
  0024f	50		 push	 eax
  00250	6a 01		 push	 1
  00252	6a 65		 push	 101			; 00000065H
  00254	6a 08		 push	 8
  00256	6a 02		 push	 2
  00258	58		 pop	 eax
  00259	6b c0 00	 imul	 eax, eax, 0
  0025c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0025f	8b 89 b8 01 00
	00		 mov	 ecx, DWORD PTR [ecx+440]
  00265	0f b7 04 01	 movzx	 eax, WORD PTR [ecx+eax]
  00269	d1 e0		 shl	 eax, 1
  0026b	50		 push	 eax
  0026c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00271	8b 00		 mov	 eax, DWORD PTR [eax]
  00273	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00279	ff 50 60	 call	 DWORD PTR [eax+96]

; 643  : 		
; 644  : 		// fill the index buffer
; 645  : 		unsigned short * pIndexBuffer = NULL;

  0027c	83 65 e4 00	 and	 DWORD PTR _pIndexBuffer$2[ebp], 0

; 646  : 		m_pFrondIndexBuffer->Lock(0, 0, reinterpret_cast<BYTE**>(&pIndexBuffer), 0);

  00280	6a 00		 push	 0
  00282	8d 45 e4	 lea	 eax, DWORD PTR _pIndexBuffer$2[ebp]
  00285	50		 push	 eax
  00286	6a 00		 push	 0
  00288	6a 00		 push	 0
  0028a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0028d	8b 80 b4 01 00
	00		 mov	 eax, DWORD PTR [eax+436]
  00293	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00296	8b 00		 mov	 eax, DWORD PTR [eax]
  00298	ff b1 b4 01 00
	00		 push	 DWORD PTR [ecx+436]
  0029e	ff 50 2c	 call	 DWORD PTR [eax+44]

; 647  : 		memcpy(pIndexBuffer, pFronds->m_pStrips[0], pFronds->m_pStripLengths[0] * sizeof(unsigned short));

  002a1	6a 02		 push	 2
  002a3	58		 pop	 eax
  002a4	6b c0 00	 imul	 eax, eax, 0
  002a7	8b 4d f8	 mov	 ecx, DWORD PTR _pFronds$[ebp]
  002aa	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  002ad	0f b7 04 01	 movzx	 eax, WORD PTR [ecx+eax]
  002b1	d1 e0		 shl	 eax, 1
  002b3	50		 push	 eax
  002b4	6a 04		 push	 4
  002b6	58		 pop	 eax
  002b7	6b c0 00	 imul	 eax, eax, 0
  002ba	8b 4d f8	 mov	 ecx, DWORD PTR _pFronds$[ebp]
  002bd	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  002c0	ff 34 01	 push	 DWORD PTR [ecx+eax]
  002c3	ff 75 e4	 push	 DWORD PTR _pIndexBuffer$2[ebp]
  002c6	e8 00 00 00 00	 call	 _memcpy
  002cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 648  : 		m_pFrondIndexBuffer->Unlock();

  002ce	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002d1	8b 80 b4 01 00
	00		 mov	 eax, DWORD PTR [eax+436]
  002d7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002da	8b 00		 mov	 eax, DWORD PTR [eax]
  002dc	ff b1 b4 01 00
	00		 push	 DWORD PTR [ecx+436]
  002e2	ff 50 30	 call	 DWORD PTR [eax+48]
$LN8@SetupFrond:

; 649  : 	}
; 650  : }

  002e5	5e		 pop	 esi
  002e6	c9		 leave
  002e7	c3		 ret	 0
?SetupFrondBuffers@CSpeedTreeWrapper@@AAEXXZ ENDP	; CSpeedTreeWrapper::SetupFrondBuffers
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?SetupBranchBuffers@CSpeedTreeWrapper@@AAEXXZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
_pIndexBuffer$2 = -28					; size = 4
_unNumLodLevels$3 = -24					; size = 4
_i$4 = -20						; size = 4
_pVertexBuffer$5 = -16					; size = 4
_i$6 = -12						; size = 4
_pBranches$ = -8					; size = 4
_this$ = -4						; size = 4
?SetupBranchBuffers@CSpeedTreeWrapper@@AAEXXZ PROC	; CSpeedTreeWrapper::SetupBranchBuffers, COMDAT
; _this$ = ecx

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 485  : 	// reference to branch structure
; 486  : 	CSpeedTreeRT::SGeometry::SIndexed* pBranches = &(m_pGeometryCache->m_sBranches);

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00013	89 45 f8	 mov	 DWORD PTR _pBranches$[ebp], eax

; 487  : 	m_unBranchVertexCount = pBranches->m_usVertexCount; // we asked for a contiguous strip

  00016	8b 45 f8	 mov	 eax, DWORD PTR _pBranches$[ebp]
  00019	0f b7 40 10	 movzx	 eax, WORD PTR [eax+16]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	89 81 a0 01 00
	00		 mov	 DWORD PTR [ecx+416], eax

; 488  : 	
; 489  : 	// check if this tree has branches
; 490  : 	if (m_unBranchVertexCount > 1)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 b8 a0 01 00
	00 01		 cmp	 DWORD PTR [eax+416], 1
  00030	0f 86 a2 02 00
	00		 jbe	 $LN8@SetupBranc

; 491  : 	{
; 492  : 		// create the vertex buffer for storing branch vertices
; 493  : 		SFVFBranchVertex * pVertexBuffer = NULL;

  00036	83 65 f0 00	 and	 DWORD PTR _pVertexBuffer$5[ebp], 0

; 494  : 		
; 495  : #ifndef WRAPPER_USE_CPU_WIND
; 496  : 		ms_lpd3dDevice->CreateVertexBuffer(m_unBranchVertexCount * sizeof(SFVFBranchVertex), D3DUSAGE_WRITEONLY, D3DFVF_SPEEDTREE_BRANCH_VERTEX, D3DPOOL_MANAGED, &m_pBranchVertexBuffer);

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	05 9c 01 00 00	 add	 eax, 412		; 0000019cH
  00042	50		 push	 eax
  00043	6a 01		 push	 1
  00045	ff 35 00 00 00
	00		 push	 DWORD PTR ?D3DFVF_SPEEDTREE_BRANCH_VERTEX@@3KA
  0004b	6a 08		 push	 8
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 80 a0 01 00
	00		 mov	 eax, DWORD PTR [eax+416]
  00056	c1 e0 05	 shl	 eax, 5
  00059	50		 push	 eax
  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00067	ff 50 5c	 call	 DWORD PTR [eax+92]

; 497  : 		// fill the vertex buffer by interleaving SpeedTree data
; 498  : 		m_pBranchVertexBuffer->Lock(0, 0, reinterpret_cast<BYTE**>(&pVertexBuffer), 0);

  0006a	6a 00		 push	 0
  0006c	8d 45 f0	 lea	 eax, DWORD PTR _pVertexBuffer$5[ebp]
  0006f	50		 push	 eax
  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00077	8b 80 9c 01 00
	00		 mov	 eax, DWORD PTR [eax+412]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
  00082	ff b1 9c 01 00
	00		 push	 DWORD PTR [ecx+412]
  00088	ff 50 2c	 call	 DWORD PTR [eax+44]

; 499  : #else
; 500  : 		ms_lpd3dDevice->CreateVertexBuffer(m_unBranchVertexCount * sizeof(SFVFBranchVertex), D3DUSAGE_DYNAMIC, D3DFVF_SPEEDTREE_BRANCH_VERTEX, D3DPOOL_SYSTEMMEM, &m_pBranchVertexBuffer);
; 501  : 		// fill the vertex buffer by interleaving SpeedTree data
; 502  : 		m_pBranchVertexBuffer->Lock(0, 0, reinterpret_cast<BYTE**>(&pVertexBuffer), D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK);
; 503  : #endif
; 504  : 		{
; 505  : 			for (UINT i = 0; i < m_unBranchVertexCount; ++i)

  0008b	83 65 f4 00	 and	 DWORD PTR _i$6[ebp], 0
  0008f	eb 07		 jmp	 SHORT $LN4@SetupBranc
$LN2@SetupBranc:
  00091	8b 45 f4	 mov	 eax, DWORD PTR _i$6[ebp]
  00094	40		 inc	 eax
  00095	89 45 f4	 mov	 DWORD PTR _i$6[ebp], eax
$LN4@SetupBranc:
  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _i$6[ebp]
  0009e	3b 88 a0 01 00
	00		 cmp	 ecx, DWORD PTR [eax+416]
  000a4	0f 83 a9 00 00
	00		 jae	 $LN3@SetupBranc

; 506  : 			{
; 507  : 				// position
; 508  : 				memcpy(&pVertexBuffer->m_vPosition, &(pBranches->m_pCoords[i * 3]), 3 * sizeof(float));

  000aa	6a 0c		 push	 12			; 0000000cH
  000ac	6b 45 f4 03	 imul	 eax, DWORD PTR _i$6[ebp], 3
  000b0	8b 4d f8	 mov	 ecx, DWORD PTR _pBranches$[ebp]
  000b3	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  000b6	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b9	50		 push	 eax
  000ba	ff 75 f0	 push	 DWORD PTR _pVertexBuffer$5[ebp]
  000bd	e8 00 00 00 00	 call	 _memcpy
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 509  : 				
; 510  : 				// normal or color
; 511  : #ifdef WRAPPER_USE_DYNAMIC_LIGHTING
; 512  : 				memcpy(&pVertexBuffer->m_vNormal, &(pBranches->m_pNormals[i * 3]), 3 * sizeof(float));
; 513  : #else
; 514  : 				pVertexBuffer->m_dwDiffuseColor = pBranches->m_pColors[i];

  000c5	8b 45 f8	 mov	 eax, DWORD PTR _pBranches$[ebp]
  000c8	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000cb	8b 4d f0	 mov	 ecx, DWORD PTR _pVertexBuffer$5[ebp]
  000ce	8b 55 f4	 mov	 edx, DWORD PTR _i$6[ebp]
  000d1	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  000d4	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 515  : #endif
; 516  : 				
; 517  : 				// texcoords for layer 0
; 518  : 				pVertexBuffer->m_fTexCoords[0] = pBranches->m_pTexCoords0[i * 2];

  000d7	8b 45 f4	 mov	 eax, DWORD PTR _i$6[ebp]
  000da	d1 e0		 shl	 eax, 1
  000dc	8b 4d f8	 mov	 ecx, DWORD PTR _pBranches$[ebp]
  000df	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  000e2	6a 04		 push	 4
  000e4	5a		 pop	 edx
  000e5	6b d2 00	 imul	 edx, edx, 0
  000e8	8b 75 f0	 mov	 esi, DWORD PTR _pVertexBuffer$5[ebp]
  000eb	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000ee	89 44 16 10	 mov	 DWORD PTR [esi+edx+16], eax

; 519  : 				pVertexBuffer->m_fTexCoords[1] = pBranches->m_pTexCoords0[i * 2 + 1];

  000f2	8b 45 f4	 mov	 eax, DWORD PTR _i$6[ebp]
  000f5	d1 e0		 shl	 eax, 1
  000f7	8b 4d f8	 mov	 ecx, DWORD PTR _pBranches$[ebp]
  000fa	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  000fd	6a 04		 push	 4
  000ff	5a		 pop	 edx
  00100	c1 e2 00	 shl	 edx, 0
  00103	8b 75 f0	 mov	 esi, DWORD PTR _pVertexBuffer$5[ebp]
  00106	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  0010a	89 44 16 10	 mov	 DWORD PTR [esi+edx+16], eax

; 520  : 				
; 521  : 				// texcoords for layer 1 (if enabled)
; 522  : #ifdef WRAPPER_RENDER_SELF_SHADOWS
; 523  : 				pVertexBuffer->m_fShadowCoords[0] = pBranches->m_pTexCoords1[i * 2];

  0010e	8b 45 f4	 mov	 eax, DWORD PTR _i$6[ebp]
  00111	d1 e0		 shl	 eax, 1
  00113	8b 4d f8	 mov	 ecx, DWORD PTR _pBranches$[ebp]
  00116	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  00119	6a 04		 push	 4
  0011b	5a		 pop	 edx
  0011c	6b d2 00	 imul	 edx, edx, 0
  0011f	8b 75 f0	 mov	 esi, DWORD PTR _pVertexBuffer$5[ebp]
  00122	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00125	89 44 16 18	 mov	 DWORD PTR [esi+edx+24], eax

; 524  : 				pVertexBuffer->m_fShadowCoords[1] = pBranches->m_pTexCoords1[i * 2 + 1];

  00129	8b 45 f4	 mov	 eax, DWORD PTR _i$6[ebp]
  0012c	d1 e0		 shl	 eax, 1
  0012e	8b 4d f8	 mov	 ecx, DWORD PTR _pBranches$[ebp]
  00131	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  00134	6a 04		 push	 4
  00136	5a		 pop	 edx
  00137	c1 e2 00	 shl	 edx, 0
  0013a	8b 75 f0	 mov	 esi, DWORD PTR _pVertexBuffer$5[ebp]
  0013d	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  00141	89 44 16 18	 mov	 DWORD PTR [esi+edx+24], eax

; 525  : #endif
; 526  : 				
; 527  : 				// extra data for gpu wind
; 528  : #ifdef WRAPPER_USE_GPU_WIND
; 529  : 				pVertexBuffer->m_fWindIndex = 4.0f * pBranches->m_pWindMatrixIndices[i];
; 530  : 				pVertexBuffer->m_fWindWeight = pBranches->m_pWindWeights[i];
; 531  : #endif
; 532  : 				
; 533  : 				++pVertexBuffer;

  00145	8b 45 f0	 mov	 eax, DWORD PTR _pVertexBuffer$5[ebp]
  00148	83 c0 20	 add	 eax, 32			; 00000020H
  0014b	89 45 f0	 mov	 DWORD PTR _pVertexBuffer$5[ebp], eax

; 534  : 			}

  0014e	e9 3e ff ff ff	 jmp	 $LN2@SetupBranc
$LN3@SetupBranc:

; 535  : 			m_pBranchVertexBuffer->Unlock();

  00153	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00156	8b 80 9c 01 00
	00		 mov	 eax, DWORD PTR [eax+412]
  0015c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015f	8b 00		 mov	 eax, DWORD PTR [eax]
  00161	ff b1 9c 01 00
	00		 push	 DWORD PTR [ecx+412]
  00167	ff 50 30	 call	 DWORD PTR [eax+48]

; 536  : 		}
; 537  : 		
; 538  : 		// create and fill the index counts for each LOD
; 539  : 		UINT unNumLodLevels = m_pSpeedTree->GetNumBranchLodLevels();

  0016a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0016d	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00173	e8 00 00 00 00	 call	 ?GetNumBranchLodLevels@CSpeedTreeRT@@QBEGXZ ; CSpeedTreeRT::GetNumBranchLodLevels
  00178	0f b7 c0	 movzx	 eax, ax
  0017b	89 45 e8	 mov	 DWORD PTR _unNumLodLevels$3[ebp], eax

; 540  : 		m_pBranchIndexCounts = new unsigned short[unNumLodLevels];

  0017e	33 c9		 xor	 ecx, ecx
  00180	8b 45 e8	 mov	 eax, DWORD PTR _unNumLodLevels$3[ebp]
  00183	6a 02		 push	 2
  00185	5a		 pop	 edx
  00186	f7 e2		 mul	 edx
  00188	0f 90 c1	 seto	 cl
  0018b	f7 d9		 neg	 ecx
  0018d	0b c8		 or	 ecx, eax
  0018f	51		 push	 ecx
  00190	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00195	59		 pop	 ecx
  00196	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
  00199	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0019c	8b 4d e0	 mov	 ecx, DWORD PTR $T1[ebp]
  0019f	89 88 a8 01 00
	00		 mov	 DWORD PTR [eax+424], ecx

; 541  : 		for (UINT i = 0; i < unNumLodLevels; ++i)

  001a5	83 65 ec 00	 and	 DWORD PTR _i$4[ebp], 0
  001a9	eb 07		 jmp	 SHORT $LN7@SetupBranc
$LN5@SetupBranc:
  001ab	8b 45 ec	 mov	 eax, DWORD PTR _i$4[ebp]
  001ae	40		 inc	 eax
  001af	89 45 ec	 mov	 DWORD PTR _i$4[ebp], eax
$LN7@SetupBranc:
  001b2	8b 45 ec	 mov	 eax, DWORD PTR _i$4[ebp]
  001b5	3b 45 e8	 cmp	 eax, DWORD PTR _unNumLodLevels$3[ebp]
  001b8	73 61		 jae	 SHORT $LN6@SetupBranc

; 542  : 		{
; 543  : 			// force update for particular LOD
; 544  : 			m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_BranchGeometry, i);

  001ba	6a ff		 push	 -1
  001bc	6a ff		 push	 -1
  001be	ff 75 ec	 push	 DWORD PTR _i$4[ebp]
  001c1	6a 01		 push	 1
  001c3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001c6	ff b0 98 01 00
	00		 push	 DWORD PTR [eax+408]
  001cc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001cf	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  001d5	e8 00 00 00 00	 call	 ?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z ; CSpeedTreeRT::GetGeometry

; 545  : 			
; 546  : 			// check if this LOD has branches
; 547  : 			if (pBranches->m_usNumStrips > 0)

  001da	8b 45 f8	 mov	 eax, DWORD PTR _pBranches$[ebp]
  001dd	0f b7 40 04	 movzx	 eax, WORD PTR [eax+4]
  001e1	85 c0		 test	 eax, eax
  001e3	7e 22		 jle	 SHORT $LN9@SetupBranc

; 548  : 				m_pBranchIndexCounts[i] = pBranches->m_pStripLengths[0];

  001e5	6a 02		 push	 2
  001e7	58		 pop	 eax
  001e8	6b c0 00	 imul	 eax, eax, 0
  001eb	8b 4d f8	 mov	 ecx, DWORD PTR _pBranches$[ebp]
  001ee	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  001f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001f4	8b 92 a8 01 00
	00		 mov	 edx, DWORD PTR [edx+424]
  001fa	8b 75 ec	 mov	 esi, DWORD PTR _i$4[ebp]
  001fd	66 8b 04 08	 mov	 ax, WORD PTR [eax+ecx]
  00201	66 89 04 72	 mov	 WORD PTR [edx+esi*2], ax
  00205	eb 12		 jmp	 SHORT $LN10@SetupBranc
$LN9@SetupBranc:

; 549  : 			else
; 550  : 				m_pBranchIndexCounts[i] = 0;

  00207	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0020a	8b 80 a8 01 00
	00		 mov	 eax, DWORD PTR [eax+424]
  00210	33 c9		 xor	 ecx, ecx
  00212	8b 55 ec	 mov	 edx, DWORD PTR _i$4[ebp]
  00215	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
$LN10@SetupBranc:

; 551  : 		}

  00219	eb 90		 jmp	 SHORT $LN5@SetupBranc
$LN6@SetupBranc:

; 552  : 		// set back to highest LOD
; 553  : 		m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_BranchGeometry, 0);

  0021b	6a ff		 push	 -1
  0021d	6a ff		 push	 -1
  0021f	6a 00		 push	 0
  00221	6a 01		 push	 1
  00223	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00226	ff b0 98 01 00
	00		 push	 DWORD PTR [eax+408]
  0022c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0022f	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00235	e8 00 00 00 00	 call	 ?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z ; CSpeedTreeRT::GetGeometry

; 554  : 		
; 555  : 		// the first LOD level contains the most indices of all the levels, so
; 556  : 		// we use its size to allocate the index buffer
; 557  : 		ms_lpd3dDevice->CreateIndexBuffer(m_pBranchIndexCounts[0] * sizeof(unsigned short), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED, &m_pBranchIndexBuffer);

  0023a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0023d	05 a4 01 00 00	 add	 eax, 420		; 000001a4H
  00242	50		 push	 eax
  00243	6a 01		 push	 1
  00245	6a 65		 push	 101			; 00000065H
  00247	6a 08		 push	 8
  00249	6a 02		 push	 2
  0024b	58		 pop	 eax
  0024c	6b c0 00	 imul	 eax, eax, 0
  0024f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00252	8b 89 a8 01 00
	00		 mov	 ecx, DWORD PTR [ecx+424]
  00258	0f b7 04 01	 movzx	 eax, WORD PTR [ecx+eax]
  0025c	d1 e0		 shl	 eax, 1
  0025e	50		 push	 eax
  0025f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00264	8b 00		 mov	 eax, DWORD PTR [eax]
  00266	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0026c	ff 50 60	 call	 DWORD PTR [eax+96]

; 558  : 		
; 559  : 		// fill the index buffer
; 560  : 		unsigned short* pIndexBuffer = NULL;

  0026f	83 65 e4 00	 and	 DWORD PTR _pIndexBuffer$2[ebp], 0

; 561  : 		m_pBranchIndexBuffer->Lock(0, 0, reinterpret_cast<BYTE**>(&pIndexBuffer), 0);

  00273	6a 00		 push	 0
  00275	8d 45 e4	 lea	 eax, DWORD PTR _pIndexBuffer$2[ebp]
  00278	50		 push	 eax
  00279	6a 00		 push	 0
  0027b	6a 00		 push	 0
  0027d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00280	8b 80 a4 01 00
	00		 mov	 eax, DWORD PTR [eax+420]
  00286	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00289	8b 00		 mov	 eax, DWORD PTR [eax]
  0028b	ff b1 a4 01 00
	00		 push	 DWORD PTR [ecx+420]
  00291	ff 50 2c	 call	 DWORD PTR [eax+44]

; 562  : 		memcpy(pIndexBuffer, pBranches->m_pStrips[0], pBranches->m_pStripLengths[0] * sizeof(unsigned short));

  00294	6a 02		 push	 2
  00296	58		 pop	 eax
  00297	6b c0 00	 imul	 eax, eax, 0
  0029a	8b 4d f8	 mov	 ecx, DWORD PTR _pBranches$[ebp]
  0029d	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  002a0	0f b7 04 01	 movzx	 eax, WORD PTR [ecx+eax]
  002a4	d1 e0		 shl	 eax, 1
  002a6	50		 push	 eax
  002a7	6a 04		 push	 4
  002a9	58		 pop	 eax
  002aa	6b c0 00	 imul	 eax, eax, 0
  002ad	8b 4d f8	 mov	 ecx, DWORD PTR _pBranches$[ebp]
  002b0	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  002b3	ff 34 01	 push	 DWORD PTR [ecx+eax]
  002b6	ff 75 e4	 push	 DWORD PTR _pIndexBuffer$2[ebp]
  002b9	e8 00 00 00 00	 call	 _memcpy
  002be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 563  : 		m_pBranchIndexBuffer->Unlock();

  002c1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002c4	8b 80 a4 01 00
	00		 mov	 eax, DWORD PTR [eax+420]
  002ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002cd	8b 00		 mov	 eax, DWORD PTR [eax]
  002cf	ff b1 a4 01 00
	00		 push	 DWORD PTR [ecx+420]
  002d5	ff 50 30	 call	 DWORD PTR [eax+48]
$LN8@SetupBranc:

; 564  : 	}
; 565  : }

  002d8	5e		 pop	 esi
  002d9	c9		 leave
  002da	c3		 ret	 0
?SetupBranchBuffers@CSpeedTreeWrapper@@AAEXXZ ENDP	; CSpeedTreeWrapper::SetupBranchBuffers
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv81 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ PROC		; CSpeedTreeWrapper::SetupBuffers, COMDAT
; _this$ = ecx

; 465  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 466  : 	// read all the geometry for highest LOD into the geometry cache (just a precaution, it's updated later)
; 467  : 	m_pSpeedTree->SetLodLevel(1.0f);

  00028	51		 push	 ecx
  00029	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  0003f	e8 00 00 00 00	 call	 ?SetLodLevel@CSpeedTreeRT@@QAEXM@Z ; CSpeedTreeRT::SetLodLevel

; 468  : 	
; 469  : 	if (m_pGeometryCache == NULL)

  00044	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00047	83 b8 98 01 00
	00 00		 cmp	 DWORD PTR [eax+408], 0
  0004e	75 3f		 jne	 SHORT $LN2@SetupBuffe

; 470  : 		m_pGeometryCache = new CSpeedTreeRT::SGeometry;

  00050	68 20 01 00 00	 push	 288			; 00000120H
  00055	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005a	59		 pop	 ecx
  0005b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0005e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00062	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  00066	74 0d		 je	 SHORT $LN4@SetupBuffe
  00068	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0006b	e8 00 00 00 00	 call	 ??0SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::SGeometry
  00070	89 45 e8	 mov	 DWORD PTR tv81[ebp], eax
  00073	eb 04		 jmp	 SHORT $LN5@SetupBuffe
$LN4@SetupBuffe:
  00075	83 65 e8 00	 and	 DWORD PTR tv81[ebp], 0
$LN5@SetupBuffe:
  00079	8b 45 e8	 mov	 eax, DWORD PTR tv81[ebp]
  0007c	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0007f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00083	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00086	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00089	89 88 98 01 00
	00		 mov	 DWORD PTR [eax+408], ecx
$LN2@SetupBuffe:

; 471  : 	
; 472  : 	m_pSpeedTree->GetGeometry(*m_pGeometryCache);

  0008f	6a ff		 push	 -1
  00091	6a ff		 push	 -1
  00093	6a ff		 push	 -1
  00095	6a 0f		 push	 15			; 0000000fH
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	ff b0 98 01 00
	00		 push	 DWORD PTR [eax+408]
  000a0	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  000a9	e8 00 00 00 00	 call	 ?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z ; CSpeedTreeRT::GetGeometry

; 473  : 	
; 474  : 	// setup the buffers for each part
; 475  : 	SetupBranchBuffers();

  000ae	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?SetupBranchBuffers@CSpeedTreeWrapper@@AAEXXZ ; CSpeedTreeWrapper::SetupBranchBuffers

; 476  : 	SetupFrondBuffers();

  000b6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?SetupFrondBuffers@CSpeedTreeWrapper@@AAEXXZ ; CSpeedTreeWrapper::SetupFrondBuffers

; 477  : 	SetupLeafBuffers();

  000be	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?SetupLeafBuffers@CSpeedTreeWrapper@@AAEXXZ ; CSpeedTreeWrapper::SetupLeafBuffers

; 478  : }

  000c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d0	59		 pop	 ecx
  000d1	c9		 leave
  000d2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ$0:
  00000	68 20 01 00 00	 push	 288			; 00000120H
  00005	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ ENDP		; CSpeedTreeWrapper::SetupBuffers
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?CleanUpMemory@CSpeedTreeWrapper@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CleanUpMemory@CSpeedTreeWrapper@@QAEXXZ PROC		; CSpeedTreeWrapper::CleanUpMemory, COMDAT
; _this$ = ecx

; 1269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1270 : 	if (!m_bIsInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 80 84 01
	00 00		 movzx	 eax, BYTE PTR [eax+388]
  00011	85 c0		 test	 eax, eax
  00013	75 0e		 jne	 SHORT $LN1@CleanUpMem

; 1271 : 		m_pSpeedTree->DeleteTransientData();

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  0001e	e8 00 00 00 00	 call	 ?DeleteTransientData@CSpeedTreeRT@@QAEXXZ ; CSpeedTreeRT::DeleteTransientData
$LN1@CleanUpMem:

; 1272 : }

  00023	c9		 leave
  00024	c3		 ret	 0
?CleanUpMemory@CSpeedTreeWrapper@@QAEXXZ ENDP		; CSpeedTreeWrapper::CleanUpMemory
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?Advance@CSpeedTreeWrapper@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Advance@CSpeedTreeWrapper@@QAEXXZ PROC			; CSpeedTreeWrapper::Advance, COMDAT
; _this$ = ecx

; 738  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 739  : 	// compute LOD level (based on distance from camera)
; 740  : 	m_pSpeedTree->ComputeLodLevel();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00010	e8 00 00 00 00	 call	 ?ComputeLodLevel@CSpeedTreeRT@@QAEXXZ ; CSpeedTreeRT::ComputeLodLevel

; 741  : 	m_pSpeedTree->SetLodLevel(1.0f);

  00015	51		 push	 ecx
  00016	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0001e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  0002c	e8 00 00 00 00	 call	 ?SetLodLevel@CSpeedTreeRT@@QAEXM@Z ; CSpeedTreeRT::SetLodLevel

; 742  : 	
; 743  : 	// compute wind
; 744  : #ifdef WRAPPER_USE_CPU_WIND
; 745  : 	m_pSpeedTree->ComputeWindEffects(true, true, true);
; 746  : #endif
; 747  : }

  00031	c9		 leave
  00032	c3		 ret	 0
?Advance@CSpeedTreeWrapper@@QAEXXZ ENDP			; CSpeedTreeWrapper::Advance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?DeleteInstance@CSpeedTreeWrapper@@QAEXPAV1@@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
$T3 = -68						; size = 4
tv140 = -64						; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
$T7 = -48						; size = 4
$T8 = -44						; size = 4
___param0$ = -40					; size = 4
___param0$ = -36					; size = 4
tv177 = -32						; size = 4
tv191 = -28						; size = 4
__My_data$9 = -24					; size = 4
__My_data$10 = -20					; size = 4
$T11 = -16						; size = 4
_this$ = -12						; size = 4
_itor$ = -8						; size = 4
$T12 = -2						; size = 1
$T13 = -1						; size = 1
_pInstance$ = 8						; size = 4
?DeleteInstance@CSpeedTreeWrapper@@QAEXPAV1@@Z PROC	; CSpeedTreeWrapper::DeleteInstance, COMDAT
; _this$ = ecx

; 822  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 88 01 00 00	 add	 eax, 392		; 00000188H
  00011	89 45 ec	 mov	 DWORD PTR __My_data$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00014	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00017	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001a	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00022	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00025	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
$LN2@DeleteInst:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	05 88 01 00 00	 add	 eax, 392		; 00000188H
  00030	89 45 e8	 mov	 DWORD PTR __My_data$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	8b 45 e8	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00036	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00039	8b 45 e8	 mov	 eax, DWORD PTR __My_data$9[ebp]
  0003c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003f	89 45 d8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00042	8b 45 d8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00045	89 45 d4	 mov	 DWORD PTR $T8[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00048	8d 45 d4	 lea	 eax, DWORD PTR $T8[ebp]
  0004b	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0004e	8b 45 d0	 mov	 eax, DWORD PTR $T7[ebp]
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _itor$[ebp]
  00054	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00056	75 09		 jne	 SHORT $LN46@DeleteInst
  00058	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv191[ebp], 1
  0005f	eb 04		 jmp	 SHORT $LN47@DeleteInst
$LN46@DeleteInst:
  00061	83 65 e4 00	 and	 DWORD PTR tv191[ebp], 0
$LN47@DeleteInst:
  00065	8a 45 e4	 mov	 al, BYTE PTR tv191[ebp]
  00068	88 45 ff	 mov	 BYTE PTR $T13[ebp], al

; 153  :         return !(*this == _Right);

  0006b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T13[ebp]
  0006f	85 c0		 test	 eax, eax
  00071	75 09		 jne	 SHORT $LN41@DeleteInst
  00073	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv177[ebp], 1
  0007a	eb 04		 jmp	 SHORT $LN42@DeleteInst
$LN41@DeleteInst:
  0007c	83 65 e0 00	 and	 DWORD PTR tv177[ebp], 0
$LN42@DeleteInst:
  00080	8a 45 e0	 mov	 al, BYTE PTR tv177[ebp]
  00083	88 45 fe	 mov	 BYTE PTR $T12[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 825  : 	while (itor != m_vInstances.end())

  00086	0f b6 45 fe	 movzx	 eax, BYTE PTR $T12[ebp]
  0008a	85 c0		 test	 eax, eax
  0008c	74 46		 je	 SHORT $LN3@DeleteInst
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  0008e	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  00091	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00094	8b 45 cc	 mov	 eax, DWORD PTR $T6[ebp]
  00097	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 827  : 		if (*itor == pInstance)

  0009a	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  0009d	8b 00		 mov	 eax, DWORD PTR [eax]
  0009f	3b 45 08	 cmp	 eax, DWORD PTR _pInstance$[ebp]
  000a2	75 22		 jne	 SHORT $LN4@DeleteInst

; 828  : 		{
; 829  : 			itor = m_vInstances.erase(itor);

  000a4	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  000a7	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax
  000aa	ff 75 c4	 push	 DWORD PTR $T4[ebp]
  000ad	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	81 c1 88 01 00
	00		 add	 ecx, 392		; 00000188H
  000ba	e8 00 00 00 00	 call	 ?erase@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@@2@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::erase
  000bf	8b 00		 mov	 eax, DWORD PTR [eax]
  000c1	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax

; 830  : 		}

  000c4	eb 09		 jmp	 SHORT $LN5@DeleteInst
$LN4@DeleteInst:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  000c6	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  000c9	83 c0 04	 add	 eax, 4
  000cc	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
$LN5@DeleteInst:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 833  : 	}

  000cf	e9 54 ff ff ff	 jmp	 $LN2@DeleteInst
$LN3@DeleteInst:

; 834  : 	delete pInstance;

  000d4	8b 45 08	 mov	 eax, DWORD PTR _pInstance$[ebp]
  000d7	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
  000da	83 7d f0 00	 cmp	 DWORD PTR $T11[ebp], 0
  000de	74 11		 je	 SHORT $LN7@DeleteInst
  000e0	6a 01		 push	 1
  000e2	8b 45 f0	 mov	 eax, DWORD PTR $T11[ebp]
  000e5	8b 00		 mov	 eax, DWORD PTR [eax]
  000e7	8b 4d f0	 mov	 ecx, DWORD PTR $T11[ebp]
  000ea	ff 10		 call	 DWORD PTR [eax]
  000ec	89 45 c0	 mov	 DWORD PTR tv140[ebp], eax
  000ef	eb 04		 jmp	 SHORT $LN1@DeleteInst
$LN7@DeleteInst:
  000f1	83 65 c0 00	 and	 DWORD PTR tv140[ebp], 0
$LN1@DeleteInst:

; 835  : }

  000f5	c9		 leave
  000f6	c2 04 00	 ret	 4
?DeleteInstance@CSpeedTreeWrapper@@QAEXPAV1@@Z ENDP	; CSpeedTreeWrapper::DeleteInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?MakeInstance@CSpeedTreeWrapper@@QAEPAV1@XZ
_TEXT	SEGMENT
tv202 = -40						; size = 4
$T2 = -36						; size = 4
tv75 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
_this$ = -20						; size = 4
_pInstance$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?MakeInstance@CSpeedTreeWrapper@@QAEPAV1@XZ PROC	; CSpeedTreeWrapper::MakeInstance, COMDAT
; _this$ = ecx

; 753  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MakeInstance@CSpeedTreeWrapper@@QAEPAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 754  : 	CSpeedTreeWrapper * pInstance = new CSpeedTreeWrapper;

  0002a	68 18 03 00 00	 push	 792			; 00000318H
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00034	59		 pop	 ecx
  00035	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00038	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	83 7d e4 00	 cmp	 DWORD PTR $T3[ebp], 0
  00040	74 0d		 je	 SHORT $LN6@MakeInstan
  00042	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  00045	e8 00 00 00 00	 call	 ??0CSpeedTreeWrapper@@QAE@XZ ; CSpeedTreeWrapper::CSpeedTreeWrapper
  0004a	89 45 e0	 mov	 DWORD PTR tv75[ebp], eax
  0004d	eb 04		 jmp	 SHORT $LN7@MakeInstan
$LN6@MakeInstan:
  0004f	83 65 e0 00	 and	 DWORD PTR tv75[ebp], 0
$LN7@MakeInstan:
  00053	8b 45 e0	 mov	 eax, DWORD PTR tv75[ebp]
  00056	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
  00059	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0005d	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
  00060	89 45 f0	 mov	 DWORD PTR _pInstance$[ebp], eax

; 755  : 	
; 756  : 	// make an instance of this object's SpeedTree
; 757  : 	pInstance->m_bIsInstance = true;

  00063	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  00066	c6 80 84 01 00
	00 01		 mov	 BYTE PTR [eax+388], 1

; 758  : 	pInstance->m_pSpeedTree = m_pSpeedTree->MakeInstance();

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00076	e8 00 00 00 00	 call	 ?MakeInstance@CSpeedTreeRT@@QAEPAV1@XZ ; CSpeedTreeRT::MakeInstance
  0007b	8b 4d f0	 mov	 ecx, DWORD PTR _pInstance$[ebp]
  0007e	89 81 7c 01 00
	00		 mov	 DWORD PTR [ecx+380], eax

; 759  : 	
; 760  : 	if (pInstance->m_pSpeedTree)

  00084	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  00087	83 b8 7c 01 00
	00 00		 cmp	 DWORD PTR [eax+380], 0
  0008e	0f 84 f5 01 00
	00		 je	 $LN2@MakeInstan

; 761  :     {
; 762  : 		// use the same materials
; 763  : 		pInstance->m_cBranchMaterial = m_cBranchMaterial;

  00094	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00097	81 c6 ec 01 00
	00		 add	 esi, 492		; 000001ecH
  0009d	8b 7d f0	 mov	 edi, DWORD PTR _pInstance$[ebp]
  000a0	81 c7 ec 01 00
	00		 add	 edi, 492		; 000001ecH
  000a6	6a 11		 push	 17			; 00000011H
  000a8	59		 pop	 ecx
  000a9	f3 a5		 rep movsd

; 764  : 		pInstance->m_cLeafMaterial = m_cLeafMaterial;

  000ab	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000ae	81 c6 30 02 00
	00		 add	 esi, 560		; 00000230H
  000b4	8b 7d f0	 mov	 edi, DWORD PTR _pInstance$[ebp]
  000b7	81 c7 30 02 00
	00		 add	 edi, 560		; 00000230H
  000bd	6a 11		 push	 17			; 00000011H
  000bf	59		 pop	 ecx
  000c0	f3 a5		 rep movsd

; 765  : 		pInstance->m_cFrondMaterial = m_cFrondMaterial;

  000c2	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000c5	81 c6 74 02 00
	00		 add	 esi, 628		; 00000274H
  000cb	8b 7d f0	 mov	 edi, DWORD PTR _pInstance$[ebp]
  000ce	81 c7 74 02 00
	00		 add	 edi, 628		; 00000274H
  000d4	6a 11		 push	 17			; 00000011H
  000d6	59		 pop	 ecx
  000d7	f3 a5		 rep movsd

; 766  : 		pInstance->m_CompositeImageInstance.SetImagePointer(m_CompositeImageInstance.GetGraphicImagePointer());

  000d9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000dc	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  000e2	e8 00 00 00 00	 call	 ?GetGraphicImagePointer@CGraphicImageInstance@@QAEPAVCGraphicImage@@XZ ; CGraphicImageInstance::GetGraphicImagePointer
  000e7	50		 push	 eax
  000e8	8b 4d f0	 mov	 ecx, DWORD PTR _pInstance$[ebp]
  000eb	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  000f1	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 767  : 		pInstance->m_BranchImageInstance.SetImagePointer(m_BranchImageInstance.GetGraphicImagePointer());

  000f6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	81 c1 b8 02 00
	00		 add	 ecx, 696		; 000002b8H
  000ff	e8 00 00 00 00	 call	 ?GetGraphicImagePointer@CGraphicImageInstance@@QAEPAVCGraphicImage@@XZ ; CGraphicImageInstance::GetGraphicImagePointer
  00104	50		 push	 eax
  00105	8b 4d f0	 mov	 ecx, DWORD PTR _pInstance$[ebp]
  00108	81 c1 b8 02 00
	00		 add	 ecx, 696		; 000002b8H
  0010e	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 768  : 		
; 769  : 		if (!m_ShadowImageInstance.IsEmpty())

  00113	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00116	81 c1 d8 02 00
	00		 add	 ecx, 728		; 000002d8H
  0011c	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  00121	0f b6 c0	 movzx	 eax, al
  00124	85 c0		 test	 eax, eax
  00126	75 1d		 jne	 SHORT $LN4@MakeInstan

; 770  : 			pInstance->m_ShadowImageInstance.SetImagePointer(m_ShadowImageInstance.GetGraphicImagePointer());

  00128	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	81 c1 d8 02 00
	00		 add	 ecx, 728		; 000002d8H
  00131	e8 00 00 00 00	 call	 ?GetGraphicImagePointer@CGraphicImageInstance@@QAEPAVCGraphicImage@@XZ ; CGraphicImageInstance::GetGraphicImagePointer
  00136	50		 push	 eax
  00137	8b 4d f0	 mov	 ecx, DWORD PTR _pInstance$[ebp]
  0013a	81 c1 d8 02 00
	00		 add	 ecx, 728		; 000002d8H
  00140	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer
$LN4@MakeInstan:

; 771  : 		
; 772  : 		pInstance->m_pTextureInfo = m_pTextureInfo;

  00145	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  00148	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0014b	8b 89 80 01 00
	00		 mov	 ecx, DWORD PTR [ecx+384]
  00151	89 88 80 01 00
	00		 mov	 DWORD PTR [eax+384], ecx

; 773  : 		
; 774  : 		// use the same geometry cache
; 775  : 		pInstance->m_pGeometryCache = m_pGeometryCache;

  00157	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  0015a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0015d	8b 89 98 01 00
	00		 mov	 ecx, DWORD PTR [ecx+408]
  00163	89 88 98 01 00
	00		 mov	 DWORD PTR [eax+408], ecx

; 776  : 		
; 777  : 		// use the same buffers
; 778  : 		pInstance->m_pBranchIndexBuffer = m_pBranchIndexBuffer;

  00169	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  0016c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	8b 89 a4 01 00
	00		 mov	 ecx, DWORD PTR [ecx+420]
  00175	89 88 a4 01 00
	00		 mov	 DWORD PTR [eax+420], ecx

; 779  : 		pInstance->m_pBranchIndexCounts = m_pBranchIndexCounts;

  0017b	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  0017e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	8b 89 a8 01 00
	00		 mov	 ecx, DWORD PTR [ecx+424]
  00187	89 88 a8 01 00
	00		 mov	 DWORD PTR [eax+424], ecx

; 780  : 		pInstance->m_pBranchVertexBuffer = m_pBranchVertexBuffer;

  0018d	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  00190	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00193	8b 89 9c 01 00
	00		 mov	 ecx, DWORD PTR [ecx+412]
  00199	89 88 9c 01 00
	00		 mov	 DWORD PTR [eax+412], ecx

; 781  : 		pInstance->m_unBranchVertexCount = m_unBranchVertexCount;

  0019f	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  001a2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	8b 89 a0 01 00
	00		 mov	 ecx, DWORD PTR [ecx+416]
  001ab	89 88 a0 01 00
	00		 mov	 DWORD PTR [eax+416], ecx

; 782  : 		
; 783  : 		pInstance->m_pFrondIndexBuffer = m_pFrondIndexBuffer;

  001b1	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  001b4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b7	8b 89 b4 01 00
	00		 mov	 ecx, DWORD PTR [ecx+436]
  001bd	89 88 b4 01 00
	00		 mov	 DWORD PTR [eax+436], ecx

; 784  : 		pInstance->m_pFrondIndexCounts = m_pFrondIndexCounts;

  001c3	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  001c6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001c9	8b 89 b8 01 00
	00		 mov	 ecx, DWORD PTR [ecx+440]
  001cf	89 88 b8 01 00
	00		 mov	 DWORD PTR [eax+440], ecx

; 785  : 		pInstance->m_pFrondVertexBuffer = m_pFrondVertexBuffer;

  001d5	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  001d8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001db	8b 89 ac 01 00
	00		 mov	 ecx, DWORD PTR [ecx+428]
  001e1	89 88 ac 01 00
	00		 mov	 DWORD PTR [eax+428], ecx

; 786  : 		pInstance->m_unFrondVertexCount = m_unFrondVertexCount;

  001e7	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  001ea	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001ed	8b 89 b0 01 00
	00		 mov	 ecx, DWORD PTR [ecx+432]
  001f3	89 88 b0 01 00
	00		 mov	 DWORD PTR [eax+432], ecx

; 787  : 		
; 788  : 		pInstance->m_pLeafVertexBuffer = m_pLeafVertexBuffer;

  001f9	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  001fc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001ff	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [ecx+448]
  00205	89 88 c0 01 00
	00		 mov	 DWORD PTR [eax+448], ecx

; 789  : 		pInstance->m_usNumLeafLods = m_usNumLeafLods;

  0020b	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  0020e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00211	66 8b 89 bc 01
	00 00		 mov	 cx, WORD PTR [ecx+444]
  00218	66 89 88 bc 01
	00 00		 mov	 WORD PTR [eax+444], cx

; 790  : 		pInstance->m_pLeavesUpdatedByCpu = m_pLeavesUpdatedByCpu;

  0021f	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  00222	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00225	8b 89 c4 01 00
	00		 mov	 ecx, DWORD PTR [ecx+452]
  0022b	89 88 c4 01 00
	00		 mov	 DWORD PTR [eax+452], ecx

; 791  : 		
; 792  : 		// new stuff
; 793  : 		memcpy(pInstance->m_afPos, m_afPos, 3 * sizeof(float));

  00231	6a 0c		 push	 12			; 0000000cH
  00233	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00236	05 c8 01 00 00	 add	 eax, 456		; 000001c8H
  0023b	50		 push	 eax
  0023c	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  0023f	05 c8 01 00 00	 add	 eax, 456		; 000001c8H
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 _memcpy
  0024a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 794  : 		memcpy(pInstance->m_afBoundingBox, m_afBoundingBox, 6 * sizeof(float));

  0024d	6a 18		 push	 24			; 00000018H
  0024f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00252	05 d4 01 00 00	 add	 eax, 468		; 000001d4H
  00257	50		 push	 eax
  00258	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  0025b	05 d4 01 00 00	 add	 eax, 468		; 000001d4H
  00260	50		 push	 eax
  00261	e8 00 00 00 00	 call	 _memcpy
  00266	83 c4 0c	 add	 esp, 12			; 0000000cH

; 795  : 		pInstance->m_pInstanceOf = this;

  00269	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  0026c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0026f	89 88 94 01 00
	00		 mov	 DWORD PTR [eax+404], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00275	8d 45 f0	 lea	 eax, DWORD PTR _pInstance$[ebp]
  00278	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 796  : 		m_vInstances.push_back(pInstance);

  00279	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0027c	81 c1 88 01 00
	00		 add	 ecx, 392		; 00000188H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00282	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXABQAVCSpeedTreeWrapper@@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::emplace_back<CSpeedTreeWrapper * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 797  :     }

  00287	eb 41		 jmp	 SHORT $LN3@MakeInstan
$LN2@MakeInstan:

; 798  :     else
; 799  : 	{
; 800  : 		fprintf(stderr, "SpeedTreeRT Error: %s\n", m_pSpeedTree->GetCurrentError());

  00289	e8 00 00 00 00	 call	 ?GetCurrentError@CSpeedTreeRT@@SAPBDXZ ; CSpeedTreeRT::GetCurrentError
  0028e	50		 push	 eax
  0028f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NANCELHN@SpeedTreeRT?5Error?3?5?$CFs?6@
  00294	6a 02		 push	 2
  00296	e8 00 00 00 00	 call	 ___acrt_iob_func
  0029b	59		 pop	 ecx
  0029c	50		 push	 eax
  0029d	e8 00 00 00 00	 call	 _fprintf
  002a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 801  :         delete pInstance;

  002a5	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]
  002a8	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
  002ab	83 7d e8 00	 cmp	 DWORD PTR $T4[ebp], 0
  002af	74 11		 je	 SHORT $LN8@MakeInstan
  002b1	6a 01		 push	 1
  002b3	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  002b6	8b 00		 mov	 eax, DWORD PTR [eax]
  002b8	8b 4d e8	 mov	 ecx, DWORD PTR $T4[ebp]
  002bb	ff 10		 call	 DWORD PTR [eax]
  002bd	89 45 d8	 mov	 DWORD PTR tv202[ebp], eax
  002c0	eb 04		 jmp	 SHORT $LN9@MakeInstan
$LN8@MakeInstan:
  002c2	83 65 d8 00	 and	 DWORD PTR tv202[ebp], 0
$LN9@MakeInstan:

; 802  :         pInstance = NULL;

  002c6	83 65 f0 00	 and	 DWORD PTR _pInstance$[ebp], 0
$LN3@MakeInstan:

; 803  : 	}
; 804  : 	
; 805  : 	return pInstance;

  002ca	8b 45 f0	 mov	 eax, DWORD PTR _pInstance$[ebp]

; 806  : }

  002cd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002d0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002d7	59		 pop	 ecx
  002d8	5f		 pop	 edi
  002d9	5e		 pop	 esi
  002da	c9		 leave
  002db	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MakeInstance@CSpeedTreeWrapper@@QAEPAV1@XZ$0:
  00000	68 18 03 00 00	 push	 792			; 00000318H
  00005	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?MakeInstance@CSpeedTreeWrapper@@QAEPAV1@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MakeInstance@CSpeedTreeWrapper@@QAEPAV1@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MakeInstance@CSpeedTreeWrapper@@QAEPAV1@XZ ENDP	; CSpeedTreeWrapper::MakeInstance
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?GetInstances@CSpeedTreeWrapper@@QAEPAPAV1@AAI@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__My_data$2 = -16					; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$4 = -4					; size = 4
_nCount$ = 8						; size = 4
?GetInstances@CSpeedTreeWrapper@@QAEPAPAV1@AAI@Z PROC	; CSpeedTreeWrapper::GetInstances, COMDAT
; _this$ = ecx

; 813  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 88 01 00 00	 add	 eax, 392		; 00000188H
  00011	89 45 fc	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00014	8b 45 fc	 mov	 eax, DWORD PTR __My_data$4[ebp]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$4[ebp]
  0001a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001d	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001f	c1 f8 02	 sar	 eax, 2
  00022	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 814  : 	nCount = m_vInstances.size();

  00025	8b 45 08	 mov	 eax, DWORD PTR _nCount$[ebp]
  00028	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 815  : 	if (nCount)

  0002d	8b 45 08	 mov	 eax, DWORD PTR _nCount$[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	74 1f		 je	 SHORT $LN2@GetInstanc
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	05 88 01 00 00	 add	 eax, 392		; 00000188H
  0003d	89 45 f0	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00040	33 c0		 xor	 eax, eax
  00042	c1 e0 02	 shl	 eax, 2
  00045	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  00048	03 01		 add	 eax, DWORD PTR [ecx]
  0004a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 816  : 		return &(m_vInstances[0]);

  0004d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00050	eb 04		 jmp	 SHORT $LN1@GetInstanc
  00052	eb 02		 jmp	 SHORT $LN1@GetInstanc
$LN2@GetInstanc:

; 817  : 	else
; 818  : 		return NULL;

  00054	33 c0		 xor	 eax, eax
$LN1@GetInstanc:

; 819  : }

  00056	c9		 leave
  00057	c2 04 00	 ret	 4
?GetInstances@CSpeedTreeWrapper@@QAEPAPAV1@AAI@Z ENDP	; CSpeedTreeWrapper::GetInstances
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?RenderBillboards@CSpeedTreeWrapper@@QBEXXZ
_TEXT	SEGMENT
$T1 = -68						; size = 4
_pTexCoords$2 = -64					; size = 4
_pTexCoords$3 = -60					; size = 4
_pCoords$4 = -56					; size = 4
_pCoords$5 = -52					; size = 4
_this$ = -48						; size = 4
_sVertex$6 = -44					; size = 80
_sVertex$7 = 36						; size = 80
__$ArrayPad$ = 116					; size = 4
?RenderBillboards@CSpeedTreeWrapper@@QBEXXZ PROC	; CSpeedTreeWrapper::RenderBillboards, COMDAT
; _this$ = ecx

; 1189 : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 74	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 1190 : 	// render billboards in immediate mode (as close as DirectX comes to immediate mode)
; 1191 : #ifdef WRAPPER_BILLBOARD_MODE
; 1192 : 	if (!m_CompositeImageInstance.IsEmpty())

  00018	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  00021	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	75 28		 jne	 SHORT $LN2@RenderBill
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00032	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1193 : 		STATEMANAGER.SetTexture(0, m_CompositeImageInstance.GetTextureReference().GetD3DTexture());

  00035	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  0003e	e8 00 00 00 00	 call	 ?GetTextureReference@CGraphicImageInstance@@QBEABVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTextureReference
  00043	8b c8		 mov	 ecx, eax
  00045	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  0004a	50		 push	 eax
  0004b	6a 00		 push	 0
  0004d	8b 4d bc	 mov	 ecx, DWORD PTR $T1[ebp]
  00050	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN2@RenderBill:

; 1194 : 	
; 1195 : 	PositionTree();	

  00055	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?PositionTree@CSpeedTreeWrapper@@ABEXXZ ; CSpeedTreeWrapper::PositionTree

; 1196 : 	
; 1197 : 	struct SBillboardVertex 
; 1198 : 	{
; 1199 : 		float fX, fY, fZ;
; 1200 : 		float fU, fV;
; 1201 : 	};
; 1202 : 	
; 1203 : 	m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_BillboardGeometry);

  0005d	6a ff		 push	 -1
  0005f	6a ff		 push	 -1
  00061	6a ff		 push	 -1
  00063	6a 08		 push	 8
  00065	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00068	ff b0 98 01 00
	00		 push	 DWORD PTR [eax+408]
  0006e	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00071	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00077	e8 00 00 00 00	 call	 ?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z ; CSpeedTreeRT::GetGeometry

; 1204 : 	
; 1205 : 	if (m_pGeometryCache->m_sBillboard0.m_bIsActive)

  0007c	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00085	0f b6 80 f0 00
	00 00		 movzx	 eax, BYTE PTR [eax+240]
  0008c	85 c0		 test	 eax, eax
  0008e	0f 84 f3 01 00
	00		 je	 $LN3@RenderBill

; 1206 : 	{
; 1207 : 		const float* pCoords = m_pGeometryCache->m_sBillboard0.m_pCoords;

  00094	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  0009d	8b 80 f8 00 00
	00		 mov	 eax, DWORD PTR [eax+248]
  000a3	89 45 cc	 mov	 DWORD PTR _pCoords$5[ebp], eax

; 1208 : 		const float* pTexCoords = m_pGeometryCache->m_sBillboard0.m_pTexCoords;

  000a6	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  000af	8b 80 f4 00 00
	00		 mov	 eax, DWORD PTR [eax+244]
  000b5	89 45 c4	 mov	 DWORD PTR _pTexCoords$3[ebp], eax

; 1209 : 		SBillboardVertex sVertex[4] = 
; 1210 : 		{
; 1211 : 			{ pCoords[0], pCoords[1], pCoords[2], pTexCoords[0], pTexCoords[1] },

  000b8	6a 04		 push	 4
  000ba	58		 pop	 eax
  000bb	6b c0 00	 imul	 eax, eax, 0
  000be	8b 4d cc	 mov	 ecx, DWORD PTR _pCoords$5[ebp]
  000c1	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000c6	f3 0f 11 45 24	 movss	 DWORD PTR _sVertex$7[ebp], xmm0
  000cb	6a 04		 push	 4
  000cd	58		 pop	 eax
  000ce	c1 e0 00	 shl	 eax, 0
  000d1	8b 4d cc	 mov	 ecx, DWORD PTR _pCoords$5[ebp]
  000d4	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000d9	f3 0f 11 45 28	 movss	 DWORD PTR _sVertex$7[ebp+4], xmm0
  000de	6a 04		 push	 4
  000e0	58		 pop	 eax
  000e1	d1 e0		 shl	 eax, 1
  000e3	8b 4d cc	 mov	 ecx, DWORD PTR _pCoords$5[ebp]
  000e6	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000eb	f3 0f 11 45 2c	 movss	 DWORD PTR _sVertex$7[ebp+8], xmm0
  000f0	6a 04		 push	 4
  000f2	58		 pop	 eax
  000f3	6b c0 00	 imul	 eax, eax, 0
  000f6	8b 4d c4	 mov	 ecx, DWORD PTR _pTexCoords$3[ebp]
  000f9	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  000fe	f3 0f 11 45 30	 movss	 DWORD PTR _sVertex$7[ebp+12], xmm0
  00103	6a 04		 push	 4
  00105	58		 pop	 eax
  00106	c1 e0 00	 shl	 eax, 0
  00109	8b 4d c4	 mov	 ecx, DWORD PTR _pTexCoords$3[ebp]
  0010c	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00111	f3 0f 11 45 34	 movss	 DWORD PTR _sVertex$7[ebp+16], xmm0

; 1212 : 			{ pCoords[3], pCoords[4], pCoords[5], pTexCoords[2], pTexCoords[3] },

  00116	6a 04		 push	 4
  00118	58		 pop	 eax
  00119	6b c0 03	 imul	 eax, eax, 3
  0011c	8b 4d cc	 mov	 ecx, DWORD PTR _pCoords$5[ebp]
  0011f	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00124	f3 0f 11 45 38	 movss	 DWORD PTR _sVertex$7[ebp+20], xmm0
  00129	6a 04		 push	 4
  0012b	58		 pop	 eax
  0012c	c1 e0 02	 shl	 eax, 2
  0012f	8b 4d cc	 mov	 ecx, DWORD PTR _pCoords$5[ebp]
  00132	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00137	f3 0f 11 45 3c	 movss	 DWORD PTR _sVertex$7[ebp+24], xmm0
  0013c	6a 04		 push	 4
  0013e	58		 pop	 eax
  0013f	6b c0 05	 imul	 eax, eax, 5
  00142	8b 4d cc	 mov	 ecx, DWORD PTR _pCoords$5[ebp]
  00145	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0014a	f3 0f 11 45 40	 movss	 DWORD PTR _sVertex$7[ebp+28], xmm0
  0014f	6a 04		 push	 4
  00151	58		 pop	 eax
  00152	d1 e0		 shl	 eax, 1
  00154	8b 4d c4	 mov	 ecx, DWORD PTR _pTexCoords$3[ebp]
  00157	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0015c	f3 0f 11 45 44	 movss	 DWORD PTR _sVertex$7[ebp+32], xmm0
  00161	6a 04		 push	 4
  00163	58		 pop	 eax
  00164	6b c0 03	 imul	 eax, eax, 3
  00167	8b 4d c4	 mov	 ecx, DWORD PTR _pTexCoords$3[ebp]
  0016a	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0016f	f3 0f 11 45 48	 movss	 DWORD PTR _sVertex$7[ebp+36], xmm0

; 1213 : 			{ pCoords[6], pCoords[7], pCoords[8], pTexCoords[4], pTexCoords[5] },

  00174	6a 04		 push	 4
  00176	58		 pop	 eax
  00177	6b c0 06	 imul	 eax, eax, 6
  0017a	8b 4d cc	 mov	 ecx, DWORD PTR _pCoords$5[ebp]
  0017d	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00182	f3 0f 11 45 4c	 movss	 DWORD PTR _sVertex$7[ebp+40], xmm0
  00187	6a 04		 push	 4
  00189	58		 pop	 eax
  0018a	6b c0 07	 imul	 eax, eax, 7
  0018d	8b 4d cc	 mov	 ecx, DWORD PTR _pCoords$5[ebp]
  00190	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00195	f3 0f 11 45 50	 movss	 DWORD PTR _sVertex$7[ebp+44], xmm0
  0019a	6a 04		 push	 4
  0019c	58		 pop	 eax
  0019d	c1 e0 03	 shl	 eax, 3
  001a0	8b 4d cc	 mov	 ecx, DWORD PTR _pCoords$5[ebp]
  001a3	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  001a8	f3 0f 11 45 54	 movss	 DWORD PTR _sVertex$7[ebp+48], xmm0
  001ad	6a 04		 push	 4
  001af	58		 pop	 eax
  001b0	c1 e0 02	 shl	 eax, 2
  001b3	8b 4d c4	 mov	 ecx, DWORD PTR _pTexCoords$3[ebp]
  001b6	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  001bb	f3 0f 11 45 58	 movss	 DWORD PTR _sVertex$7[ebp+52], xmm0
  001c0	6a 04		 push	 4
  001c2	58		 pop	 eax
  001c3	6b c0 05	 imul	 eax, eax, 5
  001c6	8b 4d c4	 mov	 ecx, DWORD PTR _pTexCoords$3[ebp]
  001c9	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  001ce	f3 0f 11 45 5c	 movss	 DWORD PTR _sVertex$7[ebp+56], xmm0

; 1214 : 			{ pCoords[9], pCoords[10], pCoords[11], pTexCoords[6], pTexCoords[7] },

  001d3	6a 04		 push	 4
  001d5	58		 pop	 eax
  001d6	6b c0 09	 imul	 eax, eax, 9
  001d9	8b 4d cc	 mov	 ecx, DWORD PTR _pCoords$5[ebp]
  001dc	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  001e1	f3 0f 11 45 60	 movss	 DWORD PTR _sVertex$7[ebp+60], xmm0
  001e6	6a 04		 push	 4
  001e8	58		 pop	 eax
  001e9	6b c0 0a	 imul	 eax, eax, 10
  001ec	8b 4d cc	 mov	 ecx, DWORD PTR _pCoords$5[ebp]
  001ef	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  001f4	f3 0f 11 45 64	 movss	 DWORD PTR _sVertex$7[ebp+64], xmm0
  001f9	6a 04		 push	 4
  001fb	58		 pop	 eax
  001fc	6b c0 0b	 imul	 eax, eax, 11
  001ff	8b 4d cc	 mov	 ecx, DWORD PTR _pCoords$5[ebp]
  00202	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00207	f3 0f 11 45 68	 movss	 DWORD PTR _sVertex$7[ebp+68], xmm0
  0020c	6a 04		 push	 4
  0020e	58		 pop	 eax
  0020f	6b c0 06	 imul	 eax, eax, 6
  00212	8b 4d c4	 mov	 ecx, DWORD PTR _pTexCoords$3[ebp]
  00215	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0021a	f3 0f 11 45 6c	 movss	 DWORD PTR _sVertex$7[ebp+72], xmm0
  0021f	6a 04		 push	 4
  00221	58		 pop	 eax
  00222	6b c0 07	 imul	 eax, eax, 7
  00225	8b 4d c4	 mov	 ecx, DWORD PTR _pTexCoords$3[ebp]
  00228	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0022d	f3 0f 11 45 70	 movss	 DWORD PTR _sVertex$7[ebp+76], xmm0

; 1215 : 		};
; 1216 : 		
; 1217 : 		STATEMANAGER.SetVertexShader(D3DFVF_XYZ | D3DFVF_TEX1);

  00232	68 02 01 00 00	 push	 258			; 00000102H
  00237	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0023d	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 1218 : 		STATEMANAGER.SetRenderState(D3DRS_ALPHAREF, DWORD(m_pGeometryCache->m_sBillboard0.m_fAlphaTestValue));

  00242	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00245	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  0024b	f3 0f 10 80 fc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+252]
  00253	e8 00 00 00 00	 call	 __ftoui3
  00258	50		 push	 eax
  00259	6a 18		 push	 24			; 00000018H
  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00261	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 1219 : 		
; 1220 : 		ms_faceCount += 2;

  00266	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_faceCount@CGraphicBase@@1KA ; CGraphicBase::ms_faceCount
  0026b	40		 inc	 eax
  0026c	40		 inc	 eax
  0026d	a3 00 00 00 00	 mov	 DWORD PTR ?ms_faceCount@CGraphicBase@@1KA, eax ; CGraphicBase::ms_faceCount

; 1221 : 		STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, sVertex, sizeof(SBillboardVertex));

  00272	6a 14		 push	 20			; 00000014H
  00274	8d 45 24	 lea	 eax, DWORD PTR _sVertex$7[ebp]
  00277	50		 push	 eax
  00278	6a 02		 push	 2
  0027a	6a 06		 push	 6
  0027c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00282	e8 00 00 00 00	 call	 ?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z ; CStateManager::DrawPrimitiveUP
$LN3@RenderBill:

; 1222 : 	}
; 1223 : 	
; 1224 : 	// if tree supports 360 degree billboards, render the second
; 1225 : 	if (m_pGeometryCache->m_sBillboard1.m_bIsActive)

  00287	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0028a	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00290	0f b6 80 00 01
	00 00		 movzx	 eax, BYTE PTR [eax+256]
  00297	85 c0		 test	 eax, eax
  00299	0f 84 e3 01 00
	00		 je	 $LN4@RenderBill

; 1226 : 	{
; 1227 : 		const float* pCoords = m_pGeometryCache->m_sBillboard1.m_pCoords;

  0029f	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  002a2	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  002a8	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [eax+264]
  002ae	89 45 c8	 mov	 DWORD PTR _pCoords$4[ebp], eax

; 1228 : 		const float* pTexCoords = m_pGeometryCache->m_sBillboard1.m_pTexCoords;

  002b1	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  002b4	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  002ba	8b 80 04 01 00
	00		 mov	 eax, DWORD PTR [eax+260]
  002c0	89 45 c0	 mov	 DWORD PTR _pTexCoords$2[ebp], eax

; 1229 : 		SBillboardVertex sVertex[4] = 
; 1230 : 		{
; 1231 : 			{ pCoords[0], pCoords[1], pCoords[2], pTexCoords[0], pTexCoords[1] },

  002c3	6a 04		 push	 4
  002c5	58		 pop	 eax
  002c6	6b c0 00	 imul	 eax, eax, 0
  002c9	8b 4d c8	 mov	 ecx, DWORD PTR _pCoords$4[ebp]
  002cc	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  002d1	f3 0f 11 45 d4	 movss	 DWORD PTR _sVertex$6[ebp], xmm0
  002d6	6a 04		 push	 4
  002d8	58		 pop	 eax
  002d9	c1 e0 00	 shl	 eax, 0
  002dc	8b 4d c8	 mov	 ecx, DWORD PTR _pCoords$4[ebp]
  002df	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  002e4	f3 0f 11 45 d8	 movss	 DWORD PTR _sVertex$6[ebp+4], xmm0
  002e9	6a 04		 push	 4
  002eb	58		 pop	 eax
  002ec	d1 e0		 shl	 eax, 1
  002ee	8b 4d c8	 mov	 ecx, DWORD PTR _pCoords$4[ebp]
  002f1	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  002f6	f3 0f 11 45 dc	 movss	 DWORD PTR _sVertex$6[ebp+8], xmm0
  002fb	6a 04		 push	 4
  002fd	58		 pop	 eax
  002fe	6b c0 00	 imul	 eax, eax, 0
  00301	8b 4d c0	 mov	 ecx, DWORD PTR _pTexCoords$2[ebp]
  00304	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00309	f3 0f 11 45 e0	 movss	 DWORD PTR _sVertex$6[ebp+12], xmm0
  0030e	6a 04		 push	 4
  00310	58		 pop	 eax
  00311	c1 e0 00	 shl	 eax, 0
  00314	8b 4d c0	 mov	 ecx, DWORD PTR _pTexCoords$2[ebp]
  00317	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0031c	f3 0f 11 45 e4	 movss	 DWORD PTR _sVertex$6[ebp+16], xmm0

; 1232 : 			{ pCoords[3], pCoords[4], pCoords[5], pTexCoords[2], pTexCoords[3] },

  00321	6a 04		 push	 4
  00323	58		 pop	 eax
  00324	6b c0 03	 imul	 eax, eax, 3
  00327	8b 4d c8	 mov	 ecx, DWORD PTR _pCoords$4[ebp]
  0032a	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0032f	f3 0f 11 45 e8	 movss	 DWORD PTR _sVertex$6[ebp+20], xmm0
  00334	6a 04		 push	 4
  00336	58		 pop	 eax
  00337	c1 e0 02	 shl	 eax, 2
  0033a	8b 4d c8	 mov	 ecx, DWORD PTR _pCoords$4[ebp]
  0033d	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00342	f3 0f 11 45 ec	 movss	 DWORD PTR _sVertex$6[ebp+24], xmm0
  00347	6a 04		 push	 4
  00349	58		 pop	 eax
  0034a	6b c0 05	 imul	 eax, eax, 5
  0034d	8b 4d c8	 mov	 ecx, DWORD PTR _pCoords$4[ebp]
  00350	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00355	f3 0f 11 45 f0	 movss	 DWORD PTR _sVertex$6[ebp+28], xmm0
  0035a	6a 04		 push	 4
  0035c	58		 pop	 eax
  0035d	d1 e0		 shl	 eax, 1
  0035f	8b 4d c0	 mov	 ecx, DWORD PTR _pTexCoords$2[ebp]
  00362	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00367	f3 0f 11 45 f4	 movss	 DWORD PTR _sVertex$6[ebp+32], xmm0
  0036c	6a 04		 push	 4
  0036e	58		 pop	 eax
  0036f	6b c0 03	 imul	 eax, eax, 3
  00372	8b 4d c0	 mov	 ecx, DWORD PTR _pTexCoords$2[ebp]
  00375	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0037a	f3 0f 11 45 f8	 movss	 DWORD PTR _sVertex$6[ebp+36], xmm0

; 1233 : 			{ pCoords[6], pCoords[7], pCoords[8], pTexCoords[4], pTexCoords[5] },

  0037f	6a 04		 push	 4
  00381	58		 pop	 eax
  00382	6b c0 06	 imul	 eax, eax, 6
  00385	8b 4d c8	 mov	 ecx, DWORD PTR _pCoords$4[ebp]
  00388	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0038d	f3 0f 11 45 fc	 movss	 DWORD PTR _sVertex$6[ebp+40], xmm0
  00392	6a 04		 push	 4
  00394	58		 pop	 eax
  00395	6b c0 07	 imul	 eax, eax, 7
  00398	8b 4d c8	 mov	 ecx, DWORD PTR _pCoords$4[ebp]
  0039b	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  003a0	f3 0f 11 45 00	 movss	 DWORD PTR _sVertex$6[ebp+44], xmm0
  003a5	6a 04		 push	 4
  003a7	58		 pop	 eax
  003a8	c1 e0 03	 shl	 eax, 3
  003ab	8b 4d c8	 mov	 ecx, DWORD PTR _pCoords$4[ebp]
  003ae	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  003b3	f3 0f 11 45 04	 movss	 DWORD PTR _sVertex$6[ebp+48], xmm0
  003b8	6a 04		 push	 4
  003ba	58		 pop	 eax
  003bb	c1 e0 02	 shl	 eax, 2
  003be	8b 4d c0	 mov	 ecx, DWORD PTR _pTexCoords$2[ebp]
  003c1	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  003c6	f3 0f 11 45 08	 movss	 DWORD PTR _sVertex$6[ebp+52], xmm0
  003cb	6a 04		 push	 4
  003cd	58		 pop	 eax
  003ce	6b c0 05	 imul	 eax, eax, 5
  003d1	8b 4d c0	 mov	 ecx, DWORD PTR _pTexCoords$2[ebp]
  003d4	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  003d9	f3 0f 11 45 0c	 movss	 DWORD PTR _sVertex$6[ebp+56], xmm0

; 1234 : 			{ pCoords[9], pCoords[10], pCoords[11], pTexCoords[6], pTexCoords[7] },

  003de	6a 04		 push	 4
  003e0	58		 pop	 eax
  003e1	6b c0 09	 imul	 eax, eax, 9
  003e4	8b 4d c8	 mov	 ecx, DWORD PTR _pCoords$4[ebp]
  003e7	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  003ec	f3 0f 11 45 10	 movss	 DWORD PTR _sVertex$6[ebp+60], xmm0
  003f1	6a 04		 push	 4
  003f3	58		 pop	 eax
  003f4	6b c0 0a	 imul	 eax, eax, 10
  003f7	8b 4d c8	 mov	 ecx, DWORD PTR _pCoords$4[ebp]
  003fa	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  003ff	f3 0f 11 45 14	 movss	 DWORD PTR _sVertex$6[ebp+64], xmm0
  00404	6a 04		 push	 4
  00406	58		 pop	 eax
  00407	6b c0 0b	 imul	 eax, eax, 11
  0040a	8b 4d c8	 mov	 ecx, DWORD PTR _pCoords$4[ebp]
  0040d	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00412	f3 0f 11 45 18	 movss	 DWORD PTR _sVertex$6[ebp+68], xmm0
  00417	6a 04		 push	 4
  00419	58		 pop	 eax
  0041a	6b c0 06	 imul	 eax, eax, 6
  0041d	8b 4d c0	 mov	 ecx, DWORD PTR _pTexCoords$2[ebp]
  00420	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00425	f3 0f 11 45 1c	 movss	 DWORD PTR _sVertex$6[ebp+72], xmm0
  0042a	6a 04		 push	 4
  0042c	58		 pop	 eax
  0042d	6b c0 07	 imul	 eax, eax, 7
  00430	8b 4d c0	 mov	 ecx, DWORD PTR _pTexCoords$2[ebp]
  00433	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00438	f3 0f 11 45 20	 movss	 DWORD PTR _sVertex$6[ebp+76], xmm0

; 1235 : 		};
; 1236 : 		STATEMANAGER.SetRenderState(D3DRS_ALPHAREF, DWORD(m_pGeometryCache->m_sBillboard1.m_fAlphaTestValue));

  0043d	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00440	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00446	f3 0f 10 80 0c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+268]
  0044e	e8 00 00 00 00	 call	 __ftoui3
  00453	50		 push	 eax
  00454	6a 18		 push	 24			; 00000018H
  00456	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0045c	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 1237 : 		
; 1238 : 		ms_faceCount += 2;

  00461	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_faceCount@CGraphicBase@@1KA ; CGraphicBase::ms_faceCount
  00466	40		 inc	 eax
  00467	40		 inc	 eax
  00468	a3 00 00 00 00	 mov	 DWORD PTR ?ms_faceCount@CGraphicBase@@1KA, eax ; CGraphicBase::ms_faceCount

; 1239 : 		STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, sVertex, sizeof(SBillboardVertex));

  0046d	6a 14		 push	 20			; 00000014H
  0046f	8d 45 d4	 lea	 eax, DWORD PTR _sVertex$6[ebp]
  00472	50		 push	 eax
  00473	6a 02		 push	 2
  00475	6a 06		 push	 6
  00477	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0047d	e8 00 00 00 00	 call	 ?DrawPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IPBXI@Z ; CStateManager::DrawPrimitiveUP
$LN4@RenderBill:

; 1240 : 	}
; 1241 : 	
; 1242 : #ifdef WRAPPER_RENDER_HORIZONTAL_BILLBOARD
; 1243 : 	// render horizontal billboard (if enabled)
; 1244 : 	if (m_pGeometryCache->m_sHorizontalBillboard.m_bIsActive)
; 1245 : 	{	
; 1246 : 		const float* pCoords = m_pGeometryCache->m_sHorizontalBillboard.m_pCoords;
; 1247 : 		const float* pTexCoords = m_pGeometryCache->m_sHorizontalBillboard.m_pTexCoords;
; 1248 : 		SBillboardVertex sVertex[4] = 
; 1249 : 		{
; 1250 : 			{ pCoords[0], pCoords[1], pCoords[2], pTexCoords[0], pTexCoords[1] },
; 1251 : 			{ pCoords[3], pCoords[4], pCoords[5], pTexCoords[2], pTexCoords[3] },
; 1252 : 			{ pCoords[6], pCoords[7], pCoords[8], pTexCoords[4], pTexCoords[5] },
; 1253 : 			{ pCoords[9], pCoords[10], pCoords[11], pTexCoords[6], pTexCoords[7] },
; 1254 : 		};
; 1255 : 		STATEMANAGER.SetRenderState(D3DRS_ALPHAREF, DWORD(m_pGeometryCache->m_sHorizontalBillboard.m_fAlphaTestValue));
; 1256 : 		
; 1257 : 		ms_faceCount += 2;
; 1258 : 		STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, sVertex, sizeof(SBillboardVertex));
; 1259 : 	}
; 1260 : 	
; 1261 : #endif
; 1262 : #endif
; 1263 : }

  00482	8b 4d 74	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00485	33 cd		 xor	 ecx, ebp
  00487	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0048c	83 c5 78	 add	 ebp, 120		; 00000078H
  0048f	c9		 leave
  00490	c3		 ret	 0
?RenderBillboards@CSpeedTreeWrapper@@QBEXXZ ENDP	; CSpeedTreeWrapper::RenderBillboards
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?RenderLeaves@CSpeedTreeWrapper@@QBEXXZ
_TEXT	SEGMENT
_VERTEX_NUM$1 = -128					; size = 4
_uVtxCount$2 = -124					; size = 4
tv409 = -120						; size = 4
_unLod$3 = -116						; size = 4
tv372 = -112						; size = 4
_pVertex$4 = -108					; size = 4
___t$ = -104						; size = 4
tv79 = -100						; size = 4
___n$ = -96						; size = 4
_unLeafLevel$5 = -92					; size = 4
_i$6 = -88						; size = 4
_unLod$7 = -84						; size = 4
_i$8 = -80						; size = 4
_pLeaf$9 = -76						; size = 4
_this$ = -72						; size = 4
_center$10 = -68					; size = 4
_unLeaf$11 = -64					; size = 4
_pLeaf$12 = -60						; size = 4
_pkPosition$13 = -56					; size = 4
_akPosition$14 = -52					; size = 98304
__$ArrayPad$ = 98252					; size = 4
?RenderLeaves@CSpeedTreeWrapper@@QBEXXZ PROC		; CSpeedTreeWrapper::RenderLeaves, COMDAT
; _this$ = ecx

; 1033 : {

  00000	55		 push	 ebp
  00001	8d ac 24 30 80
	fe ff		 lea	 ebp, DWORD PTR [esp-98256]
  00008	b8 50 80 01 00	 mov	 eax, 98384		; 00018050H
  0000d	e8 00 00 00 00	 call	 __chkstk
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	89 85 cc 7f 01
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx

; 1034 : 	// update leaf geometry
; 1035 : 	m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_LeafGeometry);

  00024	6a ff		 push	 -1
  00026	6a ff		 push	 -1
  00028	6a ff		 push	 -1
  0002a	6a 04		 push	 4
  0002c	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	ff b0 98 01 00
	00		 push	 DWORD PTR [eax+408]
  00035	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  0003e	e8 00 00 00 00	 call	 ?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z ; CSpeedTreeRT::GetGeometry

; 1036 : 	
; 1037 : 	// update the LOD level vertex arrays we need
; 1038 : #if defined(WRAPPER_USE_GPU_LEAF_PLACEMENT) && defined(WRAPPER_USE_GPU_WIND)
; 1039 : 	// do nothing, needs no updates
; 1040 : #else
; 1041 : #if !defined WRAPPER_USE_NO_WIND || defined WRAPPER_USE_CPU_LEAF_PLACEMENT
; 1042 : 	// possibly need to update both leaf LOD's
; 1043 : 	for (UINT i = 0; i < 2; ++i)

  00043	83 65 a8 00	 and	 DWORD PTR _i$6[ebp], 0
  00047	eb 07		 jmp	 SHORT $LN4@RenderLeav
$LN2@RenderLeav:
  00049	8b 45 a8	 mov	 eax, DWORD PTR _i$6[ebp]
  0004c	40		 inc	 eax
  0004d	89 45 a8	 mov	 DWORD PTR _i$6[ebp], eax
$LN4@RenderLeav:
  00050	83 7d a8 02	 cmp	 DWORD PTR _i$6[ebp], 2
  00054	0f 83 09 04 00
	00		 jae	 $LN3@RenderLeav

; 1044 : 	{
; 1045 : 		// reference to leaf structure
; 1046 : 		const CSpeedTreeRT::SGeometry::SLeaf* pLeaf = (i == 0) ? &m_pGeometryCache->m_sLeaves0 : &m_pGeometryCache->m_sLeaves1;

  0005a	83 7d a8 00	 cmp	 DWORD PTR _i$6[ebp], 0
  0005e	75 11		 jne	 SHORT $LN19@RenderLeav
  00060	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00069	83 c0 78	 add	 eax, 120		; 00000078H
  0006c	89 45 9c	 mov	 DWORD PTR tv79[ebp], eax
  0006f	eb 11		 jmp	 SHORT $LN20@RenderLeav
$LN19@RenderLeav:
  00071	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  0007a	05 b4 00 00 00	 add	 eax, 180		; 000000b4H
  0007f	89 45 9c	 mov	 DWORD PTR tv79[ebp], eax
$LN20@RenderLeav:
  00082	8b 45 9c	 mov	 eax, DWORD PTR tv79[ebp]
  00085	89 45 c4	 mov	 DWORD PTR _pLeaf$12[ebp], eax

; 1047 : 		int unLod = pLeaf->m_nDiscreteLodLevel;

  00088	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  0008b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0008e	89 45 ac	 mov	 DWORD PTR _unLod$7[ebp], eax

; 1048 : 		
; 1049 : #if defined WRAPPER_USE_GPU_LEAF_PLACEMENT
; 1050 : 		if (pLeaf->m_bIsActive && !m_pLeavesUpdatedByCpu[unLod])
; 1051 : 		{
; 1052 : 			// update the centers
; 1053 : 			SFVFLeafVertex* pVertex = NULL;
; 1054 : 			m_pLeafVertexBuffer[unLod]->Lock(0, 0, reinterpret_cast<BYTE**>(&pVertex), D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK);
; 1055 : 			for (UINT unLeaf = 0; unLeaf < pLeaf->m_usLeafCount; ++unLeaf)
; 1056 : 			{
; 1057 : 				D3DXVECTOR3 vecCenter(&(pLeaf->m_pCenterCoords[unLeaf * 3]));
; 1058 : 				(pVertex++)->m_vPosition = vecCenter;		// vertex 0
; 1059 : 				(pVertex++)->m_vPosition = vecCenter;		// vertex 1
; 1060 : 				(pVertex++)->m_vPosition = vecCenter;		// vertex 2
; 1061 : 				(pVertex++)->m_vPosition = vecCenter;		// vertex 0
; 1062 : 				(pVertex++)->m_vPosition = vecCenter;		// vertex 2
; 1063 : 				(pVertex++)->m_vPosition = vecCenter;		// vertex 3
; 1064 : 			}
; 1065 : 			m_pLeafVertexBuffer[unLod]->Unlock();
; 1066 : 			m_pLeavesUpdatedByCpu[unLod] = true;
; 1067 : 		}
; 1068 : #else
; 1069 : 		if (pLeaf->m_bIsActive && m_pLeafVertexBuffer[unLod])

  00091	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  00094	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00097	85 c0		 test	 eax, eax
  00099	0f 84 bf 03 00
	00		 je	 $LN16@RenderLeav
  0009f	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [eax+448]
  000a8	8b 4d ac	 mov	 ecx, DWORD PTR _unLod$7[ebp]
  000ab	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  000af	0f 84 a9 03 00
	00		 je	 $LN16@RenderLeav

; 1070 : 		{ 
; 1071 : 			// update the vertex positions
; 1072 : 			SFVFLeafVertex * pVertex = NULL;

  000b5	83 65 94 00	 and	 DWORD PTR _pVertex$4[ebp], 0

; 1073 : 
; 1074 : 			const UINT VERTEX_NUM = 8192;

  000b9	c7 45 80 00 20
	00 00		 mov	 DWORD PTR _VERTEX_NUM$1[ebp], 8192 ; 00002000H

; 1075 : 			if (pLeaf->m_usLeafCount*3>=VERTEX_NUM)

  000c0	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  000c3	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  000c7	6b c0 03	 imul	 eax, eax, 3
  000ca	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  000cf	72 05		 jb	 SHORT $LN15@RenderLeav

; 1076 : 				return;

  000d1	e9 6a 04 00 00	 jmp	 $LN1@RenderLeav
$LN15@RenderLeav:

; 1077 : 
; 1078 : 			D3DXVECTOR3 akPosition[VERTEX_NUM];

  000d6	c7 45 a0 00 20
	00 00		 mov	 DWORD PTR ___n$[ebp], 8192 ; 00002000H
  000dd	8d 45 cc	 lea	 eax, DWORD PTR _akPosition$14[ebp]
  000e0	89 45 98	 mov	 DWORD PTR ___t$[ebp], eax
$LN24@RenderLeav:
  000e3	8b 45 a0	 mov	 eax, DWORD PTR ___n$[ebp]
  000e6	89 45 88	 mov	 DWORD PTR tv409[ebp], eax
  000e9	8b 45 a0	 mov	 eax, DWORD PTR ___n$[ebp]
  000ec	48		 dec	 eax
  000ed	89 45 a0	 mov	 DWORD PTR ___n$[ebp], eax
  000f0	83 7d 88 00	 cmp	 DWORD PTR tv409[ebp], 0
  000f4	76 0b		 jbe	 SHORT $LN25@RenderLeav
  000f6	8b 45 98	 mov	 eax, DWORD PTR ___t$[ebp]
  000f9	83 c0 0c	 add	 eax, 12			; 0000000cH
  000fc	89 45 98	 mov	 DWORD PTR ___t$[ebp], eax
  000ff	eb e2		 jmp	 SHORT $LN24@RenderLeav
$LN25@RenderLeav:

; 1079 : 			D3DXVECTOR3*pkPosition=akPosition;

  00101	8d 45 cc	 lea	 eax, DWORD PTR _akPosition$14[ebp]
  00104	89 45 c8	 mov	 DWORD PTR _pkPosition$13[ebp], eax

; 1080 : 			const float* center=pLeaf->m_pCenterCoords;

  00107	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  0010a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0010d	89 45 bc	 mov	 DWORD PTR _center$10[ebp], eax

; 1081 : 			for (UINT unLeaf = 0; unLeaf < pLeaf->m_usLeafCount; ++unLeaf)

  00110	83 65 c0 00	 and	 DWORD PTR _unLeaf$11[ebp], 0
  00114	eb 07		 jmp	 SHORT $LN7@RenderLeav
$LN5@RenderLeav:
  00116	8b 45 c0	 mov	 eax, DWORD PTR _unLeaf$11[ebp]
  00119	40		 inc	 eax
  0011a	89 45 c0	 mov	 DWORD PTR _unLeaf$11[ebp], eax
$LN7@RenderLeav:
  0011d	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  00120	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  00124	39 45 c0	 cmp	 DWORD PTR _unLeaf$11[ebp], eax
  00127	0f 83 a4 02 00
	00		 jae	 $LN6@RenderLeav

; 1082 : 			{
; 1083 : 				pkPosition[0].x=pLeaf->m_pLeafMapCoords[unLeaf][0]+center[0];

  0012d	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  00130	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00133	6a 04		 push	 4
  00135	59		 pop	 ecx
  00136	6b c9 00	 imul	 ecx, ecx, 0
  00139	8b 55 c0	 mov	 edx, DWORD PTR _unLeaf$11[ebp]
  0013c	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  0013f	6a 04		 push	 4
  00141	5a		 pop	 edx
  00142	6b d2 00	 imul	 edx, edx, 0
  00145	8b 75 bc	 mov	 esi, DWORD PTR _center$10[ebp]
  00148	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  0014d	f3 0f 58 04 16	 addss	 xmm0, DWORD PTR [esi+edx]
  00152	6a 0c		 push	 12			; 0000000cH
  00154	58		 pop	 eax
  00155	6b c0 00	 imul	 eax, eax, 0
  00158	8b 4d c8	 mov	 ecx, DWORD PTR _pkPosition$13[ebp]
  0015b	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1084 : 				pkPosition[0].y=pLeaf->m_pLeafMapCoords[unLeaf][1]+center[1];

  00160	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  00163	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00166	6a 04		 push	 4
  00168	59		 pop	 ecx
  00169	c1 e1 00	 shl	 ecx, 0
  0016c	8b 55 c0	 mov	 edx, DWORD PTR _unLeaf$11[ebp]
  0016f	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00172	6a 04		 push	 4
  00174	5a		 pop	 edx
  00175	c1 e2 00	 shl	 edx, 0
  00178	8b 75 bc	 mov	 esi, DWORD PTR _center$10[ebp]
  0017b	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  00180	f3 0f 58 04 16	 addss	 xmm0, DWORD PTR [esi+edx]
  00185	6a 0c		 push	 12			; 0000000cH
  00187	58		 pop	 eax
  00188	6b c0 00	 imul	 eax, eax, 0
  0018b	8b 4d c8	 mov	 ecx, DWORD PTR _pkPosition$13[ebp]
  0018e	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 1085 : 				pkPosition[0].z=pLeaf->m_pLeafMapCoords[unLeaf][2]+center[2];

  00194	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  00197	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0019a	6a 04		 push	 4
  0019c	59		 pop	 ecx
  0019d	d1 e1		 shl	 ecx, 1
  0019f	8b 55 c0	 mov	 edx, DWORD PTR _unLeaf$11[ebp]
  001a2	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  001a5	6a 04		 push	 4
  001a7	5a		 pop	 edx
  001a8	d1 e2		 shl	 edx, 1
  001aa	8b 75 bc	 mov	 esi, DWORD PTR _center$10[ebp]
  001ad	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  001b2	f3 0f 58 04 16	 addss	 xmm0, DWORD PTR [esi+edx]
  001b7	6a 0c		 push	 12			; 0000000cH
  001b9	58		 pop	 eax
  001ba	6b c0 00	 imul	 eax, eax, 0
  001bd	8b 4d c8	 mov	 ecx, DWORD PTR _pkPosition$13[ebp]
  001c0	f3 0f 11 44 01
	08		 movss	 DWORD PTR [ecx+eax+8], xmm0

; 1086 : 				pkPosition[1].x=pLeaf->m_pLeafMapCoords[unLeaf][4]+center[0];

  001c6	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  001c9	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  001cc	6a 04		 push	 4
  001ce	59		 pop	 ecx
  001cf	c1 e1 02	 shl	 ecx, 2
  001d2	8b 55 c0	 mov	 edx, DWORD PTR _unLeaf$11[ebp]
  001d5	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  001d8	6a 04		 push	 4
  001da	5a		 pop	 edx
  001db	6b d2 00	 imul	 edx, edx, 0
  001de	8b 75 bc	 mov	 esi, DWORD PTR _center$10[ebp]
  001e1	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  001e6	f3 0f 58 04 16	 addss	 xmm0, DWORD PTR [esi+edx]
  001eb	6a 0c		 push	 12			; 0000000cH
  001ed	58		 pop	 eax
  001ee	c1 e0 00	 shl	 eax, 0
  001f1	8b 4d c8	 mov	 ecx, DWORD PTR _pkPosition$13[ebp]
  001f4	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1087 : 				pkPosition[1].y=pLeaf->m_pLeafMapCoords[unLeaf][5]+center[1];

  001f9	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  001fc	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  001ff	6a 04		 push	 4
  00201	59		 pop	 ecx
  00202	6b c9 05	 imul	 ecx, ecx, 5
  00205	8b 55 c0	 mov	 edx, DWORD PTR _unLeaf$11[ebp]
  00208	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  0020b	6a 04		 push	 4
  0020d	5a		 pop	 edx
  0020e	c1 e2 00	 shl	 edx, 0
  00211	8b 75 bc	 mov	 esi, DWORD PTR _center$10[ebp]
  00214	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  00219	f3 0f 58 04 16	 addss	 xmm0, DWORD PTR [esi+edx]
  0021e	6a 0c		 push	 12			; 0000000cH
  00220	58		 pop	 eax
  00221	c1 e0 00	 shl	 eax, 0
  00224	8b 4d c8	 mov	 ecx, DWORD PTR _pkPosition$13[ebp]
  00227	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 1088 : 				pkPosition[1].z=pLeaf->m_pLeafMapCoords[unLeaf][6]+center[2];			

  0022d	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  00230	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00233	6a 04		 push	 4
  00235	59		 pop	 ecx
  00236	6b c9 06	 imul	 ecx, ecx, 6
  00239	8b 55 c0	 mov	 edx, DWORD PTR _unLeaf$11[ebp]
  0023c	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  0023f	6a 04		 push	 4
  00241	5a		 pop	 edx
  00242	d1 e2		 shl	 edx, 1
  00244	8b 75 bc	 mov	 esi, DWORD PTR _center$10[ebp]
  00247	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  0024c	f3 0f 58 04 16	 addss	 xmm0, DWORD PTR [esi+edx]
  00251	6a 0c		 push	 12			; 0000000cH
  00253	58		 pop	 eax
  00254	c1 e0 00	 shl	 eax, 0
  00257	8b 4d c8	 mov	 ecx, DWORD PTR _pkPosition$13[ebp]
  0025a	f3 0f 11 44 01
	08		 movss	 DWORD PTR [ecx+eax+8], xmm0

; 1089 : 				pkPosition[2].x=pLeaf->m_pLeafMapCoords[unLeaf][8]+center[0];

  00260	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  00263	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00266	6a 04		 push	 4
  00268	59		 pop	 ecx
  00269	c1 e1 03	 shl	 ecx, 3
  0026c	8b 55 c0	 mov	 edx, DWORD PTR _unLeaf$11[ebp]
  0026f	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00272	6a 04		 push	 4
  00274	5a		 pop	 edx
  00275	6b d2 00	 imul	 edx, edx, 0
  00278	8b 75 bc	 mov	 esi, DWORD PTR _center$10[ebp]
  0027b	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  00280	f3 0f 58 04 16	 addss	 xmm0, DWORD PTR [esi+edx]
  00285	6a 0c		 push	 12			; 0000000cH
  00287	58		 pop	 eax
  00288	d1 e0		 shl	 eax, 1
  0028a	8b 4d c8	 mov	 ecx, DWORD PTR _pkPosition$13[ebp]
  0028d	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1090 : 				pkPosition[2].y=pLeaf->m_pLeafMapCoords[unLeaf][9]+center[1];

  00292	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  00295	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00298	6a 04		 push	 4
  0029a	59		 pop	 ecx
  0029b	6b c9 09	 imul	 ecx, ecx, 9
  0029e	8b 55 c0	 mov	 edx, DWORD PTR _unLeaf$11[ebp]
  002a1	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  002a4	6a 04		 push	 4
  002a6	5a		 pop	 edx
  002a7	c1 e2 00	 shl	 edx, 0
  002aa	8b 75 bc	 mov	 esi, DWORD PTR _center$10[ebp]
  002ad	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  002b2	f3 0f 58 04 16	 addss	 xmm0, DWORD PTR [esi+edx]
  002b7	6a 0c		 push	 12			; 0000000cH
  002b9	58		 pop	 eax
  002ba	d1 e0		 shl	 eax, 1
  002bc	8b 4d c8	 mov	 ecx, DWORD PTR _pkPosition$13[ebp]
  002bf	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 1091 : 				pkPosition[2].z=pLeaf->m_pLeafMapCoords[unLeaf][10]+center[2];

  002c5	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  002c8	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  002cb	6a 04		 push	 4
  002cd	59		 pop	 ecx
  002ce	6b c9 0a	 imul	 ecx, ecx, 10
  002d1	8b 55 c0	 mov	 edx, DWORD PTR _unLeaf$11[ebp]
  002d4	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  002d7	6a 04		 push	 4
  002d9	5a		 pop	 edx
  002da	d1 e2		 shl	 edx, 1
  002dc	8b 75 bc	 mov	 esi, DWORD PTR _center$10[ebp]
  002df	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  002e4	f3 0f 58 04 16	 addss	 xmm0, DWORD PTR [esi+edx]
  002e9	6a 0c		 push	 12			; 0000000cH
  002eb	58		 pop	 eax
  002ec	d1 e0		 shl	 eax, 1
  002ee	8b 4d c8	 mov	 ecx, DWORD PTR _pkPosition$13[ebp]
  002f1	f3 0f 11 44 01
	08		 movss	 DWORD PTR [ecx+eax+8], xmm0

; 1092 : 				pkPosition[3]=pkPosition[0];

  002f7	6a 0c		 push	 12			; 0000000cH
  002f9	58		 pop	 eax
  002fa	6b f0 00	 imul	 esi, eax, 0
  002fd	03 75 c8	 add	 esi, DWORD PTR _pkPosition$13[ebp]
  00300	6a 0c		 push	 12			; 0000000cH
  00302	58		 pop	 eax
  00303	6b f8 03	 imul	 edi, eax, 3
  00306	03 7d c8	 add	 edi, DWORD PTR _pkPosition$13[ebp]
  00309	a5		 movsd
  0030a	a5		 movsd
  0030b	a5		 movsd

; 1093 : 				pkPosition[4]=pkPosition[2];

  0030c	6a 0c		 push	 12			; 0000000cH
  0030e	5e		 pop	 esi
  0030f	d1 e6		 shl	 esi, 1
  00311	03 75 c8	 add	 esi, DWORD PTR _pkPosition$13[ebp]
  00314	6a 0c		 push	 12			; 0000000cH
  00316	5f		 pop	 edi
  00317	c1 e7 02	 shl	 edi, 2
  0031a	03 7d c8	 add	 edi, DWORD PTR _pkPosition$13[ebp]
  0031d	a5		 movsd
  0031e	a5		 movsd
  0031f	a5		 movsd

; 1094 : 				pkPosition[5].x=pLeaf->m_pLeafMapCoords[unLeaf][12]+center[0];

  00320	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  00323	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00326	6a 04		 push	 4
  00328	59		 pop	 ecx
  00329	6b c9 0c	 imul	 ecx, ecx, 12
  0032c	8b 55 c0	 mov	 edx, DWORD PTR _unLeaf$11[ebp]
  0032f	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00332	6a 04		 push	 4
  00334	5a		 pop	 edx
  00335	6b d2 00	 imul	 edx, edx, 0
  00338	8b 75 bc	 mov	 esi, DWORD PTR _center$10[ebp]
  0033b	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  00340	f3 0f 58 04 16	 addss	 xmm0, DWORD PTR [esi+edx]
  00345	6a 0c		 push	 12			; 0000000cH
  00347	58		 pop	 eax
  00348	6b c0 05	 imul	 eax, eax, 5
  0034b	8b 4d c8	 mov	 ecx, DWORD PTR _pkPosition$13[ebp]
  0034e	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1095 : 				pkPosition[5].y=pLeaf->m_pLeafMapCoords[unLeaf][13]+center[1];

  00353	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  00356	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00359	6a 04		 push	 4
  0035b	59		 pop	 ecx
  0035c	6b c9 0d	 imul	 ecx, ecx, 13
  0035f	8b 55 c0	 mov	 edx, DWORD PTR _unLeaf$11[ebp]
  00362	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00365	6a 04		 push	 4
  00367	5a		 pop	 edx
  00368	c1 e2 00	 shl	 edx, 0
  0036b	8b 75 bc	 mov	 esi, DWORD PTR _center$10[ebp]
  0036e	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  00373	f3 0f 58 04 16	 addss	 xmm0, DWORD PTR [esi+edx]
  00378	6a 0c		 push	 12			; 0000000cH
  0037a	58		 pop	 eax
  0037b	6b c0 05	 imul	 eax, eax, 5
  0037e	8b 4d c8	 mov	 ecx, DWORD PTR _pkPosition$13[ebp]
  00381	f3 0f 11 44 01
	04		 movss	 DWORD PTR [ecx+eax+4], xmm0

; 1096 : 				pkPosition[5].z=pLeaf->m_pLeafMapCoords[unLeaf][14]+center[2];

  00387	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  0038a	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0038d	6a 04		 push	 4
  0038f	59		 pop	 ecx
  00390	6b c9 0e	 imul	 ecx, ecx, 14
  00393	8b 55 c0	 mov	 edx, DWORD PTR _unLeaf$11[ebp]
  00396	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00399	6a 04		 push	 4
  0039b	5a		 pop	 edx
  0039c	d1 e2		 shl	 edx, 1
  0039e	8b 75 bc	 mov	 esi, DWORD PTR _center$10[ebp]
  003a1	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [eax+ecx]
  003a6	f3 0f 58 04 16	 addss	 xmm0, DWORD PTR [esi+edx]
  003ab	6a 0c		 push	 12			; 0000000cH
  003ad	58		 pop	 eax
  003ae	6b c0 05	 imul	 eax, eax, 5
  003b1	8b 4d c8	 mov	 ecx, DWORD PTR _pkPosition$13[ebp]
  003b4	f3 0f 11 44 01
	08		 movss	 DWORD PTR [ecx+eax+8], xmm0

; 1097 : 				pkPosition+=6;

  003ba	8b 45 c8	 mov	 eax, DWORD PTR _pkPosition$13[ebp]
  003bd	83 c0 48	 add	 eax, 72			; 00000048H
  003c0	89 45 c8	 mov	 DWORD PTR _pkPosition$13[ebp], eax

; 1098 : 				center+=3;

  003c3	8b 45 bc	 mov	 eax, DWORD PTR _center$10[ebp]
  003c6	83 c0 0c	 add	 eax, 12			; 0000000cH
  003c9	89 45 bc	 mov	 DWORD PTR _center$10[ebp], eax

; 1099 : 			}			

  003cc	e9 45 fd ff ff	 jmp	 $LN5@RenderLeav
$LN6@RenderLeav:

; 1100 : 			
; 1101 : 			if (SUCCEEDED(

  003d1	68 00 28 00 00	 push	 10240			; 00002800H
  003d6	8d 45 94	 lea	 eax, DWORD PTR _pVertex$4[ebp]
  003d9	50		 push	 eax
  003da	6a 00		 push	 0
  003dc	6a 00		 push	 0
  003de	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  003e1	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [eax+448]
  003e7	8b 4d ac	 mov	 ecx, DWORD PTR _unLod$7[ebp]
  003ea	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  003ed	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  003f0	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [ecx+448]
  003f6	8b 55 ac	 mov	 edx, DWORD PTR _unLod$7[ebp]
  003f9	8b 00		 mov	 eax, DWORD PTR [eax]
  003fb	ff 34 91	 push	 DWORD PTR [ecx+edx*4]
  003fe	ff 50 2c	 call	 DWORD PTR [eax+44]
  00401	85 c0		 test	 eax, eax
  00403	7c 59		 jl	 SHORT $LN16@RenderLeav

; 1102 : 				m_pLeafVertexBuffer[unLod]->Lock(0, 0, reinterpret_cast<BYTE**>(&pVertex), D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK)
; 1103 : 			))
; 1104 : 			{			
; 1105 : 				UINT uVtxCount=pLeaf->m_usLeafCount*6;

  00405	8b 45 c4	 mov	 eax, DWORD PTR _pLeaf$12[ebp]
  00408	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  0040c	6b c0 06	 imul	 eax, eax, 6
  0040f	89 45 84	 mov	 DWORD PTR _uVtxCount$2[ebp], eax

; 1106 : 				for (UINT i = 0; i<uVtxCount; ++i)

  00412	83 65 b0 00	 and	 DWORD PTR _i$8[ebp], 0
  00416	eb 07		 jmp	 SHORT $LN10@RenderLeav
$LN8@RenderLeav:
  00418	8b 45 b0	 mov	 eax, DWORD PTR _i$8[ebp]
  0041b	40		 inc	 eax
  0041c	89 45 b0	 mov	 DWORD PTR _i$8[ebp], eax
$LN10@RenderLeav:
  0041f	8b 45 b0	 mov	 eax, DWORD PTR _i$8[ebp]
  00422	3b 45 84	 cmp	 eax, DWORD PTR _uVtxCount$2[ebp]
  00425	73 14		 jae	 SHORT $LN9@RenderLeav

; 1107 : 					pVertex[i].m_vPosition=akPosition[i];

  00427	6b 45 b0 0c	 imul	 eax, DWORD PTR _i$8[ebp], 12
  0042b	8d 74 05 cc	 lea	 esi, DWORD PTR _akPosition$14[ebp+eax]
  0042f	6b 7d b0 18	 imul	 edi, DWORD PTR _i$8[ebp], 24
  00433	03 7d 94	 add	 edi, DWORD PTR _pVertex$4[ebp]
  00436	a5		 movsd
  00437	a5		 movsd
  00438	a5		 movsd
  00439	eb dd		 jmp	 SHORT $LN8@RenderLeav
$LN9@RenderLeav:

; 1108 : 				
; 1109 : 					/*
; 1110 : 					memcpy(vec0, pLeaf->m_pLeafMapCoords[unLeaf]+0, sizeof(D3DXVECTOR3));
; 1111 : 					memcpy(vec1, pLeaf->m_pLeafMapCoords[unLeaf]+4, sizeof(D3DXVECTOR3));
; 1112 : 					memcpy(vec2, pLeaf->m_pLeafMapCoords[unLeaf]+8, sizeof(D3DXVECTOR3));
; 1113 : 					memcpy(vec3, pLeaf->m_pLeafMapCoords[unLeaf]+12, sizeof(D3DXVECTOR3));
; 1114 : 					memcpy(vecCenter, pLeaf->m_pCenterCoords + unLeaf * 3, sizeof(D3DXVECTOR3));
; 1115 : 					vec0 += vecCenter;
; 1116 : 					vec1 += vecCenter;
; 1117 : 					vec2 += vecCenter;
; 1118 : 					vec3 += vecCenter;
; 1119 : 
; 1120 : 					pVertex[0].m_vPosition = vec0;
; 1121 : 					pVertex[3].m_vPosition = vec0;
; 1122 : 					pVertex[1].m_vPosition = vec1;
; 1123 : 					pVertex[4].m_vPosition = vec2;
; 1124 : 					pVertex[2].m_vPosition = vec2;
; 1125 : 					pVertex[5].m_vPosition = vec3;
; 1126 : 					*/
; 1127 : 				/*
; 1128 : 				for (UINT unLeaf = 0; unLeaf < pLeaf->m_usLeafCount; ++unLeaf)
; 1129 : 				{					
; 1130 : 					D3DXVECTOR3 vecCenter(&(pLeaf->m_pCenterCoords[unLeaf * 3]));
; 1131 : 					D3DXVECTOR3 vec0(&pLeaf->m_pLeafMapCoords[unLeaf][0]);
; 1132 : 					D3DXVECTOR3 vec1(&pLeaf->m_pLeafMapCoords[unLeaf][4]);
; 1133 : 					D3DXVECTOR3 vec2(&pLeaf->m_pLeafMapCoords[unLeaf][8]);
; 1134 : 					D3DXVECTOR3 vec3(&pLeaf->m_pLeafMapCoords[unLeaf][12]);
; 1135 : 					
; 1136 : 					(pVertex++)->m_vPosition = vecCenter + vec0;		// vertex 0
; 1137 : 					(pVertex++)->m_vPosition = vecCenter + vec1;		// vertex 1
; 1138 : 					(pVertex++)->m_vPosition = vecCenter + vec2;		// vertex 2
; 1139 : 					(pVertex++)->m_vPosition = vecCenter + vec0;		// vertex 0
; 1140 : 					(pVertex++)->m_vPosition = vecCenter + vec2;		// vertex 2
; 1141 : 					(pVertex++)->m_vPosition = vecCenter + vec3;		// vertex 3
; 1142 : 				}
; 1143 : 				*/
; 1144 : 				m_pLeafVertexBuffer[unLod]->Unlock();

  0043b	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0043e	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [eax+448]
  00444	8b 4d ac	 mov	 ecx, DWORD PTR _unLod$7[ebp]
  00447	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0044a	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0044d	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [ecx+448]
  00453	8b 55 ac	 mov	 edx, DWORD PTR _unLod$7[ebp]
  00456	8b 00		 mov	 eax, DWORD PTR [eax]
  00458	ff 34 91	 push	 DWORD PTR [ecx+edx*4]
  0045b	ff 50 30	 call	 DWORD PTR [eax+48]
$LN16@RenderLeav:

; 1145 : 			}
; 1146 : 		}
; 1147 : #endif
; 1148 : 	}

  0045e	e9 e6 fb ff ff	 jmp	 $LN2@RenderLeav
$LN3@RenderLeav:

; 1149 : #endif
; 1150 : #endif
; 1151 : 	
; 1152 : 	PositionTree();

  00463	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00466	e8 00 00 00 00	 call	 ?PositionTree@CSpeedTreeWrapper@@ABEXXZ ; CSpeedTreeWrapper::PositionTree

; 1153 : 	
; 1154 : 	// render LODs, if needed
; 1155 : 	for (UINT unLeafLevel = 0; unLeafLevel < 2; ++unLeafLevel)

  0046b	83 65 a4 00	 and	 DWORD PTR _unLeafLevel$5[ebp], 0
  0046f	eb 07		 jmp	 SHORT $LN13@RenderLeav
$LN11@RenderLeav:
  00471	8b 45 a4	 mov	 eax, DWORD PTR _unLeafLevel$5[ebp]
  00474	40		 inc	 eax
  00475	89 45 a4	 mov	 DWORD PTR _unLeafLevel$5[ebp], eax
$LN13@RenderLeav:
  00478	83 7d a4 02	 cmp	 DWORD PTR _unLeafLevel$5[ebp], 2
  0047c	0f 83 be 00 00
	00		 jae	 $LN12@RenderLeav

; 1156 : 	{
; 1157 : 		const CSpeedTreeRT::SGeometry::SLeaf* pLeaf = (unLeafLevel == 0) ?

  00482	83 7d a4 00	 cmp	 DWORD PTR _unLeafLevel$5[ebp], 0
  00486	75 11		 jne	 SHORT $LN21@RenderLeav
  00488	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0048b	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00491	83 c0 78	 add	 eax, 120		; 00000078H
  00494	89 45 90	 mov	 DWORD PTR tv372[ebp], eax
  00497	eb 11		 jmp	 SHORT $LN22@RenderLeav
$LN21@RenderLeav:
  00499	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0049c	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  004a2	05 b4 00 00 00	 add	 eax, 180		; 000000b4H
  004a7	89 45 90	 mov	 DWORD PTR tv372[ebp], eax
$LN22@RenderLeav:
  004aa	8b 45 90	 mov	 eax, DWORD PTR tv372[ebp]
  004ad	89 45 b4	 mov	 DWORD PTR _pLeaf$9[ebp], eax

; 1158 : 			&m_pGeometryCache->m_sLeaves0 : &m_pGeometryCache->m_sLeaves1;
; 1159 : 		
; 1160 : 		int unLod = pLeaf->m_nDiscreteLodLevel;

  004b0	8b 45 b4	 mov	 eax, DWORD PTR _pLeaf$9[ebp]
  004b3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  004b6	89 45 8c	 mov	 DWORD PTR _unLod$3[ebp], eax

; 1161 : 		
; 1162 : 		if (unLod > -1 && pLeaf->m_bIsActive && pLeaf->m_usLeafCount > 0)

  004b9	83 7d 8c ff	 cmp	 DWORD PTR _unLod$3[ebp], -1
  004bd	7e 7c		 jle	 SHORT $LN17@RenderLeav
  004bf	8b 45 b4	 mov	 eax, DWORD PTR _pLeaf$9[ebp]
  004c2	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  004c5	85 c0		 test	 eax, eax
  004c7	74 72		 je	 SHORT $LN17@RenderLeav
  004c9	8b 45 b4	 mov	 eax, DWORD PTR _pLeaf$9[ebp]
  004cc	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  004d0	85 c0		 test	 eax, eax
  004d2	7e 67		 jle	 SHORT $LN17@RenderLeav

; 1163 : 		{
; 1164 : 			STATEMANAGER.SetStreamSource(0, m_pLeafVertexBuffer[unLod], sizeof(SFVFLeafVertex));

  004d4	6a 18		 push	 24			; 00000018H
  004d6	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  004d9	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [eax+448]
  004df	8b 4d 8c	 mov	 ecx, DWORD PTR _unLod$3[ebp]
  004e2	ff 34 88	 push	 DWORD PTR [eax+ecx*4]
  004e5	6a 00		 push	 0
  004e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004ed	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 1165 : 			STATEMANAGER.SetRenderState(D3DRS_ALPHAREF, DWORD(pLeaf->m_fAlphaTestValue));

  004f2	8b 45 b4	 mov	 eax, DWORD PTR _pLeaf$9[ebp]
  004f5	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  004fa	e8 00 00 00 00	 call	 __ftoui3
  004ff	50		 push	 eax
  00500	6a 18		 push	 24			; 00000018H
  00502	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00508	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 1166 : 			
; 1167 : 			ms_faceCount += pLeaf->m_usLeafCount * 2;

  0050d	8b 45 b4	 mov	 eax, DWORD PTR _pLeaf$9[ebp]
  00510	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  00514	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_faceCount@CGraphicBase@@1KA ; CGraphicBase::ms_faceCount
  0051a	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0051d	a3 00 00 00 00	 mov	 DWORD PTR ?ms_faceCount@CGraphicBase@@1KA, eax ; CGraphicBase::ms_faceCount

; 1168 : 			STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLELIST, 0, pLeaf->m_usLeafCount * 2);

  00522	8b 45 b4	 mov	 eax, DWORD PTR _pLeaf$9[ebp]
  00525	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  00529	d1 e0		 shl	 eax, 1
  0052b	50		 push	 eax
  0052c	6a 00		 push	 0
  0052e	6a 04		 push	 4
  00530	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00536	e8 00 00 00 00	 call	 ?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z ; CStateManager::DrawPrimitive
$LN17@RenderLeav:

; 1169 : 		}
; 1170 : 	}

  0053b	e9 31 ff ff ff	 jmp	 $LN11@RenderLeav
$LN12@RenderLeav:
$LN1@RenderLeav:

; 1171 : }

  00540	5f		 pop	 edi
  00541	5e		 pop	 esi
  00542	8b 8d cc 7f 01
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00548	33 cd		 xor	 ecx, ebp
  0054a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0054f	81 c5 d0 7f 01
	00		 add	 ebp, 98256		; 00017fd0H
  00555	c9		 leave
  00556	c3		 ret	 0
?RenderLeaves@CSpeedTreeWrapper@@QBEXXZ ENDP		; CSpeedTreeWrapper::RenderLeaves
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?RenderFronds@CSpeedTreeWrapper@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderFronds@CSpeedTreeWrapper@@QBEXXZ PROC		; CSpeedTreeWrapper::RenderFronds, COMDAT
; _this$ = ecx

; 966  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 967  : 	m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_FrondGeometry);

  00007	6a ff		 push	 -1
  00009	6a ff		 push	 -1
  0000b	6a ff		 push	 -1
  0000d	6a 02		 push	 2
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	ff b0 98 01 00
	00		 push	 DWORD PTR [eax+408]
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00021	e8 00 00 00 00	 call	 ?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z ; CSpeedTreeRT::GetGeometry

; 968  : 	
; 969  : 	if (m_pGeometryCache->m_fFrondAlphaTestValue > 0.0f)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  0002f	f3 0f 10 40 74	 movss	 xmm0, DWORD PTR [eax+116]
  00034	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0003b	0f 86 b9 00 00
	00		 jbe	 $LN3@RenderFron

; 970  : 	{
; 971  : 		PositionTree();

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?PositionTree@CSpeedTreeWrapper@@ABEXXZ ; CSpeedTreeWrapper::PositionTree

; 972  : 		
; 973  : 		// set alpha test value
; 974  : 		STATEMANAGER.SetRenderState(D3DRS_ALPHAREF, DWORD(m_pGeometryCache->m_fFrondAlphaTestValue));

  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00052	f3 0f 10 40 74	 movss	 xmm0, DWORD PTR [eax+116]
  00057	e8 00 00 00 00	 call	 __ftoui3
  0005c	50		 push	 eax
  0005d	6a 18		 push	 24			; 00000018H
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00065	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 975  : 		
; 976  : 		// render if this LOD has fronds
; 977  : 		if (m_pFrondIndexCounts &&

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	83 b8 b8 01 00
	00 00		 cmp	 DWORD PTR [eax+440], 0
  00074	0f 84 80 00 00
	00		 je	 $LN3@RenderFron
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00083	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	8b 89 b8 01 00
	00		 mov	 ecx, DWORD PTR [ecx+440]
  0008f	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00093	85 c0		 test	 eax, eax
  00095	7e 63		 jle	 SHORT $LN3@RenderFron

; 978  : 			m_pFrondIndexCounts[m_pGeometryCache->m_sFronds.m_nDiscreteLodLevel] > 0)
; 979  : 		{
; 980  : 			ms_faceCount += m_pFrondIndexCounts[m_pGeometryCache->m_sFronds.m_nDiscreteLodLevel] - 2;

  00097	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  000a0	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 89 b8 01 00
	00		 mov	 ecx, DWORD PTR [ecx+440]
  000ac	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  000b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_faceCount@CGraphicBase@@1KA ; CGraphicBase::ms_faceCount
  000b6	8d 44 01 fe	 lea	 eax, DWORD PTR [ecx+eax-2]
  000ba	a3 00 00 00 00	 mov	 DWORD PTR ?ms_faceCount@CGraphicBase@@1KA, eax ; CGraphicBase::ms_faceCount

; 981  : 			STATEMANAGER.DrawIndexedPrimitive(D3DPT_TRIANGLESTRIP, 0, m_pGeometryCache->m_sFronds.m_usVertexCount, 0, m_pFrondIndexCounts[m_pGeometryCache->m_sFronds.m_nDiscreteLodLevel] - 2);

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  000c8	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	8b 89 b8 01 00
	00		 mov	 ecx, DWORD PTR [ecx+440]
  000d4	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  000d8	48		 dec	 eax
  000d9	48		 dec	 eax
  000da	50		 push	 eax
  000db	6a 00		 push	 0
  000dd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  000e6	0f b7 40 4c	 movzx	 eax, WORD PTR [eax+76]
  000ea	50		 push	 eax
  000eb	6a 00		 push	 0
  000ed	6a 05		 push	 5
  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000f5	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN3@RenderFron:

; 982  : 		}
; 983  : 	}
; 984  : }

  000fa	c9		 leave
  000fb	c3		 ret	 0
?RenderFronds@CSpeedTreeWrapper@@QBEXXZ ENDP		; CSpeedTreeWrapper::RenderFronds
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?RenderBranches@CSpeedTreeWrapper@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderBranches@CSpeedTreeWrapper@@QBEXXZ PROC		; CSpeedTreeWrapper::RenderBranches, COMDAT
; _this$ = ecx

; 893  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 894  : 	m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_BranchGeometry);

  00007	6a ff		 push	 -1
  00009	6a ff		 push	 -1
  0000b	6a ff		 push	 -1
  0000d	6a 01		 push	 1
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	ff b0 98 01 00
	00		 push	 DWORD PTR [eax+408]
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00021	e8 00 00 00 00	 call	 ?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z ; CSpeedTreeRT::GetGeometry

; 895  : 	
; 896  : 	if (m_pGeometryCache->m_fBranchAlphaTestValue)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  0002f	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  00034	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0003b	9f		 lahf
  0003c	f6 c4 44	 test	 ah, 68			; 00000044H
  0003f	0f 8b b2 00 00
	00		 jnp	 $LN3@RenderBran

; 897  : 	{
; 898  : 		PositionTree();

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?PositionTree@CSpeedTreeWrapper@@ABEXXZ ; CSpeedTreeWrapper::PositionTree

; 899  : 		
; 900  : 		// set alpha test value
; 901  : 		STATEMANAGER.SetRenderState(D3DRS_ALPHAREF, DWORD(m_pGeometryCache->m_fBranchAlphaTestValue));

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00056	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  0005b	e8 00 00 00 00	 call	 __ftoui3
  00060	50		 push	 eax
  00061	6a 18		 push	 24			; 00000018H
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00069	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 902  : 		
; 903  : 		// render if this LOD has branches
; 904  : 		if (m_pBranchIndexCounts && 

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00071	83 b8 a8 01 00
	00 00		 cmp	 DWORD PTR [eax+424], 0
  00078	74 7d		 je	 SHORT $LN3@RenderBran
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	8b 89 a8 01 00
	00		 mov	 ecx, DWORD PTR [ecx+424]
  0008e	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00092	85 c0		 test	 eax, eax
  00094	7e 61		 jle	 SHORT $LN3@RenderBran

; 905  : 			m_pBranchIndexCounts[m_pGeometryCache->m_sBranches.m_nDiscreteLodLevel] > 0)
; 906  : 		{
; 907  : 			ms_faceCount += m_pBranchIndexCounts[m_pGeometryCache->m_sBranches.m_nDiscreteLodLevel] - 2;

  00096	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00099	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	8b 89 a8 01 00
	00		 mov	 ecx, DWORD PTR [ecx+424]
  000aa	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_faceCount@CGraphicBase@@1KA ; CGraphicBase::ms_faceCount
  000b4	8d 44 01 fe	 lea	 eax, DWORD PTR [ecx+eax-2]
  000b8	a3 00 00 00 00	 mov	 DWORD PTR ?ms_faceCount@CGraphicBase@@1KA, eax ; CGraphicBase::ms_faceCount

; 908  : 			STATEMANAGER.DrawIndexedPrimitive(D3DPT_TRIANGLESTRIP, 0, m_pGeometryCache->m_sBranches.m_usVertexCount, 0, m_pBranchIndexCounts[m_pGeometryCache->m_sBranches.m_nDiscreteLodLevel] - 2);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  000c6	8b 00		 mov	 eax, DWORD PTR [eax]
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	8b 89 a8 01 00
	00		 mov	 ecx, DWORD PTR [ecx+424]
  000d1	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  000d5	48		 dec	 eax
  000d6	48		 dec	 eax
  000d7	50		 push	 eax
  000d8	6a 00		 push	 0
  000da	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  000e3	0f b7 40 10	 movzx	 eax, WORD PTR [eax+16]
  000e7	50		 push	 eax
  000e8	6a 00		 push	 0
  000ea	6a 05		 push	 5
  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000f2	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN3@RenderBran:

; 909  : 		}
; 910  : 	}
; 911  : }

  000f7	c9		 leave
  000f8	c3		 ret	 0
?RenderBranches@CSpeedTreeWrapper@@QBEXXZ ENDP		; CSpeedTreeWrapper::RenderBranches
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?EndLeafForTreeType@CSpeedTreeWrapper@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?EndLeafForTreeType@CSpeedTreeWrapper@@QAEXXZ PROC	; CSpeedTreeWrapper::EndLeafForTreeType, COMDAT
; _this$ = ecx

; 1178 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1179 : 	// reset copy flags for CPU wind
; 1180 : 	for (UINT i = 0; i < m_usNumLeafLods; ++i)

  00008	83 65 fc 00	 and	 DWORD PTR _i$1[ebp], 0
  0000c	eb 07		 jmp	 SHORT $LN4@EndLeafFor
$LN2@EndLeafFor:
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00011	40		 inc	 eax
  00012	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@EndLeafFor:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	0f b7 80 bc 01
	00 00		 movzx	 eax, WORD PTR [eax+444]
  0001f	39 45 fc	 cmp	 DWORD PTR _i$1[ebp], eax
  00022	73 12		 jae	 SHORT $LN1@EndLeafFor

; 1181 : 		m_pLeavesUpdatedByCpu[i] = false;

  00024	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 80 c4 01 00
	00		 mov	 eax, DWORD PTR [eax+452]
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _i$1[ebp]
  00030	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
  00034	eb d8		 jmp	 SHORT $LN2@EndLeafFor
$LN1@EndLeafFor:

; 1182 : }

  00036	c9		 leave
  00037	c3		 ret	 0
?EndLeafForTreeType@CSpeedTreeWrapper@@QAEXXZ ENDP	; CSpeedTreeWrapper::EndLeafForTreeType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?SetupLeafForTreeType@CSpeedTreeWrapper@@QBEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?SetupLeafForTreeType@CSpeedTreeWrapper@@QBEXXZ PROC	; CSpeedTreeWrapper::SetupLeafForTreeType, COMDAT
; _this$ = ecx

; 991  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 992  : #ifdef SPEEDTREE_LIGHTING_DYNAMIC
; 993  : 	// set lighting material
; 994  : 	STATEMANAGER.SetMaterial(m_cLeafMaterial.Get());
; 995  : 	SetShaderConstants(m_pSpeedTree->GetLeafMaterial());
; 996  : #endif
; 997  : 	
; 998  : 	// pass leaf tables to shader
; 999  : #ifdef WRAPPER_USE_GPU_LEAF_PLACEMENT
; 1000 : 	UploadLeafTables(c_nVertexShader_LeafTables);
; 1001 : #endif
; 1002 : 	
; 1003 : 	if (!m_CompositeImageInstance.IsEmpty())

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  00011	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	75 28		 jne	 SHORT $LN6@SetupLeafF
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00022	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1004 : 		STATEMANAGER.SetTexture(0, m_CompositeImageInstance.GetTextureReference().GetD3DTexture());

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  0002e	e8 00 00 00 00	 call	 ?GetTextureReference@CGraphicImageInstance@@QBEABVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTextureReference
  00033	8b c8		 mov	 ecx, eax
  00035	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  0003a	50		 push	 eax
  0003b	6a 00		 push	 0
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00040	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN6@SetupLeafF:

; 1005 : 	
; 1006 : 	// bind shadow texture
; 1007 : #ifdef WRAPPER_RENDER_SELF_SHADOWS
; 1008 : 	STATEMANAGER.SetTexture(1, NULL);

  00045	6a 00		 push	 0
  00047	6a 01		 push	 1
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0004f	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 1009 : #endif
; 1010 : }

  00054	c9		 leave
  00055	c3		 ret	 0
?SetupLeafForTreeType@CSpeedTreeWrapper@@QBEXXZ ENDP	; CSpeedTreeWrapper::SetupLeafForTreeType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?SetupFrondForTreeType@CSpeedTreeWrapper@@QBEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_lpd3dTexture$ = -8					; size = 4
_this$ = -4						; size = 4
?SetupFrondForTreeType@CSpeedTreeWrapper@@QBEXXZ PROC	; CSpeedTreeWrapper::SetupFrondForTreeType, COMDAT
; _this$ = ecx

; 918  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 919  : #ifdef SPEEDTREE_LIGHTING_DYNAMIC
; 920  : 	// set lighting material
; 921  : 	STATEMANAGER.SetMaterial(m_cFrondMaterial.Get());
; 922  : 	SetShaderConstants(m_pSpeedTree->GetFrondMaterial());
; 923  : #endif
; 924  : 	
; 925  : 	// update the frond geometry for CPU wind
; 926  : #ifdef WRAPPER_USE_CPU_WIND
; 927  : 	m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_FrondGeometry);
; 928  : 	if (m_pGeometryCache->m_sFronds.m_usNumStrips > 0)
; 929  : 	{
; 930  : 		// update the vertex array
; 931  : 		SFVFBranchVertex * pVertexBuffer = NULL;
; 932  : 		m_pFrondVertexBuffer->Lock(0, 0, reinterpret_cast<BYTE**>(&pVertexBuffer), D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK);
; 933  : 		for (UINT i = 0; i < m_unFrondVertexCount; ++i)
; 934  : 		{
; 935  : 			memcpy(&(pVertexBuffer[i].m_vPosition), &(m_pGeometryCache->m_sFronds.m_pCoords[i * 3]), 3 * sizeof(float));
; 936  : 		}
; 937  : 		m_pFrondVertexBuffer->Unlock();
; 938  : 	}
; 939  : #endif
; 940  : 	
; 941  : 	if (!m_CompositeImageInstance.IsEmpty())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  00012	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 28		 jne	 SHORT $LN2@SetupFrond
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00023	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 942  : 		STATEMANAGER.SetTexture(0, m_CompositeImageInstance.GetTextureReference().GetD3DTexture());

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  0002f	e8 00 00 00 00	 call	 ?GetTextureReference@CGraphicImageInstance@@QBEABVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTextureReference
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  0003b	50		 push	 eax
  0003c	6a 00		 push	 0
  0003e	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00041	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN2@SetupFrond:

; 943  : 	
; 944  : 	// bind shadow texture
; 945  : #ifdef WRAPPER_RENDER_SELF_SHADOWS
; 946  : 	LPDIRECT3DTEXTURE8 lpd3dTexture;
; 947  : 	
; 948  : 	if ((lpd3dTexture = m_ShadowImageInstance.GetTextureReference().GetD3DTexture()))

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	81 c1 d8 02 00
	00		 add	 ecx, 728		; 000002d8H
  0004f	e8 00 00 00 00	 call	 ?GetTextureReference@CGraphicImageInstance@@QBEABVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTextureReference
  00054	8b c8		 mov	 ecx, eax
  00056	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  0005b	89 45 f8	 mov	 DWORD PTR _lpd3dTexture$[ebp], eax
  0005e	83 7d f8 00	 cmp	 DWORD PTR _lpd3dTexture$[ebp], 0
  00062	74 10		 je	 SHORT $LN3@SetupFrond

; 949  : 		STATEMANAGER.SetTexture(1, lpd3dTexture);

  00064	ff 75 f8	 push	 DWORD PTR _lpd3dTexture$[ebp]
  00067	6a 01		 push	 1
  00069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0006f	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN3@SetupFrond:

; 950  : #endif
; 951  : 	
; 952  : 	if (m_pGeometryCache->m_sFronds.m_usVertexCount > 0)

  00074	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00077	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  0007d	0f b7 40 4c	 movzx	 eax, WORD PTR [eax+76]
  00081	85 c0		 test	 eax, eax
  00083	7e 2e		 jle	 SHORT $LN1@SetupFrond

; 953  : 	{
; 954  : 		// activate the frond vertex buffer
; 955  : 		STATEMANAGER.SetStreamSource(0, m_pFrondVertexBuffer, sizeof(SFVFBranchVertex));

  00085	6a 20		 push	 32			; 00000020H
  00087	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	ff b0 ac 01 00
	00		 push	 DWORD PTR [eax+428]
  00090	6a 00		 push	 0
  00092	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00098	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 956  : 		// set the index buffer
; 957  : 		STATEMANAGER.SetIndices(m_pFrondIndexBuffer, 0);

  0009d	6a 00		 push	 0
  0009f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	ff b0 b4 01 00
	00		 push	 DWORD PTR [eax+436]
  000a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ae	e8 00 00 00 00	 call	 ?SetIndices@CStateManager@@QAEXPAUIDirect3DIndexBuffer8@@I@Z ; CStateManager::SetIndices
$LN1@SetupFrond:

; 958  : 	}
; 959  : }

  000b3	c9		 leave
  000b4	c3		 ret	 0
?SetupFrondForTreeType@CSpeedTreeWrapper@@QBEXXZ ENDP	; CSpeedTreeWrapper::SetupFrondForTreeType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?SetupBranchForTreeType@CSpeedTreeWrapper@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_lpd3dTexture$ = -4					; size = 4
?SetupBranchForTreeType@CSpeedTreeWrapper@@QBEXXZ PROC	; CSpeedTreeWrapper::SetupBranchForTreeType, COMDAT
; _this$ = ecx

; 841  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 842  : #ifdef WRAPPER_USE_DYNAMIC_LIGHTING
; 843  : 	// set lighting material
; 844  : 	STATEMANAGER.SetMaterial(m_cBranchMaterial.Get());
; 845  : 	SetShaderConstants(m_pSpeedTree->GetBranchMaterial());
; 846  : #endif
; 847  : 	
; 848  : 	// update the branch geometry for CPU wind
; 849  : #ifdef WRAPPER_USE_CPU_WIND
; 850  : 	m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_BranchGeometry);
; 851  : 	
; 852  : 	if (m_pGeometryCache->m_sBranches.m_usNumStrips > 0)
; 853  : 	{
; 854  : 		// update the vertex array
; 855  : 		SFVFBranchVertex* pVertexBuffer = NULL;
; 856  : 		m_pBranchVertexBuffer->Lock(0, 0, reinterpret_cast<BYTE**>(&pVertexBuffer), D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK);
; 857  : 		for (UINT i = 0; i < m_unBranchVertexCount; ++i)
; 858  : 		{
; 859  : 			memcpy(&(pVertexBuffer[i].m_vPosition), &(m_pGeometryCache->m_sBranches.m_pCoords[i * 3]), 3 * sizeof(float));
; 860  : 		}
; 861  : 		m_pBranchVertexBuffer->Unlock();
; 862  : 	}
; 863  : #endif
; 864  : 	
; 865  : 	LPDIRECT3DTEXTURE8 lpd3dTexture;
; 866  : 	
; 867  :     // set texture map
; 868  :     if ((lpd3dTexture = m_BranchImageInstance.GetTextureReference().GetD3DTexture()))

  00008	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 b8 02 00
	00		 add	 ecx, 696		; 000002b8H
  00011	e8 00 00 00 00	 call	 ?GetTextureReference@CGraphicImageInstance@@QBEABVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTextureReference
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  0001d	89 45 fc	 mov	 DWORD PTR _lpd3dTexture$[ebp], eax
  00020	83 7d fc 00	 cmp	 DWORD PTR _lpd3dTexture$[ebp], 0
  00024	74 10		 je	 SHORT $LN2@SetupBranc

; 869  :         STATEMANAGER.SetTexture(0, lpd3dTexture);

  00026	ff 75 fc	 push	 DWORD PTR _lpd3dTexture$[ebp]
  00029	6a 00		 push	 0
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00031	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN2@SetupBranc:

; 870  : 	
; 871  : 	// bind shadow texture
; 872  : #ifdef WRAPPER_RENDER_SELF_SHADOWS
; 873  : 	if (ms_bSelfShadowOn && (lpd3dTexture = m_ShadowImageInstance.GetTextureReference().GetD3DTexture()))

  00036	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bSelfShadowOn@CSpeedTreeWrapper@@2_NA ; CSpeedTreeWrapper::ms_bSelfShadowOn
  0003d	85 c0		 test	 eax, eax
  0003f	74 30		 je	 SHORT $LN11@SetupBranc
  00041	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	81 c1 d8 02 00
	00		 add	 ecx, 728		; 000002d8H
  0004a	e8 00 00 00 00	 call	 ?GetTextureReference@CGraphicImageInstance@@QBEABVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTextureReference
  0004f	8b c8		 mov	 ecx, eax
  00051	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00056	89 45 fc	 mov	 DWORD PTR _lpd3dTexture$[ebp], eax
  00059	83 7d fc 00	 cmp	 DWORD PTR _lpd3dTexture$[ebp], 0
  0005d	74 12		 je	 SHORT $LN11@SetupBranc

; 874  : 		STATEMANAGER.SetTexture(1, lpd3dTexture);

  0005f	ff 75 fc	 push	 DWORD PTR _lpd3dTexture$[ebp]
  00062	6a 01		 push	 1
  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0006a	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
  0006f	eb 0f		 jmp	 SHORT $LN4@SetupBranc
$LN11@SetupBranc:

; 875  : 	else
; 876  : 		STATEMANAGER.SetTexture(1, NULL);

  00071	6a 00		 push	 0
  00073	6a 01		 push	 1
  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0007b	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN4@SetupBranc:

; 877  : #endif
; 878  : 	
; 879  : 	if (m_pGeometryCache->m_sBranches.m_usVertexCount > 0)

  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00089	0f b7 40 10	 movzx	 eax, WORD PTR [eax+16]
  0008d	85 c0		 test	 eax, eax
  0008f	7e 2e		 jle	 SHORT $LN1@SetupBranc

; 880  : 	{
; 881  : 		// activate the branch vertex buffer
; 882  : 		STATEMANAGER.SetStreamSource(0, m_pBranchVertexBuffer, sizeof(SFVFBranchVertex));

  00091	6a 20		 push	 32			; 00000020H
  00093	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00096	ff b0 9c 01 00
	00		 push	 DWORD PTR [eax+412]
  0009c	6a 00		 push	 0
  0009e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000a4	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 883  : 		// set the index buffer
; 884  : 		STATEMANAGER.SetIndices(m_pBranchIndexBuffer, 0);

  000a9	6a 00		 push	 0
  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	ff b0 a4 01 00
	00		 push	 DWORD PTR [eax+420]
  000b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ba	e8 00 00 00 00	 call	 ?SetIndices@CStateManager@@QAEXPAUIDirect3DIndexBuffer8@@I@Z ; CStateManager::SetIndices
$LN1@SetupBranc:

; 885  : 	}
; 886  : }

  000bf	c9		 leave
  000c0	c3		 ret	 0
?SetupBranchForTreeType@CSpeedTreeWrapper@@QBEXXZ ENDP	; CSpeedTreeWrapper::SetupBranchForTreeType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?GetCollisionObject@CSpeedTreeWrapper@@QAEXIAAW4ECollisionObjectType@CSpeedTreeRT@@PAM1@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
_eType$ = 12						; size = 4
_pPosition$ = 16					; size = 4
_pDimensions$ = 20					; size = 4
?GetCollisionObject@CSpeedTreeWrapper@@QAEXIAAW4ECollisionObjectType@CSpeedTreeRT@@PAM1@Z PROC ; CSpeedTreeWrapper::GetCollisionObject, COMDAT
; _this$ = ecx

; 1424 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1425 : 	assert(m_pSpeedTree);
; 1426 : 	m_pSpeedTree->GetCollisionObject(nIndex, eType, pPosition, pDimensions);

  00007	ff 75 14	 push	 DWORD PTR _pDimensions$[ebp]
  0000a	ff 75 10	 push	 DWORD PTR _pPosition$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR _eType$[ebp]
  00010	ff 75 08	 push	 DWORD PTR _nIndex$[ebp]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  0001c	e8 00 00 00 00	 call	 ?GetCollisionObject@CSpeedTreeRT@@QAEXIAAW4ECollisionObjectType@1@PAM1@Z ; CSpeedTreeRT::GetCollisionObject

; 1427 : }

  00021	c9		 leave
  00022	c2 10 00	 ret	 16			; 00000010H
?GetCollisionObject@CSpeedTreeWrapper@@QAEXIAAW4ECollisionObjectType@CSpeedTreeRT@@PAM1@Z ENDP ; CSpeedTreeWrapper::GetCollisionObject
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?GetCollisionObjectCount@CSpeedTreeWrapper@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCollisionObjectCount@CSpeedTreeWrapper@@QAEIXZ PROC	; CSpeedTreeWrapper::GetCollisionObjectCount, COMDAT
; _this$ = ecx

; 1418 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1419 : 	assert(m_pSpeedTree);
; 1420 : 	return m_pSpeedTree->GetCollisionObjectCount();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00010	e8 00 00 00 00	 call	 ?GetCollisionObjectCount@CSpeedTreeRT@@QAEIXZ ; CSpeedTreeRT::GetCollisionObjectCount

; 1421 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?GetCollisionObjectCount@CSpeedTreeWrapper@@QAEIXZ ENDP	; CSpeedTreeWrapper::GetCollisionObjectCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?GetTreeSize@CSpeedTreeWrapper@@QAEXAAM0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r_fSize$ = 8						; size = 4
_r_fVariance$ = 12					; size = 4
?GetTreeSize@CSpeedTreeWrapper@@QAEXAAM0@Z PROC		; CSpeedTreeWrapper::GetTreeSize, COMDAT
; _this$ = ecx

; 1436 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1437 : 	m_pSpeedTree->GetTreeSize(r_fSize, r_fVariance);

  00007	ff 75 0c	 push	 DWORD PTR _r_fVariance$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _r_fSize$[ebp]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00016	e8 00 00 00 00	 call	 ?GetTreeSize@CSpeedTreeRT@@QBEXAAM0@Z ; CSpeedTreeRT::GetTreeSize

; 1438 : }

  0001b	c9		 leave
  0001c	c2 08 00	 ret	 8
?GetTreeSize@CSpeedTreeWrapper@@QAEXAAM0@Z ENDP		; CSpeedTreeWrapper::GetTreeSize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z
_TEXT	SEGMENT
$T2 = -184						; size = 4
tv352 = -180						; size = 4
tv493 = -176						; size = 4
tv505 = -172						; size = 4
tv348 = -168						; size = 4
tv542 = -164						; size = 4
tv346 = -160						; size = 4
tv543 = -156						; size = 4
tv500 = -152						; size = 4
tv344 = -148						; size = 4
tv544 = -144						; size = 4
tv342 = -140						; size = 4
tv338 = -136						; size = 4
tv526 = -132						; size = 4
tv340 = -128						; size = 4
tv303 = -124						; size = 4
tv531 = -120						; size = 4
tv299 = -116						; size = 4
$T3 = -112						; size = 4
tv370 = -108						; size = 4
tv546 = -104						; size = 4
tv368 = -100						; size = 4
tv545 = -96						; size = 4
tv366 = -92						; size = 4
tv362 = -88						; size = 4
tv515 = -84						; size = 4
tv364 = -80						; size = 4
tv525 = -76						; size = 4
tv538 = -72						; size = 4
tv360 = -68						; size = 4
tv336 = -64						; size = 4
tv358 = -60						; size = 4
tv535 = -56						; size = 4
tv356 = -52						; size = 4
tv512 = -48						; size = 4
tv354 = -44						; size = 4
tv350 = -40						; size = 4
tv541 = -36						; size = 4
tv199 = -32						; size = 4
$T4 = -28						; size = 4
_fHeight$5 = -24					; size = 4
_bSuccess$ = -17					; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T6 = 0							; size = 24
$T7 = 24						; size = 24
$T8 = 48						; size = 24
$T9 = 72						; size = 24
$T10 = 96						; size = 24
$T11 = 120						; size = 24
$T12 = 144						; size = 24
$T13 = 168						; size = 24
$T14 = 192						; size = 24
$T15 = 216						; size = 24
$T16 = 240						; size = 24
$T17 = 264						; size = 24
$T18 = 288						; size = 24
$T19 = 312						; size = 24
$T20 = 336						; size = 24
$T21 = 360						; size = 24
$T22 = 384						; size = 24
$T23 = 408						; size = 24
__$ArrayPad$ = 432					; size = 4
_pszSptFile$ = 444					; size = 4
_c_pbBlock$ = 448					; size = 4
_uiBlockSize$ = 452					; size = 4
_nSeed$ = 456						; size = 4
_fSize$ = 460						; size = 4
_fSizeVariance$ = 464					; size = 4
?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z PROC	; CSpeedTreeWrapper::LoadTree, COMDAT
; _this$ = ecx

; 357  : {

  00000	55		 push	 ebp
  00001	8d ac 24 4c fe
	ff ff		 lea	 ebp, DWORD PTR [esp-436]
  00008	81 ec b4 01 00
	00		 sub	 esp, 436		; 000001b4H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 85 b0 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002f	56		 push	 esi
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0003d	83 a5 48 ff ff
	ff 00		 and	 DWORD PTR $T2[ebp], 0

; 358  :     bool bSuccess = false;

  00044	c6 45 ef 00	 mov	 BYTE PTR _bSuccess$[ebp], 0

; 359  : 	
; 360  : 	// directx, so allow for flipping of the texture coordinate
; 361  : #ifdef WRAPPER_FLIP_T_TEXCOORD
; 362  : 	m_pSpeedTree->SetTextureFlip(true);

  00048	6a 01		 push	 1
  0004a	e8 00 00 00 00	 call	 ?SetTextureFlip@CSpeedTreeRT@@SAX_N@Z ; CSpeedTreeRT::SetTextureFlip
  0004f	59		 pop	 ecx

; 363  : #endif
; 364  : 	
; 365  : 	// load the tree file
; 366  : 	if (!m_pSpeedTree->LoadTree(c_pbBlock, uiBlockSize))

  00050	ff b5 c4 01 00
	00		 push	 DWORD PTR _uiBlockSize$[ebp]
  00056	ff b5 c0 01 00
	00		 push	 DWORD PTR _c_pbBlock$[ebp]
  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00065	e8 00 00 00 00	 call	 ?LoadTree@CSpeedTreeRT@@QAE_NPBEI@Z ; CSpeedTreeRT::LoadTree
  0006a	0f b6 c0	 movzx	 eax, al
  0006d	85 c0		 test	 eax, eax
  0006f	75 34		 jne	 SHORT $LN3@LoadTree

; 367  : 	{
; 368  : 		if (!m_pSpeedTree->LoadTree(pszSptFile))

  00071	ff b5 bc 01 00
	00		 push	 DWORD PTR _pszSptFile$[ebp]
  00077	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00080	e8 00 00 00 00	 call	 ?LoadTree@CSpeedTreeRT@@QAE_NPBD@Z ; CSpeedTreeRT::LoadTree
  00085	0f b6 c0	 movzx	 eax, al
  00088	85 c0		 test	 eax, eax
  0008a	75 19		 jne	 SHORT $LN3@LoadTree

; 369  : 		{
; 370  : 			TraceError("SpeedTreeRT Error: %s", CSpeedTreeRT::GetCurrentError());

  0008c	e8 00 00 00 00	 call	 ?GetCurrentError@CSpeedTreeRT@@SAPBDXZ ; CSpeedTreeRT::GetCurrentError
  00091	50		 push	 eax
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FCIIGDPL@SpeedTreeRT?5Error?3?5?$CFs@
  00097	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0009c	59		 pop	 ecx
  0009d	59		 pop	 ecx

; 371  : 			return false;

  0009e	32 c0		 xor	 al, al
  000a0	e9 3e 06 00 00	 jmp	 $LN1@LoadTree
$LN3@LoadTree:

; 372  : 		}
; 373  : 	}
; 374  : 		
; 375  : 	// override the lighting method stored in the spt file
; 376  : #ifdef WRAPPER_USE_DYNAMIC_LIGHTING
; 377  : 	m_pSpeedTree->SetBranchLightingMethod(CSpeedTreeRT::LIGHT_DYNAMIC);
; 378  : 	m_pSpeedTree->SetLeafLightingMethod(CSpeedTreeRT::LIGHT_DYNAMIC);
; 379  : 	m_pSpeedTree->SetFrondLightingMethod(CSpeedTreeRT::LIGHT_DYNAMIC);
; 380  : #else
; 381  : 	m_pSpeedTree->SetBranchLightingMethod(CSpeedTreeRT::LIGHT_STATIC);

  000a5	6a 01		 push	 1
  000a7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  000b0	e8 00 00 00 00	 call	 ?SetBranchLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z ; CSpeedTreeRT::SetBranchLightingMethod

; 382  : 	m_pSpeedTree->SetLeafLightingMethod(CSpeedTreeRT::LIGHT_STATIC);

  000b5	6a 01		 push	 1
  000b7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  000c0	e8 00 00 00 00	 call	 ?SetLeafLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z ; CSpeedTreeRT::SetLeafLightingMethod

; 383  : 	m_pSpeedTree->SetFrondLightingMethod(CSpeedTreeRT::LIGHT_STATIC);

  000c5	6a 01		 push	 1
  000c7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  000d0	e8 00 00 00 00	 call	 ?SetFrondLightingMethod@CSpeedTreeRT@@QAEXW4ELightingMethod@1@@Z ; CSpeedTreeRT::SetFrondLightingMethod

; 384  : #endif
; 385  : 	
; 386  : 	// set the wind method
; 387  : #ifdef WRAPPER_USE_GPU_WIND
; 388  : 	m_pSpeedTree->SetBranchWindMethod(CSpeedTreeRT::WIND_GPU);
; 389  : 	m_pSpeedTree->SetLeafWindMethod(CSpeedTreeRT::WIND_GPU);
; 390  : 	m_pSpeedTree->SetFrondWindMethod(CSpeedTreeRT::WIND_GPU);
; 391  : #endif
; 392  : #ifdef WRAPPER_USE_CPU_WIND
; 393  : 	m_pSpeedTree->SetBranchWindMethod(CSpeedTreeRT::WIND_CPU);
; 394  : 	m_pSpeedTree->SetLeafWindMethod(CSpeedTreeRT::WIND_CPU);
; 395  : 	m_pSpeedTree->SetFrondWindMethod(CSpeedTreeRT::WIND_CPU);
; 396  : #endif
; 397  : #ifdef WRAPPER_USE_NO_WIND
; 398  : 	m_pSpeedTree->SetBranchWindMethod(CSpeedTreeRT::WIND_NONE);

  000d5	6a 02		 push	 2
  000d7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  000e0	e8 00 00 00 00	 call	 ?SetBranchWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z ; CSpeedTreeRT::SetBranchWindMethod

; 399  : 	m_pSpeedTree->SetLeafWindMethod(CSpeedTreeRT::WIND_NONE);

  000e5	6a 02		 push	 2
  000e7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ea	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  000f0	e8 00 00 00 00	 call	 ?SetLeafWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z ; CSpeedTreeRT::SetLeafWindMethod

; 400  : 	m_pSpeedTree->SetFrondWindMethod(CSpeedTreeRT::WIND_NONE);

  000f5	6a 02		 push	 2
  000f7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00100	e8 00 00 00 00	 call	 ?SetFrondWindMethod@CSpeedTreeRT@@QAEXW4EWindMethod@1@@Z ; CSpeedTreeRT::SetFrondWindMethod

; 401  : #endif
; 402  : 	
; 403  : 	m_pSpeedTree->SetNumLeafRockingGroups(1);

  00105	6a 01		 push	 1
  00107	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0010a	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00110	e8 00 00 00 00	 call	 ?SetNumLeafRockingGroups@CSpeedTreeRT@@QAEXI@Z ; CSpeedTreeRT::SetNumLeafRockingGroups

; 404  : 	
; 405  : 	// override the size, if necessary
; 406  : 	if (fSize >= 0.0f && fSizeVariance >= 0.0f)

  00115	f3 0f 10 85 cc
	01 00 00	 movss	 xmm0, DWORD PTR _fSize$[ebp]
  0011d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00124	72 3b		 jb	 SHORT $LN4@LoadTree
  00126	f3 0f 10 85 d0
	01 00 00	 movss	 xmm0, DWORD PTR _fSizeVariance$[ebp]
  0012e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00135	72 2a		 jb	 SHORT $LN4@LoadTree

; 407  : 		m_pSpeedTree->SetTreeSize(fSize, fSizeVariance);

  00137	51		 push	 ecx
  00138	f3 0f 10 85 d0
	01 00 00	 movss	 xmm0, DWORD PTR _fSizeVariance$[ebp]
  00140	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00145	51		 push	 ecx
  00146	f3 0f 10 85 cc
	01 00 00	 movss	 xmm0, DWORD PTR _fSize$[ebp]
  0014e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00153	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00156	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  0015c	e8 00 00 00 00	 call	 ?SetTreeSize@CSpeedTreeRT@@QAEXMM@Z ; CSpeedTreeRT::SetTreeSize
$LN4@LoadTree:

; 408  : 	
; 409  : 	// generate tree geometry
; 410  : 	if (m_pSpeedTree->Compute(NULL, nSeed))

  00161	6a 01		 push	 1
  00163	ff b5 c8 01 00
	00		 push	 DWORD PTR _nSeed$[ebp]
  00169	6a 00		 push	 0
  0016b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0016e	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00174	e8 00 00 00 00	 call	 ?Compute@CSpeedTreeRT@@QAE_NPBMI_N@Z ; CSpeedTreeRT::Compute
  00179	0f b6 c0	 movzx	 eax, al
  0017c	85 c0		 test	 eax, eax
  0017e	0f 84 40 05 00
	00		 je	 $LN5@LoadTree

; 411  : 	{
; 412  : 		// get the dimensions
; 413  : 		m_pSpeedTree->GetBoundingBox(m_afBoundingBox);

  00184	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00187	05 d4 01 00 00	 add	 eax, 468		; 000001d4H
  0018c	50		 push	 eax
  0018d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00190	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00196	e8 00 00 00 00	 call	 ?GetBoundingBox@CSpeedTreeRT@@QBEXPAM@Z ; CSpeedTreeRT::GetBoundingBox

; 414  : 		
; 415  : 		// make the leaves rock in the wind
; 416  : 		m_pSpeedTree->SetLeafRockingState(true);

  0019b	6a 01		 push	 1
  0019d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001a0	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  001a6	e8 00 00 00 00	 call	 ?SetLeafRockingState@CSpeedTreeRT@@QAEX_N@Z ; CSpeedTreeRT::SetLeafRockingState

; 417  : 		
; 418  : 		// billboard setup
; 419  : #ifdef WRAPPER_NO_BILLBOARD_MODE
; 420  : 		CSpeedTreeRT::SetDropToBillboard(false);
; 421  : #else
; 422  : 		CSpeedTreeRT::SetDropToBillboard(true);

  001ab	6a 01		 push	 1
  001ad	e8 00 00 00 00	 call	 ?SetDropToBillboard@CSpeedTreeRT@@SAX_N@Z ; CSpeedTreeRT::SetDropToBillboard
  001b2	59		 pop	 ecx

; 423  : #endif
; 424  : 		
; 425  : 		// query & set materials
; 426  : 		m_cBranchMaterial.Set(m_pSpeedTree->GetBranchMaterial());

  001b3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001b6	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  001bc	e8 00 00 00 00	 call	 ?GetBranchMaterial@CSpeedTreeRT@@QBEPBMXZ ; CSpeedTreeRT::GetBranchMaterial
  001c1	50		 push	 eax
  001c2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001c5	81 c1 ec 01 00
	00		 add	 ecx, 492		; 000001ecH
  001cb	e8 00 00 00 00	 call	 ?Set@CSpeedTreeMaterial@@QAEXPBM@Z ; CSpeedTreeMaterial::Set

; 427  : 		m_cFrondMaterial.Set(m_pSpeedTree->GetFrondMaterial());

  001d0	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001d3	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  001d9	e8 00 00 00 00	 call	 ?GetFrondMaterial@CSpeedTreeRT@@QBEPBMXZ ; CSpeedTreeRT::GetFrondMaterial
  001de	50		 push	 eax
  001df	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e2	81 c1 74 02 00
	00		 add	 ecx, 628		; 00000274H
  001e8	e8 00 00 00 00	 call	 ?Set@CSpeedTreeMaterial@@QAEXPBM@Z ; CSpeedTreeMaterial::Set

; 428  : 		m_cLeafMaterial.Set(m_pSpeedTree->GetLeafMaterial());

  001ed	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001f0	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  001f6	e8 00 00 00 00	 call	 ?GetLeafMaterial@CSpeedTreeRT@@QBEPBMXZ ; CSpeedTreeRT::GetLeafMaterial
  001fb	50		 push	 eax
  001fc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ff	81 c1 30 02 00
	00		 add	 ecx, 560		; 00000230H
  00205	e8 00 00 00 00	 call	 ?Set@CSpeedTreeMaterial@@QAEXPBM@Z ; CSpeedTreeMaterial::Set

; 429  : 		
; 430  : 		// adjust lod distances
; 431  : 		float fHeight = m_afBoundingBox[5] - m_afBoundingBox[2];

  0020a	6a 04		 push	 4
  0020c	58		 pop	 eax
  0020d	6b c0 05	 imul	 eax, eax, 5
  00210	6a 04		 push	 4
  00212	59		 pop	 ecx
  00213	d1 e1		 shl	 ecx, 1
  00215	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00218	8b 75 f0	 mov	 esi, DWORD PTR _this$[ebp]
  0021b	f3 0f 10 84 02
	d4 01 00 00	 movss	 xmm0, DWORD PTR [edx+eax+468]
  00224	f3 0f 5c 84 0e
	d4 01 00 00	 subss	 xmm0, DWORD PTR [esi+ecx+468]
  0022d	f3 0f 11 45 e8	 movss	 DWORD PTR _fHeight$5[ebp], xmm0

; 432  : 		m_pSpeedTree->SetLodLimits(fHeight * c_fNearLodFactor, fHeight * c_fFarLodFactor);

  00232	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fHeight$5[ebp]
  00237	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41100000
  0023f	51		 push	 ecx
  00240	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00245	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fHeight$5[ebp]
  0024a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00252	51		 push	 ecx
  00253	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00258	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0025b	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00261	e8 00 00 00 00	 call	 ?SetLodLimits@CSpeedTreeRT@@QAEXMM@Z ; CSpeedTreeRT::SetLodLimits

; 433  : 		
; 434  : 		// query textures
; 435  : 		m_pTextureInfo = new CSpeedTreeRT::STextures;

  00266	6a 1c		 push	 28			; 0000001cH
  00268	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0026d	59		 pop	 ecx
  0026e	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
  00271	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00275	83 7d e4 00	 cmp	 DWORD PTR $T4[ebp], 0
  00279	74 0d		 je	 SHORT $LN10@LoadTree
  0027b	8b 4d e4	 mov	 ecx, DWORD PTR $T4[ebp]
  0027e	e8 00 00 00 00	 call	 ??0STextures@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::STextures::STextures
  00283	89 45 e0	 mov	 DWORD PTR tv199[ebp], eax
  00286	eb 04		 jmp	 SHORT $LN11@LoadTree
$LN10@LoadTree:
  00288	83 65 e0 00	 and	 DWORD PTR tv199[ebp], 0
$LN11@LoadTree:
  0028c	8b 45 e0	 mov	 eax, DWORD PTR tv199[ebp]
  0028f	89 45 90	 mov	 DWORD PTR $T3[ebp], eax
  00292	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00296	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00299	8b 4d 90	 mov	 ecx, DWORD PTR $T3[ebp]
  0029c	89 88 80 01 00
	00		 mov	 DWORD PTR [eax+384], ecx

; 436  : 		m_pSpeedTree->GetTextures(*m_pTextureInfo);

  002a2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002a5	ff b0 80 01 00
	00		 push	 DWORD PTR [eax+384]
  002ab	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002ae	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  002b4	e8 00 00 00 00	 call	 ?GetTextures@CSpeedTreeRT@@QBEXAAUSTextures@1@@Z ; CSpeedTreeRT::GetTextures

; 439  : 		LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pBranchTextureFilename)) + ".dds").c_str(), m_BranchImageInstance);

  002b9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002bc	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]
  002c2	ff 30		 push	 DWORD PTR [eax]
  002c4	8d 8d 08 01 00
	00		 lea	 ecx, DWORD PTR $T17[ebp]
  002ca	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002cf	89 45 8c	 mov	 DWORD PTR tv299[ebp], eax
  002d2	8b 45 8c	 mov	 eax, DWORD PTR tv299[ebp]
  002d5	89 45 c0	 mov	 DWORD PTR tv336[ebp], eax
  002d8	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  002df	ff 75 c0	 push	 DWORD PTR tv336[ebp]
  002e2	8d 85 20 01 00
	00		 lea	 eax, DWORD PTR $T18[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 ?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; CFileNameHelper::NoExtension
  002ee	59		 pop	 ecx
  002ef	59		 pop	 ecx
  002f0	89 45 88	 mov	 DWORD PTR tv531[ebp], eax
  002f3	8b 45 88	 mov	 eax, DWORD PTR tv531[ebp]
  002f6	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv338[ebp], eax
  002fc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00300	ff b5 bc 01 00
	00		 push	 DWORD PTR _pszSptFile$[ebp]
  00306	8d 8d 38 01 00
	00		 lea	 ecx, DWORD PTR $T19[ebp]
  0030c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00311	89 45 84	 mov	 DWORD PTR tv303[ebp], eax
  00314	8b 45 84	 mov	 eax, DWORD PTR tv303[ebp]
  00317	89 45 80	 mov	 DWORD PTR tv340[ebp], eax
  0031a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0031e	ff 75 80	 push	 DWORD PTR tv340[ebp]
  00321	8d 85 50 01 00
	00		 lea	 eax, DWORD PTR $T20[ebp]
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ?GetPath@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; CFileNameHelper::GetPath
  0032d	59		 pop	 ecx
  0032e	59		 pop	 ecx
  0032f	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv526[ebp], eax
  00335	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv526[ebp]
  0033b	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv342[ebp], eax
  00341	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00345	ff b5 78 ff ff
	ff		 push	 DWORD PTR tv338[ebp]
  0034b	ff b5 74 ff ff
	ff		 push	 DWORD PTR tv342[ebp]
  00351	8d 85 68 01 00
	00		 lea	 eax, DWORD PTR $T21[ebp]
  00357	50		 push	 eax
  00358	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0035d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00360	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv544[ebp], eax
  00366	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv544[ebp]
  0036c	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv344[ebp], eax
  00372	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00376	68 00 00 00 00	 push	 OFFSET ??_C@_04LIKELABK@?4dds@
  0037b	ff b5 6c ff ff
	ff		 push	 DWORD PTR tv344[ebp]
  00381	8d 85 80 01 00
	00		 lea	 eax, DWORD PTR $T22[ebp]
  00387	50		 push	 eax
  00388	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0038d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00390	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv543[ebp], eax
  00396	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv543[ebp]
  0039c	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv346[ebp], eax
  003a2	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  003a6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  003a9	05 b8 02 00 00	 add	 eax, 696		; 000002b8H
  003ae	50		 push	 eax
  003af	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv346[ebp]
  003b5	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  003ba	50		 push	 eax
  003bb	e8 00 00 00 00	 call	 ?LoadTexture@CSpeedTreeWrapper@@CA_NPBDAAVCGraphicImageInstance@@@Z ; CSpeedTreeWrapper::LoadTexture
  003c0	59		 pop	 ecx
  003c1	59		 pop	 ecx
  003c2	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  003c6	8d 8d 80 01 00
	00		 lea	 ecx, DWORD PTR $T22[ebp]
  003cc	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 439  : 		LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pBranchTextureFilename)) + ".dds").c_str(), m_BranchImageInstance);

  003d1	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  003d5	8d 8d 68 01 00
	00		 lea	 ecx, DWORD PTR $T21[ebp]
  003db	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 439  : 		LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pBranchTextureFilename)) + ".dds").c_str(), m_BranchImageInstance);

  003e0	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  003e4	8d 8d 50 01 00
	00		 lea	 ecx, DWORD PTR $T20[ebp]
  003ea	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 439  : 		LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pBranchTextureFilename)) + ".dds").c_str(), m_BranchImageInstance);

  003ef	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  003f3	8d 8d 38 01 00
	00		 lea	 ecx, DWORD PTR $T19[ebp]
  003f9	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 439  : 		LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pBranchTextureFilename)) + ".dds").c_str(), m_BranchImageInstance);

  003fe	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00402	8d 8d 20 01 00
	00		 lea	 ecx, DWORD PTR $T18[ebp]
  00408	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 439  : 		LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pBranchTextureFilename)) + ".dds").c_str(), m_BranchImageInstance);

  0040d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00411	8d 8d 08 01 00
	00		 lea	 ecx, DWORD PTR $T17[ebp]
  00417	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 442  : 		if (m_pTextureInfo->m_pSelfShadowFilename != NULL)

  0041c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0041f	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]
  00425	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00429	0f 84 58 01 00
	00		 je	 $LN316@LoadTree

; 443  : 			LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pSelfShadowFilename)) + ".dds").c_str(), m_ShadowImageInstance);

  0042f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00432	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]
  00438	ff 70 18	 push	 DWORD PTR [eax+24]
  0043b	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR $T12[ebp]
  00441	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00446	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv542[ebp], eax
  0044c	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv542[ebp]
  00452	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv348[ebp], eax
  00458	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7
  0045f	ff b5 58 ff ff
	ff		 push	 DWORD PTR tv348[ebp]
  00465	8d 85 98 01 00
	00		 lea	 eax, DWORD PTR $T23[ebp]
  0046b	50		 push	 eax
  0046c	e8 00 00 00 00	 call	 ?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; CFileNameHelper::NoExtension
  00471	59		 pop	 ecx
  00472	59		 pop	 ecx
  00473	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv505[ebp], eax
  00479	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv505[ebp]
  0047f	89 45 d8	 mov	 DWORD PTR tv350[ebp], eax
  00482	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00486	ff b5 bc 01 00
	00		 push	 DWORD PTR _pszSptFile$[ebp]
  0048c	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR $T13[ebp]
  00492	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00497	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv493[ebp], eax
  0049d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv493[ebp]
  004a3	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv352[ebp], eax
  004a9	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  004ad	ff b5 4c ff ff
	ff		 push	 DWORD PTR tv352[ebp]
  004b3	8d 85 c0 00 00
	00		 lea	 eax, DWORD PTR $T14[ebp]
  004b9	50		 push	 eax
  004ba	e8 00 00 00 00	 call	 ?GetPath@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; CFileNameHelper::GetPath
  004bf	59		 pop	 ecx
  004c0	59		 pop	 ecx
  004c1	89 45 dc	 mov	 DWORD PTR tv541[ebp], eax
  004c4	8b 45 dc	 mov	 eax, DWORD PTR tv541[ebp]
  004c7	89 45 d4	 mov	 DWORD PTR tv354[ebp], eax
  004ca	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  004ce	ff 75 d8	 push	 DWORD PTR tv350[ebp]
  004d1	ff 75 d4	 push	 DWORD PTR tv354[ebp]
  004d4	8d 85 d8 00 00
	00		 lea	 eax, DWORD PTR $T15[ebp]
  004da	50		 push	 eax
  004db	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  004e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  004e3	89 45 d0	 mov	 DWORD PTR tv512[ebp], eax
  004e6	8b 45 d0	 mov	 eax, DWORD PTR tv512[ebp]
  004e9	89 45 cc	 mov	 DWORD PTR tv356[ebp], eax
  004ec	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  004f0	68 00 00 00 00	 push	 OFFSET ??_C@_04LIKELABK@?4dds@
  004f5	ff 75 cc	 push	 DWORD PTR tv356[ebp]
  004f8	8d 85 f0 00 00
	00		 lea	 eax, DWORD PTR $T16[ebp]
  004fe	50		 push	 eax
  004ff	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00504	83 c4 0c	 add	 esp, 12			; 0000000cH
  00507	89 45 c8	 mov	 DWORD PTR tv535[ebp], eax
  0050a	8b 45 c8	 mov	 eax, DWORD PTR tv535[ebp]
  0050d	89 45 c4	 mov	 DWORD PTR tv358[ebp], eax
  00510	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00514	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00517	05 d8 02 00 00	 add	 eax, 728		; 000002d8H
  0051c	50		 push	 eax
  0051d	8b 4d c4	 mov	 ecx, DWORD PTR tv358[ebp]
  00520	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00525	50		 push	 eax
  00526	e8 00 00 00 00	 call	 ?LoadTexture@CSpeedTreeWrapper@@CA_NPBDAAVCGraphicImageInstance@@@Z ; CSpeedTreeWrapper::LoadTexture
  0052b	59		 pop	 ecx
  0052c	59		 pop	 ecx
  0052d	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00531	8d 8d f0 00 00
	00		 lea	 ecx, DWORD PTR $T16[ebp]
  00537	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 443  : 			LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pSelfShadowFilename)) + ".dds").c_str(), m_ShadowImageInstance);

  0053c	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00540	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR $T15[ebp]
  00546	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 443  : 			LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pSelfShadowFilename)) + ".dds").c_str(), m_ShadowImageInstance);

  0054b	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0054f	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR $T14[ebp]
  00555	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 443  : 			LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pSelfShadowFilename)) + ".dds").c_str(), m_ShadowImageInstance);

  0055a	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0055e	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR $T13[ebp]
  00564	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 443  : 			LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pSelfShadowFilename)) + ".dds").c_str(), m_ShadowImageInstance);

  00569	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0056d	8d 8d 98 01 00
	00		 lea	 ecx, DWORD PTR $T23[ebp]
  00573	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 443  : 			LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pSelfShadowFilename)) + ".dds").c_str(), m_ShadowImageInstance);

  00578	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0057c	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR $T12[ebp]
  00582	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN316@LoadTree:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 445  : 		if (m_pTextureInfo->m_pCompositeFilename)

  00587	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0058a	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]
  00590	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00594	0f 84 1c 01 00
	00		 je	 $LN460@LoadTree

; 446  : 			LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pCompositeFilename)) + ".dds").c_str(), m_CompositeImageInstance);

  0059a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0059d	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]
  005a3	ff 70 14	 push	 DWORD PTR [eax+20]
  005a6	8d 4d 00	 lea	 ecx, DWORD PTR $T6[ebp]
  005a9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  005ae	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv500[ebp], eax
  005b4	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv500[ebp]
  005ba	89 45 bc	 mov	 DWORD PTR tv360[ebp], eax
  005bd	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  005c4	ff 75 bc	 push	 DWORD PTR tv360[ebp]
  005c7	8d 45 18	 lea	 eax, DWORD PTR $T7[ebp]
  005ca	50		 push	 eax
  005cb	e8 00 00 00 00	 call	 ?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; CFileNameHelper::NoExtension
  005d0	59		 pop	 ecx
  005d1	59		 pop	 ecx
  005d2	89 45 b8	 mov	 DWORD PTR tv538[ebp], eax
  005d5	8b 45 b8	 mov	 eax, DWORD PTR tv538[ebp]
  005d8	89 45 a8	 mov	 DWORD PTR tv362[ebp], eax
  005db	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  005df	ff b5 bc 01 00
	00		 push	 DWORD PTR _pszSptFile$[ebp]
  005e5	8d 4d 30	 lea	 ecx, DWORD PTR $T8[ebp]
  005e8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  005ed	89 45 b4	 mov	 DWORD PTR tv525[ebp], eax
  005f0	8b 45 b4	 mov	 eax, DWORD PTR tv525[ebp]
  005f3	89 45 b0	 mov	 DWORD PTR tv364[ebp], eax
  005f6	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  005fa	ff 75 b0	 push	 DWORD PTR tv364[ebp]
  005fd	8d 45 48	 lea	 eax, DWORD PTR $T9[ebp]
  00600	50		 push	 eax
  00601	e8 00 00 00 00	 call	 ?GetPath@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; CFileNameHelper::GetPath
  00606	59		 pop	 ecx
  00607	59		 pop	 ecx
  00608	89 45 ac	 mov	 DWORD PTR tv515[ebp], eax
  0060b	8b 45 ac	 mov	 eax, DWORD PTR tv515[ebp]
  0060e	89 45 a4	 mov	 DWORD PTR tv366[ebp], eax
  00611	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  00615	ff 75 a8	 push	 DWORD PTR tv362[ebp]
  00618	ff 75 a4	 push	 DWORD PTR tv366[ebp]
  0061b	8d 45 60	 lea	 eax, DWORD PTR $T10[ebp]
  0061e	50		 push	 eax
  0061f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00624	83 c4 0c	 add	 esp, 12			; 0000000cH
  00627	89 45 a0	 mov	 DWORD PTR tv545[ebp], eax
  0062a	8b 45 a0	 mov	 eax, DWORD PTR tv545[ebp]
  0062d	89 45 9c	 mov	 DWORD PTR tv368[ebp], eax
  00630	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  00634	68 00 00 00 00	 push	 OFFSET ??_C@_04LIKELABK@?4dds@
  00639	ff 75 9c	 push	 DWORD PTR tv368[ebp]
  0063c	8d 45 78	 lea	 eax, DWORD PTR $T11[ebp]
  0063f	50		 push	 eax
  00640	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00645	83 c4 0c	 add	 esp, 12			; 0000000cH
  00648	89 45 98	 mov	 DWORD PTR tv546[ebp], eax
  0064b	8b 45 98	 mov	 eax, DWORD PTR tv546[ebp]
  0064e	89 45 94	 mov	 DWORD PTR tv370[ebp], eax
  00651	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  00655	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00658	05 f8 02 00 00	 add	 eax, 760		; 000002f8H
  0065d	50		 push	 eax
  0065e	8b 4d 94	 mov	 ecx, DWORD PTR tv370[ebp]
  00661	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00666	50		 push	 eax
  00667	e8 00 00 00 00	 call	 ?LoadTexture@CSpeedTreeWrapper@@CA_NPBDAAVCGraphicImageInstance@@@Z ; CSpeedTreeWrapper::LoadTexture
  0066c	59		 pop	 ecx
  0066d	59		 pop	 ecx
  0066e	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00672	8d 4d 78	 lea	 ecx, DWORD PTR $T11[ebp]
  00675	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 446  : 			LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pCompositeFilename)) + ".dds").c_str(), m_CompositeImageInstance);

  0067a	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0067e	8d 4d 60	 lea	 ecx, DWORD PTR $T10[ebp]
  00681	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 446  : 			LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pCompositeFilename)) + ".dds").c_str(), m_CompositeImageInstance);

  00686	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0068a	8d 4d 48	 lea	 ecx, DWORD PTR $T9[ebp]
  0068d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 446  : 			LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pCompositeFilename)) + ".dds").c_str(), m_CompositeImageInstance);

  00692	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00696	8d 4d 30	 lea	 ecx, DWORD PTR $T8[ebp]
  00699	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 446  : 			LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pCompositeFilename)) + ".dds").c_str(), m_CompositeImageInstance);

  0069e	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  006a2	8d 4d 18	 lea	 ecx, DWORD PTR $T7[ebp]
  006a5	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 446  : 			LoadTexture((CFileNameHelper::GetPath(string(pszSptFile)) + CFileNameHelper::NoExtension(string(m_pTextureInfo->m_pCompositeFilename)) + ".dds").c_str(), m_CompositeImageInstance);

  006aa	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  006ae	8d 4d 00	 lea	 ecx, DWORD PTR $T6[ebp]
  006b1	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN460@LoadTree:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 449  : 		SetupBuffers();

  006b6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  006b9	e8 00 00 00 00	 call	 ?SetupBuffers@CSpeedTreeWrapper@@AAEXXZ ; CSpeedTreeWrapper::SetupBuffers

; 450  : 		
; 451  : 		// everything appeared to go well
; 452  : 		bSuccess = true;

  006be	c6 45 ef 01	 mov	 BYTE PTR _bSuccess$[ebp], 1

; 453  : 	}

  006c2	eb 1c		 jmp	 SHORT $LN6@LoadTree
$LN5@LoadTree:

; 454  : 	else // tree failed to compute
; 455  : 		fprintf(stderr, "\nFatal Error, cannot compute tree [%s]\n\n", CSpeedTreeRT::GetCurrentError());

  006c4	e8 00 00 00 00	 call	 ?GetCurrentError@CSpeedTreeRT@@SAPBDXZ ; CSpeedTreeRT::GetCurrentError
  006c9	50		 push	 eax
  006ca	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@CEEBAJFC@?6Fatal?5Error?0?5cannot?5compute?5tr@
  006cf	6a 02		 push	 2
  006d1	e8 00 00 00 00	 call	 ___acrt_iob_func
  006d6	59		 pop	 ecx
  006d7	50		 push	 eax
  006d8	e8 00 00 00 00	 call	 _fprintf
  006dd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@LoadTree:

; 456  : 	
; 457  :     return bSuccess;

  006e0	8a 45 ef	 mov	 al, BYTE PTR _bSuccess$[ebp]
$LN1@LoadTree:

; 458  : }

  006e3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006e6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006ed	59		 pop	 ecx
  006ee	5e		 pop	 esi
  006ef	8b 8d b0 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006f5	33 cd		 xor	 ecx, ebp
  006f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006fc	81 c5 b4 01 00
	00		 add	 ebp, 436		; 000001b4H
  00702	c9		 leave
  00703	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$0:
  00000	6a 1c		 push	 28			; 0000001cH
  00002	ff 75 e4	 push	 DWORD PTR $T4[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$1:
  0000d	8d 8d 08 01 00
	00		 lea	 ecx, DWORD PTR $T17[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$2:
  00018	8d 8d 20 01 00
	00		 lea	 ecx, DWORD PTR $T18[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$3:
  00023	8d 8d 38 01 00
	00		 lea	 ecx, DWORD PTR $T19[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$4:
  0002e	8d 8d 50 01 00
	00		 lea	 ecx, DWORD PTR $T20[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$5:
  00039	8d 8d 68 01 00
	00		 lea	 ecx, DWORD PTR $T21[ebp]
  0003f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$6:
  00044	8d 8d 80 01 00
	00		 lea	 ecx, DWORD PTR $T22[ebp]
  0004a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$7:
  0004f	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR $T12[ebp]
  00055	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$8:
  0005a	8d 8d 98 01 00
	00		 lea	 ecx, DWORD PTR $T23[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$9:
  00065	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR $T13[ebp]
  0006b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$10:
  00070	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR $T14[ebp]
  00076	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$11:
  0007b	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR $T15[ebp]
  00081	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$12:
  00086	8d 8d f0 00 00
	00		 lea	 ecx, DWORD PTR $T16[ebp]
  0008c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$13:
  00091	8d 4d 00	 lea	 ecx, DWORD PTR $T6[ebp]
  00094	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$14:
  00099	8d 4d 18	 lea	 ecx, DWORD PTR $T7[ebp]
  0009c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$15:
  000a1	8d 4d 30	 lea	 ecx, DWORD PTR $T8[ebp]
  000a4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$16:
  000a9	8d 4d 48	 lea	 ecx, DWORD PTR $T9[ebp]
  000ac	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$17:
  000b1	8d 4d 60	 lea	 ecx, DWORD PTR $T10[ebp]
  000b4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z$18:
  000b9	8d 4d 78	 lea	 ecx, DWORD PTR $T11[ebp]
  000bc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000c1	cc		 int	 3
  000c2	cc		 int	 3
  000c3	cc		 int	 3
  000c4	cc		 int	 3
  000c5	cc		 int	 3
__ehhandler$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z:
  000c6	90		 npad	 1
  000c7	90		 npad	 1
  000c8	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000cc	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000cf	8b 8a 4c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-180]
  000d5	33 c8		 xor	 ecx, eax
  000d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dc	8b 8a bc 01 00
	00		 mov	 ecx, DWORD PTR [edx+444]
  000e2	33 c8		 xor	 ecx, eax
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z
  000ee	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadTree@CSpeedTreeWrapper@@QAE_NPBDPBEIIMM@Z ENDP	; CSpeedTreeWrapper::LoadTree
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?SetVertexShaders@CSpeedTreeWrapper@@SAXKK@Z
_TEXT	SEGMENT
_dwBranchVertexShader$ = 8				; size = 4
_dwLeafVertexShader$ = 12				; size = 4
?SetVertexShaders@CSpeedTreeWrapper@@SAXKK@Z PROC	; CSpeedTreeWrapper::SetVertexShaders, COMDAT

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   : 	ms_dwBranchVertexShader = dwBranchVertexShader;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwBranchVertexShader$[ebp]
  00006	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwBranchVertexShader@CSpeedTreeWrapper@@0KA, eax ; CSpeedTreeWrapper::ms_dwBranchVertexShader

; 87   : 	ms_dwLeafVertexShader = dwLeafVertexShader;

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _dwLeafVertexShader$[ebp]
  0000e	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwLeafVertexShader@CSpeedTreeWrapper@@0KA, eax ; CSpeedTreeWrapper::ms_dwLeafVertexShader

; 88   : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?SetVertexShaders@CSpeedTreeWrapper@@SAXKK@Z ENDP	; CSpeedTreeWrapper::SetVertexShaders
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?GetPosition@CSpeedTreeWrapper@@QAEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPosition@CSpeedTreeWrapper@@QAEPBMXZ PROC		; CSpeedTreeWrapper::GetPosition, COMDAT
; _this$ = ecx

; 1431 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1432 : 	return m_afPos;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	05 c8 01 00 00	 add	 eax, 456		; 000001c8H

; 1433 : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?GetPosition@CSpeedTreeWrapper@@QAEPBMXZ ENDP		; CSpeedTreeWrapper::GetPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ??1CSpeedTreeWrapper@@UAE@XZ
_TEXT	SEGMENT
$T2 = -68						; size = 4
$T3 = -64						; size = 4
tv266 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
tv257 = -36						; size = 4
tv248 = -32						; size = 4
$T9 = -28						; size = 4
$T10 = -24						; size = 4
_i$11 = -20						; size = 2
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CSpeedTreeWrapper@@UAE@XZ PROC			; CSpeedTreeWrapper::~CSpeedTreeWrapper, COMDAT
; _this$ = ecx

; 313  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CSpeedTreeWrapper@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CSpeedTreeWrapper@@6B@

; 314  : 	// if this is not an instance, clean up
; 315  : 	if (!m_bIsInstance)

  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	0f b6 80 84 01
	00 00		 movzx	 eax, BYTE PTR [eax+388]
  0003b	85 c0		 test	 eax, eax
  0003d	0f 85 db 02 00
	00		 jne	 $LN5@CSpeedTree

; 316  : 	{
; 317  : 		if (m_unBranchVertexCount > 0)

  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 b8 a0 01 00
	00 00		 cmp	 DWORD PTR [eax+416], 0
  0004d	0f 86 85 00 00
	00		 jbe	 $LN6@CSpeedTree

; 318  : 		{
; 319  : 			SAFE_RELEASE(m_pBranchVertexBuffer);

  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	83 b8 9c 01 00
	00 00		 cmp	 DWORD PTR [eax+412], 0
  0005d	74 21		 je	 SHORT $LN7@CSpeedTree
  0005f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 80 9c 01 00
	00		 mov	 eax, DWORD PTR [eax+412]
  00068	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	ff b1 9c 01 00
	00		 push	 DWORD PTR [ecx+412]
  00073	ff 50 08	 call	 DWORD PTR [eax+8]
  00076	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00079	83 a0 9c 01 00
	00 00		 and	 DWORD PTR [eax+412], 0
$LN7@CSpeedTree:

; 320  : 			SAFE_RELEASE(m_pBranchIndexBuffer);

  00080	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 b8 a4 01 00
	00 00		 cmp	 DWORD PTR [eax+420], 0
  0008a	74 21		 je	 SHORT $LN8@CSpeedTree
  0008c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	8b 80 a4 01 00
	00		 mov	 eax, DWORD PTR [eax+420]
  00095	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	8b 00		 mov	 eax, DWORD PTR [eax]
  0009a	ff b1 a4 01 00
	00		 push	 DWORD PTR [ecx+420]
  000a0	ff 50 08	 call	 DWORD PTR [eax+8]
  000a3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	83 a0 a4 01 00
	00 00		 and	 DWORD PTR [eax+420], 0
$LN8@CSpeedTree:

; 321  : 			SAFE_DELETE_ARRAY(m_pBranchIndexCounts);

  000ad	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	83 b8 a8 01 00
	00 00		 cmp	 DWORD PTR [eax+424], 0
  000b7	74 1f		 je	 SHORT $LN6@CSpeedTree
  000b9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	8b 80 a8 01 00
	00		 mov	 eax, DWORD PTR [eax+424]
  000c2	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
  000c5	ff 75 d4	 push	 DWORD PTR $T7[ebp]
  000c8	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000cd	59		 pop	 ecx
  000ce	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	83 a0 a8 01 00
	00 00		 and	 DWORD PTR [eax+424], 0
$LN6@CSpeedTree:

; 322  : 		}
; 323  : 		
; 324  : 		if (m_unFrondVertexCount > 0)

  000d8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000db	83 b8 b0 01 00
	00 00		 cmp	 DWORD PTR [eax+432], 0
  000e2	0f 86 85 00 00
	00		 jbe	 $LN10@CSpeedTree

; 325  : 		{	
; 326  : 			SAFE_RELEASE(m_pFrondVertexBuffer);

  000e8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [eax+428], 0
  000f2	74 21		 je	 SHORT $LN11@CSpeedTree
  000f4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [eax+428]
  000fd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	8b 00		 mov	 eax, DWORD PTR [eax]
  00102	ff b1 ac 01 00
	00		 push	 DWORD PTR [ecx+428]
  00108	ff 50 08	 call	 DWORD PTR [eax+8]
  0010b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0010e	83 a0 ac 01 00
	00 00		 and	 DWORD PTR [eax+428], 0
$LN11@CSpeedTree:

; 327  : 			SAFE_RELEASE(m_pFrondIndexBuffer);

  00115	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00118	83 b8 b4 01 00
	00 00		 cmp	 DWORD PTR [eax+436], 0
  0011f	74 21		 je	 SHORT $LN12@CSpeedTree
  00121	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00124	8b 80 b4 01 00
	00		 mov	 eax, DWORD PTR [eax+436]
  0012a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	8b 00		 mov	 eax, DWORD PTR [eax]
  0012f	ff b1 b4 01 00
	00		 push	 DWORD PTR [ecx+436]
  00135	ff 50 08	 call	 DWORD PTR [eax+8]
  00138	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0013b	83 a0 b4 01 00
	00 00		 and	 DWORD PTR [eax+436], 0
$LN12@CSpeedTree:

; 328  : 			SAFE_DELETE_ARRAY(m_pFrondIndexCounts);

  00142	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00145	83 b8 b8 01 00
	00 00		 cmp	 DWORD PTR [eax+440], 0
  0014c	74 1f		 je	 SHORT $LN10@CSpeedTree
  0014e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00151	8b 80 b8 01 00
	00		 mov	 eax, DWORD PTR [eax+440]
  00157	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax
  0015a	ff 75 d0	 push	 DWORD PTR $T6[ebp]
  0015d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00162	59		 pop	 ecx
  00163	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00166	83 a0 b8 01 00
	00 00		 and	 DWORD PTR [eax+440], 0
$LN10@CSpeedTree:

; 329  : 		}
; 330  : 		
; 331  : 		for (short i = 0; i < m_usNumLeafLods; ++i)

  0016d	33 c0		 xor	 eax, eax
  0016f	66 89 45 ec	 mov	 WORD PTR _i$11[ebp], ax
  00173	eb 0c		 jmp	 SHORT $LN4@CSpeedTree
$LN2@CSpeedTree:
  00175	66 8b 45 ec	 mov	 ax, WORD PTR _i$11[ebp]
  00179	66 83 c0 01	 add	 ax, 1
  0017d	66 89 45 ec	 mov	 WORD PTR _i$11[ebp], ax
$LN4@CSpeedTree:
  00181	0f bf 45 ec	 movsx	 eax, WORD PTR _i$11[ebp]
  00185	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00188	0f b7 89 bc 01
	00 00		 movzx	 ecx, WORD PTR [ecx+444]
  0018f	3b c1		 cmp	 eax, ecx
  00191	0f 8d 82 00 00
	00		 jge	 $LN3@CSpeedTree

; 332  : 		{			
; 333  : 			m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_LeafGeometry, -1, -1, i);

  00197	ff 75 ec	 push	 DWORD PTR _i$11[ebp]
  0019a	6a ff		 push	 -1
  0019c	6a ff		 push	 -1
  0019e	6a 04		 push	 4
  001a0	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001a3	ff b0 98 01 00
	00		 push	 DWORD PTR [eax+408]
  001a9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001ac	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  001b2	e8 00 00 00 00	 call	 ?GetGeometry@CSpeedTreeRT@@QAEXAAUSGeometry@1@KFFF@Z ; CSpeedTreeRT::GetGeometry

; 334  : 			
; 335  : 			if (m_pGeometryCache->m_sLeaves0.m_usLeafCount > 0)

  001b7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001ba	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  001c0	0f b7 80 84 00
	00 00		 movzx	 eax, WORD PTR [eax+132]
  001c7	85 c0		 test	 eax, eax
  001c9	7e 49		 jle	 SHORT $LN14@CSpeedTree

; 336  : 				SAFE_RELEASE(m_pLeafVertexBuffer[i]);

  001cb	0f bf 45 ec	 movsx	 eax, WORD PTR _i$11[ebp]
  001cf	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001d2	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [ecx+448]
  001d8	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  001dc	74 36		 je	 SHORT $LN14@CSpeedTree
  001de	0f bf 45 ec	 movsx	 eax, WORD PTR _i$11[ebp]
  001e2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e5	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [ecx+448]
  001eb	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  001ee	0f bf 4d ec	 movsx	 ecx, WORD PTR _i$11[ebp]
  001f2	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  001f5	8b 92 c0 01 00
	00		 mov	 edx, DWORD PTR [edx+448]
  001fb	8b 00		 mov	 eax, DWORD PTR [eax]
  001fd	ff 34 8a	 push	 DWORD PTR [edx+ecx*4]
  00200	ff 50 08	 call	 DWORD PTR [eax+8]
  00203	0f bf 45 ec	 movsx	 eax, WORD PTR _i$11[ebp]
  00207	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0020a	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [ecx+448]
  00210	83 24 81 00	 and	 DWORD PTR [ecx+eax*4], 0
$LN14@CSpeedTree:

; 337  : 		}

  00214	e9 5c ff ff ff	 jmp	 $LN2@CSpeedTree
$LN3@CSpeedTree:

; 338  : 		
; 339  : 		SAFE_DELETE_ARRAY(m_pLeavesUpdatedByCpu);

  00219	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0021c	83 b8 c4 01 00
	00 00		 cmp	 DWORD PTR [eax+452], 0
  00223	74 1f		 je	 SHORT $LN16@CSpeedTree
  00225	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00228	8b 80 c4 01 00
	00		 mov	 eax, DWORD PTR [eax+452]
  0022e	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
  00231	ff 75 cc	 push	 DWORD PTR $T5[ebp]
  00234	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00239	59		 pop	 ecx
  0023a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0023d	83 a0 c4 01 00
	00 00		 and	 DWORD PTR [eax+452], 0
$LN16@CSpeedTree:

; 340  : 		SAFE_DELETE_ARRAY(m_pLeafVertexBuffer);

  00244	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00247	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [eax+448], 0
  0024e	74 1f		 je	 SHORT $LN17@CSpeedTree
  00250	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00253	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [eax+448]
  00259	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  0025c	ff 75 c8	 push	 DWORD PTR $T4[ebp]
  0025f	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00264	59		 pop	 ecx
  00265	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00268	83 a0 c0 01 00
	00 00		 and	 DWORD PTR [eax+448], 0
$LN17@CSpeedTree:

; 341  : 		
; 342  : 		SAFE_DELETE(m_pTextureInfo);

  0026f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00272	83 b8 80 01 00
	00 00		 cmp	 DWORD PTR [eax+384], 0
  00279	74 4a		 je	 SHORT $LN18@CSpeedTree
  0027b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0027e	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]
  00284	89 45 e8	 mov	 DWORD PTR $T10[ebp], eax
  00287	83 7d e8 00	 cmp	 DWORD PTR $T10[ebp], 0
  0028b	74 2a		 je	 SHORT $LN22@CSpeedTree
  0028d	8b 45 c0	 mov	 eax, DWORD PTR $T3[ebp]
  00290	89 45 e0	 mov	 DWORD PTR tv248[ebp], eax
  00293	8b 4d e8	 mov	 ecx, DWORD PTR $T10[ebp]
  00296	e8 00 00 00 00	 call	 ??1STextures@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::STextures::~STextures
  0029b	33 c0		 xor	 eax, eax
  0029d	40		 inc	 eax
  0029e	83 e0 01	 and	 eax, 1
  002a1	74 0c		 je	 SHORT $LN29@CSpeedTree
  002a3	6a 1c		 push	 28			; 0000001cH
  002a5	ff 75 e8	 push	 DWORD PTR $T10[ebp]
  002a8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002ad	59		 pop	 ecx
  002ae	59		 pop	 ecx
$LN29@CSpeedTree:
  002af	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp]
  002b2	89 45 e0	 mov	 DWORD PTR tv248[ebp], eax
  002b5	eb 04		 jmp	 SHORT $LN23@CSpeedTree
$LN22@CSpeedTree:
  002b7	83 65 e0 00	 and	 DWORD PTR tv248[ebp], 0
$LN23@CSpeedTree:
  002bb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002be	83 a0 80 01 00
	00 00		 and	 DWORD PTR [eax+384], 0
$LN18@CSpeedTree:

; 343  : 
; 344  : 		SAFE_DELETE(m_pGeometryCache);

  002c5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002c8	83 b8 98 01 00
	00 00		 cmp	 DWORD PTR [eax+408], 0
  002cf	74 4d		 je	 SHORT $LN5@CSpeedTree
  002d1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002d4	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  002da	89 45 e4	 mov	 DWORD PTR $T9[ebp], eax
  002dd	83 7d e4 00	 cmp	 DWORD PTR $T9[ebp], 0
  002e1	74 2d		 je	 SHORT $LN24@CSpeedTree
  002e3	8b 45 bc	 mov	 eax, DWORD PTR $T2[ebp]
  002e6	89 45 dc	 mov	 DWORD PTR tv257[ebp], eax
  002e9	8b 4d e4	 mov	 ecx, DWORD PTR $T9[ebp]
  002ec	e8 00 00 00 00	 call	 ??1SGeometry@CSpeedTreeRT@@QAE@XZ ; CSpeedTreeRT::SGeometry::~SGeometry
  002f1	33 c0		 xor	 eax, eax
  002f3	40		 inc	 eax
  002f4	83 e0 01	 and	 eax, 1
  002f7	74 0f		 je	 SHORT $LN33@CSpeedTree
  002f9	68 20 01 00 00	 push	 288			; 00000120H
  002fe	ff 75 e4	 push	 DWORD PTR $T9[ebp]
  00301	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00306	59		 pop	 ecx
  00307	59		 pop	 ecx
$LN33@CSpeedTree:
  00308	8b 45 e4	 mov	 eax, DWORD PTR $T9[ebp]
  0030b	89 45 dc	 mov	 DWORD PTR tv257[ebp], eax
  0030e	eb 04		 jmp	 SHORT $LN25@CSpeedTree
$LN24@CSpeedTree:
  00310	83 65 dc 00	 and	 DWORD PTR tv257[ebp], 0
$LN25@CSpeedTree:
  00314	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00317	83 a0 98 01 00
	00 00		 and	 DWORD PTR [eax+408], 0
$LN5@CSpeedTree:

; 345  : 	}
; 346  : 	
; 347  : 	// always delete the speedtree
; 348  : 	SAFE_DELETE(m_pSpeedTree);

  0031e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00321	83 b8 7c 01 00
	00 00		 cmp	 DWORD PTR [eax+380], 0
  00328	74 2f		 je	 SHORT $LN20@CSpeedTree
  0032a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0032d	8b 80 7c 01 00
	00		 mov	 eax, DWORD PTR [eax+380]
  00333	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
  00336	83 7d d8 00	 cmp	 DWORD PTR $T8[ebp], 0
  0033a	74 0f		 je	 SHORT $LN26@CSpeedTree
  0033c	6a 01		 push	 1
  0033e	8b 4d d8	 mov	 ecx, DWORD PTR $T8[ebp]
  00341	e8 00 00 00 00	 call	 ??_GCSpeedTreeRT@@QAEPAXI@Z
  00346	89 45 c4	 mov	 DWORD PTR tv266[ebp], eax
  00349	eb 04		 jmp	 SHORT $LN27@CSpeedTree
$LN26@CSpeedTree:
  0034b	83 65 c4 00	 and	 DWORD PTR tv266[ebp], 0
$LN27@CSpeedTree:
  0034f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00352	83 a0 7c 01 00
	00 00		 and	 DWORD PTR [eax+380], 0
$LN20@CSpeedTree:

; 349  : 
; 350  : 	Clear();

  00359	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0035c	e8 00 00 00 00	 call	 ?Clear@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Clear

; 351  : }

  00361	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00364	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  0036a	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  0036f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00372	81 c1 d8 02 00
	00		 add	 ecx, 728		; 000002d8H
  00378	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  0037d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00380	81 c1 b8 02 00
	00		 add	 ecx, 696		; 000002b8H
  00386	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  0038b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0038e	81 c1 88 01 00
	00		 add	 ecx, 392		; 00000188H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00394	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 351  : }

  00399	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0039c	e8 00 00 00 00	 call	 ??1CGraphicObjectInstance@@UAE@XZ ; CGraphicObjectInstance::~CGraphicObjectInstance
  003a1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003a4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003ab	59		 pop	 ecx
  003ac	c9		 leave
  003ad	c3		 ret	 0
  003ae	cc		 int	 3
  003af	cc		 int	 3
  003b0	cc		 int	 3
  003b1	cc		 int	 3
  003b2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CSpeedTreeWrapper@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CSpeedTreeWrapper@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CSpeedTreeWrapper@@UAE@XZ ENDP			; CSpeedTreeWrapper::~CSpeedTreeWrapper
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ??0CSpeedTreeWrapper@@QAE@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
_this$ = -36						; size = 4
$T2 = -32						; size = 4
tv91 = -28						; size = 4
$T3 = -24						; size = 4
_this$4 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CSpeedTreeWrapper@@QAE@XZ PROC			; CSpeedTreeWrapper::CSpeedTreeWrapper, COMDAT
; _this$ = ecx

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CSpeedTreeWrapper@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0CGraphicObjectInstance@@QAE@XZ ; CGraphicObjectInstance::CGraphicObjectInstance
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CSpeedTreeWrapper@@6B@

; 60   : m_pSpeedTree(new CSpeedTreeRT),

  0003d	68 9c 00 00 00	 push	 156			; 0000009cH
  00042	e8 00 00 00 00	 call	 ??2CSpeedTreeRT@@SAPAXI@Z ; CSpeedTreeRT::operator new
  00047	59		 pop	 ecx
  00048	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004f	83 7d e8 00	 cmp	 DWORD PTR $T3[ebp], 0
  00053	74 0d		 je	 SHORT $LN3@CSpeedTree
  00055	8b 4d e8	 mov	 ecx, DWORD PTR $T3[ebp]
  00058	e8 00 00 00 00	 call	 ??0CSpeedTreeRT@@QAE@XZ	; CSpeedTreeRT::CSpeedTreeRT
  0005d	89 45 e4	 mov	 DWORD PTR tv91[ebp], eax
  00060	eb 04		 jmp	 SHORT $LN4@CSpeedTree
$LN3@CSpeedTree:
  00062	83 65 e4 00	 and	 DWORD PTR tv91[ebp], 0
$LN4@CSpeedTree:
  00066	8b 45 e4	 mov	 eax, DWORD PTR tv91[ebp]
  00069	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  0006c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00070	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d e0	 mov	 ecx, DWORD PTR $T2[ebp]
  00076	89 88 7c 01 00
	00		 mov	 DWORD PTR [eax+380], ecx

; 75   : m_pTextureInfo(NULL)

  0007c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	83 a0 80 01 00
	00 00		 and	 DWORD PTR [eax+384], 0

; 61   : m_bIsInstance(false),

  00086	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	c6 80 84 01 00
	00 00		 mov	 BYTE PTR [eax+388], 0

; 76   : {

  00090	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00093	05 88 01 00 00	 add	 eax, 392		; 00000188H
  00098	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0009b	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	89 45 d8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000a1	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	89 45 ec	 mov	 DWORD PTR _this$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000a7	8b 45 ec	 mov	 eax, DWORD PTR _this$4[ebp]
  000aa	83 20 00	 and	 DWORD PTR [eax], 0
  000ad	8b 45 ec	 mov	 eax, DWORD PTR _this$4[ebp]
  000b0	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  000b4	8b 45 ec	 mov	 eax, DWORD PTR _this$4[ebp]
  000b7	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 76   : {

  000bb	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 62   : m_pInstanceOf(NULL),

  000bf	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	83 a0 94 01 00
	00 00		 and	 DWORD PTR [eax+404], 0

; 63   : m_pGeometryCache(NULL),

  000c9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	83 a0 98 01 00
	00 00		 and	 DWORD PTR [eax+408], 0

; 67   : m_pBranchVertexBuffer(NULL),

  000d3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	83 a0 9c 01 00
	00 00		 and	 DWORD PTR [eax+412], 0

; 73   : m_unBranchVertexCount(0),

  000dd	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	83 a0 a0 01 00
	00 00		 and	 DWORD PTR [eax+416], 0

; 66   : m_pBranchIndexBuffer(NULL),

  000e7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ea	83 a0 a4 01 00
	00 00		 and	 DWORD PTR [eax+420], 0

; 65   : m_pBranchIndexCounts(NULL),

  000f1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f4	83 a0 a8 01 00
	00 00		 and	 DWORD PTR [eax+424], 0

; 70   : m_pFrondVertexBuffer(NULL),

  000fb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000fe	83 a0 ac 01 00
	00 00		 and	 DWORD PTR [eax+428], 0

; 74   : m_unFrondVertexCount(0),

  00105	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00108	83 a0 b0 01 00
	00 00		 and	 DWORD PTR [eax+432], 0

; 69   : m_pFrondIndexBuffer(NULL),

  0010f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00112	83 a0 b4 01 00
	00 00		 and	 DWORD PTR [eax+436], 0

; 68   : m_pFrondIndexCounts(NULL),

  00119	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0011c	83 a0 b8 01 00
	00 00		 and	 DWORD PTR [eax+440], 0

; 64   : m_usNumLeafLods(0),

  00123	33 c0		 xor	 eax, eax
  00125	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00128	66 89 81 bc 01
	00 00		 mov	 WORD PTR [ecx+444], ax

; 71   : m_pLeafVertexBuffer(NULL),

  0012f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00132	83 a0 c0 01 00
	00 00		 and	 DWORD PTR [eax+448], 0

; 72   : m_pLeavesUpdatedByCpu(NULL),

  00139	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0013c	83 a0 c4 01 00
	00 00		 and	 DWORD PTR [eax+452], 0

; 76   : {

  00143	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	81 c1 ec 01 00
	00		 add	 ecx, 492		; 000001ecH
  0014c	e8 00 00 00 00	 call	 ??0CSpeedTreeMaterial@@QAE@XZ ; CSpeedTreeMaterial::CSpeedTreeMaterial
  00151	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00154	81 c1 30 02 00
	00		 add	 ecx, 560		; 00000230H
  0015a	e8 00 00 00 00	 call	 ??0CSpeedTreeMaterial@@QAE@XZ ; CSpeedTreeMaterial::CSpeedTreeMaterial
  0015f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	81 c1 74 02 00
	00		 add	 ecx, 628		; 00000274H
  00168	e8 00 00 00 00	 call	 ??0CSpeedTreeMaterial@@QAE@XZ ; CSpeedTreeMaterial::CSpeedTreeMaterial
  0016d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00170	81 c1 b8 02 00
	00		 add	 ecx, 696		; 000002b8H
  00176	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  0017b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0017f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00182	81 c1 d8 02 00
	00		 add	 ecx, 728		; 000002d8H
  00188	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  0018d	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00191	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00194	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  0019a	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  0019f	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 77   : 	// set initial position
; 78   : 	m_afPos[0] = m_afPos[1] = m_afPos[2] = 0.0f;

  001a3	6a 04		 push	 4
  001a5	58		 pop	 eax
  001a6	d1 e0		 shl	 eax, 1
  001a8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	0f 57 c0	 xorps	 xmm0, xmm0
  001ae	f3 0f 11 84 01
	c8 01 00 00	 movss	 DWORD PTR [ecx+eax+456], xmm0
  001b7	6a 04		 push	 4
  001b9	58		 pop	 eax
  001ba	c1 e0 00	 shl	 eax, 0
  001bd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001c0	0f 57 c0	 xorps	 xmm0, xmm0
  001c3	f3 0f 11 84 01
	c8 01 00 00	 movss	 DWORD PTR [ecx+eax+456], xmm0
  001cc	6a 04		 push	 4
  001ce	58		 pop	 eax
  001cf	6b c0 00	 imul	 eax, eax, 0
  001d2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001d5	0f 57 c0	 xorps	 xmm0, xmm0
  001d8	f3 0f 11 84 01
	c8 01 00 00	 movss	 DWORD PTR [ecx+eax+456], xmm0

; 79   : 	
; 80   : 	m_pSpeedTree->SetWindStrength(1.0f);

  001e1	51		 push	 ecx
  001e2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  001ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ef	51		 push	 ecx
  001f0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  001f8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fd	51		 push	 ecx
  001fe	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00206	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0020b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0020e	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00214	e8 00 00 00 00	 call	 ?SetWindStrength@CSpeedTreeRT@@QAEMMMM@Z ; CSpeedTreeRT::SetWindStrength
  00219	dd d8		 fstp	 ST(0)

; 81   : 	m_pSpeedTree->SetLocalMatrices(0, 4);

  0021b	6a 04		 push	 4
  0021d	6a 00		 push	 0
  0021f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00222	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00228	e8 00 00 00 00	 call	 ?SetLocalMatrices@CSpeedTreeRT@@QAEXII@Z ; CSpeedTreeRT::SetLocalMatrices

; 82   : }

  0022d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00231	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00234	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00237	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0023e	59		 pop	 ecx
  0023f	c9		 leave
  00240	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CSpeedTreeWrapper@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CGraphicObjectInstance@@UAE@XZ ; CGraphicObjectInstance::~CGraphicObjectInstance
__unwindfunclet$??0CSpeedTreeWrapper@@QAE@XZ$1:
  00008	ff 75 e8	 push	 DWORD PTR $T3[ebp]
  0000b	e8 00 00 00 00	 call	 ??3CSpeedTreeRT@@SAXPAX@Z ; CSpeedTreeRT::operator delete
  00010	59		 pop	 ecx
  00011	c3		 ret	 0
__unwindfunclet$??0CSpeedTreeWrapper@@QAE@XZ$2:
  00012	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	81 c1 88 01 00
	00		 add	 ecx, 392		; 00000188H
  0001b	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::~vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >
__unwindfunclet$??0CSpeedTreeWrapper@@QAE@XZ$3:
  00020	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	81 c1 b8 02 00
	00		 add	 ecx, 696		; 000002b8H
  00029	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
__unwindfunclet$??0CSpeedTreeWrapper@@QAE@XZ$4:
  0002e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	81 c1 d8 02 00
	00		 add	 ecx, 728		; 000002d8H
  00037	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
__unwindfunclet$??0CSpeedTreeWrapper@@QAE@XZ$5:
  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  00045	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
__ehhandler$??0CSpeedTreeWrapper@@QAE@XZ:
  0004f	90		 npad	 1
  00050	90		 npad	 1
  00051	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00055	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00058	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0005b	33 c8		 xor	 ecx, eax
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CSpeedTreeWrapper@@QAE@XZ
  00067	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CSpeedTreeWrapper@@QAE@XZ ENDP			; CSpeedTreeWrapper::CSpeedTreeWrapper
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Camera.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?OnRenderPCBlocker@CSpeedTreeWrapper@@UAEXXZ
_TEXT	SEGMENT
tv366 = -68						; size = 8
_dwFogEnable$ = -60					; size = 4
_dwLighting$ = -56					; size = 4
_dwAlphaBlendEnable$ = -52				; size = 4
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
_this$ = -24						; size = 4
$T7 = -20						; size = 4
$T8 = -16						; size = 4
_lpd3dTexture$9 = -12					; size = 4
tv363 = -8						; size = 4
_this$ = -4						; size = 4
?OnRenderPCBlocker@CSpeedTreeWrapper@@UAEXXZ PROC	; CSpeedTreeWrapper::OnRenderPCBlocker, COMDAT
; _this$ = ecx

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 92   : 	if (ms_dwBranchVertexShader == 0)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_dwBranchVertexShader@CSpeedTreeWrapper@@0KA, 0 ; CSpeedTreeWrapper::ms_dwBranchVertexShader
  00010	75 11		 jne	 SHORT $LN2@OnRenderPC

; 93   : 	{
; 94   : 		ms_dwBranchVertexShader = LoadBranchShader(ms_lpd3dDevice);

  00012	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00018	e8 00 00 00 00	 call	 ?LoadBranchShader@@YAKPAUIDirect3DDevice8@@@Z ; LoadBranchShader
  0001d	59		 pop	 ecx
  0001e	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwBranchVertexShader@CSpeedTreeWrapper@@0KA, eax ; CSpeedTreeWrapper::ms_dwBranchVertexShader
$LN2@OnRenderPC:

; 95   : 		//LogBox("Vertex Shader not assigned. You must call CSpeedTreeWrapper::SetVertexShader for this");
; 96   : 	}
; 97   : 	
; 98   : 	if (ms_dwLeafVertexShader == 0)

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_dwLeafVertexShader@CSpeedTreeWrapper@@0KA, 0 ; CSpeedTreeWrapper::ms_dwLeafVertexShader
  0002a	75 11		 jne	 SHORT $LN3@OnRenderPC

; 99   : 	{
; 100  : 		ms_dwLeafVertexShader = LoadLeafShader(ms_lpd3dDevice);

  0002c	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00032	e8 00 00 00 00	 call	 ?LoadLeafShader@@YAKPAUIDirect3DDevice8@@@Z ; LoadLeafShader
  00037	59		 pop	 ecx
  00038	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwLeafVertexShader@CSpeedTreeWrapper@@0KA, eax ; CSpeedTreeWrapper::ms_dwLeafVertexShader
$LN3@OnRenderPC:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
  00042	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 104  : 	CSpeedTreeForestDirectX8::Instance().UpdateSystem(ELTimer_GetMSec() / 1000.0f);

  00045	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0004a	89 45 f8	 mov	 DWORD PTR tv363[ebp], eax
  0004d	f2 0f 2a 45 f8	 cvtsi2sd xmm0, DWORD PTR tv363[ebp]
  00052	8b 45 f8	 mov	 eax, DWORD PTR tv363[ebp]
  00055	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00058	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00061	f2 0f 11 45 bc	 movsd	 QWORD PTR tv366[ebp], xmm0
  00066	f2 0f 5a 45 bc	 cvtsd2ss xmm0, QWORD PTR tv366[ebp]
  0006b	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@447a0000
  00073	51		 push	 ecx
  00074	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00079	8b 4d f0	 mov	 ecx, DWORD PTR $T8[ebp]
  0007c	e8 00 00 00 00	 call	 ?UpdateSystem@CSpeedTreeForest@@QAEXM@Z ; CSpeedTreeForest::UpdateSystem

; 105  : 	
; 106  : 	//     LOD  
; 107  : 	m_pSpeedTree->SetLodLevel(1.0f);

  00081	51		 push	 ecx
  00082	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0008a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00098	e8 00 00 00 00	 call	 ?SetLodLevel@CSpeedTreeRT@@QAEXM@Z ; CSpeedTreeRT::SetLodLevel
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  000a2	89 45 ec	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 110  : 	CSpeedTreeForestDirectX8::Instance().UpdateCompundMatrix(CCameraManager::Instance().GetCurrentCamera()->GetEye(), ms_matView, ms_matProj);

  000a5	8b 4d ec	 mov	 ecx, DWORD PTR $T7[ebp]
  000a8	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  000ad	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
  000b0	68 00 00 00 00	 push	 OFFSET ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A ; CGraphicBase::ms_matProj
  000b5	68 00 00 00 00	 push	 OFFSET ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A ; CGraphicBase::ms_matView
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Camera.h

; 168  : 		const D3DXVECTOR3 & GetEye() const		{ return m_v3Eye; }

  000ba	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	83 c0 30	 add	 eax, 48			; 00000030H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 110  : 	CSpeedTreeForestDirectX8::Instance().UpdateCompundMatrix(CCameraManager::Instance().GetCurrentCamera()->GetEye(), ms_matView, ms_matProj);

  000c0	50		 push	 eax
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
  000c7	e8 00 00 00 00	 call	 ?UpdateCompundMatrix@CSpeedTreeForestDirectX8@@QAEXABUD3DXVECTOR3@@ABUD3DXMATRIX@@1@Z ; CSpeedTreeForestDirectX8::UpdateCompundMatrix

; 111  : 	
; 112  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1,	D3DTA_TEXTURE);

  000cc	6a 02		 push	 2
  000ce	6a 02		 push	 2
  000d0	6a 00		 push	 0
  000d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000d8	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 113  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2,	D3DTA_DIFFUSE);

  000dd	6a 00		 push	 0
  000df	6a 03		 push	 3
  000e1	6a 00		 push	 0
  000e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000e9	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 114  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,	D3DTOP_MODULATE);

  000ee	6a 04		 push	 4
  000f0	6a 01		 push	 1
  000f2	6a 00		 push	 0
  000f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000fa	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 115  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1,	D3DTA_TEXTURE);

  000ff	6a 02		 push	 2
  00101	6a 05		 push	 5
  00103	6a 00		 push	 0
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0010b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 116  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG2,	D3DTA_DIFFUSE);

  00110	6a 00		 push	 0
  00112	6a 06		 push	 6
  00114	6a 00		 push	 0
  00116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0011c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 117  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,	D3DTOP_MODULATE);

  00121	6a 04		 push	 4
  00123	6a 04		 push	 4
  00125	6a 00		 push	 0
  00127	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0012d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 118  : 
; 119  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00132	6a 02		 push	 2
  00134	6a 05		 push	 5
  00136	6a 01		 push	 1
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0013e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 120  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);

  00143	6a 01		 push	 1
  00145	6a 06		 push	 6
  00147	6a 01		 push	 1
  00149	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0014f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 121  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_MODULATE);

  00154	6a 04		 push	 4
  00156	6a 04		 push	 4
  00158	6a 01		 push	 1
  0015a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00160	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0016a	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 123  : 	DWORD dwLighting = STATEMANAGER.GetRenderState(D3DRS_LIGHTING);

  0016d	68 89 00 00 00	 push	 137			; 00000089H
  00172	8b 4d e4	 mov	 ecx, DWORD PTR $T6[ebp]
  00175	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState
  0017a	89 45 c8	 mov	 DWORD PTR _dwLighting$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  0017d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00182	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 124  : 	DWORD dwFogEnable = STATEMANAGER.GetRenderState(D3DRS_FOGENABLE);

  00185	6a 1c		 push	 28			; 0000001cH
  00187	8b 4d e0	 mov	 ecx, DWORD PTR $T5[ebp]
  0018a	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState
  0018f	89 45 c4	 mov	 DWORD PTR _dwFogEnable$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  00192	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00197	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 125  : 	DWORD dwAlphaBlendEnable = STATEMANAGER.GetRenderState(D3DRS_ALPHABLENDENABLE);

  0019a	6a 1b		 push	 27			; 0000001bH
  0019c	8b 4d dc	 mov	 ecx, DWORD PTR $T4[ebp]
  0019f	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState
  001a4	89 45 cc	 mov	 DWORD PTR _dwAlphaBlendEnable$[ebp], eax

; 126  :  	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  001a7	6a 00		 push	 0
  001a9	68 89 00 00 00	 push	 137			; 00000089H
  001ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001b4	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 127  : 	STATEMANAGER.SaveRenderState(D3DRS_COLORVERTEX, TRUE);

  001b9	6a 01		 push	 1
  001bb	68 8d 00 00 00	 push	 141			; 0000008dH
  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c6	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 128  :     STATEMANAGER.SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  001cb	6a 01		 push	 1
  001cd	6a 1b		 push	 27			; 0000001bH
  001cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001d5	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 129  :     STATEMANAGER.SaveRenderState(D3DRS_ALPHATESTENABLE, TRUE);

  001da	6a 01		 push	 1
  001dc	6a 0f		 push	 15			; 0000000fH
  001de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001e4	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 130  :     STATEMANAGER.SaveRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);

  001e9	6a 05		 push	 5
  001eb	6a 19		 push	 25			; 00000019H
  001ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001f3	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 131  : 	STATEMANAGER.SaveRenderState(D3DRS_CULLMODE, D3DCULL_CW);

  001f8	6a 02		 push	 2
  001fa	6a 16		 push	 22			; 00000016H
  001fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00202	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 132  :  	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  00207	6a 00		 push	 0
  00209	6a 1c		 push	 28			; 0000001cH
  0020b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00211	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 133  : 	
; 134  : 	// choose fixed function pipeline or custom shader for fronds and branches
; 135  : 	STATEMANAGER.SetVertexShader(ms_dwBranchVertexShader);

  00216	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_dwBranchVertexShader@CSpeedTreeWrapper@@0KA ; CSpeedTreeWrapper::ms_dwBranchVertexShader
  0021c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00222	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 136  : 	
; 137  : // 	SetupBranchForTreeType();
; 138  : 	{
; 139  : 		// update the branch geometry for CPU wind
; 140  : #ifdef WRAPPER_USE_CPU_WIND
; 141  : 		m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_BranchGeometry);
; 142  : 		
; 143  : 		if (m_pGeometryCache->m_sBranches.m_usNumStrips > 0)
; 144  : 		{
; 145  : 			// update the vertex array
; 146  : 			SFVFBranchVertex* pVertexBuffer = NULL;
; 147  : 			m_pBranchVertexBuffer->Lock(0, 0, reinterpret_cast<BYTE**>(&pVertexBuffer), D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK);
; 148  : 			for (UINT i = 0; i < m_unBranchVertexCount; ++i)
; 149  : 			{
; 150  : 				memcpy(&(pVertexBuffer[i].m_vPosition), &(m_pGeometryCache->m_sBranches.m_pCoords[i * 3]), 3 * sizeof(float));
; 151  : 			}
; 152  : 			m_pBranchVertexBuffer->Unlock();
; 153  : 		}
; 154  : #endif
; 155  : 		
; 156  : 		LPDIRECT3DTEXTURE8 lpd3dTexture;
; 157  : 		
; 158  : 		// set texture map
; 159  : 		if ((lpd3dTexture = m_BranchImageInstance.GetTextureReference().GetD3DTexture()))

  00227	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022a	81 c1 b8 02 00
	00		 add	 ecx, 696		; 000002b8H
  00230	e8 00 00 00 00	 call	 ?GetTextureReference@CGraphicImageInstance@@QBEABVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTextureReference
  00235	8b c8		 mov	 ecx, eax
  00237	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  0023c	89 45 f4	 mov	 DWORD PTR _lpd3dTexture$9[ebp], eax
  0023f	83 7d f4 00	 cmp	 DWORD PTR _lpd3dTexture$9[ebp], 0
  00243	74 10		 je	 SHORT $LN4@OnRenderPC

; 160  : 			STATEMANAGER.SetTexture(0, lpd3dTexture);

  00245	ff 75 f4	 push	 DWORD PTR _lpd3dTexture$9[ebp]
  00248	6a 00		 push	 0
  0024a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00250	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN4@OnRenderPC:

; 161  : 		
; 162  : 		if (m_pGeometryCache->m_sBranches.m_usVertexCount > 0)

  00255	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00258	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  0025e	0f b7 40 10	 movzx	 eax, WORD PTR [eax+16]
  00262	85 c0		 test	 eax, eax
  00264	7e 2e		 jle	 SHORT $LN5@OnRenderPC

; 163  : 		{
; 164  : 			// activate the branch vertex buffer
; 165  : 			STATEMANAGER.SetStreamSource(0, m_pBranchVertexBuffer, sizeof(SFVFBranchVertex));

  00266	6a 20		 push	 32			; 00000020H
  00268	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0026b	ff b0 9c 01 00
	00		 push	 DWORD PTR [eax+412]
  00271	6a 00		 push	 0
  00273	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00279	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 166  : 			// set the index buffer
; 167  : 			STATEMANAGER.SetIndices(m_pBranchIndexBuffer, 0);

  0027e	6a 00		 push	 0
  00280	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00283	ff b0 a4 01 00
	00		 push	 DWORD PTR [eax+420]
  00289	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0028f	e8 00 00 00 00	 call	 ?SetIndices@CStateManager@@QAEXPAUIDirect3DIndexBuffer8@@I@Z ; CStateManager::SetIndices
$LN5@OnRenderPC:

; 168  : 		}
; 169  : 	}
; 170  : 
; 171  : 	RenderBranches();

  00294	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00297	e8 00 00 00 00	 call	 ?RenderBranches@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::RenderBranches
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  0029c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002a1	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 173  : 	STATEMANAGER.SetTexture(0, m_CompositeImageInstance.GetTextureReference().GetD3DTexture());

  002a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002a7	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  002ad	e8 00 00 00 00	 call	 ?GetTextureReference@CGraphicImageInstance@@QBEABVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTextureReference
  002b2	8b c8		 mov	 ecx, eax
  002b4	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  002b9	50		 push	 eax
  002ba	6a 00		 push	 0
  002bc	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp]
  002bf	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 174  : 	STATEMANAGER.SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

  002c4	6a 01		 push	 1
  002c6	6a 16		 push	 22			; 00000016H
  002c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ce	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 175  : 	
; 176  : // 	SetupFrondForTreeType();
; 177  : 	{
; 178  : 		// update the frond geometry for CPU wind
; 179  : #ifdef WRAPPER_USE_CPU_WIND
; 180  : 		m_pSpeedTree->GetGeometry(*m_pGeometryCache, SpeedTree_FrondGeometry);
; 181  : 		if (m_pGeometryCache->m_sFronds.m_usNumStrips > 0)
; 182  : 		{
; 183  : 			// update the vertex array
; 184  : 			SFVFBranchVertex * pVertexBuffer = NULL;
; 185  : 			m_pFrondVertexBuffer->Lock(0, 0, reinterpret_cast<BYTE**>(&pVertexBuffer), D3DLOCK_DISCARD | D3DLOCK_NOSYSLOCK);
; 186  : 			for (UINT i = 0; i < m_unFrondVertexCount; ++i)
; 187  : 			{
; 188  : 				memcpy(&(pVertexBuffer[i].m_vPosition), &(m_pGeometryCache->m_sFronds.m_pCoords[i * 3]), 3 * sizeof(float));
; 189  : 			}
; 190  : 			m_pFrondVertexBuffer->Unlock();
; 191  : 		}
; 192  : #endif
; 193  : 		
; 194  : 		if (!m_CompositeImageInstance.IsEmpty())

  002d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d6	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  002dc	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  002e1	0f b6 c0	 movzx	 eax, al
  002e4	85 c0		 test	 eax, eax
  002e6	75 28		 jne	 SHORT $LN6@OnRenderPC
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  002e8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ed	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 195  : 			STATEMANAGER.SetTexture(0, m_CompositeImageInstance.GetTextureReference().GetD3DTexture());

  002f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002f3	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  002f9	e8 00 00 00 00	 call	 ?GetTextureReference@CGraphicImageInstance@@QBEABVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTextureReference
  002fe	8b c8		 mov	 ecx, eax
  00300	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00305	50		 push	 eax
  00306	6a 00		 push	 0
  00308	8b 4d d4	 mov	 ecx, DWORD PTR $T2[ebp]
  0030b	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN6@OnRenderPC:

; 196  : 		
; 197  : 		if (m_pGeometryCache->m_sFronds.m_usVertexCount > 0)

  00310	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00313	8b 80 98 01 00
	00		 mov	 eax, DWORD PTR [eax+408]
  00319	0f b7 40 4c	 movzx	 eax, WORD PTR [eax+76]
  0031d	85 c0		 test	 eax, eax
  0031f	7e 2e		 jle	 SHORT $LN7@OnRenderPC

; 198  : 		{
; 199  : 			// activate the frond vertex buffer
; 200  : 			STATEMANAGER.SetStreamSource(0, m_pFrondVertexBuffer, sizeof(SFVFBranchVertex));

  00321	6a 20		 push	 32			; 00000020H
  00323	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00326	ff b0 ac 01 00
	00		 push	 DWORD PTR [eax+428]
  0032c	6a 00		 push	 0
  0032e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00334	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 201  : 			// set the index buffer
; 202  : 			STATEMANAGER.SetIndices(m_pFrondIndexBuffer, 0);

  00339	6a 00		 push	 0
  0033b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0033e	ff b0 b4 01 00
	00		 push	 DWORD PTR [eax+436]
  00344	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0034a	e8 00 00 00 00	 call	 ?SetIndices@CStateManager@@QAEXPAUIDirect3DIndexBuffer8@@I@Z ; CStateManager::SetIndices
$LN7@OnRenderPC:

; 203  : 		}
; 204  : 	}
; 205  : 	RenderFronds();

  0034f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00352	e8 00 00 00 00	 call	 ?RenderFronds@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::RenderFronds

; 206  : 	
; 207  : 	STATEMANAGER.SetVertexShader(ms_dwLeafVertexShader);

  00357	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_dwLeafVertexShader@CSpeedTreeWrapper@@0KA ; CSpeedTreeWrapper::ms_dwLeafVertexShader
  0035d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00363	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 208  : 	
; 209  : // 	SetupLeafForTreeType();
; 210  : 	{
; 211  : 		// pass leaf tables to shader
; 212  : #ifdef WRAPPER_USE_GPU_LEAF_PLACEMENT
; 213  : 		UploadLeafTables(c_nVertexShader_LeafTables);
; 214  : #endif
; 215  : 		
; 216  : 		if (!m_CompositeImageInstance.IsEmpty())

  00368	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0036b	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  00371	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  00376	0f b6 c0	 movzx	 eax, al
  00379	85 c0		 test	 eax, eax
  0037b	75 28		 jne	 SHORT $LN8@OnRenderPC
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  0037d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00382	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 217  : 			STATEMANAGER.SetTexture(0, m_CompositeImageInstance.GetTextureReference().GetD3DTexture());

  00385	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00388	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  0038e	e8 00 00 00 00	 call	 ?GetTextureReference@CGraphicImageInstance@@QBEABVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTextureReference
  00393	8b c8		 mov	 ecx, eax
  00395	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  0039a	50		 push	 eax
  0039b	6a 00		 push	 0
  0039d	8b 4d d0	 mov	 ecx, DWORD PTR $T1[ebp]
  003a0	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN8@OnRenderPC:

; 218  : 	}
; 219  : 	RenderLeaves();

  003a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	e8 00 00 00 00	 call	 ?RenderLeaves@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::RenderLeaves

; 220  : 	EndLeafForTreeType();

  003ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003b0	e8 00 00 00 00	 call	 ?EndLeafForTreeType@CSpeedTreeWrapper@@QAEXXZ ; CSpeedTreeWrapper::EndLeafForTreeType

; 221  : 	
; 222  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  003b5	6a 00		 push	 0
  003b7	68 89 00 00 00	 push	 137			; 00000089H
  003bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003c2	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 223  : 	STATEMANAGER.SetRenderState(D3DRS_COLORVERTEX, FALSE);

  003c7	6a 00		 push	 0
  003c9	68 8d 00 00 00	 push	 141			; 0000008dH
  003ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003d4	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 224  : 	RenderBillboards();

  003d9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003dc	e8 00 00 00 00	 call	 ?RenderBillboards@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::RenderBillboards

; 225  : 	
; 226  : 	STATEMANAGER.RestoreRenderState(D3DRS_COLORVERTEX);

  003e1	68 8d 00 00 00	 push	 141			; 0000008dH
  003e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003ec	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 227  : 	STATEMANAGER.RestoreRenderState(D3DRS_CULLMODE);

  003f1	6a 16		 push	 22			; 00000016H
  003f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003f9	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 228  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHATESTENABLE);

  003fe	6a 0f		 push	 15			; 0000000fH
  00400	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00406	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 229  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHAFUNC);

  0040b	6a 19		 push	 25			; 00000019H
  0040d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00413	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 230  : 	STATEMANAGER.SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlphaBlendEnable);

  00418	ff 75 cc	 push	 DWORD PTR _dwAlphaBlendEnable$[ebp]
  0041b	6a 1b		 push	 27			; 0000001bH
  0041d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00423	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 231  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, dwLighting);

  00428	ff 75 c8	 push	 DWORD PTR _dwLighting$[ebp]
  0042b	68 89 00 00 00	 push	 137			; 00000089H
  00430	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00436	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 232  :  	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, dwFogEnable);

  0043b	ff 75 c4	 push	 DWORD PTR _dwFogEnable$[ebp]
  0043e	6a 1c		 push	 28			; 0000001cH
  00440	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00446	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 233  : 
; 234  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

  0044b	6a 02		 push	 2
  0044d	6a 04		 push	 4
  0044f	6a 01		 push	 1
  00451	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00457	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 235  : }

  0045c	c9		 leave
  0045d	c3		 ret	 0
?OnRenderPCBlocker@CSpeedTreeWrapper@@UAEXXZ ENDP	; CSpeedTreeWrapper::OnRenderPCBlocker
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.h
;	COMDAT ?OnRenderShadow@CSpeedTreeWrapper@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnRenderShadow@CSpeedTreeWrapper@@UAEXXZ PROC		; CSpeedTreeWrapper::OnRenderShadow, COMDAT
; _this$ = ecx

; 94   : 	virtual void				OnRenderShadow() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?OnRenderShadow@CSpeedTreeWrapper@@UAEXXZ ENDP		; CSpeedTreeWrapper::OnRenderShadow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.h
;	COMDAT ?OnRenderToShadowMap@CSpeedTreeWrapper@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnRenderToShadowMap@CSpeedTreeWrapper@@UAEXXZ PROC	; CSpeedTreeWrapper::OnRenderToShadowMap, COMDAT
; _this$ = ecx

; 93   : 	virtual void				OnRenderToShadowMap() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?OnRenderToShadowMap@CSpeedTreeWrapper@@UAEXXZ ENDP	; CSpeedTreeWrapper::OnRenderToShadowMap
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.h
;	COMDAT ?OnBlendRender@CSpeedTreeWrapper@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnBlendRender@CSpeedTreeWrapper@@UAEXXZ PROC		; CSpeedTreeWrapper::OnBlendRender, COMDAT
; _this$ = ecx

; 92   : 	virtual void				OnBlendRender() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?OnBlendRender@CSpeedTreeWrapper@@UAEXXZ ENDP		; CSpeedTreeWrapper::OnBlendRender
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Camera.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?OnRender@CSpeedTreeWrapper@@UAEXXZ
_TEXT	SEGMENT
tv268 = -32						; size = 8
$T1 = -24						; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
tv265 = -8						; size = 4
_this$ = -4						; size = 4
?OnRender@CSpeedTreeWrapper@@UAEXXZ PROC		; CSpeedTreeWrapper::OnRender, COMDAT
; _this$ = ecx

; 238  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 	if (ms_dwBranchVertexShader == 0)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_dwBranchVertexShader@CSpeedTreeWrapper@@0KA, 0 ; CSpeedTreeWrapper::ms_dwBranchVertexShader
  00010	75 11		 jne	 SHORT $LN2@OnRender

; 240  : 	{
; 241  : 		ms_dwBranchVertexShader = LoadBranchShader(ms_lpd3dDevice);

  00012	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00018	e8 00 00 00 00	 call	 ?LoadBranchShader@@YAKPAUIDirect3DDevice8@@@Z ; LoadBranchShader
  0001d	59		 pop	 ecx
  0001e	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwBranchVertexShader@CSpeedTreeWrapper@@0KA, eax ; CSpeedTreeWrapper::ms_dwBranchVertexShader
$LN2@OnRender:

; 242  : 		//LogBox("Vertex Shader not assigned. You must call CSpeedTreeWrapper::SetVertexShader for this");
; 243  : 	}
; 244  : 	
; 245  : 	if (ms_dwLeafVertexShader == 0)

  00023	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_dwLeafVertexShader@CSpeedTreeWrapper@@0KA, 0 ; CSpeedTreeWrapper::ms_dwLeafVertexShader
  0002a	75 11		 jne	 SHORT $LN3@OnRender

; 246  : 	{
; 247  : 		ms_dwLeafVertexShader = LoadLeafShader(ms_lpd3dDevice);

  0002c	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00032	e8 00 00 00 00	 call	 ?LoadLeafShader@@YAKPAUIDirect3DDevice8@@@Z ; LoadLeafShader
  00037	59		 pop	 ecx
  00038	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwLeafVertexShader@CSpeedTreeWrapper@@0KA, eax ; CSpeedTreeWrapper::ms_dwLeafVertexShader
$LN3@OnRender:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
  00042	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 251  : 	CSpeedTreeForestDirectX8::Instance().UpdateSystem(ELTimer_GetMSec() / 1000.0f);

  00045	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0004a	89 45 f8	 mov	 DWORD PTR tv265[ebp], eax
  0004d	f2 0f 2a 45 f8	 cvtsi2sd xmm0, DWORD PTR tv265[ebp]
  00052	8b 45 f8	 mov	 eax, DWORD PTR tv265[ebp]
  00055	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00058	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00061	f2 0f 11 45 e0	 movsd	 QWORD PTR tv268[ebp], xmm0
  00066	f2 0f 5a 45 e0	 cvtsd2ss xmm0, QWORD PTR tv268[ebp]
  0006b	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@447a0000
  00073	51		 push	 ecx
  00074	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00079	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  0007c	e8 00 00 00 00	 call	 ?UpdateSystem@CSpeedTreeForest@@QAEXM@Z ; CSpeedTreeForest::UpdateSystem

; 252  : 	
; 253  : 	//     LOD  
; 254  : 	m_pSpeedTree->SetLodLevel(1.0f);

  00081	51		 push	 ecx
  00082	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0008a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00098	e8 00 00 00 00	 call	 ?SetLodLevel@CSpeedTreeRT@@QAEXM@Z ; CSpeedTreeRT::SetLodLevel
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCameraManager@@@@0PAVCCameraManager@@A ; CSingleton<CCameraManager>::ms_singleton
  000a2	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 257  : 	CSpeedTreeForestDirectX8::Instance().UpdateCompundMatrix(CCameraManager::Instance().GetCurrentCamera()->GetEye(), ms_matView, ms_matProj);

  000a5	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  000a8	e8 00 00 00 00	 call	 ?GetCurrentCamera@CCameraManager@@QAEPAVCCamera@@XZ ; CCameraManager::GetCurrentCamera
  000ad	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
  000b0	68 00 00 00 00	 push	 OFFSET ?ms_matProj@CGraphicBase@@1UD3DXMATRIX@@A ; CGraphicBase::ms_matProj
  000b5	68 00 00 00 00	 push	 OFFSET ?ms_matView@CGraphicBase@@1UD3DXMATRIX@@A ; CGraphicBase::ms_matView
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Camera.h

; 168  : 		const D3DXVECTOR3 & GetEye() const		{ return m_v3Eye; }

  000ba	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	83 c0 30	 add	 eax, 48			; 00000030H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 257  : 	CSpeedTreeForestDirectX8::Instance().UpdateCompundMatrix(CCameraManager::Instance().GetCurrentCamera()->GetEye(), ms_matView, ms_matProj);

  000c0	50		 push	 eax
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
  000c7	e8 00 00 00 00	 call	 ?UpdateCompundMatrix@CSpeedTreeForestDirectX8@@QAEXABUD3DXVECTOR3@@ABUD3DXMATRIX@@1@Z ; CSpeedTreeForestDirectX8::UpdateCompundMatrix

; 258  : 	
; 259  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1,	D3DTA_TEXTURE);

  000cc	6a 02		 push	 2
  000ce	6a 02		 push	 2
  000d0	6a 00		 push	 0
  000d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000d8	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 260  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2,	D3DTA_DIFFUSE);

  000dd	6a 00		 push	 0
  000df	6a 03		 push	 3
  000e1	6a 00		 push	 0
  000e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000e9	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 261  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,	D3DTOP_MODULATE);

  000ee	6a 04		 push	 4
  000f0	6a 01		 push	 1
  000f2	6a 00		 push	 0
  000f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000fa	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 262  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1,	D3DTA_TEXTURE);

  000ff	6a 02		 push	 2
  00101	6a 05		 push	 5
  00103	6a 00		 push	 0
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0010b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 263  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG2,	D3DTA_DIFFUSE);

  00110	6a 00		 push	 0
  00112	6a 06		 push	 6
  00114	6a 00		 push	 0
  00116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0011c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 264  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,	D3DTOP_MODULATE);

  00121	6a 04		 push	 4
  00123	6a 04		 push	 4
  00125	6a 00		 push	 0
  00127	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0012d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 265  : 	
; 266  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_MODULATE);

  00132	6a 04		 push	 4
  00134	6a 01		 push	 1
  00136	6a 01		 push	 1
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0013e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 267  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00143	6a 02		 push	 2
  00145	6a 02		 push	 2
  00147	6a 01		 push	 1
  00149	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0014f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 268  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00154	6a 01		 push	 1
  00156	6a 03		 push	 3
  00158	6a 01		 push	 1
  0015a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00160	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 269  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);

  00165	6a 01		 push	 1
  00167	6a 0d		 push	 13			; 0000000dH
  00169	6a 01		 push	 1
  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00171	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 270  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);

  00176	6a 01		 push	 1
  00178	6a 0e		 push	 14			; 0000000eH
  0017a	6a 01		 push	 1
  0017c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00182	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 271  : 	
; 272  : 	STATEMANAGER.SaveRenderState(D3DRS_LIGHTING, FALSE);

  00187	6a 00		 push	 0
  00189	68 89 00 00 00	 push	 137			; 00000089H
  0018e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00194	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 273  : 	STATEMANAGER.SaveRenderState(D3DRS_COLORVERTEX, TRUE);

  00199	6a 01		 push	 1
  0019b	68 8d 00 00 00	 push	 141			; 0000008dH
  001a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001a6	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 274  :     STATEMANAGER.SaveRenderState(D3DRS_ALPHATESTENABLE, TRUE);

  001ab	6a 01		 push	 1
  001ad	6a 0f		 push	 15			; 0000000fH
  001af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001b5	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 275  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);

  001ba	6a 05		 push	 5
  001bc	6a 19		 push	 25			; 00000019H
  001be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c4	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 276  : 	STATEMANAGER.SaveRenderState(D3DRS_CULLMODE, D3DCULL_CW);

  001c9	6a 02		 push	 2
  001cb	6a 16		 push	 22			; 00000016H
  001cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001d3	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 277  : 	STATEMANAGER.SaveRenderState(D3DRS_FOGENABLE, FALSE);

  001d8	6a 00		 push	 0
  001da	6a 1c		 push	 28			; 0000001cH
  001dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001e2	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 278  : 	
; 279  : 	// choose fixed function pipeline or custom shader for fronds and branches
; 280  : 	STATEMANAGER.SetVertexShader(ms_dwBranchVertexShader);

  001e7	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_dwBranchVertexShader@CSpeedTreeWrapper@@0KA ; CSpeedTreeWrapper::ms_dwBranchVertexShader
  001ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001f3	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 281  : 	
; 282  : 	SetupBranchForTreeType();

  001f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001fb	e8 00 00 00 00	 call	 ?SetupBranchForTreeType@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::SetupBranchForTreeType

; 283  : 	RenderBranches();

  00200	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00203	e8 00 00 00 00	 call	 ?RenderBranches@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::RenderBranches
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterbase\Singleton.h

; 27   : 		return (*ms_singleton);

  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0020d	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 285  : 	STATEMANAGER.SetTexture(0, m_CompositeImageInstance.GetTextureReference().GetD3DTexture());

  00210	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00213	81 c1 f8 02 00
	00		 add	 ecx, 760		; 000002f8H
  00219	e8 00 00 00 00	 call	 ?GetTextureReference@CGraphicImageInstance@@QBEABVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTextureReference
  0021e	8b c8		 mov	 ecx, eax
  00220	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00225	50		 push	 eax
  00226	6a 00		 push	 0
  00228	8b 4d e8	 mov	 ecx, DWORD PTR $T1[ebp]
  0022b	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 286  : 	STATEMANAGER.SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

  00230	6a 01		 push	 1
  00232	6a 16		 push	 22			; 00000016H
  00234	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0023a	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 287  : 	
; 288  : 	SetupFrondForTreeType();

  0023f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00242	e8 00 00 00 00	 call	 ?SetupFrondForTreeType@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::SetupFrondForTreeType

; 289  : 	RenderFronds();

  00247	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0024a	e8 00 00 00 00	 call	 ?RenderFronds@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::RenderFronds

; 290  : 	
; 291  : 	STATEMANAGER.SetVertexShader(ms_dwLeafVertexShader);

  0024f	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_dwLeafVertexShader@CSpeedTreeWrapper@@0KA ; CSpeedTreeWrapper::ms_dwLeafVertexShader
  00255	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0025b	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 292  : 	
; 293  : 	SetupLeafForTreeType();

  00260	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00263	e8 00 00 00 00	 call	 ?SetupLeafForTreeType@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::SetupLeafForTreeType

; 294  : 	RenderLeaves();

  00268	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0026b	e8 00 00 00 00	 call	 ?RenderLeaves@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::RenderLeaves

; 295  : 	EndLeafForTreeType();

  00270	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00273	e8 00 00 00 00	 call	 ?EndLeafForTreeType@CSpeedTreeWrapper@@QAEXXZ ; CSpeedTreeWrapper::EndLeafForTreeType

; 296  : 	
; 297  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  00278	6a 00		 push	 0
  0027a	68 89 00 00 00	 push	 137			; 00000089H
  0027f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00285	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 298  : 	STATEMANAGER.SetRenderState(D3DRS_COLORVERTEX, FALSE);

  0028a	6a 00		 push	 0
  0028c	68 8d 00 00 00	 push	 141			; 0000008dH
  00291	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00297	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 299  : 	RenderBillboards();

  0029c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0029f	e8 00 00 00 00	 call	 ?RenderBillboards@CSpeedTreeWrapper@@QBEXXZ ; CSpeedTreeWrapper::RenderBillboards

; 300  : 	
; 301  : 	STATEMANAGER.RestoreRenderState(D3DRS_LIGHTING);

  002a4	68 89 00 00 00	 push	 137			; 00000089H
  002a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002af	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 302  : 	STATEMANAGER.RestoreRenderState(D3DRS_COLORVERTEX);

  002b4	68 8d 00 00 00	 push	 141			; 0000008dH
  002b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002bf	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 303  :     STATEMANAGER.RestoreRenderState(D3DRS_ALPHATESTENABLE);

  002c4	6a 0f		 push	 15			; 0000000fH
  002c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002cc	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 304  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHAFUNC);

  002d1	6a 19		 push	 25			; 00000019H
  002d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002d9	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 305  : 	STATEMANAGER.RestoreRenderState(D3DRS_CULLMODE);

  002de	6a 16		 push	 22			; 00000016H
  002e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002e6	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 306  : 	STATEMANAGER.RestoreRenderState(D3DRS_FOGENABLE);

  002eb	6a 1c		 push	 28			; 0000001cH
  002ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002f3	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 307  : }

  002f8	c9		 leave
  002f9	c3		 ret	 0
?OnRender@CSpeedTreeWrapper@@UAEXXZ ENDP		; CSpeedTreeWrapper::OnRender
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?CalculateBBox@CSpeedTreeWrapper@@UAEXXZ
_TEXT	SEGMENT
$T1 = -248						; size = 16
$T2 = -232						; size = 16
$T3 = -216						; size = 16
$T4 = -200						; size = 16
$T5 = -184						; size = 16
$T6 = -168						; size = 16
$T7 = -152						; size = 16
$T8 = -136						; size = 16
_c_rmatTransform$ = -120				; size = 4
_fz$ = -116						; size = 4
_fy$ = -112						; size = 4
_fx$ = -108						; size = 4
_fz$ = -104						; size = 4
_fy$ = -100						; size = 4
_fx$ = -96						; size = 4
_fz$ = -92						; size = 4
_fy$ = -88						; size = 4
_fx$ = -84						; size = 4
_fz$ = -80						; size = 4
_fy$ = -76						; size = 4
_fx$ = -72						; size = 4
_fz$ = -68						; size = 4
_fy$ = -64						; size = 4
_fx$ = -60						; size = 4
_fz$ = -56						; size = 4
_fy$ = -52						; size = 4
_fx$ = -48						; size = 4
_fz$ = -44						; size = 4
_fy$ = -40						; size = 4
_fx$ = -36						; size = 4
_fz$ = -32						; size = 4
_fy$ = -28						; size = 4
_fx$ = -24						; size = 4
_fZ$ = -20						; size = 4
_fY$ = -16						; size = 4
_fX$ = -12						; size = 4
_i$9 = -8						; size = 4
_this$ = -4						; size = 4
?CalculateBBox@CSpeedTreeWrapper@@UAEXXZ PROC		; CSpeedTreeWrapper::CalculateBBox, COMDAT
; _this$ = ecx

; 1361 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1362 : 	float fX, fY, fZ;
; 1363 : 	
; 1364 : 	fX = m_afBoundingBox[3] - m_afBoundingBox[0];

  0000e	6a 04		 push	 4
  00010	58		 pop	 eax
  00011	6b c0 03	 imul	 eax, eax, 3
  00014	6a 04		 push	 4
  00016	59		 pop	 ecx
  00017	6b c9 00	 imul	 ecx, ecx, 0
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00020	f3 0f 10 84 02
	d4 01 00 00	 movss	 xmm0, DWORD PTR [edx+eax+468]
  00029	f3 0f 5c 84 0e
	d4 01 00 00	 subss	 xmm0, DWORD PTR [esi+ecx+468]
  00032	f3 0f 11 45 f4	 movss	 DWORD PTR _fX$[ebp], xmm0

; 1365 : 	fY = m_afBoundingBox[4] - m_afBoundingBox[1];

  00037	6a 04		 push	 4
  00039	58		 pop	 eax
  0003a	c1 e0 02	 shl	 eax, 2
  0003d	6a 04		 push	 4
  0003f	59		 pop	 ecx
  00040	c1 e1 00	 shl	 ecx, 0
  00043	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00046	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00049	f3 0f 10 84 02
	d4 01 00 00	 movss	 xmm0, DWORD PTR [edx+eax+468]
  00052	f3 0f 5c 84 0e
	d4 01 00 00	 subss	 xmm0, DWORD PTR [esi+ecx+468]
  0005b	f3 0f 11 45 f0	 movss	 DWORD PTR _fY$[ebp], xmm0

; 1366 : 	fZ = m_afBoundingBox[5] - m_afBoundingBox[2];

  00060	6a 04		 push	 4
  00062	58		 pop	 eax
  00063	6b c0 05	 imul	 eax, eax, 5
  00066	6a 04		 push	 4
  00068	59		 pop	 ecx
  00069	d1 e1		 shl	 ecx, 1
  0006b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006e	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00071	f3 0f 10 84 02
	d4 01 00 00	 movss	 xmm0, DWORD PTR [edx+eax+468]
  0007a	f3 0f 5c 84 0e
	d4 01 00 00	 subss	 xmm0, DWORD PTR [esi+ecx+468]
  00083	f3 0f 11 45 ec	 movss	 DWORD PTR _fZ$[ebp], xmm0

; 1367 : 	
; 1368 : 	m_v3BBoxMin.x = -fX / 2.0f;

  00088	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fX$[ebp]
  0008d	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00094	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0009c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	f3 0f 11 80 48
	01 00 00	 movss	 DWORD PTR [eax+328], xmm0

; 1369 : 	m_v3BBoxMin.y = -fY / 2.0f;

  000a7	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fY$[ebp]
  000ac	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000b3	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000bb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000be	f3 0f 11 80 4c
	01 00 00	 movss	 DWORD PTR [eax+332], xmm0

; 1370 : 	m_v3BBoxMin.z = 0.0f;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	0f 57 c0	 xorps	 xmm0, xmm0
  000cc	f3 0f 11 80 50
	01 00 00	 movss	 DWORD PTR [eax+336], xmm0

; 1371 : 	m_v3BBoxMax.x = fX / 2.0f;

  000d4	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fX$[ebp]
  000d9	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000e1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	f3 0f 11 80 54
	01 00 00	 movss	 DWORD PTR [eax+340], xmm0

; 1372 : 	m_v3BBoxMax.y = fY / 2.0f;

  000ec	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fY$[ebp]
  000f1	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  000f9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	f3 0f 11 80 58
	01 00 00	 movss	 DWORD PTR [eax+344], xmm0

; 1373 : 	m_v3BBoxMax.z = fZ;

  00104	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00107	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fZ$[ebp]
  0010c	f3 0f 11 80 5c
	01 00 00	 movss	 DWORD PTR [eax+348], xmm0

; 1375 : 	m_v4TBBox[0] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMin.y, m_v3BBoxMin.z, 1.0f);

  00114	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00117	f3 0f 10 80 48
	01 00 00	 movss	 xmm0, DWORD PTR [eax+328]
  0011f	f3 0f 11 45 e8	 movss	 DWORD PTR _fx$[ebp], xmm0
  00124	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00127	f3 0f 10 80 4c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+332]
  0012f	f3 0f 11 45 e4	 movss	 DWORD PTR _fy$[ebp], xmm0
  00134	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00137	f3 0f 10 80 50
	01 00 00	 movss	 xmm0, DWORD PTR [eax+336]
  0013f	f3 0f 11 45 e0	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 321  :     x = fx;

  00144	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00149	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR $T8[ebp], xmm0

; 322  :     y = fy;

  00151	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00156	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR $T8[ebp+4], xmm0

; 323  :     z = fz;

  0015e	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00163	f3 0f 11 45 80	 movss	 DWORD PTR $T8[ebp+8], xmm0

; 324  :     w = fw;

  00168	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00170	f3 0f 11 45 84	 movss	 DWORD PTR $T8[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1375 : 	m_v4TBBox[0] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMin.y, m_v3BBoxMin.z, 1.0f);

  00175	6a 10		 push	 16			; 00000010H
  00177	58		 pop	 eax
  00178	6b c0 00	 imul	 eax, eax, 0
  0017b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	8d bc 01 b0 00
	00 00		 lea	 edi, DWORD PTR [ecx+eax+176]
  00185	8d b5 78 ff ff
	ff		 lea	 esi, DWORD PTR $T8[ebp]
  0018b	a5		 movsd
  0018c	a5		 movsd
  0018d	a5		 movsd
  0018e	a5		 movsd

; 1376 : 	m_v4TBBox[1] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMax.y, m_v3BBoxMin.z, 1.0f);

  0018f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00192	f3 0f 10 80 48
	01 00 00	 movss	 xmm0, DWORD PTR [eax+328]
  0019a	f3 0f 11 45 dc	 movss	 DWORD PTR _fx$[ebp], xmm0
  0019f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001a2	f3 0f 10 80 58
	01 00 00	 movss	 xmm0, DWORD PTR [eax+344]
  001aa	f3 0f 11 45 d8	 movss	 DWORD PTR _fy$[ebp], xmm0
  001af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	f3 0f 10 80 50
	01 00 00	 movss	 xmm0, DWORD PTR [eax+336]
  001ba	f3 0f 11 45 d4	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 321  :     x = fx;

  001bf	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fx$[ebp]
  001c4	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR $T7[ebp], xmm0

; 322  :     y = fy;

  001cc	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fy$[ebp]
  001d1	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR $T7[ebp+4], xmm0

; 323  :     z = fz;

  001d9	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _fz$[ebp]
  001de	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR $T7[ebp+8], xmm0

; 324  :     w = fw;

  001e6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001ee	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR $T7[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1376 : 	m_v4TBBox[1] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMax.y, m_v3BBoxMin.z, 1.0f);

  001f6	6a 10		 push	 16			; 00000010H
  001f8	58		 pop	 eax
  001f9	c1 e0 00	 shl	 eax, 0
  001fc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ff	8d bc 01 b0 00
	00 00		 lea	 edi, DWORD PTR [ecx+eax+176]
  00206	8d b5 68 ff ff
	ff		 lea	 esi, DWORD PTR $T7[ebp]
  0020c	a5		 movsd
  0020d	a5		 movsd
  0020e	a5		 movsd
  0020f	a5		 movsd

; 1377 : 	m_v4TBBox[2] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMin.y, m_v3BBoxMin.z, 1.0f);

  00210	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00213	f3 0f 10 80 54
	01 00 00	 movss	 xmm0, DWORD PTR [eax+340]
  0021b	f3 0f 11 45 d0	 movss	 DWORD PTR _fx$[ebp], xmm0
  00220	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00223	f3 0f 10 80 4c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+332]
  0022b	f3 0f 11 45 cc	 movss	 DWORD PTR _fy$[ebp], xmm0
  00230	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00233	f3 0f 10 80 50
	01 00 00	 movss	 xmm0, DWORD PTR [eax+336]
  0023b	f3 0f 11 45 c8	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 321  :     x = fx;

  00240	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00245	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR $T6[ebp], xmm0

; 322  :     y = fy;

  0024d	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00252	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR $T6[ebp+4], xmm0

; 323  :     z = fz;

  0025a	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0025f	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR $T6[ebp+8], xmm0

; 324  :     w = fw;

  00267	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0026f	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR $T6[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1377 : 	m_v4TBBox[2] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMin.y, m_v3BBoxMin.z, 1.0f);

  00277	6a 10		 push	 16			; 00000010H
  00279	58		 pop	 eax
  0027a	d1 e0		 shl	 eax, 1
  0027c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0027f	8d bc 01 b0 00
	00 00		 lea	 edi, DWORD PTR [ecx+eax+176]
  00286	8d b5 58 ff ff
	ff		 lea	 esi, DWORD PTR $T6[ebp]
  0028c	a5		 movsd
  0028d	a5		 movsd
  0028e	a5		 movsd
  0028f	a5		 movsd

; 1378 : 	m_v4TBBox[3] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMax.y, m_v3BBoxMin.z, 1.0f);

  00290	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00293	f3 0f 10 80 54
	01 00 00	 movss	 xmm0, DWORD PTR [eax+340]
  0029b	f3 0f 11 45 c4	 movss	 DWORD PTR _fx$[ebp], xmm0
  002a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002a3	f3 0f 10 80 58
	01 00 00	 movss	 xmm0, DWORD PTR [eax+344]
  002ab	f3 0f 11 45 c0	 movss	 DWORD PTR _fy$[ebp], xmm0
  002b0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002b3	f3 0f 10 80 50
	01 00 00	 movss	 xmm0, DWORD PTR [eax+336]
  002bb	f3 0f 11 45 bc	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 321  :     x = fx;

  002c0	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002c5	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR $T5[ebp], xmm0

; 322  :     y = fy;

  002cd	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002d2	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR $T5[ebp+4], xmm0

; 323  :     z = fz;

  002da	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002df	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR $T5[ebp+8], xmm0

; 324  :     w = fw;

  002e7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002ef	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR $T5[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1378 : 	m_v4TBBox[3] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMax.y, m_v3BBoxMin.z, 1.0f);

  002f7	6a 10		 push	 16			; 00000010H
  002f9	58		 pop	 eax
  002fa	6b c0 03	 imul	 eax, eax, 3
  002fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00300	8d bc 01 b0 00
	00 00		 lea	 edi, DWORD PTR [ecx+eax+176]
  00307	8d b5 48 ff ff
	ff		 lea	 esi, DWORD PTR $T5[ebp]
  0030d	a5		 movsd
  0030e	a5		 movsd
  0030f	a5		 movsd
  00310	a5		 movsd

; 1379 : 	m_v4TBBox[4] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMin.y, m_v3BBoxMax.z, 1.0f);

  00311	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00314	f3 0f 10 80 48
	01 00 00	 movss	 xmm0, DWORD PTR [eax+328]
  0031c	f3 0f 11 45 b8	 movss	 DWORD PTR _fx$[ebp], xmm0
  00321	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00324	f3 0f 10 80 4c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+332]
  0032c	f3 0f 11 45 b4	 movss	 DWORD PTR _fy$[ebp], xmm0
  00331	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00334	f3 0f 10 80 5c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+348]
  0033c	f3 0f 11 45 b0	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 321  :     x = fx;

  00341	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00346	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR $T4[ebp], xmm0

; 322  :     y = fy;

  0034e	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00353	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR $T4[ebp+4], xmm0

; 323  :     z = fz;

  0035b	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00360	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR $T4[ebp+8], xmm0

; 324  :     w = fw;

  00368	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00370	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR $T4[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1379 : 	m_v4TBBox[4] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMin.y, m_v3BBoxMax.z, 1.0f);

  00378	6a 10		 push	 16			; 00000010H
  0037a	58		 pop	 eax
  0037b	c1 e0 02	 shl	 eax, 2
  0037e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00381	8d bc 01 b0 00
	00 00		 lea	 edi, DWORD PTR [ecx+eax+176]
  00388	8d b5 38 ff ff
	ff		 lea	 esi, DWORD PTR $T4[ebp]
  0038e	a5		 movsd
  0038f	a5		 movsd
  00390	a5		 movsd
  00391	a5		 movsd

; 1380 : 	m_v4TBBox[5] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMax.y, m_v3BBoxMax.z, 1.0f);

  00392	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00395	f3 0f 10 80 48
	01 00 00	 movss	 xmm0, DWORD PTR [eax+328]
  0039d	f3 0f 11 45 ac	 movss	 DWORD PTR _fx$[ebp], xmm0
  003a2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003a5	f3 0f 10 80 58
	01 00 00	 movss	 xmm0, DWORD PTR [eax+344]
  003ad	f3 0f 11 45 a8	 movss	 DWORD PTR _fy$[ebp], xmm0
  003b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003b5	f3 0f 10 80 5c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+348]
  003bd	f3 0f 11 45 a4	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 321  :     x = fx;

  003c2	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fx$[ebp]
  003c7	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR $T3[ebp], xmm0

; 322  :     y = fy;

  003cf	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _fy$[ebp]
  003d4	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 323  :     z = fz;

  003dc	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _fz$[ebp]
  003e1	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR $T3[ebp+8], xmm0

; 324  :     w = fw;

  003e9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003f1	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR $T3[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1380 : 	m_v4TBBox[5] = D3DXVECTOR4(m_v3BBoxMin.x, m_v3BBoxMax.y, m_v3BBoxMax.z, 1.0f);

  003f9	6a 10		 push	 16			; 00000010H
  003fb	58		 pop	 eax
  003fc	6b c0 05	 imul	 eax, eax, 5
  003ff	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00402	8d bc 01 b0 00
	00 00		 lea	 edi, DWORD PTR [ecx+eax+176]
  00409	8d b5 28 ff ff
	ff		 lea	 esi, DWORD PTR $T3[ebp]
  0040f	a5		 movsd
  00410	a5		 movsd
  00411	a5		 movsd
  00412	a5		 movsd

; 1381 : 	m_v4TBBox[6] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMin.y, m_v3BBoxMax.z, 1.0f);

  00413	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00416	f3 0f 10 80 54
	01 00 00	 movss	 xmm0, DWORD PTR [eax+340]
  0041e	f3 0f 11 45 a0	 movss	 DWORD PTR _fx$[ebp], xmm0
  00423	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00426	f3 0f 10 80 4c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+332]
  0042e	f3 0f 11 45 9c	 movss	 DWORD PTR _fy$[ebp], xmm0
  00433	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00436	f3 0f 10 80 5c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+348]
  0043e	f3 0f 11 45 98	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 321  :     x = fx;

  00443	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00448	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR $T2[ebp], xmm0

; 322  :     y = fy;

  00450	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00455	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 323  :     z = fz;

  0045d	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00462	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR $T2[ebp+8], xmm0

; 324  :     w = fw;

  0046a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00472	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR $T2[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1381 : 	m_v4TBBox[6] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMin.y, m_v3BBoxMax.z, 1.0f);

  0047a	6a 10		 push	 16			; 00000010H
  0047c	58		 pop	 eax
  0047d	6b c0 06	 imul	 eax, eax, 6
  00480	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00483	8d bc 01 b0 00
	00 00		 lea	 edi, DWORD PTR [ecx+eax+176]
  0048a	8d b5 18 ff ff
	ff		 lea	 esi, DWORD PTR $T2[ebp]
  00490	a5		 movsd
  00491	a5		 movsd
  00492	a5		 movsd
  00493	a5		 movsd

; 1382 : 	m_v4TBBox[7] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMax.y, m_v3BBoxMax.z, 1.0f);

  00494	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00497	f3 0f 10 80 54
	01 00 00	 movss	 xmm0, DWORD PTR [eax+340]
  0049f	f3 0f 11 45 94	 movss	 DWORD PTR _fx$[ebp], xmm0
  004a4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004a7	f3 0f 10 80 58
	01 00 00	 movss	 xmm0, DWORD PTR [eax+344]
  004af	f3 0f 11 45 90	 movss	 DWORD PTR _fy$[ebp], xmm0
  004b4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  004b7	f3 0f 10 80 5c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+348]
  004bf	f3 0f 11 45 8c	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 321  :     x = fx;

  004c4	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _fx$[ebp]
  004c9	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR $T1[ebp], xmm0

; 322  :     y = fy;

  004d1	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _fy$[ebp]
  004d6	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 323  :     z = fz;

  004de	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _fz$[ebp]
  004e3	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR $T1[ebp+8], xmm0

; 324  :     w = fw;

  004eb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  004f3	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR $T1[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1382 : 	m_v4TBBox[7] = D3DXVECTOR4(m_v3BBoxMax.x, m_v3BBoxMax.y, m_v3BBoxMax.z, 1.0f);

  004fb	6a 10		 push	 16			; 00000010H
  004fd	58		 pop	 eax
  004fe	6b c0 07	 imul	 eax, eax, 7
  00501	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00504	8d bc 01 b0 00
	00 00		 lea	 edi, DWORD PTR [ecx+eax+176]
  0050b	8d b5 08 ff ff
	ff		 lea	 esi, DWORD PTR $T1[ebp]
  00511	a5		 movsd
  00512	a5		 movsd
  00513	a5		 movsd
  00514	a5		 movsd

; 1383 : 	
; 1384 : 	const D3DXMATRIX & c_rmatTransform = GetTransform();

  00515	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00518	e8 00 00 00 00	 call	 ?GetTransform@CGraphicObjectInstance@@QAEAAUD3DXMATRIX@@XZ ; CGraphicObjectInstance::GetTransform
  0051d	89 45 88	 mov	 DWORD PTR _c_rmatTransform$[ebp], eax

; 1385 : 	
; 1386 : 	for (DWORD i = 0; i < 8; ++i)

  00520	83 65 f8 00	 and	 DWORD PTR _i$9[ebp], 0
  00524	eb 07		 jmp	 SHORT $LN4@CalculateB
$LN2@CalculateB:
  00526	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  00529	40		 inc	 eax
  0052a	89 45 f8	 mov	 DWORD PTR _i$9[ebp], eax
$LN4@CalculateB:
  0052d	83 7d f8 08	 cmp	 DWORD PTR _i$9[ebp], 8
  00531	0f 83 1e 02 00
	00		 jae	 $LN3@CalculateB

; 1387 : 	{
; 1388 : 		D3DXVec4Transform(&m_v4TBBox[i], &m_v4TBBox[i], &c_rmatTransform);

  00537	ff 75 88	 push	 DWORD PTR _c_rmatTransform$[ebp]
  0053a	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  0053d	c1 e0 04	 shl	 eax, 4
  00540	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00543	8d 84 01 b0 00
	00 00		 lea	 eax, DWORD PTR [ecx+eax+176]
  0054a	50		 push	 eax
  0054b	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  0054e	c1 e0 04	 shl	 eax, 4
  00551	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00554	8d 84 01 b0 00
	00 00		 lea	 eax, DWORD PTR [ecx+eax+176]
  0055b	50		 push	 eax
  0055c	e8 00 00 00 00	 call	 _D3DXVec4Transform@12

; 1389 : 		if (0 == i)

  00561	83 7d f8 00	 cmp	 DWORD PTR _i$9[ebp], 0
  00565	0f 85 9b 00 00
	00		 jne	 $LN5@CalculateB

; 1390 : 		{
; 1391 : 			m_v3TBBoxMin.x = m_v4TBBox[i].x;

  0056b	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  0056e	c1 e0 04	 shl	 eax, 4
  00571	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00574	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00577	8b 84 02 b0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+176]
  0057e	89 81 30 01 00
	00		 mov	 DWORD PTR [ecx+304], eax

; 1392 : 			m_v3TBBoxMin.y = m_v4TBBox[i].y;

  00584	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  00587	c1 e0 04	 shl	 eax, 4
  0058a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0058d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00590	8b 84 02 b4 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+180]
  00597	89 81 34 01 00
	00		 mov	 DWORD PTR [ecx+308], eax

; 1393 : 			m_v3TBBoxMin.z = m_v4TBBox[i].z;

  0059d	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  005a0	c1 e0 04	 shl	 eax, 4
  005a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005a6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005a9	8b 84 02 b8 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+184]
  005b0	89 81 38 01 00
	00		 mov	 DWORD PTR [ecx+312], eax

; 1394 : 			m_v3TBBoxMax.x = m_v4TBBox[i].x;

  005b6	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  005b9	c1 e0 04	 shl	 eax, 4
  005bc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005bf	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005c2	8b 84 02 b0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+176]
  005c9	89 81 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], eax

; 1395 : 			m_v3TBBoxMax.y = m_v4TBBox[i].y;

  005cf	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  005d2	c1 e0 04	 shl	 eax, 4
  005d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005d8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005db	8b 84 02 b4 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+180]
  005e2	89 81 40 01 00
	00		 mov	 DWORD PTR [ecx+320], eax

; 1396 : 			m_v3TBBoxMax.z = m_v4TBBox[i].z;

  005e8	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  005eb	c1 e0 04	 shl	 eax, 4
  005ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  005f1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  005f4	8b 84 02 b8 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+184]
  005fb	89 81 44 01 00
	00		 mov	 DWORD PTR [ecx+324], eax

; 1397 : 		}

  00601	e9 4a 01 00 00	 jmp	 $LN12@CalculateB
$LN5@CalculateB:

; 1398 : 		else
; 1399 : 		{
; 1400 : 			if (m_v3TBBoxMin.x > m_v4TBBox[i].x)

  00606	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  00609	c1 e0 04	 shl	 eax, 4
  0060c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0060f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00612	f3 0f 10 81 30
	01 00 00	 movss	 xmm0, DWORD PTR [ecx+304]
  0061a	0f 2f 84 02 b0
	00 00 00	 comiss	 xmm0, DWORD PTR [edx+eax+176]
  00622	76 19		 jbe	 SHORT $LN7@CalculateB

; 1401 : 				m_v3TBBoxMin.x = m_v4TBBox[i].x;

  00624	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  00627	c1 e0 04	 shl	 eax, 4
  0062a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0062d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00630	8b 84 02 b0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+176]
  00637	89 81 30 01 00
	00		 mov	 DWORD PTR [ecx+304], eax
$LN7@CalculateB:

; 1402 : 			if (m_v3TBBoxMax.x < m_v4TBBox[i].x)

  0063d	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  00640	c1 e0 04	 shl	 eax, 4
  00643	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00646	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00649	f3 0f 10 84 01
	b0 00 00 00	 movss	 xmm0, DWORD PTR [ecx+eax+176]
  00652	0f 2f 82 3c 01
	00 00		 comiss	 xmm0, DWORD PTR [edx+316]
  00659	76 19		 jbe	 SHORT $LN8@CalculateB

; 1403 : 				m_v3TBBoxMax.x = m_v4TBBox[i].x;

  0065b	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  0065e	c1 e0 04	 shl	 eax, 4
  00661	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00664	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00667	8b 84 02 b0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+176]
  0066e	89 81 3c 01 00
	00		 mov	 DWORD PTR [ecx+316], eax
$LN8@CalculateB:

; 1404 : 			if (m_v3TBBoxMin.y > m_v4TBBox[i].y)

  00674	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  00677	c1 e0 04	 shl	 eax, 4
  0067a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0067d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00680	f3 0f 10 81 34
	01 00 00	 movss	 xmm0, DWORD PTR [ecx+308]
  00688	0f 2f 84 02 b4
	00 00 00	 comiss	 xmm0, DWORD PTR [edx+eax+180]
  00690	76 19		 jbe	 SHORT $LN9@CalculateB

; 1405 : 				m_v3TBBoxMin.y = m_v4TBBox[i].y;

  00692	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  00695	c1 e0 04	 shl	 eax, 4
  00698	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0069b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0069e	8b 84 02 b4 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+180]
  006a5	89 81 34 01 00
	00		 mov	 DWORD PTR [ecx+308], eax
$LN9@CalculateB:

; 1406 : 			if (m_v3TBBoxMax.y < m_v4TBBox[i].y)

  006ab	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  006ae	c1 e0 04	 shl	 eax, 4
  006b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006b4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  006b7	f3 0f 10 84 01
	b4 00 00 00	 movss	 xmm0, DWORD PTR [ecx+eax+180]
  006c0	0f 2f 82 40 01
	00 00		 comiss	 xmm0, DWORD PTR [edx+320]
  006c7	76 19		 jbe	 SHORT $LN10@CalculateB

; 1407 : 				m_v3TBBoxMax.y = m_v4TBBox[i].y;

  006c9	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  006cc	c1 e0 04	 shl	 eax, 4
  006cf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006d2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  006d5	8b 84 02 b4 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+180]
  006dc	89 81 40 01 00
	00		 mov	 DWORD PTR [ecx+320], eax
$LN10@CalculateB:

; 1408 : 			if (m_v3TBBoxMin.z > m_v4TBBox[i].z)

  006e2	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  006e5	c1 e0 04	 shl	 eax, 4
  006e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  006eb	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  006ee	f3 0f 10 81 38
	01 00 00	 movss	 xmm0, DWORD PTR [ecx+312]
  006f6	0f 2f 84 02 b8
	00 00 00	 comiss	 xmm0, DWORD PTR [edx+eax+184]
  006fe	76 19		 jbe	 SHORT $LN11@CalculateB

; 1409 : 				m_v3TBBoxMin.z = m_v4TBBox[i].z;

  00700	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  00703	c1 e0 04	 shl	 eax, 4
  00706	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00709	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0070c	8b 84 02 b8 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+184]
  00713	89 81 38 01 00
	00		 mov	 DWORD PTR [ecx+312], eax
$LN11@CalculateB:

; 1410 : 			if (m_v3TBBoxMax.z < m_v4TBBox[i].z)

  00719	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  0071c	c1 e0 04	 shl	 eax, 4
  0071f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00722	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00725	f3 0f 10 84 01
	b8 00 00 00	 movss	 xmm0, DWORD PTR [ecx+eax+184]
  0072e	0f 2f 82 44 01
	00 00		 comiss	 xmm0, DWORD PTR [edx+324]
  00735	76 19		 jbe	 SHORT $LN12@CalculateB

; 1411 : 				m_v3TBBoxMax.z = m_v4TBBox[i].z;

  00737	8b 45 f8	 mov	 eax, DWORD PTR _i$9[ebp]
  0073a	c1 e0 04	 shl	 eax, 4
  0073d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00740	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00743	8b 84 02 b8 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+184]
  0074a	89 81 44 01 00
	00		 mov	 DWORD PTR [ecx+324], eax
$LN12@CalculateB:

; 1412 : 		}
; 1413 : 	}	

  00750	e9 d1 fd ff ff	 jmp	 $LN2@CalculateB
$LN3@CalculateB:

; 1414 : }

  00755	5f		 pop	 edi
  00756	5e		 pop	 esi
  00757	c9		 leave
  00758	c3		 ret	 0
?CalculateBBox@CSpeedTreeWrapper@@UAEXXZ ENDP		; CSpeedTreeWrapper::CalculateBBox
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?SetPosition@CSpeedTreeWrapper@@UAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetPosition@CSpeedTreeWrapper@@UAEXMMM@Z PROC		; CSpeedTreeWrapper::SetPosition, COMDAT
; _this$ = ecx

; 1331 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1332 : 	m_afPos[0] = x;

  00007	6a 04		 push	 4
  00009	58		 pop	 eax
  0000a	6b c0 00	 imul	 eax, eax, 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  00015	f3 0f 11 84 01
	c8 01 00 00	 movss	 DWORD PTR [ecx+eax+456], xmm0

; 1333 : 	m_afPos[1] = y;

  0001e	6a 04		 push	 4
  00020	58		 pop	 eax
  00021	c1 e0 00	 shl	 eax, 0
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  0002c	f3 0f 11 84 01
	c8 01 00 00	 movss	 DWORD PTR [ecx+eax+456], xmm0

; 1334 : 	m_afPos[2] = z;

  00035	6a 04		 push	 4
  00037	58		 pop	 eax
  00038	d1 e0		 shl	 eax, 1
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  00042	f3 0f 11 84 01
	c8 01 00 00	 movss	 DWORD PTR [ecx+eax+456], xmm0

; 1335 : 	m_pSpeedTree->SetTreePosition(x, y, z);

  0004b	51		 push	 ecx
  0004c	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  00051	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00056	51		 push	 ecx
  00057	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  0005c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00061	51		 push	 ecx
  00062	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  00067	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  00075	e8 00 00 00 00	 call	 ?SetTreePosition@CSpeedTreeRT@@QAEXMMM@Z ; CSpeedTreeRT::SetTreePosition

; 1336 : 	CGraphicObjectInstance::SetPosition(x, y, z);

  0007a	51		 push	 ecx
  0007b	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  00080	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00085	51		 push	 ecx
  00086	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  0008b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00090	51		 push	 ecx
  00091	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  00096	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ?SetPosition@CGraphicObjectInstance@@QAEXMMM@Z ; CGraphicObjectInstance::SetPosition

; 1337 : }

  000a3	c9		 leave
  000a4	c2 0c 00	 ret	 12			; 0000000cH
?SetPosition@CSpeedTreeWrapper@@UAEXMMM@Z ENDP		; CSpeedTreeWrapper::SetPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?GetBoundingSphere@CSpeedTreeWrapper@@UAE_NAAUD3DXVECTOR3@@AAM@Z
_TEXT	SEGMENT
tv237 = -44						; size = 4
tv236 = -40						; size = 4
_fX$ = -36						; size = 4
_fY$ = -32						; size = 4
_pf$ = -28						; size = 4
_fZ$ = -24						; size = 4
_this$ = -20						; size = 4
_vec$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_v3Center$ = 8						; size = 4
_fRadius$ = 12						; size = 4
?GetBoundingSphere@CSpeedTreeWrapper@@UAE_NAAUD3DXVECTOR3@@AAM@Z PROC ; CSpeedTreeWrapper::GetBoundingSphere, COMDAT
; _this$ = ecx

; 1340 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1341 : 	float fX, fY, fZ;
; 1342 : 	
; 1343 : 	fX = m_afBoundingBox[3] - m_afBoundingBox[0];

  00014	6a 04		 push	 4
  00016	58		 pop	 eax
  00017	6b c0 03	 imul	 eax, eax, 3
  0001a	6a 04		 push	 4
  0001c	59		 pop	 ecx
  0001d	6b c9 00	 imul	 ecx, ecx, 0
  00020	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00023	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00026	f3 0f 10 84 02
	d4 01 00 00	 movss	 xmm0, DWORD PTR [edx+eax+468]
  0002f	f3 0f 5c 84 0e
	d4 01 00 00	 subss	 xmm0, DWORD PTR [esi+ecx+468]
  00038	f3 0f 11 45 dc	 movss	 DWORD PTR _fX$[ebp], xmm0

; 1344 : 	fY = m_afBoundingBox[4] - m_afBoundingBox[1];

  0003d	6a 04		 push	 4
  0003f	58		 pop	 eax
  00040	c1 e0 02	 shl	 eax, 2
  00043	6a 04		 push	 4
  00045	59		 pop	 ecx
  00046	c1 e1 00	 shl	 ecx, 0
  00049	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  0004f	f3 0f 10 84 02
	d4 01 00 00	 movss	 xmm0, DWORD PTR [edx+eax+468]
  00058	f3 0f 5c 84 0e
	d4 01 00 00	 subss	 xmm0, DWORD PTR [esi+ecx+468]
  00061	f3 0f 11 45 e0	 movss	 DWORD PTR _fY$[ebp], xmm0

; 1345 : 	fZ = m_afBoundingBox[5] - m_afBoundingBox[2];

  00066	6a 04		 push	 4
  00068	58		 pop	 eax
  00069	6b c0 05	 imul	 eax, eax, 5
  0006c	6a 04		 push	 4
  0006e	59		 pop	 ecx
  0006f	d1 e1		 shl	 ecx, 1
  00071	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00074	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  00077	f3 0f 10 84 02
	d4 01 00 00	 movss	 xmm0, DWORD PTR [edx+eax+468]
  00080	f3 0f 5c 84 0e
	d4 01 00 00	 subss	 xmm0, DWORD PTR [esi+ecx+468]
  00089	f3 0f 11 45 e8	 movss	 DWORD PTR _fZ$[ebp], xmm0

; 1346 : 	
; 1347 : 	v3Center.x = 0.0f;

  0008e	8b 45 08	 mov	 eax, DWORD PTR _v3Center$[ebp]
  00091	0f 57 c0	 xorps	 xmm0, xmm0
  00094	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1348 : 	v3Center.y = 0.0f;

  00098	8b 45 08	 mov	 eax, DWORD PTR _v3Center$[ebp]
  0009b	0f 57 c0	 xorps	 xmm0, xmm0
  0009e	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 1349 : 	v3Center.z = fZ * 0.5f;

  000a3	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fZ$[ebp]
  000a8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  000b0	8b 45 08	 mov	 eax, DWORD PTR _v3Center$[ebp]
  000b3	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 1351 : 	fRadius = sqrtf(fX * fX + fY * fY + fZ * fZ) * 0.5f * 0.9f; // 0.9f for reduce size

  000b8	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fZ$[ebp]
  000bd	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _fZ$[ebp]
  000c2	f3 0f 10 4d e0	 movss	 xmm1, DWORD PTR _fY$[ebp]
  000c7	f3 0f 59 4d e0	 mulss	 xmm1, DWORD PTR _fY$[ebp]
  000cc	f3 0f 10 55 dc	 movss	 xmm2, DWORD PTR _fX$[ebp]
  000d1	f3 0f 59 55 dc	 mulss	 xmm2, DWORD PTR _fX$[ebp]
  000d6	f3 0f 58 d1	 addss	 xmm2, xmm1
  000da	f3 0f 58 d0	 addss	 xmm2, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  000de	f3 0f 5a c2	 cvtss2sd xmm0, xmm2
  000e2	51		 push	 ecx
  000e3	51		 push	 ecx
  000e4	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000e9	e8 00 00 00 00	 call	 _sqrt
  000ee	59		 pop	 ecx
  000ef	59		 pop	 ecx
  000f0	d9 5d d8	 fstp	 DWORD PTR tv236[ebp]
  000f3	d9 45 d8	 fld	 DWORD PTR tv236[ebp]
  000f6	d9 5d d4	 fstp	 DWORD PTR tv237[ebp]
  000f9	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR tv237[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1351 : 	fRadius = sqrtf(fX * fX + fY * fY + fZ * fZ) * 0.5f * 0.9f; // 0.9f for reduce size

  000fe	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00106	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f666666
  0010e	8b 45 0c	 mov	 eax, DWORD PTR _fRadius$[ebp]
  00111	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1352 : 	
; 1353 : 	D3DXVECTOR3 vec = m_pSpeedTree->GetTreePosition();

  00115	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00118	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR [eax+380]
  0011e	e8 00 00 00 00	 call	 ?GetTreePosition@CSpeedTreeRT@@QBEPBMXZ ; CSpeedTreeRT::GetTreePosition
  00123	89 45 e4	 mov	 DWORD PTR _pf$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 164  :     x = pf[0];

  00126	6a 04		 push	 4
  00128	58		 pop	 eax
  00129	6b c0 00	 imul	 eax, eax, 0
  0012c	8b 4d e4	 mov	 ecx, DWORD PTR _pf$[ebp]
  0012f	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00134	f3 0f 11 45 f0	 movss	 DWORD PTR _vec$[ebp], xmm0

; 165  :     y = pf[1];

  00139	6a 04		 push	 4
  0013b	58		 pop	 eax
  0013c	c1 e0 00	 shl	 eax, 0
  0013f	8b 4d e4	 mov	 ecx, DWORD PTR _pf$[ebp]
  00142	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00147	f3 0f 11 45 f4	 movss	 DWORD PTR _vec$[ebp+4], xmm0

; 166  :     z = pf[2];

  0014c	6a 04		 push	 4
  0014e	58		 pop	 eax
  0014f	d1 e0		 shl	 eax, 1
  00151	8b 4d e4	 mov	 ecx, DWORD PTR _pf$[ebp]
  00154	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00159	f3 0f 11 45 f8	 movss	 DWORD PTR _vec$[ebp+8], xmm0

; 204  :     x += v.x;

  0015e	8b 45 08	 mov	 eax, DWORD PTR _v3Center$[ebp]
  00161	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00165	f3 0f 58 45 f0	 addss	 xmm0, DWORD PTR _vec$[ebp]
  0016a	8b 45 08	 mov	 eax, DWORD PTR _v3Center$[ebp]
  0016d	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 205  :     y += v.y;

  00171	8b 45 08	 mov	 eax, DWORD PTR _v3Center$[ebp]
  00174	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00179	f3 0f 58 45 f4	 addss	 xmm0, DWORD PTR _vec$[ebp+4]
  0017e	8b 45 08	 mov	 eax, DWORD PTR _v3Center$[ebp]
  00181	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 206  :     z += v.z;

  00186	8b 45 08	 mov	 eax, DWORD PTR _v3Center$[ebp]
  00189	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0018e	f3 0f 58 45 f8	 addss	 xmm0, DWORD PTR _vec$[ebp+8]
  00193	8b 45 08	 mov	 eax, DWORD PTR _v3Center$[ebp]
  00196	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp

; 1357 : 	return true;

  0019b	b0 01		 mov	 al, 1

; 1358 : }

  0019d	5e		 pop	 esi
  0019e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a1	33 cd		 xor	 ecx, ebp
  001a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a8	c9		 leave
  001a9	c2 08 00	 ret	 8
?GetBoundingSphere@CSpeedTreeWrapper@@UAE_NAAUD3DXVECTOR3@@AAM@Z ENDP ; CSpeedTreeWrapper::GetBoundingSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.h
;	COMDAT ?OnGetObjectHeight@CSpeedTreeWrapper@@MAE_NMMPAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
_pfHeight$ = 16						; size = 4
?OnGetObjectHeight@CSpeedTreeWrapper@@MAE_NMMPAM@Z PROC	; CSpeedTreeWrapper::OnGetObjectHeight, COMDAT
; _this$ = ecx

; 77   : 	virtual bool OnGetObjectHeight(float fX, float fY, float * pfHeight) { return false; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	32 c0		 xor	 al, al
  00009	c9		 leave
  0000a	c2 0c 00	 ret	 12			; 0000000cH
?OnGetObjectHeight@CSpeedTreeWrapper@@MAE_NMMPAM@Z ENDP	; CSpeedTreeWrapper::OnGetObjectHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.h
;	COMDAT ?OnUpdateHeighInstance@CSpeedTreeWrapper@@MAEXPAVCAttributeInstance@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pAttributeInstance$ = 8				; size = 4
?OnUpdateHeighInstance@CSpeedTreeWrapper@@MAEXPAVCAttributeInstance@@@Z PROC ; CSpeedTreeWrapper::OnUpdateHeighInstance, COMDAT
; _this$ = ecx

; 76   : 	virtual void OnUpdateHeighInstance(CAttributeInstance * pAttributeInstance) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 04 00	 ret	 4
?OnUpdateHeighInstance@CSpeedTreeWrapper@@MAEXPAVCAttributeInstance@@@Z ENDP ; CSpeedTreeWrapper::OnUpdateHeighInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?OnUpdateCollisionData@CSpeedTreeWrapper@@MAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z
_TEXT	SEGMENT
tv89 = -48						; size = 4
_ObjectType$1 = -44					; size = 4
_i$2 = -40						; size = 4
_this$ = -36						; size = 4
_mat$ = -32						; size = 64
_CollisionData$3 = 32					; size = 80
__$ArrayPad$ = 112					; size = 4
___formal$ = 124					; size = 4
?OnUpdateCollisionData@CSpeedTreeWrapper@@MAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z PROC ; CSpeedTreeWrapper::OnUpdateCollisionData, COMDAT
; _this$ = ecx

; 1442 : {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 70	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 1443 : 	D3DXMATRIX mat;
; 1444 : 	D3DXMatrixTranslation(&mat, m_afPos[0], m_afPos[1], m_afPos[2]);

  00018	6a 04		 push	 4
  0001a	58		 pop	 eax
  0001b	d1 e0		 shl	 eax, 1
  0001d	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	51		 push	 ecx
  00021	f3 0f 10 84 01
	c8 01 00 00	 movss	 xmm0, DWORD PTR [ecx+eax+456]
  0002a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002f	6a 04		 push	 4
  00031	58		 pop	 eax
  00032	c1 e0 00	 shl	 eax, 0
  00035	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	51		 push	 ecx
  00039	f3 0f 10 84 01
	c8 01 00 00	 movss	 xmm0, DWORD PTR [ecx+eax+456]
  00042	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00047	6a 04		 push	 4
  00049	58		 pop	 eax
  0004a	6b c0 00	 imul	 eax, eax, 0
  0004d	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	51		 push	 ecx
  00051	f3 0f 10 84 01
	c8 01 00 00	 movss	 xmm0, DWORD PTR [ecx+eax+456]
  0005a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005f	8d 45 e0	 lea	 eax, DWORD PTR _mat$[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16

; 1445 : 	
; 1446 : 	/////
; 1447 : 	for (UINT i = 0; i < GetCollisionObjectCount(); ++i)

  00068	83 65 d8 00	 and	 DWORD PTR _i$2[ebp], 0
  0006c	eb 07		 jmp	 SHORT $LN4@OnUpdateCo
$LN2@OnUpdateCo:
  0006e	8b 45 d8	 mov	 eax, DWORD PTR _i$2[ebp]
  00071	40		 inc	 eax
  00072	89 45 d8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@OnUpdateCo:
  00075	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?GetCollisionObjectCount@CSpeedTreeWrapper@@QAEIXZ ; CSpeedTreeWrapper::GetCollisionObjectCount
  0007d	39 45 d8	 cmp	 DWORD PTR _i$2[ebp], eax
  00080	0f 83 94 00 00
	00		 jae	 $LN3@OnUpdateCo

; 1448 : 	{
; 1449 : 		CSpeedTreeRT::ECollisionObjectType ObjectType;
; 1450 : 		CStaticCollisionData CollisionData;
; 1451 : 		
; 1452 : 		GetCollisionObject(i, ObjectType, (float * )&CollisionData.v3Position, CollisionData.fDimensions);

  00086	8d 45 54	 lea	 eax, DWORD PTR _CollisionData$3[ebp+52]
  00089	50		 push	 eax
  0008a	8d 45 48	 lea	 eax, DWORD PTR _CollisionData$3[ebp+40]
  0008d	50		 push	 eax
  0008e	8d 45 d4	 lea	 eax, DWORD PTR _ObjectType$1[ebp]
  00091	50		 push	 eax
  00092	ff 75 d8	 push	 DWORD PTR _i$2[ebp]
  00095	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ?GetCollisionObject@CSpeedTreeWrapper@@QAEXIAAW4ECollisionObjectType@CSpeedTreeRT@@PAM1@Z ; CSpeedTreeWrapper::GetCollisionObject

; 1453 : 		
; 1454 : 		if (ObjectType == CSpeedTreeRT::CO_BOX)

  0009d	83 7d d4 02	 cmp	 DWORD PTR _ObjectType$1[ebp], 2
  000a1	75 02		 jne	 SHORT $LN7@OnUpdateCo

; 1455 : 			continue;

  000a3	eb c9		 jmp	 SHORT $LN2@OnUpdateCo
$LN7@OnUpdateCo:

; 1456 : 		
; 1457 : 		switch(ObjectType)

  000a5	8b 45 d4	 mov	 eax, DWORD PTR _ObjectType$1[ebp]
  000a8	89 45 d0	 mov	 DWORD PTR tv89[ebp], eax
  000ab	83 7d d0 00	 cmp	 DWORD PTR tv89[ebp], 0
  000af	74 08		 je	 SHORT $LN8@OnUpdateCo
  000b1	83 7d d0 01	 cmp	 DWORD PTR tv89[ebp], 1
  000b5	74 1f		 je	 SHORT $LN9@OnUpdateCo
  000b7	eb 4c		 jmp	 SHORT $LN5@OnUpdateCo
$LN8@OnUpdateCo:

; 1458 : 		{
; 1459 : 		case CSpeedTreeRT::CO_SPHERE:
; 1460 : 			CollisionData.dwType = COLLISION_TYPE_SPHERE;

  000b9	c7 45 20 02 00
	00 00		 mov	 DWORD PTR _CollisionData$3[ebp], 2

; 1461 : 			CollisionData.fDimensions[0] = CollisionData.fDimensions[0] /** fSizeRatio*/;

  000c0	6a 04		 push	 4
  000c2	58		 pop	 eax
  000c3	6b c0 00	 imul	 eax, eax, 0
  000c6	6a 04		 push	 4
  000c8	59		 pop	 ecx
  000c9	6b c9 00	 imul	 ecx, ecx, 0
  000cc	8b 44 05 54	 mov	 eax, DWORD PTR _CollisionData$3[ebp+eax+52]
  000d0	89 44 0d 54	 mov	 DWORD PTR _CollisionData$3[ebp+ecx+52], eax

; 1462 : 			//AddCollision(&CollisionData);
; 1463 : 			break;

  000d4	eb 2f		 jmp	 SHORT $LN5@OnUpdateCo
$LN9@OnUpdateCo:

; 1464 : 			
; 1465 : 		case CSpeedTreeRT::CO_CYLINDER:
; 1466 : 			CollisionData.dwType = COLLISION_TYPE_CYLINDER;

  000d6	c7 45 20 03 00
	00 00		 mov	 DWORD PTR _CollisionData$3[ebp], 3

; 1467 : 			CollisionData.fDimensions[0] = CollisionData.fDimensions[0] /** fSizeRatio*/;

  000dd	6a 04		 push	 4
  000df	58		 pop	 eax
  000e0	6b c0 00	 imul	 eax, eax, 0
  000e3	6a 04		 push	 4
  000e5	59		 pop	 ecx
  000e6	6b c9 00	 imul	 ecx, ecx, 0
  000e9	8b 44 05 54	 mov	 eax, DWORD PTR _CollisionData$3[ebp+eax+52]
  000ed	89 44 0d 54	 mov	 DWORD PTR _CollisionData$3[ebp+ecx+52], eax

; 1468 : 			CollisionData.fDimensions[1] = CollisionData.fDimensions[1] /** fSizeRatio*/;

  000f1	6a 04		 push	 4
  000f3	58		 pop	 eax
  000f4	c1 e0 00	 shl	 eax, 0
  000f7	6a 04		 push	 4
  000f9	59		 pop	 ecx
  000fa	c1 e1 00	 shl	 ecx, 0
  000fd	8b 44 05 54	 mov	 eax, DWORD PTR _CollisionData$3[ebp+eax+52]
  00101	89 44 0d 54	 mov	 DWORD PTR _CollisionData$3[ebp+ecx+52], eax
$LN5@OnUpdateCo:

; 1469 : 			//AddCollision(&CollisionData);
; 1470 : 			break;
; 1471 : 			
; 1472 : 			/*case CSpeedTreeRT::CO_BOX:
; 1473 : 			break;*/
; 1474 : 		}
; 1475 : 		AddCollision(&CollisionData, &mat);

  00105	8d 45 e0	 lea	 eax, DWORD PTR _mat$[ebp]
  00108	50		 push	 eax
  00109	8d 45 20	 lea	 eax, DWORD PTR _CollisionData$3[ebp]
  0010c	50		 push	 eax
  0010d	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00110	e8 00 00 00 00	 call	 ?AddCollision@CGraphicObjectInstance@@QAEXPBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z ; CGraphicObjectInstance::AddCollision

; 1476 : 	}

  00115	e9 54 ff ff ff	 jmp	 $LN2@OnUpdateCo
$LN3@OnUpdateCo:

; 1477 : }

  0011a	8b 4d 70	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011d	33 cd		 xor	 ecx, ebp
  0011f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00124	83 c5 74	 add	 ebp, 116		; 00000074H
  00127	c9		 leave
  00128	c2 04 00	 ret	 4
?OnUpdateCollisionData@CSpeedTreeWrapper@@MAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z ENDP ; CSpeedTreeWrapper::OnUpdateCollisionData
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.h
;	COMDAT ?GetType@CSpeedTreeWrapper@@EBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetType@CSpeedTreeWrapper@@EBEHXZ PROC			; CSpeedTreeWrapper::GetType, COMDAT
; _this$ = ecx

; 71   : 	int GetType() const { return ID; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 a6 f7 c9 8a	 mov	 eax, -1966475354	; 8ac9f7a6H
  0000c	c9		 leave
  0000d	c3		 ret	 0
?GetType@CSpeedTreeWrapper@@EBEHXZ ENDP			; CSpeedTreeWrapper::GetType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\GrpObjectInstance.h
;	COMDAT ?OnDeform@CGraphicObjectInstance@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnDeform@CGraphicObjectInstance@@UAEXXZ PROC		; CGraphicObjectInstance::OnDeform, COMDAT
; _this$ = ecx

; 99   : 		virtual void			OnDeform(){}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?OnDeform@CGraphicObjectInstance@@UAEXXZ ENDP		; CGraphicObjectInstance::OnDeform
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\GrpObjectInstance.h
;	COMDAT ?OnUpdate@CGraphicObjectInstance@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnUpdate@CGraphicObjectInstance@@UAEXXZ PROC		; CGraphicObjectInstance::OnUpdate, COMDAT
; _this$ = ecx

; 98   : 		virtual void			OnUpdate(){}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?OnUpdate@CGraphicObjectInstance@@UAEXXZ ENDP		; CGraphicObjectInstance::OnUpdate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\GrpObjectInstance.h
;	COMDAT ?OnClear@CGraphicObjectInstance@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnClear@CGraphicObjectInstance@@UAEXXZ PROC		; CGraphicObjectInstance::OnClear, COMDAT
; _this$ = ecx

; 97   : 		virtual void			OnClear(){}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?OnClear@CGraphicObjectInstance@@UAEXXZ ENDP		; CGraphicObjectInstance::OnClear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\filename.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\filename.h
;	COMDAT ?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z
_TEXT	SEGMENT
__Alproxy$2 = -36					; size = 4
_this$ = -32						; size = 4
_npos$ = -28						; size = 4
_this$3 = -24						; size = 4
$T4 = -20						; size = 4
_$S8$5 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_str$ = 12						; size = 4
?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z PROC ; CFileNameHelper::NoExtension, COMDAT

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	83 65 ec 00	 and	 DWORD PTR $T4[ebp], 0

; 215  : 	std::size_t npos = str.find_last_of('.');

  00029	6a ff		 push	 -1
  0002b	6a 2e		 push	 46			; 0000002eH
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _str$[ebp]
  00030	e8 00 00 00 00	 call	 ?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of
  00035	89 45 e4	 mov	 DWORD PTR _npos$[ebp], eax

; 216  : 
; 217  : 	if (string::npos != npos)

  00038	83 7d e4 ff	 cmp	 DWORD PTR _npos$[ebp], -1
  0003c	74 4e		 je	 SHORT $LN2@NoExtensio
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

  0003e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00041	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00044	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e8	 mov	 DWORD PTR _this$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  0004a	8b 45 e8	 mov	 eax, DWORD PTR _this$3[ebp]
  0004d	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00051	8b 45 e8	 mov	 eax, DWORD PTR _this$3[ebp]
  00054	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

  00058	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2387 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0005c	8d 45 f3	 lea	 eax, DWORD PTR _$S8$5[ebp]
  0005f	89 45 dc	 mov	 DWORD PTR __Alproxy$2[ebp], eax

; 2388 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2389 :         _Tidy_init();

  00062	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00065	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2390 :         assign(_Right, _Roff, _Count);

  0006a	ff 75 e4	 push	 DWORD PTR _npos$[ebp]
  0006d	6a 00		 push	 0
  0006f	ff 75 0c	 push	 DWORD PTR _str$[ebp]
  00072	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00075	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2391 :         _Proxy._Release();
; 2392 :     }

  0007a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\filename.h

; 218  : 		return std::string(str, 0, npos);

  0007e	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00081	83 c8 01	 or	 eax, 1
  00084	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
  00087	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0008a	eb 17		 jmp	 SHORT $LN1@NoExtensio
$LN2@NoExtensio:

; 219  : 
; 220  : 	return str;

  0008c	ff 75 0c	 push	 DWORD PTR _str$[ebp]
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00092	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00097	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  0009a	83 c8 01	 or	 eax, 1
  0009d	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
  000a0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@NoExtensio:

; 221  : }

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ad	59		 pop	 ecx
  000ae	c9		 leave
  000af	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z$9:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ENDP ; CFileNameHelper::NoExtension
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\filename.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\filename.h
;	COMDAT ?GetPath@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z
_TEXT	SEGMENT
$T1 = -128						; size = 4
$T2 = -124						; size = 4
_nLength$ = -120					; size = 4
$T3 = -116						; size = 4
_j$4 = -112						; size = 4
_i$5 = -108						; size = 4
_szPath$ = -104						; size = 1024
__$ArrayPad$ = 920					; size = 4
___$ReturnUdt$ = 932					; size = 4
_str$ = 936						; size = 4
?GetPath@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z PROC ; CFileNameHelper::GetPath, COMDAT

; 184  : {

  00000	55		 push	 ebp
  00001	8d ac 24 64 fc
	ff ff		 lea	 ebp, DWORD PTR [esp-924]
  00008	81 ec 1c 04 00
	00		 sub	 esp, 1052		; 0000041cH
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 98 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	83 65 80 00	 and	 DWORD PTR $T1[ebp], 0

; 185  : 	char szPath[1024];
; 186  : 	szPath[0] = '\0';

  0001f	33 c0		 xor	 eax, eax
  00021	40		 inc	 eax
  00022	6b c0 00	 imul	 eax, eax, 0
  00025	89 45 8c	 mov	 DWORD PTR $T3[ebp], eax
  00028	81 7d 8c 00 04
	00 00		 cmp	 DWORD PTR $T3[ebp], 1024 ; 00000400H
  0002f	73 02		 jae	 SHORT $LN13@GetPath
  00031	eb 05		 jmp	 SHORT $LN14@GetPath
$LN13@GetPath:
  00033	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN14@GetPath:
  00038	8b 45 8c	 mov	 eax, DWORD PTR $T3[ebp]
  0003b	c6 44 05 98 00	 mov	 BYTE PTR _szPath$[ebp+eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  00040	8b 85 a8 03 00
	00		 mov	 eax, DWORD PTR _str$[ebp]
  00046	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00049	89 45 88	 mov	 DWORD PTR _nLength$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\filename.h

; 190  : 	if (nLength > 0)

  0004c	83 7d 88 00	 cmp	 DWORD PTR _nLength$[ebp], 0
  00050	0f 86 a3 00 00
	00		 jbe	 $LN8@GetPath

; 191  : 	{
; 192  : 		for (size_t i = nLength - 1; i > 0; i--)

  00056	8b 45 88	 mov	 eax, DWORD PTR _nLength$[ebp]
  00059	48		 dec	 eax
  0005a	89 45 94	 mov	 DWORD PTR _i$5[ebp], eax
  0005d	eb 07		 jmp	 SHORT $LN4@GetPath
$LN2@GetPath:
  0005f	8b 45 94	 mov	 eax, DWORD PTR _i$5[ebp]
  00062	48		 dec	 eax
  00063	89 45 94	 mov	 DWORD PTR _i$5[ebp], eax
$LN4@GetPath:
  00066	83 7d 94 00	 cmp	 DWORD PTR _i$5[ebp], 0
  0006a	0f 86 89 00 00
	00		 jbe	 $LN8@GetPath

; 193  : 		{
; 194  : 			if (str[i] == '/' || str[i] == '\\')

  00070	ff 75 94	 push	 DWORD PTR _i$5[ebp]
  00073	8b 8d a8 03 00
	00		 mov	 ecx, DWORD PTR _str$[ebp]
  00079	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  0007e	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00081	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00084	74 16		 je	 SHORT $LN10@GetPath
  00086	ff 75 94	 push	 DWORD PTR _i$5[ebp]
  00089	8b 8d a8 03 00
	00		 mov	 ecx, DWORD PTR _str$[ebp]
  0008f	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00094	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00097	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0009a	75 50		 jne	 SHORT $LN9@GetPath
$LN10@GetPath:

; 195  : 			{
; 196  : 				for (size_t j = 0; j < i + 1; j++)

  0009c	83 65 90 00	 and	 DWORD PTR _j$4[ebp], 0
  000a0	eb 07		 jmp	 SHORT $LN7@GetPath
$LN5@GetPath:
  000a2	8b 45 90	 mov	 eax, DWORD PTR _j$4[ebp]
  000a5	40		 inc	 eax
  000a6	89 45 90	 mov	 DWORD PTR _j$4[ebp], eax
$LN7@GetPath:
  000a9	8b 45 94	 mov	 eax, DWORD PTR _i$5[ebp]
  000ac	40		 inc	 eax
  000ad	39 45 90	 cmp	 DWORD PTR _j$4[ebp], eax
  000b0	73 19		 jae	 SHORT $LN6@GetPath

; 197  : 					szPath[j] = str[j];

  000b2	ff 75 90	 push	 DWORD PTR _j$4[ebp]
  000b5	8b 8d a8 03 00
	00		 mov	 ecx, DWORD PTR _str$[ebp]
  000bb	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  000c0	8b 4d 90	 mov	 ecx, DWORD PTR _j$4[ebp]
  000c3	8a 00		 mov	 al, BYTE PTR [eax]
  000c5	88 44 0d 98	 mov	 BYTE PTR _szPath$[ebp+ecx], al
  000c9	eb d7		 jmp	 SHORT $LN5@GetPath
$LN6@GetPath:

; 198  : 				szPath[i+1] = '\0';

  000cb	8b 45 94	 mov	 eax, DWORD PTR _i$5[ebp]
  000ce	40		 inc	 eax
  000cf	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
  000d2	81 7d 84 00 04
	00 00		 cmp	 DWORD PTR $T2[ebp], 1024 ; 00000400H
  000d9	73 02		 jae	 SHORT $LN15@GetPath
  000db	eb 05		 jmp	 SHORT $LN16@GetPath
$LN15@GetPath:
  000dd	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN16@GetPath:
  000e2	8b 45 84	 mov	 eax, DWORD PTR $T2[ebp]
  000e5	c6 44 05 98 00	 mov	 BYTE PTR _szPath$[ebp+eax], 0

; 199  : 				break;

  000ea	eb 0d		 jmp	 SHORT $LN8@GetPath
$LN9@GetPath:

; 200  : 			}
; 201  : 
; 202  : 			if (0 == i)

  000ec	83 7d 94 00	 cmp	 DWORD PTR _i$5[ebp], 0
  000f0	75 02		 jne	 SHORT $LN11@GetPath

; 203  : 				break;

  000f2	eb 05		 jmp	 SHORT $LN8@GetPath
$LN11@GetPath:

; 204  : 		}

  000f4	e9 66 ff ff ff	 jmp	 $LN2@GetPath
$LN8@GetPath:

; 205  : 	}
; 206  : 	return szPath;

  000f9	8d 45 98	 lea	 eax, DWORD PTR _szPath$[ebp]
  000fc	50		 push	 eax
  000fd	8b 8d a4 03 00
	00		 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00103	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00108	8b 45 80	 mov	 eax, DWORD PTR $T1[ebp]
  0010b	83 c8 01	 or	 eax, 1
  0010e	89 45 80	 mov	 DWORD PTR $T1[ebp], eax
  00111	8b 85 a4 03 00
	00		 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN12@GetPath:

; 207  : }

  00117	8b 8d 98 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011d	33 cd		 xor	 ecx, ebp
  0011f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00124	81 c5 9c 03 00
	00		 add	 ebp, 924		; 0000039cH
  0012a	c9		 leave
  0012b	c3		 ret	 0
?GetPath@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ENDP ; CFileNameHelper::GetPath
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv75 = -12						; size = 4
$T3 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4284 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 0f	 or	 eax, 15			; 0000000fH
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  00012	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4287 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 46		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0001f	d1 e8		 shr	 eax, 1
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4291 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 32		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003e	3b 45 f8	 cmp	 eax, DWORD PTR $T3[ebp]
  00041	73 08		 jae	 SHORT $LN7@Calculate_
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00046	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00049	eb 06		 jmp	 SHORT $LN8@Calculate_
$LN7@Calculate_:
  0004b	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  0004e	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
$LN8@Calculate_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00057	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4295 :     }

  00062	c9		 leave
  00063	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
__Ptr$ = -64						; size = 4
$T3 = -60						; size = 4
tv135 = -56						; size = 4
tv133 = -52						; size = 4
__Start_at$ = -48					; size = 4
$T4 = -44						; size = 4
__Hay_size$ = -40					; size = 4
_this$ = -36						; size = 4
__Result$5 = -32					; size = 4
tv88 = -28						; size = 4
$T6 = -24						; size = 4
_this$ = -20						; size = 4
__Match_try$7 = -16					; size = 4
$T8 = -9						; size = 1
__Ch$ = -8						; size = 1
$T9 = -1						; size = 1
__Ch$ = 8						; size = 1
__Off$ = 12						; size = 4
?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of, COMDAT
; _this$ = ecx

; 4079 :     _NODISCARD size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 4080 :         // look for _Ch before _Off
; 4081 :         return static_cast<size_type>(

  00009	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 e0	 mov	 DWORD PTR __Result$5[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@find_last_
  0001e	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@find_last_
$LN9@find_last_:
  00027	83 65 e4 00	 and	 DWORD PTR tv88[ebp], 0
$LN10@find_last_:
  0002b	8a 45 e4	 mov	 al, BYTE PTR tv88[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T9[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T9[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@find_last_

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 c0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 c0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 e0	 mov	 DWORD PTR __Result$5[ebp], eax
$LN4@find_last_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 e0	 mov	 eax, DWORD PTR __Result$5[ebp]
  0004a	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax

; 4080 :         // look for _Ch before _Off
; 4081 :         return static_cast<size_type>(

  0004d	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  00050	88 45 f8	 mov	 BYTE PTR __Ch$[ebp], al
  00053	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00056	89 45 d0	 mov	 DWORD PTR __Start_at$[ebp], eax
  00059	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005f	89 45 d8	 mov	 DWORD PTR __Hay_size$[ebp], eax

; 661  :     if (_Hay_size != 0) { // room for match, look for it

  00062	83 7d d8 00	 cmp	 DWORD PTR __Hay_size$[ebp], 0
  00066	74 7d		 je	 SHORT $LN19@find_last_

; 662  :         for (auto _Match_try = _Haystack + (_STD min)(_Start_at, _Hay_size - 1);; --_Match_try) {

  00068	8b 45 d8	 mov	 eax, DWORD PTR __Hay_size$[ebp]
  0006b	48		 dec	 eax
  0006c	89 45 d4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0006f	8b 45 d4	 mov	 eax, DWORD PTR $T4[ebp]
  00072	3b 45 d0	 cmp	 eax, DWORD PTR __Start_at$[ebp]
  00075	73 08		 jae	 SHORT $LN26@find_last_
  00077	8d 45 d4	 lea	 eax, DWORD PTR $T4[ebp]
  0007a	89 45 cc	 mov	 DWORD PTR tv133[ebp], eax
  0007d	eb 06		 jmp	 SHORT $LN27@find_last_
$LN26@find_last_:
  0007f	8d 45 d0	 lea	 eax, DWORD PTR __Start_at$[ebp]
  00082	89 45 cc	 mov	 DWORD PTR tv133[ebp], eax
$LN27@find_last_:
  00085	8b 45 cc	 mov	 eax, DWORD PTR tv133[ebp]
  00088	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
  0008b	8b 45 bc	 mov	 eax, DWORD PTR $T2[ebp]
  0008e	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 662  :         for (auto _Match_try = _Haystack + (_STD min)(_Start_at, _Hay_size - 1);; --_Match_try) {

  00091	8b 45 b8	 mov	 eax, DWORD PTR $T1[ebp]
  00094	8b 4d e8	 mov	 ecx, DWORD PTR $T6[ebp]
  00097	03 08		 add	 ecx, DWORD PTR [eax]
  00099	89 4d f0	 mov	 DWORD PTR __Match_try$7[ebp], ecx
  0009c	eb 07		 jmp	 SHORT $LN18@find_last_
$LN16@find_last_:
  0009e	8b 45 f0	 mov	 eax, DWORD PTR __Match_try$7[ebp]
  000a1	48		 dec	 eax
  000a2	89 45 f0	 mov	 DWORD PTR __Match_try$7[ebp], eax
$LN18@find_last_:

; 432  :         return _Left == _Right;

  000a5	8b 45 f0	 mov	 eax, DWORD PTR __Match_try$7[ebp]
  000a8	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000ab	0f be 4d f8	 movsx	 ecx, BYTE PTR __Ch$[ebp]
  000af	3b c1		 cmp	 eax, ecx
  000b1	75 09		 jne	 SHORT $LN31@find_last_
  000b3	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR tv135[ebp], 1
  000ba	eb 04		 jmp	 SHORT $LN32@find_last_
$LN31@find_last_:
  000bc	83 65 c8 00	 and	 DWORD PTR tv135[ebp], 0
$LN32@find_last_:
  000c0	8a 45 c8	 mov	 al, BYTE PTR tv135[ebp]
  000c3	88 45 f7	 mov	 BYTE PTR $T8[ebp], al

; 663  :             if (_Traits::eq(*_Match_try, _Ch)) {

  000c6	0f b6 45 f7	 movzx	 eax, BYTE PTR $T8[ebp]
  000ca	85 c0		 test	 eax, eax
  000cc	74 0b		 je	 SHORT $LN20@find_last_

; 664  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  000ce	8b 45 f0	 mov	 eax, DWORD PTR __Match_try$7[ebp]
  000d1	2b 45 e8	 sub	 eax, DWORD PTR $T6[ebp]
  000d4	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
  000d7	eb 10		 jmp	 SHORT $LN22@find_last_
$LN20@find_last_:

; 665  :             }
; 666  : 
; 667  :             if (_Match_try == _Haystack) {

  000d9	8b 45 f0	 mov	 eax, DWORD PTR __Match_try$7[ebp]
  000dc	3b 45 e8	 cmp	 eax, DWORD PTR $T6[ebp]
  000df	75 02		 jne	 SHORT $LN21@find_last_

; 668  :                 break; // at beginning, no more chance for match

  000e1	eb 02		 jmp	 SHORT $LN19@find_last_
$LN21@find_last_:

; 669  :             }
; 670  :         }

  000e3	eb b9		 jmp	 SHORT $LN16@find_last_
$LN19@find_last_:

; 671  :     }
; 672  : 
; 673  :     return static_cast<size_t>(-1); // no match

  000e5	83 4d c4 ff	 or	 DWORD PTR $T3[ebp], -1
$LN22@find_last_:

; 4080 :         // look for _Ch before _Off
; 4081 :         return static_cast<size_type>(

  000e9	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]

; 4082 :             _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
; 4083 :     }

  000ec	c9		 leave
  000ed	c2 08 00	 ret	 8
?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv82 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 3670 :     _NODISCARD reference operator[](const size_type _Off) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3671 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3672 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3673 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3674 :         return _Mypair._Myval2._Myptr()[_Off];

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2209 :         value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@operator
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00027	83 65 f4 00	 and	 DWORD PTR tv82[ebp], 0
$LN10@operator:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv82[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@operator

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3671 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3672 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3673 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3674 :         return _Mypair._Myval2._Myptr()[_Off];

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00050	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]

; 3675 :     }

  00053	c9		 leave
  00054	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T1 = -44						; size = 4
__Ptr$ = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
__Result$4 = -28					; size = 4
tv128 = -24						; size = 4
tv89 = -20						; size = 4
__Size$ = -16						; size = 4
$T5 = -12						; size = 4
_this$ = -8						; size = 4
$T6 = -1						; size = 1
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3020 :     basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 2231 :         if (_Mysize < _Off) {

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  00012	73 05		 jae	 SHORT $LN5@assign

; 2232 :             _Xran();

  00014	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN5@assign:

; 3021 :         // assign _Right [_Roff, _Roff + _Count)
; 3022 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 3023 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);

  00019	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 f0	 mov	 DWORD PTR __Size$[ebp], eax

; 2248 :         return (_STD min)(_Size, _Mysize - _Off);

  0001f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00022	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00025	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0002b	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  0002e	3b 45 f0	 cmp	 eax, DWORD PTR __Size$[ebp]
  00031	73 08		 jae	 SHORT $LN12@assign
  00033	8d 45 f4	 lea	 eax, DWORD PTR $T5[ebp]
  00036	89 45 ec	 mov	 DWORD PTR tv89[ebp], eax
  00039	eb 06		 jmp	 SHORT $LN13@assign
$LN12@assign:
  0003b	8d 45 f0	 lea	 eax, DWORD PTR __Size$[ebp]
  0003e	89 45 ec	 mov	 DWORD PTR tv89[ebp], eax
$LN13@assign:
  00041	8b 45 ec	 mov	 eax, DWORD PTR tv89[ebp]
  00044	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
  00047	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  0004a	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2248 :         return (_STD min)(_Size, _Mysize - _Off);

  0004d	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 3024 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00055	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00058	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	89 45 e4	 mov	 DWORD PTR __Result$4[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00068	72 09		 jb	 SHORT $LN21@assign
  0006a	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv128[ebp], 1
  00071	eb 04		 jmp	 SHORT $LN22@assign
$LN21@assign:
  00073	83 65 e8 00	 and	 DWORD PTR tv128[ebp], 0
$LN22@assign:
  00077	8a 45 e8	 mov	 al, BYTE PTR tv128[ebp]
  0007a	88 45 ff	 mov	 BYTE PTR $T6[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0007d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T6[ebp]
  00081	85 c0		 test	 eax, eax
  00083	74 0e		 je	 SHORT $LN16@assign

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0008d	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00090	89 45 e4	 mov	 DWORD PTR __Result$4[ebp], eax
$LN16@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00093	8b 45 e4	 mov	 eax, DWORD PTR __Result$4[ebp]
  00096	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 3024 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00099	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  0009c	8b 45 d4	 mov	 eax, DWORD PTR $T1[ebp]
  0009f	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  000a2	50		 push	 eax
  000a3	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN6@assign:

; 3025 :     }

  000ab	c9		 leave
  000ac	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -24						; size = 1
__First1$ = -20						; size = 4
__Old_ptr$2 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2935 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2936 :         // append [_Ptr, _Ptr + _Count)
; 2937 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 2938 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 49		 ja	 SHORT $LN2@append

; 2939 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00023	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2940 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 2941 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8b 45 f0	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  0003a	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR __First1$[ebp], eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00046	ff 75 ec	 push	 DWORD PTR __First1$[ebp]
  00049	e8 00 00 00 00	 call	 _memmove
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2942 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00051	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00055	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00058	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]

; 428  :         _Left = _Right;

  0005b	8b 4d f0	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  0005e	8a 55 ff	 mov	 dl, BYTE PTR $T3[ebp]
  00061	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2943 :             return *this;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	eb 19		 jmp	 SHORT $LN1@append
$LN2@append:

; 2944 :         }
; 2945 : 
; 2946 :         return _Reallocate_grow_by(

  00069	33 c0		 xor	 eax, eax
  0006b	88 45 e8	 mov	 BYTE PTR $T1[ebp], al
  0006e	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00071	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00074	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00077	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 2947 :             _Count,
; 2948 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2949 :                 const size_type _Count) {
; 2950 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2953 :             },
; 2954 :             _Ptr, _Count);
; 2955 :     }

  00082	c9		 leave
  00083	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Al$ = -72						; size = 4
$T1 = -68						; size = 4
__Ptr$ = -64						; size = 4
$T2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
__First1$ = -48						; size = 4
__New_capacity$ = -44					; size = 4
__Right_ptr$ = -40					; size = 4
__New_array$ = -36					; size = 4
tv138 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
__Right_data$ = -20					; size = 4
_this$ = -16						; size = 4
__Right_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$7 = -1				; size = 1
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2728 :     void _Construct_lv_contents(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2729 :         // assign by copying data stored in _Right
; 2730 :         // pre: this != &_Right
; 2731 :         // pre: *this owns no memory, iterators orphaned (note:
; 2732 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2733 :         auto& _Right_data             = _Right._Mypair._Myval2;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __Right_data$[ebp], eax

; 2734 :         const size_type _Right_size   = _Right_data._Mysize;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax

; 2735 :         const _Elem* const _Right_ptr = _Right_data._Myptr();

  00018	8b 4d ec	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00020	89 45 d8	 mov	 DWORD PTR __Right_ptr$[ebp], eax

; 2736 :         auto& _My_data                = _Mypair._Myval2;

  00023	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2737 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00029	83 7d f4 10	 cmp	 DWORD PTR __Right_size$[ebp], 16 ; 00000010H
  0002d	73 2e		 jae	 SHORT $LN2@Construct_

; 2738 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00032	89 45 d0	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00035	6a 10		 push	 16			; 00000010H
  00037	ff 75 d8	 push	 DWORD PTR __Right_ptr$[ebp]
  0003a	ff 75 d0	 push	 DWORD PTR __First1$[ebp]
  0003d	e8 00 00 00 00	 call	 _memcpy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2739 :             _My_data._Mysize = _Right_size;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  0004b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2740 :             _My_data._Myres  = _BUF_SIZE - 1;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00051	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 2741 :             return;

  00058	e9 9b 00 00 00	 jmp	 $LN1@Construct_
$LN2@Construct_:

; 4409 :         return _Mypair._Get_first();

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00060	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00063	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  00066	89 45 b8	 mov	 DWORD PTR __Al$[ebp], eax

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  00069	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00071	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
  00074	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00077	83 c8 0f	 or	 eax, 15			; 0000000fH
  0007a	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0007d	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  00080	3b 45 e4	 cmp	 eax, DWORD PTR $T5[ebp]
  00083	73 08		 jae	 SHORT $LN52@Construct_
  00085	8d 45 e8	 lea	 eax, DWORD PTR $T6[ebp]
  00088	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
  0008b	eb 06		 jmp	 SHORT $LN53@Construct_
$LN52@Construct_:
  0008d	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  00090	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
$LN53@Construct_:
  00093	8b 45 e0	 mov	 eax, DWORD PTR tv138[ebp]
  00096	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
  00099	8b 45 c8	 mov	 eax, DWORD PTR $T3[ebp]
  0009c	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0009f	8b 45 c4	 mov	 eax, DWORD PTR $T2[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	89 45 d4	 mov	 DWORD PTR __New_capacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000a7	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$7[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000ab	8b 45 d4	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  000ae	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000b5	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000b6	89 45 dc	 mov	 DWORD PTR __New_array$[ebp], eax

; 2747 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  000b9	8d 45 dc	 lea	 eax, DWORD PTR __New_array$[ebp]
  000bc	50		 push	 eax
  000bd	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  000c0	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c5	59		 pop	 ecx
  000c6	59		 pop	 ecx

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000c7	8b 45 dc	 mov	 eax, DWORD PTR __New_array$[ebp]
  000ca	89 45 c0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000cd	8b 45 c0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000d0	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000d3	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  000d6	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d7	50		 push	 eax
  000d8	ff 75 d8	 push	 DWORD PTR __Right_ptr$[ebp]
  000db	ff 75 bc	 push	 DWORD PTR $T1[ebp]
  000de	e8 00 00 00 00	 call	 _memcpy
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2749 :         _My_data._Mysize = _Right_size;

  000e6	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  000ec	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2750 :         _My_data._Myres  = _New_capacity;

  000ef	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000f2	8b 4d d4	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000f5	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN1@Construct_:

; 2751 :     }

  000f8	c9		 leave
  000f9	c2 04 00	 ret	 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__My_data_mem$ = -12					; size = 4
__Right_data_mem$ = -8					; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT
; _this$ = ecx

; 2678 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2679 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2680 :         const auto _My_data_mem =

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR __My_data_mem$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  0000f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	89 45 f8	 mov	 DWORD PTR __Right_data_mem$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00015	6a 18		 push	 24			; 00000018H
  00017	ff 75 f8	 push	 DWORD PTR __Right_data_mem$[ebp]
  0001a	ff 75 f4	 push	 DWORD PTR __My_data_mem$[ebp]
  0001d	e8 00 00 00 00	 call	 _memcpy
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2685 :     }

  00025	c9		 leave
  00026	c2 04 00	 ret	 4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
_TEXT	SEGMENT
$T2 = -156						; size = 4
__Alproxy$ = -152					; size = 4
$T3 = -148						; size = 4
$T4 = -144						; size = 4
$T5 = -140						; size = 4
__First1$ = -136					; size = 4
$T6 = -132						; size = 4
__Ptr$ = -128						; size = 4
$T7 = -124						; size = 4
__Ptr$ = -120						; size = 4
__Ptr$ = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
__Ptr$ = -96						; size = 4
__First1$ = -92						; size = 4
__Ptr$ = -88						; size = 4
__My_data_mem$12 = -84					; size = 4
__Right_data_mem$13 = -80				; size = 4
$T14 = -76						; size = 4
$T15 = -72						; size = 4
__First1$ = -68						; size = 4
$T16 = -64						; size = 4
__Ptr$17 = -60						; size = 4
__Ptr$ = -56						; size = 4
__Ptr$ = -52						; size = 4
_this$ = -48						; size = 4
$T18 = -44						; size = 4
__Ptr$ = -40						; size = 4
__Result$19 = -36					; size = 4
tv391 = -32						; size = 4
__Result$20 = -28					; size = 4
tv349 = -24						; size = 4
__Fancyptr$ = -20					; size = 4
tv338 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T21 = 0						; size = 4
__Result$22 = 4						; size = 4
tv320 = 8						; size = 4
__Right_capacity$ = 12					; size = 4
__Result$23 = 16					; size = 4
tv301 = 20						; size = 4
__Result$24 = 24					; size = 4
tv292 = 28						; size = 4
__Left_capacity$ = 32					; size = 4
__Masked$25 = 36					; size = 4
__Ptr$26 = 40						; size = 4
__Overflow_is_possible$27 = 46				; size = 1
_$S10$ = 47						; size = 1
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
__New_capacity$ = 56					; size = 4
__New_size$ = 60					; size = 4
__Max$ = 64						; size = 4
__Right_size$ = 68					; size = 4
$T28 = 74						; size = 1
$T29 = 75						; size = 1
$T30 = 76						; size = 1
$T31 = 77						; size = 1
__Fits_in_right$ = 78					; size = 1
$T32 = 79						; size = 1
$T33 = 80						; size = 1
$T34 = 81						; size = 1
$T35 = 82						; size = 1
__Fits_in_left$ = 83					; size = 1
_this$ = 84						; size = 4
__Right_data$ = 88					; size = 4
__Left_data$ = 92					; size = 4
__Left_size$ = 96					; size = 4
__My_data$ = 100					; size = 4
tv156 = 106						; size = 1
tv128 = 107						; size = 1
___formal$ = 116					; size = 1
__Left$ = 120						; size = 4
__Right$ = 124						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2547 :         : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {

  00000	55		 push	 ebp
  00001	8d 6c 24 94	 lea	 ebp, DWORD PTR [esp-108]
  00005	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	89 4d 54	 mov	 DWORD PTR _this$[ebp], ecx

; 4409 :         return _Mypair._Get_first();

  00030	8b 45 78	 mov	 eax, DWORD PTR __Left$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00033	89 45 d4	 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00036	8b 45 d4	 mov	 eax, DWORD PTR $T18[ebp]
  00039	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax

; 2547 :         : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {

  0003f	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  00042	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00045	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2547 :         : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {

  0004d	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2548 :         auto& _My_data    = _Mypair._Myval2;

  00051	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  00054	89 45 64	 mov	 DWORD PTR __My_data$[ebp], eax

; 2549 :         auto& _Left_data  = _Left._Mypair._Myval2;

  00057	8b 45 78	 mov	 eax, DWORD PTR __Left$[ebp]
  0005a	89 45 5c	 mov	 DWORD PTR __Left_data$[ebp], eax

; 2550 :         auto& _Right_data = _Right._Mypair._Myval2;

  0005d	8b 45 7c	 mov	 eax, DWORD PTR __Right$[ebp]
  00060	89 45 58	 mov	 DWORD PTR __Right_data$[ebp], eax

; 2551 :         _Left_data._Orphan_all();
; 2552 :         _Right_data._Orphan_all();
; 2553 :         const auto _Left_size  = _Left_data._Mysize;

  00063	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  00066	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00069	89 45 60	 mov	 DWORD PTR __Left_size$[ebp], eax

; 2554 :         const auto _Right_size = _Right_data._Mysize;

  0006c	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  0006f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00072	89 45 44	 mov	 DWORD PTR __Right_size$[ebp], eax

; 2555 : 
; 2556 :         const auto _Left_capacity  = _Left_data._Myres;

  00075	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  00078	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0007b	89 45 20	 mov	 DWORD PTR __Left_capacity$[ebp], eax

; 2557 :         const auto _Right_capacity = _Right_data._Myres;

  0007e	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00081	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00084	89 45 0c	 mov	 DWORD PTR __Right_capacity$[ebp], eax

; 2558 :         // overflow is OK due to max_size() checks:
; 2559 :         const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);

  00087	8b 45 60	 mov	 eax, DWORD PTR __Left_size$[ebp]
  0008a	03 45 44	 add	 eax, DWORD PTR __Right_size$[ebp]
  0008d	89 45 3c	 mov	 DWORD PTR __New_size$[ebp], eax

; 2560 :         const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;

  00090	8b 45 20	 mov	 eax, DWORD PTR __Left_capacity$[ebp]
  00093	2b 45 60	 sub	 eax, DWORD PTR __Left_size$[ebp]
  00096	39 45 44	 cmp	 DWORD PTR __Right_size$[ebp], eax
  00099	77 06		 ja	 SHORT $LN6@basic_stri
  0009b	c6 45 6b 01	 mov	 BYTE PTR tv128[ebp], 1
  0009f	eb 04		 jmp	 SHORT $LN7@basic_stri
$LN6@basic_stri:
  000a1	c6 45 6b 00	 mov	 BYTE PTR tv128[ebp], 0
$LN7@basic_stri:
  000a5	8a 45 6b	 mov	 al, BYTE PTR tv128[ebp]
  000a8	88 45 53	 mov	 BYTE PTR __Fits_in_left$[ebp], al

; 2561 :         if (_Fits_in_left && _Right_capacity <= _Left_capacity) {

  000ab	0f b6 45 53	 movzx	 eax, BYTE PTR __Fits_in_left$[ebp]
  000af	85 c0		 test	 eax, eax
  000b1	0f 84 d0 00 00
	00		 je	 $LN2@basic_stri
  000b7	8b 45 0c	 mov	 eax, DWORD PTR __Right_capacity$[ebp]
  000ba	3b 45 20	 cmp	 eax, DWORD PTR __Left_capacity$[ebp]
  000bd	0f 87 c4 00 00
	00		 ja	 $LN2@basic_stri

; 2562 :             // take _Left's buffer, max_size() is OK because _Fits_in_left
; 2563 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2564 :             _Take_contents(_Left, bool_constant<_Can_memcpy_val>{});

  000c3	33 c0		 xor	 eax, eax
  000c5	88 45 52	 mov	 BYTE PTR $T35[ebp], al
  000c8	8a 45 52	 mov	 al, BYTE PTR $T35[ebp]
  000cb	88 45 34	 mov	 BYTE PTR ___formal$[ebp], al

; 2702 :         _Memcpy_val_from(_Right);

  000ce	ff 75 78	 push	 DWORD PTR __Left$[ebp]
  000d1	8b 4d 54	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	e8 00 00 00 00	 call	 ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from

; 2703 :         _Right._Tidy_init();

  000d9	8b 4d 78	 mov	 ecx, DWORD PTR __Left$[ebp]
  000dc	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2209 :         value_type* _Result = _Bx._Buf;

  000e1	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e4	89 45 18	 mov	 DWORD PTR __Result$24[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  000e7	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ea	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  000ee	72 09		 jb	 SHORT $LN41@basic_stri
  000f0	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR tv292[ebp], 1
  000f7	eb 04		 jmp	 SHORT $LN42@basic_stri
$LN41@basic_stri:
  000f9	83 65 1c 00	 and	 DWORD PTR tv292[ebp], 0
$LN42@basic_stri:
  000fd	8a 45 1c	 mov	 al, BYTE PTR tv292[ebp]
  00100	88 45 51	 mov	 BYTE PTR $T34[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00103	0f b6 45 51	 movzx	 eax, BYTE PTR $T34[ebp]
  00107	85 c0		 test	 eax, eax
  00109	74 0e		 je	 SHORT $LN36@basic_stri

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  0010b	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  0010e	8b 00		 mov	 eax, DWORD PTR [eax]
  00110	89 45 cc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00113	8b 45 cc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00116	89 45 18	 mov	 DWORD PTR __Result$24[ebp], eax
$LN36@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00119	8b 45 18	 mov	 eax, DWORD PTR __Result$24[ebp]
  0011c	89 45 c4	 mov	 DWORD PTR __Ptr$17[ebp], eax

; 2209 :         value_type* _Result = _Bx._Buf;

  0011f	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00122	89 45 10	 mov	 DWORD PTR __Result$23[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00125	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00128	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0012c	72 09		 jb	 SHORT $LN53@basic_stri
  0012e	c7 45 14 01 00
	00 00		 mov	 DWORD PTR tv301[ebp], 1
  00135	eb 04		 jmp	 SHORT $LN54@basic_stri
$LN53@basic_stri:
  00137	83 65 14 00	 and	 DWORD PTR tv301[ebp], 0
$LN54@basic_stri:
  0013b	8a 45 14	 mov	 al, BYTE PTR tv301[ebp]
  0013e	88 45 50	 mov	 BYTE PTR $T33[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00141	0f b6 45 50	 movzx	 eax, BYTE PTR $T33[ebp]
  00145	85 c0		 test	 eax, eax
  00147	74 0e		 je	 SHORT $LN48@basic_stri

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00149	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  0014c	8b 00		 mov	 eax, DWORD PTR [eax]
  0014e	89 45 c8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00151	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00154	89 45 10	 mov	 DWORD PTR __Result$23[ebp], eax
$LN48@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00157	8b 45 10	 mov	 eax, DWORD PTR __Result$23[ebp]
  0015a	89 45 c0	 mov	 DWORD PTR $T16[ebp], eax

; 2565 :             const auto _Ptr = _My_data._Myptr();
; 2566 :             _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

  0015d	8b 45 c4	 mov	 eax, DWORD PTR __Ptr$17[ebp]
  00160	03 45 60	 add	 eax, DWORD PTR __Left_size$[ebp]
  00163	89 45 bc	 mov	 DWORD PTR __First1$[ebp], eax
  00166	8b 45 44	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00169	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0016a	50		 push	 eax
  0016b	ff 75 c0	 push	 DWORD PTR $T16[ebp]
  0016e	ff 75 bc	 push	 DWORD PTR __First1$[ebp]
  00171	e8 00 00 00 00	 call	 _memcpy
  00176	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2567 :             _My_data._Mysize = _New_size;

  00179	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  0017c	8b 4d 3c	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0017f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2568 :             return;

  00182	e9 96 02 00 00	 jmp	 $LN1@basic_stri
$LN2@basic_stri:

; 2569 :         }
; 2570 : 
; 2571 :         const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;

  00187	8b 45 0c	 mov	 eax, DWORD PTR __Right_capacity$[ebp]
  0018a	2b 45 44	 sub	 eax, DWORD PTR __Right_size$[ebp]
  0018d	39 45 60	 cmp	 DWORD PTR __Left_size$[ebp], eax
  00190	77 06		 ja	 SHORT $LN8@basic_stri
  00192	c6 45 6a 01	 mov	 BYTE PTR tv156[ebp], 1
  00196	eb 04		 jmp	 SHORT $LN9@basic_stri
$LN8@basic_stri:
  00198	c6 45 6a 00	 mov	 BYTE PTR tv156[ebp], 0
$LN9@basic_stri:
  0019c	8a 45 6a	 mov	 al, BYTE PTR tv156[ebp]
  0019f	88 45 4e	 mov	 BYTE PTR __Fits_in_right$[ebp], al

; 4409 :         return _Mypair._Get_first();

  001a2	8b 45 7c	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001a5	89 45 b8	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  001a8	8b 45 b8	 mov	 eax, DWORD PTR $T15[ebp]
  001ab	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  001b1	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001b4	89 45 b4	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  001b7	8b 45 b4	 mov	 eax, DWORD PTR $T14[ebp]
  001ba	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 2039 :         return true;

  001c0	c6 45 4f 01	 mov	 BYTE PTR $T32[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2572 :         if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {

  001c4	0f b6 45 4f	 movzx	 eax, BYTE PTR $T32[ebp]
  001c8	85 c0		 test	 eax, eax
  001ca	0f 84 c2 00 00
	00		 je	 $LN3@basic_stri
  001d0	0f b6 45 4e	 movzx	 eax, BYTE PTR __Fits_in_right$[ebp]
  001d4	85 c0		 test	 eax, eax
  001d6	0f 84 b6 00 00
	00		 je	 $LN3@basic_stri

; 2573 :             // take _Right's buffer, max_size() is OK because _Fits_in_right
; 2574 :             // At this point, we have tested:
; 2575 :             // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
; 2576 :             // therefore: (by De Morgan's Laws)
; 2577 :             // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
; 2578 :             // therefore: (by the distributive property)
; 2579 :             // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
; 2580 :             //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
; 2581 :             // therefore: _Right must have more than the minimum capacity, so it must be _Large_string_engaged()
; 2582 :             _STL_INTERNAL_CHECK(_Right_data._Large_string_engaged());
; 2583 :             _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
; 2584 :             _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  001dc	33 c0		 xor	 eax, eax
  001de	88 45 4d	 mov	 BYTE PTR $T31[ebp], al
  001e1	8a 45 4d	 mov	 al, BYTE PTR $T31[ebp]
  001e4	88 45 30	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  001e7	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  001ea	89 45 ac	 mov	 DWORD PTR __My_data_mem$12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  001ed	8b 45 7c	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  001f0	89 45 b0	 mov	 DWORD PTR __Right_data_mem$13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  001f3	6a 18		 push	 24			; 00000018H
  001f5	ff 75 b0	 push	 DWORD PTR __Right_data_mem$13[ebp]
  001f8	ff 75 ac	 push	 DWORD PTR __My_data_mem$12[ebp]
  001fb	e8 00 00 00 00	 call	 _memcpy
  00200	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  00203	8b 4d 7c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00206	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2585 :             const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);

  0020b	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  0020e	8b 00		 mov	 eax, DWORD PTR [eax]
  00210	89 45 a8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00213	8b 45 a8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00216	89 45 28	 mov	 DWORD PTR __Ptr$26[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2586 :             _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);

  00219	8b 45 28	 mov	 eax, DWORD PTR __Ptr$26[ebp]
  0021c	03 45 60	 add	 eax, DWORD PTR __Left_size$[ebp]
  0021f	89 45 a4	 mov	 DWORD PTR __First1$[ebp], eax
  00222	8b 45 44	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00225	40		 inc	 eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00226	50		 push	 eax
  00227	ff 75 28	 push	 DWORD PTR __Ptr$26[ebp]
  0022a	ff 75 a4	 push	 DWORD PTR __First1$[ebp]
  0022d	e8 00 00 00 00	 call	 _memmove
  00232	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2209 :         value_type* _Result = _Bx._Buf;

  00235	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  00238	89 45 04	 mov	 DWORD PTR __Result$22[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0023b	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  0023e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00242	72 09		 jb	 SHORT $LN104@basic_stri
  00244	c7 45 08 01 00
	00 00		 mov	 DWORD PTR tv320[ebp], 1
  0024b	eb 04		 jmp	 SHORT $LN105@basic_stri
$LN104@basic_stri:
  0024d	83 65 08 00	 and	 DWORD PTR tv320[ebp], 0
$LN105@basic_stri:
  00251	8a 45 08	 mov	 al, BYTE PTR tv320[ebp]
  00254	88 45 4a	 mov	 BYTE PTR $T28[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00257	0f b6 45 4a	 movzx	 eax, BYTE PTR $T28[ebp]
  0025b	85 c0		 test	 eax, eax
  0025d	74 0e		 je	 SHORT $LN99@basic_stri

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  0025f	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  00262	8b 00		 mov	 eax, DWORD PTR [eax]
  00264	89 45 a0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00267	8b 45 a0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0026a	89 45 04	 mov	 DWORD PTR __Result$22[ebp], eax
$LN99@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  0026d	8b 45 04	 mov	 eax, DWORD PTR __Result$22[ebp]
  00270	89 45 9c	 mov	 DWORD PTR $T11[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00273	ff 75 60	 push	 DWORD PTR __Left_size$[ebp]
  00276	ff 75 9c	 push	 DWORD PTR $T11[ebp]
  00279	ff 75 28	 push	 DWORD PTR __Ptr$26[ebp]
  0027c	e8 00 00 00 00	 call	 _memcpy
  00281	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2587 :             _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2588 :             _My_data._Mysize = _New_size;

  00284	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  00287	8b 4d 3c	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0028a	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2589 :             return;

  0028d	e9 8b 01 00 00	 jmp	 $LN1@basic_stri
$LN3@basic_stri:

; 2590 :         }
; 2591 : 
; 2592 :         // can't use either buffer, reallocate
; 2593 :         const auto _Max = max_size();

  00292	8b 4d 54	 mov	 ecx, DWORD PTR _this$[ebp]
  00295	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0029a	89 45 40	 mov	 DWORD PTR __Max$[ebp], eax

; 2594 :         if (_Max - _Left_size < _Right_size) { // check if max_size() is OK

  0029d	8b 45 40	 mov	 eax, DWORD PTR __Max$[ebp]
  002a0	2b 45 60	 sub	 eax, DWORD PTR __Left_size$[ebp]
  002a3	3b 45 44	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  002a6	73 05		 jae	 SHORT $LN4@basic_stri

; 2595 :             _Xlen_string();

  002a8	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN4@basic_stri:

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  002ad	8b 45 3c	 mov	 eax, DWORD PTR __New_size$[ebp]
  002b0	83 c8 0f	 or	 eax, 15			; 0000000fH
  002b3	89 45 24	 mov	 DWORD PTR __Masked$25[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  002b6	8b 45 24	 mov	 eax, DWORD PTR __Masked$25[ebp]
  002b9	3b 45 40	 cmp	 eax, DWORD PTR __Max$[ebp]
  002bc	76 08		 jbe	 SHORT $LN139@basic_stri

; 4287 :             return _Max;

  002be	8b 45 40	 mov	 eax, DWORD PTR __Max$[ebp]
  002c1	89 45 38	 mov	 DWORD PTR __New_capacity$[ebp], eax
  002c4	eb 4c		 jmp	 SHORT $LN141@basic_stri
$LN139@basic_stri:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  002c6	6a 0f		 push	 15			; 0000000fH
  002c8	58		 pop	 eax
  002c9	d1 e8		 shr	 eax, 1
  002cb	8b 4d 40	 mov	 ecx, DWORD PTR __Max$[ebp]
  002ce	2b c8		 sub	 ecx, eax
  002d0	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  002d3	73 08		 jae	 SHORT $LN140@basic_stri

; 4291 :             return _Max;

  002d5	8b 45 40	 mov	 eax, DWORD PTR __Max$[ebp]
  002d8	89 45 38	 mov	 DWORD PTR __New_capacity$[ebp], eax
  002db	eb 35		 jmp	 SHORT $LN141@basic_stri
$LN140@basic_stri:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  002dd	6a 0f		 push	 15			; 0000000fH
  002df	58		 pop	 eax
  002e0	d1 e8		 shr	 eax, 1
  002e2	83 c0 0f	 add	 eax, 15			; 0000000fH
  002e5	89 45 00	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  002e8	8b 45 24	 mov	 eax, DWORD PTR __Masked$25[ebp]
  002eb	3b 45 00	 cmp	 eax, DWORD PTR $T21[ebp]
  002ee	73 08		 jae	 SHORT $LN145@basic_stri
  002f0	8d 45 00	 lea	 eax, DWORD PTR $T21[ebp]
  002f3	89 45 f0	 mov	 DWORD PTR tv338[ebp], eax
  002f6	eb 06		 jmp	 SHORT $LN146@basic_stri
$LN145@basic_stri:
  002f8	8d 45 24	 lea	 eax, DWORD PTR __Masked$25[ebp]
  002fb	89 45 f0	 mov	 DWORD PTR tv338[ebp], eax
$LN146@basic_stri:
  002fe	8b 45 f0	 mov	 eax, DWORD PTR tv338[ebp]
  00301	89 45 98	 mov	 DWORD PTR $T10[ebp], eax
  00304	8b 45 98	 mov	 eax, DWORD PTR $T10[ebp]
  00307	89 45 94	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0030a	8b 45 94	 mov	 eax, DWORD PTR $T9[ebp]
  0030d	8b 00		 mov	 eax, DWORD PTR [eax]
  0030f	89 45 38	 mov	 DWORD PTR __New_capacity$[ebp], eax
$LN141@basic_stri:

; 2596 :         }
; 2597 : 
; 2598 :         const auto _New_capacity = _Calculate_growth(_New_size, _BUF_SIZE - 1, _Max);
; 2599 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00312	8d 45 2f	 lea	 eax, DWORD PTR _$S10$[ebp]
  00315	89 85 68 ff ff
	ff		 mov	 DWORD PTR __Alproxy$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0031b	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0031e	89 45 90	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00321	8b 45 90	 mov	 eax, DWORD PTR $T8[ebp]
  00324	89 85 64 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0032a	c6 45 2e 00	 mov	 BYTE PTR __Overflow_is_possible$27[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2601 :         const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  0032e	8b 45 38	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00331	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00332	50		 push	 eax
  00333	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00338	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2601 :         const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  00339	89 45 ec	 mov	 DWORD PTR __Fancyptr$[ebp], eax

; 2602 :         // nothrow hereafter
; 2603 :         _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  0033c	8d 45 ec	 lea	 eax, DWORD PTR __Fancyptr$[ebp]
  0033f	50		 push	 eax
  00340	ff 75 64	 push	 DWORD PTR __My_data$[ebp]
  00343	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00348	59		 pop	 ecx
  00349	59		 pop	 ecx

; 2604 :         _My_data._Mysize = _New_size;

  0034a	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  0034d	8b 4d 3c	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00350	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2605 :         _My_data._Myres  = _New_capacity;

  00353	8b 45 64	 mov	 eax, DWORD PTR __My_data$[ebp]
  00356	8b 4d 38	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00359	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 2606 :         const auto _Ptr  = _Unfancy(_Fancyptr);

  0035c	8b 45 ec	 mov	 eax, DWORD PTR __Fancyptr$[ebp]
  0035f	89 45 8c	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00362	8b 45 8c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00365	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2209 :         value_type* _Result = _Bx._Buf;

  00368	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  0036b	89 45 e4	 mov	 DWORD PTR __Result$20[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0036e	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  00371	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00375	72 09		 jb	 SHORT $LN170@basic_stri
  00377	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv349[ebp], 1
  0037e	eb 04		 jmp	 SHORT $LN171@basic_stri
$LN170@basic_stri:
  00380	83 65 e8 00	 and	 DWORD PTR tv349[ebp], 0
$LN171@basic_stri:
  00384	8a 45 e8	 mov	 al, BYTE PTR tv349[ebp]
  00387	88 45 4c	 mov	 BYTE PTR $T30[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0038a	0f b6 45 4c	 movzx	 eax, BYTE PTR $T30[ebp]
  0038e	85 c0		 test	 eax, eax
  00390	74 0e		 je	 SHORT $LN165@basic_stri

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00392	8b 45 5c	 mov	 eax, DWORD PTR __Left_data$[ebp]
  00395	8b 00		 mov	 eax, DWORD PTR [eax]
  00397	89 45 88	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0039a	8b 45 88	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0039d	89 45 e4	 mov	 DWORD PTR __Result$20[ebp], eax
$LN165@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  003a0	8b 45 e4	 mov	 eax, DWORD PTR __Result$20[ebp]
  003a3	89 45 84	 mov	 DWORD PTR $T7[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  003a6	ff 75 60	 push	 DWORD PTR __Left_size$[ebp]
  003a9	ff 75 84	 push	 DWORD PTR $T7[ebp]
  003ac	ff 75 d8	 push	 DWORD PTR __Ptr$[ebp]
  003af	e8 00 00 00 00	 call	 _memcpy
  003b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2209 :         value_type* _Result = _Bx._Buf;

  003b7	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  003ba	89 45 dc	 mov	 DWORD PTR __Result$19[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  003bd	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  003c0	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  003c4	72 09		 jb	 SHORT $LN185@basic_stri
  003c6	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv391[ebp], 1
  003cd	eb 04		 jmp	 SHORT $LN186@basic_stri
$LN185@basic_stri:
  003cf	83 65 e0 00	 and	 DWORD PTR tv391[ebp], 0
$LN186@basic_stri:
  003d3	8a 45 e0	 mov	 al, BYTE PTR tv391[ebp]
  003d6	88 45 4b	 mov	 BYTE PTR $T29[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  003d9	0f b6 45 4b	 movzx	 eax, BYTE PTR $T29[ebp]
  003dd	85 c0		 test	 eax, eax
  003df	74 0e		 je	 SHORT $LN180@basic_stri

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  003e1	8b 45 58	 mov	 eax, DWORD PTR __Right_data$[ebp]
  003e4	8b 00		 mov	 eax, DWORD PTR [eax]
  003e6	89 45 80	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  003e9	8b 45 80	 mov	 eax, DWORD PTR __Ptr$[ebp]
  003ec	89 45 dc	 mov	 DWORD PTR __Result$19[ebp], eax
$LN180@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  003ef	8b 45 dc	 mov	 eax, DWORD PTR __Result$19[ebp]
  003f2	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax

; 2607 :         _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
; 2608 :         _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);

  003f8	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  003fb	03 45 60	 add	 eax, DWORD PTR __Left_size$[ebp]
  003fe	89 85 78 ff ff
	ff		 mov	 DWORD PTR __First1$[ebp], eax
  00404	8b 45 44	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00407	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00408	50		 push	 eax
  00409	ff b5 7c ff ff
	ff		 push	 DWORD PTR $T6[ebp]
  0040f	ff b5 78 ff ff
	ff		 push	 DWORD PTR __First1$[ebp]
  00415	e8 00 00 00 00	 call	 _memcpy
  0041a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@basic_stri:

; 2609 :         _Proxy._Release();
; 2610 :     }

  0041d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00421	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@basic_stri:
  00424	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00427	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0042e	59		 pop	 ecx
  0042f	83 c5 6c	 add	 ebp, 108		; 0000006cH
  00432	c9		 leave
  00433	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z$0:
  00000	8b 4d 54	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 6c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-148]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@AAV01@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
__My_data_mem$2 = -36					; size = 4
__Right_data_mem$3 = -32				; size = 4
_this$ = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T6 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4409 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00015	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00035	33 c0		 xor	 eax, eax
  00037	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
  0003a	8a 45 ff	 mov	 al, BYTE PTR $T6[ebp]
  0003d	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00040	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 dc	 mov	 DWORD PTR __My_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00046	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00049	89 45 e0	 mov	 DWORD PTR __Right_data_mem$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004c	6a 18		 push	 24			; 00000018H
  0004e	ff 75 e0	 push	 DWORD PTR __Right_data_mem$3[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __My_data_mem$2[ebp]
  00054	e8 00 00 00 00	 call	 _memcpy
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2499 :     }

  00064	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c9		 leave
  00068	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S6$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0003b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00046	8d 45 f3	 lea	 eax, DWORD PTR _$S6$[ebp]
  00049	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00054	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	59		 pop	 ecx
  0005d	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00063	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00066	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00069	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }

  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
_this$ = -32						; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S9$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00031	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00034	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003a	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00040	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00047	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  0004e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00052	8d 45 f3	 lea	 eax, DWORD PTR _$S9$[ebp]
  00055	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);

  00058	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents

; 2355 :         _Proxy._Release();
; 2356 :     }

  00063	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	c9		 leave
  00076	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2242 :     [[noreturn]] static void _Xran() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2243 :         _Xout_of_range("invalid string position");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00008	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 2244 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 14 00	 and	 DWORD PTR [eax+20], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c9		 leave
  00019	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	6a ff		 push	 -1
  0001c	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  0001f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	83 c9 01	 or	 ecx, 1
  00029	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00033	83 c4 1c	 add	 esp, 28			; 0000001cH
  00036	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00039	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003d	7d 06		 jge	 SHORT $LN7@sprintf
  0003f	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00043	eb 06		 jmp	 SHORT $LN3@sprintf
$LN7@sprintf:
  00045	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00048	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@sprintf:

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00051	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00058	c9		 leave
  00059	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Result$ = -12						; size = 4
__Format$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Format$[ebp], eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00012	ff 75 fc	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f8	 push	 DWORD PTR __Format$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	ff 70 04	 push	 DWORD PTR [eax+4]
  00025	ff 30		 push	 DWORD PTR [eax]
  00027	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0002c	83 c4 18	 add	 esp, 24			; 00000018H

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0002f	89 45 f4	 mov	 DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

  00032	83 65 fc 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp]

; 842  :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeMaterial.h
;	COMDAT ?Set@CSpeedTreeMaterial@@QAEXPBM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pMaterialArray$ = 8					; size = 4
?Set@CSpeedTreeMaterial@@QAEXPBM@Z PROC			; CSpeedTreeMaterial::Set, COMDAT
; _this$ = ecx

; 56   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 57   : 			memcpy(&m_cMaterial.Diffuse, pMaterialArray, 3 * sizeof(float));

  00007	6a 0c		 push	 12			; 0000000cH
  00009	ff 75 08	 push	 DWORD PTR _pMaterialArray$[ebp]
  0000c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 _memcpy
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 58   : 			m_cMaterial.Diffuse.a = 1.0f;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00022	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 59   : 
; 60   : 			memcpy(&m_cMaterial.Ambient, pMaterialArray + 3, 3 * sizeof(float));

  00027	6a 0c		 push	 12			; 0000000cH
  00029	8b 45 08	 mov	 eax, DWORD PTR _pMaterialArray$[ebp]
  0002c	83 c0 0c	 add	 eax, 12			; 0000000cH
  0002f	50		 push	 eax
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 c0 10	 add	 eax, 16			; 00000010H
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _memcpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 61   : 			m_cMaterial.Ambient.a = 1.0f;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004a	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 62   : 			
; 63   : 			memcpy(&m_cMaterial.Specular, pMaterialArray + 6, 3 * sizeof(float));

  0004f	6a 0c		 push	 12			; 0000000cH
  00051	8b 45 08	 mov	 eax, DWORD PTR _pMaterialArray$[ebp]
  00054	83 c0 18	 add	 eax, 24			; 00000018H
  00057	50		 push	 eax
  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 c0 20	 add	 eax, 32			; 00000020H
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _memcpy
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 64   : 			m_cMaterial.Specular.a = 1.0f;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00072	f3 0f 11 40 2c	 movss	 DWORD PTR [eax+44], xmm0

; 65   : 			
; 66   : 			memcpy(&m_cMaterial.Emissive, pMaterialArray + 9, 3 * sizeof(float));

  00077	6a 0c		 push	 12			; 0000000cH
  00079	8b 45 08	 mov	 eax, DWORD PTR _pMaterialArray$[ebp]
  0007c	83 c0 24	 add	 eax, 36			; 00000024H
  0007f	50		 push	 eax
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 c0 30	 add	 eax, 48			; 00000030H
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _memcpy
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 67   : 			m_cMaterial.Emissive.a = 1.0f;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0009a	f3 0f 11 40 3c	 movss	 DWORD PTR [eax+60], xmm0

; 68   : 
; 69   : 			m_cMaterial.Power = pMaterialArray[12];

  0009f	6a 04		 push	 4
  000a1	58		 pop	 eax
  000a2	6b c0 0c	 imul	 eax, eax, 12
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	8b 55 08	 mov	 edx, DWORD PTR _pMaterialArray$[ebp]
  000ab	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000ae	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 70   : 		}

  000b1	c9		 leave
  000b2	c2 04 00	 ret	 4
?Set@CSpeedTreeMaterial@@QAEXPBM@Z ENDP			; CSpeedTreeMaterial::Set
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeMaterial.h
;	COMDAT ??0CSpeedTreeMaterial@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CSpeedTreeMaterial@@QAE@XZ PROC			; CSpeedTreeMaterial::CSpeedTreeMaterial, COMDAT
; _this$ = ecx

; 46   : 		CSpeedTreeMaterial()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 47   : 		{
; 48   : 			m_cMaterial.Ambient.r = m_cMaterial.Diffuse.r = m_cMaterial.Specular.r = m_cMaterial.Emissive.r = 1.0f;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00012	f3 0f 11 40 30	 movss	 DWORD PTR [eax+48], xmm0
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00022	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00032	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00041	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 49   : 			m_cMaterial.Ambient.g = m_cMaterial.Diffuse.g = m_cMaterial.Specular.g = m_cMaterial.Emissive.g = 1.0f;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00051	f3 0f 11 40 34	 movss	 DWORD PTR [eax+52], xmm0
  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00061	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0
  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00071	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00079	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00081	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 50   : 			m_cMaterial.Ambient.b = m_cMaterial.Diffuse.b = m_cMaterial.Specular.b = m_cMaterial.Emissive.b = 1.0f;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00091	f3 0f 11 40 38	 movss	 DWORD PTR [eax+56], xmm0
  00096	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00099	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000a1	f3 0f 11 40 28	 movss	 DWORD PTR [eax+40], xmm0
  000a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000b1	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  000b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000c1	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 51   : 			m_cMaterial.Ambient.a = m_cMaterial.Diffuse.a = m_cMaterial.Specular.a = m_cMaterial.Emissive.a = 1.0f;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000d1	f3 0f 11 40 3c	 movss	 DWORD PTR [eax+60], xmm0
  000d6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000e1	f3 0f 11 40 2c	 movss	 DWORD PTR [eax+44], xmm0
  000e6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000f1	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  000f6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00101	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 52   : 			m_cMaterial.Power = 5.0f;

  00106	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00109	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40a00000
  00111	f3 0f 11 40 40	 movss	 DWORD PTR [eax+64], xmm0

; 53   : 		}

  00116	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00119	c9		 leave
  0011a	c3		 ret	 0
??0CSpeedTreeMaterial@@QAE@XZ ENDP			; CSpeedTreeMaterial::CSpeedTreeMaterial
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCSpeedTreeRT@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCSpeedTreeRT@@QAEPAXI@Z PROC			; CSpeedTreeRT::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CSpeedTreeRT@@QAE@XZ	; CSpeedTreeRT::~CSpeedTreeRT
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 22		 je	 SHORT $LN2@scalar
  00017	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001a	83 e0 04	 and	 eax, 4
  0001d	75 0b		 jne	 SHORT $LN3@scalar
  0001f	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ??3CSpeedTreeRT@@SAXPAX@Z ; CSpeedTreeRT::operator delete
  00027	59		 pop	 ecx
  00028	eb 0f		 jmp	 SHORT $LN2@scalar
$LN3@scalar:
  0002a	68 9c 00 00 00	 push	 156			; 0000009cH
  0002f	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx
$LN2@scalar:
  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c2 04 00	 ret	 4
??_GCSpeedTreeRT@@QAEPAXI@Z ENDP			; CSpeedTreeRT::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SpeedTreeLib\SpeedTreeWrapper.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
